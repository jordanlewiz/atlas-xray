"use strict";
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __esm = (fn2, res) => function __init() {
    return fn2 && (res = (0, fn2[__getOwnPropNames(fn2)[0]])(fn2 = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from2, except, desc) => {
    if (from2 && typeof from2 === "object" || typeof from2 === "function") {
      for (let key of __getOwnPropNames(from2))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc(from2, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // node_modules/react/cjs/react.production.min.js
  var require_react_production_min = __commonJS({
    "node_modules/react/cjs/react.production.min.js"(exports) {
      "use strict";
      var l = Symbol.for("react.element");
      var n = Symbol.for("react.portal");
      var p = Symbol.for("react.fragment");
      var q = Symbol.for("react.strict_mode");
      var r = Symbol.for("react.profiler");
      var t = Symbol.for("react.provider");
      var u = Symbol.for("react.context");
      var v = Symbol.for("react.forward_ref");
      var w2 = Symbol.for("react.suspense");
      var x = Symbol.for("react.memo");
      var y = Symbol.for("react.lazy");
      var z = Symbol.iterator;
      function A(a) {
        if (null === a || "object" !== typeof a) return null;
        a = z && a[z] || a["@@iterator"];
        return "function" === typeof a ? a : null;
      }
      var B = { isMounted: function() {
        return false;
      }, enqueueForceUpdate: function() {
      }, enqueueReplaceState: function() {
      }, enqueueSetState: function() {
      } };
      var C = Object.assign;
      var D = {};
      function E(a, b, e) {
        this.props = a;
        this.context = b;
        this.refs = D;
        this.updater = e || B;
      }
      E.prototype.isReactComponent = {};
      E.prototype.setState = function(a, b) {
        if ("object" !== typeof a && "function" !== typeof a && null != a) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
        this.updater.enqueueSetState(this, a, b, "setState");
      };
      E.prototype.forceUpdate = function(a) {
        this.updater.enqueueForceUpdate(this, a, "forceUpdate");
      };
      function F() {
      }
      F.prototype = E.prototype;
      function G(a, b, e) {
        this.props = a;
        this.context = b;
        this.refs = D;
        this.updater = e || B;
      }
      var H = G.prototype = new F();
      H.constructor = G;
      C(H, E.prototype);
      H.isPureReactComponent = true;
      var I = Array.isArray;
      var J = Object.prototype.hasOwnProperty;
      var K = { current: null };
      var L = { key: true, ref: true, __self: true, __source: true };
      function M(a, b, e) {
        var d, c = {}, k = null, h = null;
        if (null != b) for (d in void 0 !== b.ref && (h = b.ref), void 0 !== b.key && (k = "" + b.key), b) J.call(b, d) && !L.hasOwnProperty(d) && (c[d] = b[d]);
        var g = arguments.length - 2;
        if (1 === g) c.children = e;
        else if (1 < g) {
          for (var f = Array(g), m = 0; m < g; m++) f[m] = arguments[m + 2];
          c.children = f;
        }
        if (a && a.defaultProps) for (d in g = a.defaultProps, g) void 0 === c[d] && (c[d] = g[d]);
        return { $$typeof: l, type: a, key: k, ref: h, props: c, _owner: K.current };
      }
      function N(a, b) {
        return { $$typeof: l, type: a.type, key: b, ref: a.ref, props: a.props, _owner: a._owner };
      }
      function O(a) {
        return "object" === typeof a && null !== a && a.$$typeof === l;
      }
      function escape(a) {
        var b = { "=": "=0", ":": "=2" };
        return "$" + a.replace(/[=:]/g, function(a2) {
          return b[a2];
        });
      }
      var P = /\/+/g;
      function Q(a, b) {
        return "object" === typeof a && null !== a && null != a.key ? escape("" + a.key) : b.toString(36);
      }
      function R(a, b, e, d, c) {
        var k = typeof a;
        if ("undefined" === k || "boolean" === k) a = null;
        var h = false;
        if (null === a) h = true;
        else switch (k) {
          case "string":
          case "number":
            h = true;
            break;
          case "object":
            switch (a.$$typeof) {
              case l:
              case n:
                h = true;
            }
        }
        if (h) return h = a, c = c(h), a = "" === d ? "." + Q(h, 0) : d, I(c) ? (e = "", null != a && (e = a.replace(P, "$&/") + "/"), R(c, b, e, "", function(a2) {
          return a2;
        })) : null != c && (O(c) && (c = N(c, e + (!c.key || h && h.key === c.key ? "" : ("" + c.key).replace(P, "$&/") + "/") + a)), b.push(c)), 1;
        h = 0;
        d = "" === d ? "." : d + ":";
        if (I(a)) for (var g = 0; g < a.length; g++) {
          k = a[g];
          var f = d + Q(k, g);
          h += R(k, b, e, f, c);
        }
        else if (f = A(a), "function" === typeof f) for (a = f.call(a), g = 0; !(k = a.next()).done; ) k = k.value, f = d + Q(k, g++), h += R(k, b, e, f, c);
        else if ("object" === k) throw b = String(a), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b ? "object with keys {" + Object.keys(a).join(", ") + "}" : b) + "). If you meant to render a collection of children, use an array instead.");
        return h;
      }
      function S(a, b, e) {
        if (null == a) return a;
        var d = [], c = 0;
        R(a, d, "", "", function(a2) {
          return b.call(e, a2, c++);
        });
        return d;
      }
      function T(a) {
        if (-1 === a._status) {
          var b = a._result;
          b = b();
          b.then(function(b2) {
            if (0 === a._status || -1 === a._status) a._status = 1, a._result = b2;
          }, function(b2) {
            if (0 === a._status || -1 === a._status) a._status = 2, a._result = b2;
          });
          -1 === a._status && (a._status = 0, a._result = b);
        }
        if (1 === a._status) return a._result.default;
        throw a._result;
      }
      var U = { current: null };
      var V = { transition: null };
      var W = { ReactCurrentDispatcher: U, ReactCurrentBatchConfig: V, ReactCurrentOwner: K };
      function X() {
        throw Error("act(...) is not supported in production builds of React.");
      }
      exports.Children = { map: S, forEach: function(a, b, e) {
        S(a, function() {
          b.apply(this, arguments);
        }, e);
      }, count: function(a) {
        var b = 0;
        S(a, function() {
          b++;
        });
        return b;
      }, toArray: function(a) {
        return S(a, function(a2) {
          return a2;
        }) || [];
      }, only: function(a) {
        if (!O(a)) throw Error("React.Children.only expected to receive a single React element child.");
        return a;
      } };
      exports.Component = E;
      exports.Fragment = p;
      exports.Profiler = r;
      exports.PureComponent = G;
      exports.StrictMode = q;
      exports.Suspense = w2;
      exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W;
      exports.act = X;
      exports.cloneElement = function(a, b, e) {
        if (null === a || void 0 === a) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a + ".");
        var d = C({}, a.props), c = a.key, k = a.ref, h = a._owner;
        if (null != b) {
          void 0 !== b.ref && (k = b.ref, h = K.current);
          void 0 !== b.key && (c = "" + b.key);
          if (a.type && a.type.defaultProps) var g = a.type.defaultProps;
          for (f in b) J.call(b, f) && !L.hasOwnProperty(f) && (d[f] = void 0 === b[f] && void 0 !== g ? g[f] : b[f]);
        }
        var f = arguments.length - 2;
        if (1 === f) d.children = e;
        else if (1 < f) {
          g = Array(f);
          for (var m = 0; m < f; m++) g[m] = arguments[m + 2];
          d.children = g;
        }
        return { $$typeof: l, type: a.type, key: c, ref: k, props: d, _owner: h };
      };
      exports.createContext = function(a) {
        a = { $$typeof: u, _currentValue: a, _currentValue2: a, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
        a.Provider = { $$typeof: t, _context: a };
        return a.Consumer = a;
      };
      exports.createElement = M;
      exports.createFactory = function(a) {
        var b = M.bind(null, a);
        b.type = a;
        return b;
      };
      exports.createRef = function() {
        return { current: null };
      };
      exports.forwardRef = function(a) {
        return { $$typeof: v, render: a };
      };
      exports.isValidElement = O;
      exports.lazy = function(a) {
        return { $$typeof: y, _payload: { _status: -1, _result: a }, _init: T };
      };
      exports.memo = function(a, b) {
        return { $$typeof: x, type: a, compare: void 0 === b ? null : b };
      };
      exports.startTransition = function(a) {
        var b = V.transition;
        V.transition = {};
        try {
          a();
        } finally {
          V.transition = b;
        }
      };
      exports.unstable_act = X;
      exports.useCallback = function(a, b) {
        return U.current.useCallback(a, b);
      };
      exports.useContext = function(a) {
        return U.current.useContext(a);
      };
      exports.useDebugValue = function() {
      };
      exports.useDeferredValue = function(a) {
        return U.current.useDeferredValue(a);
      };
      exports.useEffect = function(a, b) {
        return U.current.useEffect(a, b);
      };
      exports.useId = function() {
        return U.current.useId();
      };
      exports.useImperativeHandle = function(a, b, e) {
        return U.current.useImperativeHandle(a, b, e);
      };
      exports.useInsertionEffect = function(a, b) {
        return U.current.useInsertionEffect(a, b);
      };
      exports.useLayoutEffect = function(a, b) {
        return U.current.useLayoutEffect(a, b);
      };
      exports.useMemo = function(a, b) {
        return U.current.useMemo(a, b);
      };
      exports.useReducer = function(a, b, e) {
        return U.current.useReducer(a, b, e);
      };
      exports.useRef = function(a) {
        return U.current.useRef(a);
      };
      exports.useState = function(a) {
        return U.current.useState(a);
      };
      exports.useSyncExternalStore = function(a, b, e) {
        return U.current.useSyncExternalStore(a, b, e);
      };
      exports.useTransition = function() {
        return U.current.useTransition();
      };
      exports.version = "18.3.1";
    }
  });

  // node_modules/react/index.js
  var require_react = __commonJS({
    "node_modules/react/index.js"(exports, module2) {
      "use strict";
      if (true) {
        module2.exports = require_react_production_min();
      } else {
        module2.exports = null;
      }
    }
  });

  // node_modules/dexie/dist/dexie.js
  var require_dexie = __commonJS({
    "node_modules/dexie/dist/dexie.js"(exports, module2) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.Dexie = factory());
      })(exports, (function() {
        "use strict";
        var extendStatics2 = function(d, b) {
          extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
          };
          return extendStatics2(d, b);
        };
        function __extends2(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics2(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        }
        var __assign2 = function() {
          __assign2 = Object.assign || function __assign3(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
              s = arguments[i];
              for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
          };
          return __assign2.apply(this, arguments);
        };
        function __spreadArray2(to, from2, pack) {
          if (pack || arguments.length === 2) for (var i = 0, l = from2.length, ar; i < l; i++) {
            if (ar || !(i in from2)) {
              if (!ar) ar = Array.prototype.slice.call(from2, 0, i);
              ar[i] = from2[i];
            }
          }
          return to.concat(ar || Array.prototype.slice.call(from2));
        }
        var _global = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
        var keys = Object.keys;
        var isArray3 = Array.isArray;
        if (typeof Promise !== "undefined" && !_global.Promise) {
          _global.Promise = Promise;
        }
        function extend(obj, extension) {
          if (typeof extension !== "object")
            return obj;
          keys(extension).forEach(function(key) {
            obj[key] = extension[key];
          });
          return obj;
        }
        var getProto = Object.getPrototypeOf;
        var _hasOwn = {}.hasOwnProperty;
        function hasOwn3(obj, prop) {
          return _hasOwn.call(obj, prop);
        }
        function props(proto, extension) {
          if (typeof extension === "function")
            extension = extension(getProto(proto));
          (typeof Reflect === "undefined" ? keys : Reflect.ownKeys)(extension).forEach(function(key) {
            setProp(proto, key, extension[key]);
          });
        }
        var defineProperty = Object.defineProperty;
        function setProp(obj, prop, functionOrGetSet, options2) {
          defineProperty(obj, prop, extend(functionOrGetSet && hasOwn3(functionOrGetSet, "get") && typeof functionOrGetSet.get === "function" ? { get: functionOrGetSet.get, set: functionOrGetSet.set, configurable: true } : { value: functionOrGetSet, configurable: true, writable: true }, options2));
        }
        function derive(Child) {
          return {
            from: function(Parent) {
              Child.prototype = Object.create(Parent.prototype);
              setProp(Child.prototype, "constructor", Child);
              return {
                extend: props.bind(null, Child.prototype)
              };
            }
          };
        }
        var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
        function getPropertyDescriptor(obj, prop) {
          var pd = getOwnPropertyDescriptor(obj, prop);
          var proto;
          return pd || (proto = getProto(obj)) && getPropertyDescriptor(proto, prop);
        }
        var _slice = [].slice;
        function slice3(args, start3, end2) {
          return _slice.call(args, start3, end2);
        }
        function override(origFunc, overridedFactory) {
          return overridedFactory(origFunc);
        }
        function assert2(b) {
          if (!b)
            throw new Error("Assertion Failed");
        }
        function asap$1(fn2) {
          if (_global.setImmediate)
            setImmediate(fn2);
          else
            setTimeout(fn2, 0);
        }
        function arrayToObject(array, extractor) {
          return array.reduce(function(result2, item, i) {
            var nameAndValue = extractor(item, i);
            if (nameAndValue)
              result2[nameAndValue[0]] = nameAndValue[1];
            return result2;
          }, {});
        }
        function getByKeyPath(obj, keyPath) {
          if (typeof keyPath === "string" && hasOwn3(obj, keyPath))
            return obj[keyPath];
          if (!keyPath)
            return obj;
          if (typeof keyPath !== "string") {
            var rv = [];
            for (var i = 0, l = keyPath.length; i < l; ++i) {
              var val = getByKeyPath(obj, keyPath[i]);
              rv.push(val);
            }
            return rv;
          }
          var period = keyPath.indexOf(".");
          if (period !== -1) {
            var innerObj = obj[keyPath.substr(0, period)];
            return innerObj == null ? void 0 : getByKeyPath(innerObj, keyPath.substr(period + 1));
          }
          return void 0;
        }
        function setByKeyPath(obj, keyPath, value) {
          if (!obj || keyPath === void 0)
            return;
          if ("isFrozen" in Object && Object.isFrozen(obj))
            return;
          if (typeof keyPath !== "string" && "length" in keyPath) {
            assert2(typeof value !== "string" && "length" in value);
            for (var i = 0, l = keyPath.length; i < l; ++i) {
              setByKeyPath(obj, keyPath[i], value[i]);
            }
          } else {
            var period = keyPath.indexOf(".");
            if (period !== -1) {
              var currentKeyPath = keyPath.substr(0, period);
              var remainingKeyPath = keyPath.substr(period + 1);
              if (remainingKeyPath === "")
                if (value === void 0) {
                  if (isArray3(obj) && !isNaN(parseInt(currentKeyPath)))
                    obj.splice(currentKeyPath, 1);
                  else
                    delete obj[currentKeyPath];
                } else
                  obj[currentKeyPath] = value;
              else {
                var innerObj = obj[currentKeyPath];
                if (!innerObj || !hasOwn3(obj, currentKeyPath))
                  innerObj = obj[currentKeyPath] = {};
                setByKeyPath(innerObj, remainingKeyPath, value);
              }
            } else {
              if (value === void 0) {
                if (isArray3(obj) && !isNaN(parseInt(keyPath)))
                  obj.splice(keyPath, 1);
                else
                  delete obj[keyPath];
              } else
                obj[keyPath] = value;
            }
          }
        }
        function delByKeyPath(obj, keyPath) {
          if (typeof keyPath === "string")
            setByKeyPath(obj, keyPath, void 0);
          else if ("length" in keyPath)
            [].map.call(keyPath, function(kp) {
              setByKeyPath(obj, kp, void 0);
            });
        }
        function shallowClone(obj) {
          var rv = {};
          for (var m in obj) {
            if (hasOwn3(obj, m))
              rv[m] = obj[m];
          }
          return rv;
        }
        var concat = [].concat;
        function flatten(a) {
          return concat.apply([], a);
        }
        var intrinsicTypeNames = "BigUint64Array,BigInt64Array,Array,Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,FileSystemDirectoryHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey".split(",").concat(flatten([8, 16, 32, 64].map(function(num) {
          return ["Int", "Uint", "Float"].map(function(t) {
            return t + num + "Array";
          });
        }))).filter(function(t) {
          return _global[t];
        });
        var intrinsicTypes = new Set(intrinsicTypeNames.map(function(t) {
          return _global[t];
        }));
        function cloneSimpleObjectTree(o) {
          var rv = {};
          for (var k in o)
            if (hasOwn3(o, k)) {
              var v = o[k];
              rv[k] = !v || typeof v !== "object" || intrinsicTypes.has(v.constructor) ? v : cloneSimpleObjectTree(v);
            }
          return rv;
        }
        function objectIsEmpty(o) {
          for (var k in o)
            if (hasOwn3(o, k))
              return false;
          return true;
        }
        var circularRefs = null;
        function deepClone(any) {
          circularRefs = /* @__PURE__ */ new WeakMap();
          var rv = innerDeepClone(any);
          circularRefs = null;
          return rv;
        }
        function innerDeepClone(x) {
          if (!x || typeof x !== "object")
            return x;
          var rv = circularRefs.get(x);
          if (rv)
            return rv;
          if (isArray3(x)) {
            rv = [];
            circularRefs.set(x, rv);
            for (var i = 0, l = x.length; i < l; ++i) {
              rv.push(innerDeepClone(x[i]));
            }
          } else if (intrinsicTypes.has(x.constructor)) {
            rv = x;
          } else {
            var proto = getProto(x);
            rv = proto === Object.prototype ? {} : Object.create(proto);
            circularRefs.set(x, rv);
            for (var prop in x) {
              if (hasOwn3(x, prop)) {
                rv[prop] = innerDeepClone(x[prop]);
              }
            }
          }
          return rv;
        }
        var toString3 = {}.toString;
        function toStringTag(o) {
          return toString3.call(o).slice(8, -1);
        }
        var iteratorSymbol = typeof Symbol !== "undefined" ? Symbol.iterator : "@@iterator";
        var getIteratorOf = typeof iteratorSymbol === "symbol" ? function(x) {
          var i;
          return x != null && (i = x[iteratorSymbol]) && i.apply(x);
        } : function() {
          return null;
        };
        function delArrayItem(a, x) {
          var i = a.indexOf(x);
          if (i >= 0)
            a.splice(i, 1);
          return i >= 0;
        }
        var NO_CHAR_ARRAY = {};
        function getArrayOf(arrayLike) {
          var i, a, x, it;
          if (arguments.length === 1) {
            if (isArray3(arrayLike))
              return arrayLike.slice();
            if (this === NO_CHAR_ARRAY && typeof arrayLike === "string")
              return [arrayLike];
            if (it = getIteratorOf(arrayLike)) {
              a = [];
              while (x = it.next(), !x.done)
                a.push(x.value);
              return a;
            }
            if (arrayLike == null)
              return [arrayLike];
            i = arrayLike.length;
            if (typeof i === "number") {
              a = new Array(i);
              while (i--)
                a[i] = arrayLike[i];
              return a;
            }
            return [arrayLike];
          }
          i = arguments.length;
          a = new Array(i);
          while (i--)
            a[i] = arguments[i];
          return a;
        }
        var isAsyncFunction = typeof Symbol !== "undefined" ? function(fn2) {
          return fn2[Symbol.toStringTag] === "AsyncFunction";
        } : function() {
          return false;
        };
        var dexieErrorNames = [
          "Modify",
          "Bulk",
          "OpenFailed",
          "VersionChange",
          "Schema",
          "Upgrade",
          "InvalidTable",
          "MissingAPI",
          "NoSuchDatabase",
          "InvalidArgument",
          "SubTransaction",
          "Unsupported",
          "Internal",
          "DatabaseClosed",
          "PrematureCommit",
          "ForeignAwait"
        ];
        var idbDomErrorNames = [
          "Unknown",
          "Constraint",
          "Data",
          "TransactionInactive",
          "ReadOnly",
          "Version",
          "NotFound",
          "InvalidState",
          "InvalidAccess",
          "Abort",
          "Timeout",
          "QuotaExceeded",
          "Syntax",
          "DataClone"
        ];
        var errorList = dexieErrorNames.concat(idbDomErrorNames);
        var defaultTexts = {
          VersionChanged: "Database version changed by other database connection",
          DatabaseClosed: "Database has been closed",
          Abort: "Transaction aborted",
          TransactionInactive: "Transaction has already completed or failed",
          MissingAPI: "IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb"
        };
        function DexieError(name, msg) {
          this.name = name;
          this.message = msg;
        }
        derive(DexieError).from(Error).extend({
          toString: function() {
            return this.name + ": " + this.message;
          }
        });
        function getMultiErrorMessage(msg, failures) {
          return msg + ". Errors: " + Object.keys(failures).map(function(key) {
            return failures[key].toString();
          }).filter(function(v, i, s) {
            return s.indexOf(v) === i;
          }).join("\n");
        }
        function ModifyError(msg, failures, successCount, failedKeys) {
          this.failures = failures;
          this.failedKeys = failedKeys;
          this.successCount = successCount;
          this.message = getMultiErrorMessage(msg, failures);
        }
        derive(ModifyError).from(DexieError);
        function BulkError(msg, failures) {
          this.name = "BulkError";
          this.failures = Object.keys(failures).map(function(pos) {
            return failures[pos];
          });
          this.failuresByPos = failures;
          this.message = getMultiErrorMessage(msg, this.failures);
        }
        derive(BulkError).from(DexieError);
        var errnames = errorList.reduce(function(obj, name) {
          return obj[name] = name + "Error", obj;
        }, {});
        var BaseException = DexieError;
        var exceptions = errorList.reduce(function(obj, name) {
          var fullName = name + "Error";
          function DexieError2(msgOrInner, inner) {
            this.name = fullName;
            if (!msgOrInner) {
              this.message = defaultTexts[name] || fullName;
              this.inner = null;
            } else if (typeof msgOrInner === "string") {
              this.message = "".concat(msgOrInner).concat(!inner ? "" : "\n " + inner);
              this.inner = inner || null;
            } else if (typeof msgOrInner === "object") {
              this.message = "".concat(msgOrInner.name, " ").concat(msgOrInner.message);
              this.inner = msgOrInner;
            }
          }
          derive(DexieError2).from(BaseException);
          obj[name] = DexieError2;
          return obj;
        }, {});
        exceptions.Syntax = SyntaxError;
        exceptions.Type = TypeError;
        exceptions.Range = RangeError;
        var exceptionMap = idbDomErrorNames.reduce(function(obj, name) {
          obj[name + "Error"] = exceptions[name];
          return obj;
        }, {});
        function mapError(domError, message2) {
          if (!domError || domError instanceof DexieError || domError instanceof TypeError || domError instanceof SyntaxError || !domError.name || !exceptionMap[domError.name])
            return domError;
          var rv = new exceptionMap[domError.name](message2 || domError.message, domError);
          if ("stack" in domError) {
            setProp(rv, "stack", { get: function() {
              return this.inner.stack;
            } });
          }
          return rv;
        }
        var fullNameExceptions = errorList.reduce(function(obj, name) {
          if (["Syntax", "Type", "Range"].indexOf(name) === -1)
            obj[name + "Error"] = exceptions[name];
          return obj;
        }, {});
        fullNameExceptions.ModifyError = ModifyError;
        fullNameExceptions.DexieError = DexieError;
        fullNameExceptions.BulkError = BulkError;
        function nop() {
        }
        function mirror(val) {
          return val;
        }
        function pureFunctionChain(f1, f2) {
          if (f1 == null || f1 === mirror)
            return f2;
          return function(val) {
            return f2(f1(val));
          };
        }
        function callBoth(on1, on2) {
          return function() {
            on1.apply(this, arguments);
            on2.apply(this, arguments);
          };
        }
        function hookCreatingChain(f1, f2) {
          if (f1 === nop)
            return f2;
          return function() {
            var res = f1.apply(this, arguments);
            if (res !== void 0)
              arguments[0] = res;
            var onsuccess = this.onsuccess, onerror = this.onerror;
            this.onsuccess = null;
            this.onerror = null;
            var res2 = f2.apply(this, arguments);
            if (onsuccess)
              this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;
            if (onerror)
              this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;
            return res2 !== void 0 ? res2 : res;
          };
        }
        function hookDeletingChain(f1, f2) {
          if (f1 === nop)
            return f2;
          return function() {
            f1.apply(this, arguments);
            var onsuccess = this.onsuccess, onerror = this.onerror;
            this.onsuccess = this.onerror = null;
            f2.apply(this, arguments);
            if (onsuccess)
              this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;
            if (onerror)
              this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;
          };
        }
        function hookUpdatingChain(f1, f2) {
          if (f1 === nop)
            return f2;
          return function(modifications) {
            var res = f1.apply(this, arguments);
            extend(modifications, res);
            var onsuccess = this.onsuccess, onerror = this.onerror;
            this.onsuccess = null;
            this.onerror = null;
            var res2 = f2.apply(this, arguments);
            if (onsuccess)
              this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;
            if (onerror)
              this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;
            return res === void 0 ? res2 === void 0 ? void 0 : res2 : extend(res, res2);
          };
        }
        function reverseStoppableEventChain(f1, f2) {
          if (f1 === nop)
            return f2;
          return function() {
            if (f2.apply(this, arguments) === false)
              return false;
            return f1.apply(this, arguments);
          };
        }
        function promisableChain(f1, f2) {
          if (f1 === nop)
            return f2;
          return function() {
            var res = f1.apply(this, arguments);
            if (res && typeof res.then === "function") {
              var thiz = this, i = arguments.length, args = new Array(i);
              while (i--)
                args[i] = arguments[i];
              return res.then(function() {
                return f2.apply(thiz, args);
              });
            }
            return f2.apply(this, arguments);
          };
        }
        var debug = typeof location !== "undefined" && /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);
        function setDebug(value, filter) {
          debug = value;
        }
        var INTERNAL = {};
        var ZONE_ECHO_LIMIT = 100, _a$1 = typeof Promise === "undefined" ? [] : (function() {
          var globalP = Promise.resolve();
          if (typeof crypto === "undefined" || !crypto.subtle)
            return [globalP, getProto(globalP), globalP];
          var nativeP = crypto.subtle.digest("SHA-512", new Uint8Array([0]));
          return [
            nativeP,
            getProto(nativeP),
            globalP
          ];
        })(), resolvedNativePromise = _a$1[0], nativePromiseProto = _a$1[1], resolvedGlobalPromise = _a$1[2], nativePromiseThen = nativePromiseProto && nativePromiseProto.then;
        var NativePromise = resolvedNativePromise && resolvedNativePromise.constructor;
        var patchGlobalPromise = !!resolvedGlobalPromise;
        function schedulePhysicalTick() {
          queueMicrotask(physicalTick);
        }
        var asap = function(callback, args) {
          microtickQueue.push([callback, args]);
          if (needsNewPhysicalTick) {
            schedulePhysicalTick();
            needsNewPhysicalTick = false;
          }
        };
        var isOutsideMicroTick = true, needsNewPhysicalTick = true, unhandledErrors = [], rejectingErrors = [], rejectionMapper = mirror;
        var globalPSD = {
          id: "global",
          global: true,
          ref: 0,
          unhandleds: [],
          onunhandled: nop,
          pgp: false,
          env: {},
          finalize: nop
        };
        var PSD = globalPSD;
        var microtickQueue = [];
        var numScheduledCalls = 0;
        var tickFinalizers = [];
        function DexiePromise(fn2) {
          if (typeof this !== "object")
            throw new TypeError("Promises must be constructed via new");
          this._listeners = [];
          this._lib = false;
          var psd = this._PSD = PSD;
          if (typeof fn2 !== "function") {
            if (fn2 !== INTERNAL)
              throw new TypeError("Not a function");
            this._state = arguments[1];
            this._value = arguments[2];
            if (this._state === false)
              handleRejection(this, this._value);
            return;
          }
          this._state = null;
          this._value = null;
          ++psd.ref;
          executePromiseTask(this, fn2);
        }
        var thenProp = {
          get: function() {
            var psd = PSD, microTaskId = totalEchoes;
            function then(onFulfilled, onRejected) {
              var _this = this;
              var possibleAwait = !psd.global && (psd !== PSD || microTaskId !== totalEchoes);
              var cleanup = possibleAwait && !decrementExpectedAwaits();
              var rv = new DexiePromise(function(resolve, reject) {
                propagateToListener(_this, new Listener(nativeAwaitCompatibleWrap(onFulfilled, psd, possibleAwait, cleanup), nativeAwaitCompatibleWrap(onRejected, psd, possibleAwait, cleanup), resolve, reject, psd));
              });
              if (this._consoleTask)
                rv._consoleTask = this._consoleTask;
              return rv;
            }
            then.prototype = INTERNAL;
            return then;
          },
          set: function(value) {
            setProp(this, "then", value && value.prototype === INTERNAL ? thenProp : {
              get: function() {
                return value;
              },
              set: thenProp.set
            });
          }
        };
        props(DexiePromise.prototype, {
          then: thenProp,
          _then: function(onFulfilled, onRejected) {
            propagateToListener(this, new Listener(null, null, onFulfilled, onRejected, PSD));
          },
          catch: function(onRejected) {
            if (arguments.length === 1)
              return this.then(null, onRejected);
            var type2 = arguments[0], handler = arguments[1];
            return typeof type2 === "function" ? this.then(null, function(err) {
              return err instanceof type2 ? handler(err) : PromiseReject(err);
            }) : this.then(null, function(err) {
              return err && err.name === type2 ? handler(err) : PromiseReject(err);
            });
          },
          finally: function(onFinally) {
            return this.then(function(value) {
              return DexiePromise.resolve(onFinally()).then(function() {
                return value;
              });
            }, function(err) {
              return DexiePromise.resolve(onFinally()).then(function() {
                return PromiseReject(err);
              });
            });
          },
          timeout: function(ms, msg) {
            var _this = this;
            return ms < Infinity ? new DexiePromise(function(resolve, reject) {
              var handle = setTimeout(function() {
                return reject(new exceptions.Timeout(msg));
              }, ms);
              _this.then(resolve, reject).finally(clearTimeout.bind(null, handle));
            }) : this;
          }
        });
        if (typeof Symbol !== "undefined" && Symbol.toStringTag)
          setProp(DexiePromise.prototype, Symbol.toStringTag, "Dexie.Promise");
        globalPSD.env = snapShot();
        function Listener(onFulfilled, onRejected, resolve, reject, zone) {
          this.onFulfilled = typeof onFulfilled === "function" ? onFulfilled : null;
          this.onRejected = typeof onRejected === "function" ? onRejected : null;
          this.resolve = resolve;
          this.reject = reject;
          this.psd = zone;
        }
        props(DexiePromise, {
          all: function() {
            var values = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
            return new DexiePromise(function(resolve, reject) {
              if (values.length === 0)
                resolve([]);
              var remaining = values.length;
              values.forEach(function(a, i) {
                return DexiePromise.resolve(a).then(function(x) {
                  values[i] = x;
                  if (!--remaining)
                    resolve(values);
                }, reject);
              });
            });
          },
          resolve: function(value) {
            if (value instanceof DexiePromise)
              return value;
            if (value && typeof value.then === "function")
              return new DexiePromise(function(resolve, reject) {
                value.then(resolve, reject);
              });
            var rv = new DexiePromise(INTERNAL, true, value);
            return rv;
          },
          reject: PromiseReject,
          race: function() {
            var values = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
            return new DexiePromise(function(resolve, reject) {
              values.map(function(value) {
                return DexiePromise.resolve(value).then(resolve, reject);
              });
            });
          },
          PSD: {
            get: function() {
              return PSD;
            },
            set: function(value) {
              return PSD = value;
            }
          },
          totalEchoes: { get: function() {
            return totalEchoes;
          } },
          newPSD: newScope,
          usePSD,
          scheduler: {
            get: function() {
              return asap;
            },
            set: function(value) {
              asap = value;
            }
          },
          rejectionMapper: {
            get: function() {
              return rejectionMapper;
            },
            set: function(value) {
              rejectionMapper = value;
            }
          },
          follow: function(fn2, zoneProps) {
            return new DexiePromise(function(resolve, reject) {
              return newScope(function(resolve2, reject2) {
                var psd = PSD;
                psd.unhandleds = [];
                psd.onunhandled = reject2;
                psd.finalize = callBoth(function() {
                  var _this = this;
                  run_at_end_of_this_or_next_physical_tick(function() {
                    _this.unhandleds.length === 0 ? resolve2() : reject2(_this.unhandleds[0]);
                  });
                }, psd.finalize);
                fn2();
              }, zoneProps, resolve, reject);
            });
          }
        });
        if (NativePromise) {
          if (NativePromise.allSettled)
            setProp(DexiePromise, "allSettled", function() {
              var possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
              return new DexiePromise(function(resolve) {
                if (possiblePromises.length === 0)
                  resolve([]);
                var remaining = possiblePromises.length;
                var results = new Array(remaining);
                possiblePromises.forEach(function(p, i) {
                  return DexiePromise.resolve(p).then(function(value) {
                    return results[i] = { status: "fulfilled", value };
                  }, function(reason) {
                    return results[i] = { status: "rejected", reason };
                  }).then(function() {
                    return --remaining || resolve(results);
                  });
                });
              });
            });
          if (NativePromise.any && typeof AggregateError !== "undefined")
            setProp(DexiePromise, "any", function() {
              var possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
              return new DexiePromise(function(resolve, reject) {
                if (possiblePromises.length === 0)
                  reject(new AggregateError([]));
                var remaining = possiblePromises.length;
                var failures = new Array(remaining);
                possiblePromises.forEach(function(p, i) {
                  return DexiePromise.resolve(p).then(function(value) {
                    return resolve(value);
                  }, function(failure) {
                    failures[i] = failure;
                    if (!--remaining)
                      reject(new AggregateError(failures));
                  });
                });
              });
            });
          if (NativePromise.withResolvers)
            DexiePromise.withResolvers = NativePromise.withResolvers;
        }
        function executePromiseTask(promise, fn2) {
          try {
            fn2(function(value) {
              if (promise._state !== null)
                return;
              if (value === promise)
                throw new TypeError("A promise cannot be resolved with itself.");
              var shouldExecuteTick = promise._lib && beginMicroTickScope();
              if (value && typeof value.then === "function") {
                executePromiseTask(promise, function(resolve, reject) {
                  value instanceof DexiePromise ? value._then(resolve, reject) : value.then(resolve, reject);
                });
              } else {
                promise._state = true;
                promise._value = value;
                propagateAllListeners(promise);
              }
              if (shouldExecuteTick)
                endMicroTickScope();
            }, handleRejection.bind(null, promise));
          } catch (ex) {
            handleRejection(promise, ex);
          }
        }
        function handleRejection(promise, reason) {
          rejectingErrors.push(reason);
          if (promise._state !== null)
            return;
          var shouldExecuteTick = promise._lib && beginMicroTickScope();
          reason = rejectionMapper(reason);
          promise._state = false;
          promise._value = reason;
          addPossiblyUnhandledError(promise);
          propagateAllListeners(promise);
          if (shouldExecuteTick)
            endMicroTickScope();
        }
        function propagateAllListeners(promise) {
          var listeners = promise._listeners;
          promise._listeners = [];
          for (var i = 0, len = listeners.length; i < len; ++i) {
            propagateToListener(promise, listeners[i]);
          }
          var psd = promise._PSD;
          --psd.ref || psd.finalize();
          if (numScheduledCalls === 0) {
            ++numScheduledCalls;
            asap(function() {
              if (--numScheduledCalls === 0)
                finalizePhysicalTick();
            }, []);
          }
        }
        function propagateToListener(promise, listener) {
          if (promise._state === null) {
            promise._listeners.push(listener);
            return;
          }
          var cb = promise._state ? listener.onFulfilled : listener.onRejected;
          if (cb === null) {
            return (promise._state ? listener.resolve : listener.reject)(promise._value);
          }
          ++listener.psd.ref;
          ++numScheduledCalls;
          asap(callListener, [cb, promise, listener]);
        }
        function callListener(cb, promise, listener) {
          try {
            var ret, value = promise._value;
            if (!promise._state && rejectingErrors.length)
              rejectingErrors = [];
            ret = debug && promise._consoleTask ? promise._consoleTask.run(function() {
              return cb(value);
            }) : cb(value);
            if (!promise._state && rejectingErrors.indexOf(value) === -1) {
              markErrorAsHandled(promise);
            }
            listener.resolve(ret);
          } catch (e) {
            listener.reject(e);
          } finally {
            if (--numScheduledCalls === 0)
              finalizePhysicalTick();
            --listener.psd.ref || listener.psd.finalize();
          }
        }
        function physicalTick() {
          usePSD(globalPSD, function() {
            beginMicroTickScope() && endMicroTickScope();
          });
        }
        function beginMicroTickScope() {
          var wasRootExec = isOutsideMicroTick;
          isOutsideMicroTick = false;
          needsNewPhysicalTick = false;
          return wasRootExec;
        }
        function endMicroTickScope() {
          var callbacks, i, l;
          do {
            while (microtickQueue.length > 0) {
              callbacks = microtickQueue;
              microtickQueue = [];
              l = callbacks.length;
              for (i = 0; i < l; ++i) {
                var item = callbacks[i];
                item[0].apply(null, item[1]);
              }
            }
          } while (microtickQueue.length > 0);
          isOutsideMicroTick = true;
          needsNewPhysicalTick = true;
        }
        function finalizePhysicalTick() {
          var unhandledErrs = unhandledErrors;
          unhandledErrors = [];
          unhandledErrs.forEach(function(p) {
            p._PSD.onunhandled.call(null, p._value, p);
          });
          var finalizers = tickFinalizers.slice(0);
          var i = finalizers.length;
          while (i)
            finalizers[--i]();
        }
        function run_at_end_of_this_or_next_physical_tick(fn2) {
          function finalizer() {
            fn2();
            tickFinalizers.splice(tickFinalizers.indexOf(finalizer), 1);
          }
          tickFinalizers.push(finalizer);
          ++numScheduledCalls;
          asap(function() {
            if (--numScheduledCalls === 0)
              finalizePhysicalTick();
          }, []);
        }
        function addPossiblyUnhandledError(promise) {
          if (!unhandledErrors.some(function(p) {
            return p._value === promise._value;
          }))
            unhandledErrors.push(promise);
        }
        function markErrorAsHandled(promise) {
          var i = unhandledErrors.length;
          while (i)
            if (unhandledErrors[--i]._value === promise._value) {
              unhandledErrors.splice(i, 1);
              return;
            }
        }
        function PromiseReject(reason) {
          return new DexiePromise(INTERNAL, false, reason);
        }
        function wrap4(fn2, errorCatcher) {
          var psd = PSD;
          return function() {
            var wasRootExec = beginMicroTickScope(), outerScope = PSD;
            try {
              switchToZone(psd, true);
              return fn2.apply(this, arguments);
            } catch (e) {
              errorCatcher && errorCatcher(e);
            } finally {
              switchToZone(outerScope, false);
              if (wasRootExec)
                endMicroTickScope();
            }
          };
        }
        var task = { awaits: 0, echoes: 0, id: 0 };
        var taskCounter = 0;
        var zoneStack = [];
        var zoneEchoes = 0;
        var totalEchoes = 0;
        var zone_id_counter = 0;
        function newScope(fn2, props2, a1, a2) {
          var parent = PSD, psd = Object.create(parent);
          psd.parent = parent;
          psd.ref = 0;
          psd.global = false;
          psd.id = ++zone_id_counter;
          globalPSD.env;
          psd.env = patchGlobalPromise ? {
            Promise: DexiePromise,
            PromiseProp: { value: DexiePromise, configurable: true, writable: true },
            all: DexiePromise.all,
            race: DexiePromise.race,
            allSettled: DexiePromise.allSettled,
            any: DexiePromise.any,
            resolve: DexiePromise.resolve,
            reject: DexiePromise.reject
          } : {};
          if (props2)
            extend(psd, props2);
          ++parent.ref;
          psd.finalize = function() {
            --this.parent.ref || this.parent.finalize();
          };
          var rv = usePSD(psd, fn2, a1, a2);
          if (psd.ref === 0)
            psd.finalize();
          return rv;
        }
        function incrementExpectedAwaits() {
          if (!task.id)
            task.id = ++taskCounter;
          ++task.awaits;
          task.echoes += ZONE_ECHO_LIMIT;
          return task.id;
        }
        function decrementExpectedAwaits() {
          if (!task.awaits)
            return false;
          if (--task.awaits === 0)
            task.id = 0;
          task.echoes = task.awaits * ZONE_ECHO_LIMIT;
          return true;
        }
        if (("" + nativePromiseThen).indexOf("[native code]") === -1) {
          incrementExpectedAwaits = decrementExpectedAwaits = nop;
        }
        function onPossibleParallellAsync(possiblePromise) {
          if (task.echoes && possiblePromise && possiblePromise.constructor === NativePromise) {
            incrementExpectedAwaits();
            return possiblePromise.then(function(x) {
              decrementExpectedAwaits();
              return x;
            }, function(e) {
              decrementExpectedAwaits();
              return rejection(e);
            });
          }
          return possiblePromise;
        }
        function zoneEnterEcho(targetZone) {
          ++totalEchoes;
          if (!task.echoes || --task.echoes === 0) {
            task.echoes = task.awaits = task.id = 0;
          }
          zoneStack.push(PSD);
          switchToZone(targetZone, true);
        }
        function zoneLeaveEcho() {
          var zone = zoneStack[zoneStack.length - 1];
          zoneStack.pop();
          switchToZone(zone, false);
        }
        function switchToZone(targetZone, bEnteringZone) {
          var currentZone = PSD;
          if (bEnteringZone ? task.echoes && (!zoneEchoes++ || targetZone !== PSD) : zoneEchoes && (!--zoneEchoes || targetZone !== PSD)) {
            queueMicrotask(bEnteringZone ? zoneEnterEcho.bind(null, targetZone) : zoneLeaveEcho);
          }
          if (targetZone === PSD)
            return;
          PSD = targetZone;
          if (currentZone === globalPSD)
            globalPSD.env = snapShot();
          if (patchGlobalPromise) {
            var GlobalPromise = globalPSD.env.Promise;
            var targetEnv = targetZone.env;
            if (currentZone.global || targetZone.global) {
              Object.defineProperty(_global, "Promise", targetEnv.PromiseProp);
              GlobalPromise.all = targetEnv.all;
              GlobalPromise.race = targetEnv.race;
              GlobalPromise.resolve = targetEnv.resolve;
              GlobalPromise.reject = targetEnv.reject;
              if (targetEnv.allSettled)
                GlobalPromise.allSettled = targetEnv.allSettled;
              if (targetEnv.any)
                GlobalPromise.any = targetEnv.any;
            }
          }
        }
        function snapShot() {
          var GlobalPromise = _global.Promise;
          return patchGlobalPromise ? {
            Promise: GlobalPromise,
            PromiseProp: Object.getOwnPropertyDescriptor(_global, "Promise"),
            all: GlobalPromise.all,
            race: GlobalPromise.race,
            allSettled: GlobalPromise.allSettled,
            any: GlobalPromise.any,
            resolve: GlobalPromise.resolve,
            reject: GlobalPromise.reject
          } : {};
        }
        function usePSD(psd, fn2, a1, a2, a3) {
          var outerScope = PSD;
          try {
            switchToZone(psd, true);
            return fn2(a1, a2, a3);
          } finally {
            switchToZone(outerScope, false);
          }
        }
        function nativeAwaitCompatibleWrap(fn2, zone, possibleAwait, cleanup) {
          return typeof fn2 !== "function" ? fn2 : function() {
            var outerZone = PSD;
            if (possibleAwait)
              incrementExpectedAwaits();
            switchToZone(zone, true);
            try {
              return fn2.apply(this, arguments);
            } finally {
              switchToZone(outerZone, false);
              if (cleanup)
                queueMicrotask(decrementExpectedAwaits);
            }
          };
        }
        function execInGlobalContext(cb) {
          if (Promise === NativePromise && task.echoes === 0) {
            if (zoneEchoes === 0) {
              cb();
            } else {
              enqueueNativeMicroTask(cb);
            }
          } else {
            setTimeout(cb, 0);
          }
        }
        var rejection = DexiePromise.reject;
        function tempTransaction(db2, mode, storeNames, fn2) {
          if (!db2.idbdb || !db2._state.openComplete && (!PSD.letThrough && !db2._vip)) {
            if (db2._state.openComplete) {
              return rejection(new exceptions.DatabaseClosed(db2._state.dbOpenError));
            }
            if (!db2._state.isBeingOpened) {
              if (!db2._state.autoOpen)
                return rejection(new exceptions.DatabaseClosed());
              db2.open().catch(nop);
            }
            return db2._state.dbReadyPromise.then(function() {
              return tempTransaction(db2, mode, storeNames, fn2);
            });
          } else {
            var trans = db2._createTransaction(mode, storeNames, db2._dbSchema);
            try {
              trans.create();
              db2._state.PR1398_maxLoop = 3;
            } catch (ex) {
              if (ex.name === errnames.InvalidState && db2.isOpen() && --db2._state.PR1398_maxLoop > 0) {
                console.warn("Dexie: Need to reopen db");
                db2.close({ disableAutoOpen: false });
                return db2.open().then(function() {
                  return tempTransaction(db2, mode, storeNames, fn2);
                });
              }
              return rejection(ex);
            }
            return trans._promise(mode, function(resolve, reject) {
              return newScope(function() {
                PSD.trans = trans;
                return fn2(resolve, reject, trans);
              });
            }).then(function(result2) {
              if (mode === "readwrite")
                try {
                  trans.idbtrans.commit();
                } catch (_a3) {
                }
              return mode === "readonly" ? result2 : trans._completion.then(function() {
                return result2;
              });
            });
          }
        }
        var DEXIE_VERSION = "4.0.11";
        var maxString = String.fromCharCode(65535);
        var minKey = -Infinity;
        var INVALID_KEY_ARGUMENT = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.";
        var STRING_EXPECTED = "String expected.";
        var connections = [];
        var DBNAMES_DB = "__dbnames";
        var READONLY = "readonly";
        var READWRITE = "readwrite";
        function combine3(filter1, filter2) {
          return filter1 ? filter2 ? function() {
            return filter1.apply(this, arguments) && filter2.apply(this, arguments);
          } : filter1 : filter2;
        }
        var AnyRange = {
          type: 3,
          lower: -Infinity,
          lowerOpen: false,
          upper: [[]],
          upperOpen: false
        };
        function workaroundForUndefinedPrimKey(keyPath) {
          return typeof keyPath === "string" && !/\./.test(keyPath) ? function(obj) {
            if (obj[keyPath] === void 0 && keyPath in obj) {
              obj = deepClone(obj);
              delete obj[keyPath];
            }
            return obj;
          } : function(obj) {
            return obj;
          };
        }
        function Entity2() {
          throw exceptions.Type();
        }
        function cmp2(a, b) {
          try {
            var ta = type(a);
            var tb = type(b);
            if (ta !== tb) {
              if (ta === "Array")
                return 1;
              if (tb === "Array")
                return -1;
              if (ta === "binary")
                return 1;
              if (tb === "binary")
                return -1;
              if (ta === "string")
                return 1;
              if (tb === "string")
                return -1;
              if (ta === "Date")
                return 1;
              if (tb !== "Date")
                return NaN;
              return -1;
            }
            switch (ta) {
              case "number":
              case "Date":
              case "string":
                return a > b ? 1 : a < b ? -1 : 0;
              case "binary": {
                return compareUint8Arrays(getUint8Array(a), getUint8Array(b));
              }
              case "Array":
                return compareArrays(a, b);
            }
          } catch (_a3) {
          }
          return NaN;
        }
        function compareArrays(a, b) {
          var al = a.length;
          var bl = b.length;
          var l = al < bl ? al : bl;
          for (var i = 0; i < l; ++i) {
            var res = cmp2(a[i], b[i]);
            if (res !== 0)
              return res;
          }
          return al === bl ? 0 : al < bl ? -1 : 1;
        }
        function compareUint8Arrays(a, b) {
          var al = a.length;
          var bl = b.length;
          var l = al < bl ? al : bl;
          for (var i = 0; i < l; ++i) {
            if (a[i] !== b[i])
              return a[i] < b[i] ? -1 : 1;
          }
          return al === bl ? 0 : al < bl ? -1 : 1;
        }
        function type(x) {
          var t = typeof x;
          if (t !== "object")
            return t;
          if (ArrayBuffer.isView(x))
            return "binary";
          var tsTag = toStringTag(x);
          return tsTag === "ArrayBuffer" ? "binary" : tsTag;
        }
        function getUint8Array(a) {
          if (a instanceof Uint8Array)
            return a;
          if (ArrayBuffer.isView(a))
            return new Uint8Array(a.buffer, a.byteOffset, a.byteLength);
          return new Uint8Array(a);
        }
        var Table = (function() {
          function Table2() {
          }
          Table2.prototype._trans = function(mode, fn2, writeLocked) {
            var trans = this._tx || PSD.trans;
            var tableName = this.name;
            var task2 = debug && typeof console !== "undefined" && console.createTask && console.createTask("Dexie: ".concat(mode === "readonly" ? "read" : "write", " ").concat(this.name));
            function checkTableInTransaction(resolve, reject, trans2) {
              if (!trans2.schema[tableName])
                throw new exceptions.NotFound("Table " + tableName + " not part of transaction");
              return fn2(trans2.idbtrans, trans2);
            }
            var wasRootExec = beginMicroTickScope();
            try {
              var p = trans && trans.db._novip === this.db._novip ? trans === PSD.trans ? trans._promise(mode, checkTableInTransaction, writeLocked) : newScope(function() {
                return trans._promise(mode, checkTableInTransaction, writeLocked);
              }, { trans, transless: PSD.transless || PSD }) : tempTransaction(this.db, mode, [this.name], checkTableInTransaction);
              if (task2) {
                p._consoleTask = task2;
                p = p.catch(function(err) {
                  console.trace(err);
                  return rejection(err);
                });
              }
              return p;
            } finally {
              if (wasRootExec)
                endMicroTickScope();
            }
          };
          Table2.prototype.get = function(keyOrCrit, cb) {
            var _this = this;
            if (keyOrCrit && keyOrCrit.constructor === Object)
              return this.where(keyOrCrit).first(cb);
            if (keyOrCrit == null)
              return rejection(new exceptions.Type("Invalid argument to Table.get()"));
            return this._trans("readonly", function(trans) {
              return _this.core.get({ trans, key: keyOrCrit }).then(function(res) {
                return _this.hook.reading.fire(res);
              });
            }).then(cb);
          };
          Table2.prototype.where = function(indexOrCrit) {
            if (typeof indexOrCrit === "string")
              return new this.db.WhereClause(this, indexOrCrit);
            if (isArray3(indexOrCrit))
              return new this.db.WhereClause(this, "[".concat(indexOrCrit.join("+"), "]"));
            var keyPaths = keys(indexOrCrit);
            if (keyPaths.length === 1)
              return this.where(keyPaths[0]).equals(indexOrCrit[keyPaths[0]]);
            var compoundIndex = this.schema.indexes.concat(this.schema.primKey).filter(function(ix) {
              if (ix.compound && keyPaths.every(function(keyPath) {
                return ix.keyPath.indexOf(keyPath) >= 0;
              })) {
                for (var i = 0; i < keyPaths.length; ++i) {
                  if (keyPaths.indexOf(ix.keyPath[i]) === -1)
                    return false;
                }
                return true;
              }
              return false;
            }).sort(function(a, b) {
              return a.keyPath.length - b.keyPath.length;
            })[0];
            if (compoundIndex && this.db._maxKey !== maxString) {
              var keyPathsInValidOrder = compoundIndex.keyPath.slice(0, keyPaths.length);
              return this.where(keyPathsInValidOrder).equals(keyPathsInValidOrder.map(function(kp) {
                return indexOrCrit[kp];
              }));
            }
            if (!compoundIndex && debug)
              console.warn("The query ".concat(JSON.stringify(indexOrCrit), " on ").concat(this.name, " would benefit from a ") + "compound index [".concat(keyPaths.join("+"), "]"));
            var idxByName = this.schema.idxByName;
            function equals(a, b) {
              return cmp2(a, b) === 0;
            }
            var _a3 = keyPaths.reduce(function(_a4, keyPath) {
              var prevIndex = _a4[0], prevFilterFn = _a4[1];
              var index2 = idxByName[keyPath];
              var value = indexOrCrit[keyPath];
              return [
                prevIndex || index2,
                prevIndex || !index2 ? combine3(prevFilterFn, index2 && index2.multi ? function(x) {
                  var prop = getByKeyPath(x, keyPath);
                  return isArray3(prop) && prop.some(function(item) {
                    return equals(value, item);
                  });
                } : function(x) {
                  return equals(value, getByKeyPath(x, keyPath));
                }) : prevFilterFn
              ];
            }, [null, null]), idx = _a3[0], filterFunction = _a3[1];
            return idx ? this.where(idx.name).equals(indexOrCrit[idx.keyPath]).filter(filterFunction) : compoundIndex ? this.filter(filterFunction) : this.where(keyPaths).equals("");
          };
          Table2.prototype.filter = function(filterFunction) {
            return this.toCollection().and(filterFunction);
          };
          Table2.prototype.count = function(thenShortcut) {
            return this.toCollection().count(thenShortcut);
          };
          Table2.prototype.offset = function(offset3) {
            return this.toCollection().offset(offset3);
          };
          Table2.prototype.limit = function(numRows) {
            return this.toCollection().limit(numRows);
          };
          Table2.prototype.each = function(callback) {
            return this.toCollection().each(callback);
          };
          Table2.prototype.toArray = function(thenShortcut) {
            return this.toCollection().toArray(thenShortcut);
          };
          Table2.prototype.toCollection = function() {
            return new this.db.Collection(new this.db.WhereClause(this));
          };
          Table2.prototype.orderBy = function(index2) {
            return new this.db.Collection(new this.db.WhereClause(this, isArray3(index2) ? "[".concat(index2.join("+"), "]") : index2));
          };
          Table2.prototype.reverse = function() {
            return this.toCollection().reverse();
          };
          Table2.prototype.mapToClass = function(constructor) {
            var _a3 = this, db2 = _a3.db, tableName = _a3.name;
            this.schema.mappedClass = constructor;
            if (constructor.prototype instanceof Entity2) {
              constructor = (function(_super) {
                __extends2(class_1, _super);
                function class_1() {
                  return _super !== null && _super.apply(this, arguments) || this;
                }
                Object.defineProperty(class_1.prototype, "db", {
                  get: function() {
                    return db2;
                  },
                  enumerable: false,
                  configurable: true
                });
                class_1.prototype.table = function() {
                  return tableName;
                };
                return class_1;
              })(constructor);
            }
            var inheritedProps = /* @__PURE__ */ new Set();
            for (var proto = constructor.prototype; proto; proto = getProto(proto)) {
              Object.getOwnPropertyNames(proto).forEach(function(propName) {
                return inheritedProps.add(propName);
              });
            }
            var readHook = function(obj) {
              if (!obj)
                return obj;
              var res = Object.create(constructor.prototype);
              for (var m in obj)
                if (!inheritedProps.has(m))
                  try {
                    res[m] = obj[m];
                  } catch (_) {
                  }
              return res;
            };
            if (this.schema.readHook) {
              this.hook.reading.unsubscribe(this.schema.readHook);
            }
            this.schema.readHook = readHook;
            this.hook("reading", readHook);
            return constructor;
          };
          Table2.prototype.defineClass = function() {
            function Class(content) {
              extend(this, content);
            }
            return this.mapToClass(Class);
          };
          Table2.prototype.add = function(obj, key) {
            var _this = this;
            var _a3 = this.schema.primKey, auto2 = _a3.auto, keyPath = _a3.keyPath;
            var objToAdd = obj;
            if (keyPath && auto2) {
              objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);
            }
            return this._trans("readwrite", function(trans) {
              return _this.core.mutate({ trans, type: "add", keys: key != null ? [key] : null, values: [objToAdd] });
            }).then(function(res) {
              return res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult;
            }).then(function(lastResult) {
              if (keyPath) {
                try {
                  setByKeyPath(obj, keyPath, lastResult);
                } catch (_) {
                }
              }
              return lastResult;
            });
          };
          Table2.prototype.update = function(keyOrObject, modifications) {
            if (typeof keyOrObject === "object" && !isArray3(keyOrObject)) {
              var key = getByKeyPath(keyOrObject, this.schema.primKey.keyPath);
              if (key === void 0)
                return rejection(new exceptions.InvalidArgument("Given object does not contain its primary key"));
              return this.where(":id").equals(key).modify(modifications);
            } else {
              return this.where(":id").equals(keyOrObject).modify(modifications);
            }
          };
          Table2.prototype.put = function(obj, key) {
            var _this = this;
            var _a3 = this.schema.primKey, auto2 = _a3.auto, keyPath = _a3.keyPath;
            var objToAdd = obj;
            if (keyPath && auto2) {
              objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);
            }
            return this._trans("readwrite", function(trans) {
              return _this.core.mutate({ trans, type: "put", values: [objToAdd], keys: key != null ? [key] : null });
            }).then(function(res) {
              return res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult;
            }).then(function(lastResult) {
              if (keyPath) {
                try {
                  setByKeyPath(obj, keyPath, lastResult);
                } catch (_) {
                }
              }
              return lastResult;
            });
          };
          Table2.prototype.delete = function(key) {
            var _this = this;
            return this._trans("readwrite", function(trans) {
              return _this.core.mutate({ trans, type: "delete", keys: [key] });
            }).then(function(res) {
              return res.numFailures ? DexiePromise.reject(res.failures[0]) : void 0;
            });
          };
          Table2.prototype.clear = function() {
            var _this = this;
            return this._trans("readwrite", function(trans) {
              return _this.core.mutate({ trans, type: "deleteRange", range: AnyRange });
            }).then(function(res) {
              return res.numFailures ? DexiePromise.reject(res.failures[0]) : void 0;
            });
          };
          Table2.prototype.bulkGet = function(keys2) {
            var _this = this;
            return this._trans("readonly", function(trans) {
              return _this.core.getMany({
                keys: keys2,
                trans
              }).then(function(result2) {
                return result2.map(function(res) {
                  return _this.hook.reading.fire(res);
                });
              });
            });
          };
          Table2.prototype.bulkAdd = function(objects, keysOrOptions, options2) {
            var _this = this;
            var keys2 = Array.isArray(keysOrOptions) ? keysOrOptions : void 0;
            options2 = options2 || (keys2 ? void 0 : keysOrOptions);
            var wantResults = options2 ? options2.allKeys : void 0;
            return this._trans("readwrite", function(trans) {
              var _a3 = _this.schema.primKey, auto2 = _a3.auto, keyPath = _a3.keyPath;
              if (keyPath && keys2)
                throw new exceptions.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");
              if (keys2 && keys2.length !== objects.length)
                throw new exceptions.InvalidArgument("Arguments objects and keys must have the same length");
              var numObjects = objects.length;
              var objectsToAdd = keyPath && auto2 ? objects.map(workaroundForUndefinedPrimKey(keyPath)) : objects;
              return _this.core.mutate({ trans, type: "add", keys: keys2, values: objectsToAdd, wantResults }).then(function(_a4) {
                var numFailures = _a4.numFailures, results = _a4.results, lastResult = _a4.lastResult, failures = _a4.failures;
                var result2 = wantResults ? results : lastResult;
                if (numFailures === 0)
                  return result2;
                throw new BulkError("".concat(_this.name, ".bulkAdd(): ").concat(numFailures, " of ").concat(numObjects, " operations failed"), failures);
              });
            });
          };
          Table2.prototype.bulkPut = function(objects, keysOrOptions, options2) {
            var _this = this;
            var keys2 = Array.isArray(keysOrOptions) ? keysOrOptions : void 0;
            options2 = options2 || (keys2 ? void 0 : keysOrOptions);
            var wantResults = options2 ? options2.allKeys : void 0;
            return this._trans("readwrite", function(trans) {
              var _a3 = _this.schema.primKey, auto2 = _a3.auto, keyPath = _a3.keyPath;
              if (keyPath && keys2)
                throw new exceptions.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");
              if (keys2 && keys2.length !== objects.length)
                throw new exceptions.InvalidArgument("Arguments objects and keys must have the same length");
              var numObjects = objects.length;
              var objectsToPut = keyPath && auto2 ? objects.map(workaroundForUndefinedPrimKey(keyPath)) : objects;
              return _this.core.mutate({ trans, type: "put", keys: keys2, values: objectsToPut, wantResults }).then(function(_a4) {
                var numFailures = _a4.numFailures, results = _a4.results, lastResult = _a4.lastResult, failures = _a4.failures;
                var result2 = wantResults ? results : lastResult;
                if (numFailures === 0)
                  return result2;
                throw new BulkError("".concat(_this.name, ".bulkPut(): ").concat(numFailures, " of ").concat(numObjects, " operations failed"), failures);
              });
            });
          };
          Table2.prototype.bulkUpdate = function(keysAndChanges) {
            var _this = this;
            var coreTable = this.core;
            var keys2 = keysAndChanges.map(function(entry) {
              return entry.key;
            });
            var changeSpecs = keysAndChanges.map(function(entry) {
              return entry.changes;
            });
            var offsetMap = [];
            return this._trans("readwrite", function(trans) {
              return coreTable.getMany({ trans, keys: keys2, cache: "clone" }).then(function(objs) {
                var resultKeys = [];
                var resultObjs = [];
                keysAndChanges.forEach(function(_a3, idx) {
                  var key = _a3.key, changes = _a3.changes;
                  var obj = objs[idx];
                  if (obj) {
                    for (var _i = 0, _b = Object.keys(changes); _i < _b.length; _i++) {
                      var keyPath = _b[_i];
                      var value = changes[keyPath];
                      if (keyPath === _this.schema.primKey.keyPath) {
                        if (cmp2(value, key) !== 0) {
                          throw new exceptions.Constraint("Cannot update primary key in bulkUpdate()");
                        }
                      } else {
                        setByKeyPath(obj, keyPath, value);
                      }
                    }
                    offsetMap.push(idx);
                    resultKeys.push(key);
                    resultObjs.push(obj);
                  }
                });
                var numEntries = resultKeys.length;
                return coreTable.mutate({
                  trans,
                  type: "put",
                  keys: resultKeys,
                  values: resultObjs,
                  updates: {
                    keys: keys2,
                    changeSpecs
                  }
                }).then(function(_a3) {
                  var numFailures = _a3.numFailures, failures = _a3.failures;
                  if (numFailures === 0)
                    return numEntries;
                  for (var _i = 0, _b = Object.keys(failures); _i < _b.length; _i++) {
                    var offset3 = _b[_i];
                    var mappedOffset = offsetMap[Number(offset3)];
                    if (mappedOffset != null) {
                      var failure = failures[offset3];
                      delete failures[offset3];
                      failures[mappedOffset] = failure;
                    }
                  }
                  throw new BulkError("".concat(_this.name, ".bulkUpdate(): ").concat(numFailures, " of ").concat(numEntries, " operations failed"), failures);
                });
              });
            });
          };
          Table2.prototype.bulkDelete = function(keys2) {
            var _this = this;
            var numKeys = keys2.length;
            return this._trans("readwrite", function(trans) {
              return _this.core.mutate({ trans, type: "delete", keys: keys2 });
            }).then(function(_a3) {
              var numFailures = _a3.numFailures, lastResult = _a3.lastResult, failures = _a3.failures;
              if (numFailures === 0)
                return lastResult;
              throw new BulkError("".concat(_this.name, ".bulkDelete(): ").concat(numFailures, " of ").concat(numKeys, " operations failed"), failures);
            });
          };
          return Table2;
        })();
        function Events(ctx) {
          var evs = {};
          var rv = function(eventName, subscriber) {
            if (subscriber) {
              var i2 = arguments.length, args = new Array(i2 - 1);
              while (--i2)
                args[i2 - 1] = arguments[i2];
              evs[eventName].subscribe.apply(null, args);
              return ctx;
            } else if (typeof eventName === "string") {
              return evs[eventName];
            }
          };
          rv.addEventType = add3;
          for (var i = 1, l = arguments.length; i < l; ++i) {
            add3(arguments[i]);
          }
          return rv;
          function add3(eventName, chainFunction, defaultFunction) {
            if (typeof eventName === "object")
              return addConfiguredEvents(eventName);
            if (!chainFunction)
              chainFunction = reverseStoppableEventChain;
            if (!defaultFunction)
              defaultFunction = nop;
            var context = {
              subscribers: [],
              fire: defaultFunction,
              subscribe: function(cb) {
                if (context.subscribers.indexOf(cb) === -1) {
                  context.subscribers.push(cb);
                  context.fire = chainFunction(context.fire, cb);
                }
              },
              unsubscribe: function(cb) {
                context.subscribers = context.subscribers.filter(function(fn2) {
                  return fn2 !== cb;
                });
                context.fire = context.subscribers.reduce(chainFunction, defaultFunction);
              }
            };
            evs[eventName] = rv[eventName] = context;
            return context;
          }
          function addConfiguredEvents(cfg) {
            keys(cfg).forEach(function(eventName) {
              var args = cfg[eventName];
              if (isArray3(args)) {
                add3(eventName, cfg[eventName][0], cfg[eventName][1]);
              } else if (args === "asap") {
                var context = add3(eventName, mirror, function fire() {
                  var i2 = arguments.length, args2 = new Array(i2);
                  while (i2--)
                    args2[i2] = arguments[i2];
                  context.subscribers.forEach(function(fn2) {
                    asap$1(function fireEvent() {
                      fn2.apply(null, args2);
                    });
                  });
                });
              } else
                throw new exceptions.InvalidArgument("Invalid event config");
            });
          }
        }
        function makeClassConstructor(prototype2, constructor) {
          derive(constructor).from({ prototype: prototype2 });
          return constructor;
        }
        function createTableConstructor(db2) {
          return makeClassConstructor(Table.prototype, function Table2(name, tableSchema, trans) {
            this.db = db2;
            this._tx = trans;
            this.name = name;
            this.schema = tableSchema;
            this.hook = db2._allTables[name] ? db2._allTables[name].hook : Events(null, {
              "creating": [hookCreatingChain, nop],
              "reading": [pureFunctionChain, mirror],
              "updating": [hookUpdatingChain, nop],
              "deleting": [hookDeletingChain, nop]
            });
          });
        }
        function isPlainKeyRange(ctx, ignoreLimitFilter) {
          return !(ctx.filter || ctx.algorithm || ctx.or) && (ignoreLimitFilter ? ctx.justLimit : !ctx.replayFilter);
        }
        function addFilter(ctx, fn2) {
          ctx.filter = combine3(ctx.filter, fn2);
        }
        function addReplayFilter(ctx, factory, isLimitFilter) {
          var curr = ctx.replayFilter;
          ctx.replayFilter = curr ? function() {
            return combine3(curr(), factory());
          } : factory;
          ctx.justLimit = isLimitFilter && !curr;
        }
        function addMatchFilter(ctx, fn2) {
          ctx.isMatch = combine3(ctx.isMatch, fn2);
        }
        function getIndexOrStore(ctx, coreSchema) {
          if (ctx.isPrimKey)
            return coreSchema.primaryKey;
          var index2 = coreSchema.getIndexByKeyPath(ctx.index);
          if (!index2)
            throw new exceptions.Schema("KeyPath " + ctx.index + " on object store " + coreSchema.name + " is not indexed");
          return index2;
        }
        function openCursor(ctx, coreTable, trans) {
          var index2 = getIndexOrStore(ctx, coreTable.schema);
          return coreTable.openCursor({
            trans,
            values: !ctx.keysOnly,
            reverse: ctx.dir === "prev",
            unique: !!ctx.unique,
            query: {
              index: index2,
              range: ctx.range
            }
          });
        }
        function iter(ctx, fn2, coreTrans, coreTable) {
          var filter = ctx.replayFilter ? combine3(ctx.filter, ctx.replayFilter()) : ctx.filter;
          if (!ctx.or) {
            return iterate(openCursor(ctx, coreTable, coreTrans), combine3(ctx.algorithm, filter), fn2, !ctx.keysOnly && ctx.valueMapper);
          } else {
            var set_1 = {};
            var union = function(item, cursor2, advance) {
              if (!filter || filter(cursor2, advance, function(result2) {
                return cursor2.stop(result2);
              }, function(err) {
                return cursor2.fail(err);
              })) {
                var primaryKey = cursor2.primaryKey;
                var key = "" + primaryKey;
                if (key === "[object ArrayBuffer]")
                  key = "" + new Uint8Array(primaryKey);
                if (!hasOwn3(set_1, key)) {
                  set_1[key] = true;
                  fn2(item, cursor2, advance);
                }
              }
            };
            return Promise.all([
              ctx.or._iterate(union, coreTrans),
              iterate(openCursor(ctx, coreTable, coreTrans), ctx.algorithm, union, !ctx.keysOnly && ctx.valueMapper)
            ]);
          }
        }
        function iterate(cursorPromise, filter, fn2, valueMapper) {
          var mappedFn = valueMapper ? function(x, c, a) {
            return fn2(valueMapper(x), c, a);
          } : fn2;
          var wrappedFn = wrap4(mappedFn);
          return cursorPromise.then(function(cursor2) {
            if (cursor2) {
              return cursor2.start(function() {
                var c = function() {
                  return cursor2.continue();
                };
                if (!filter || filter(cursor2, function(advancer) {
                  return c = advancer;
                }, function(val) {
                  cursor2.stop(val);
                  c = nop;
                }, function(e) {
                  cursor2.fail(e);
                  c = nop;
                }))
                  wrappedFn(cursor2.value, cursor2, function(advancer) {
                    return c = advancer;
                  });
                c();
              });
            }
          });
        }
        var PropModification2 = (function() {
          function PropModification3(spec) {
            this["@@propmod"] = spec;
          }
          PropModification3.prototype.execute = function(value) {
            var _a3;
            var spec = this["@@propmod"];
            if (spec.add !== void 0) {
              var term = spec.add;
              if (isArray3(term)) {
                return __spreadArray2(__spreadArray2([], isArray3(value) ? value : [], true), term, true).sort();
              }
              if (typeof term === "number")
                return (Number(value) || 0) + term;
              if (typeof term === "bigint") {
                try {
                  return BigInt(value) + term;
                } catch (_b) {
                  return BigInt(0) + term;
                }
              }
              throw new TypeError("Invalid term ".concat(term));
            }
            if (spec.remove !== void 0) {
              var subtrahend_1 = spec.remove;
              if (isArray3(subtrahend_1)) {
                return isArray3(value) ? value.filter(function(item) {
                  return !subtrahend_1.includes(item);
                }).sort() : [];
              }
              if (typeof subtrahend_1 === "number")
                return Number(value) - subtrahend_1;
              if (typeof subtrahend_1 === "bigint") {
                try {
                  return BigInt(value) - subtrahend_1;
                } catch (_c) {
                  return BigInt(0) - subtrahend_1;
                }
              }
              throw new TypeError("Invalid subtrahend ".concat(subtrahend_1));
            }
            var prefixToReplace = (_a3 = spec.replacePrefix) === null || _a3 === void 0 ? void 0 : _a3[0];
            if (prefixToReplace && typeof value === "string" && value.startsWith(prefixToReplace)) {
              return spec.replacePrefix[1] + value.substring(prefixToReplace.length);
            }
            return value;
          };
          return PropModification3;
        })();
        var Collection = (function() {
          function Collection2() {
          }
          Collection2.prototype._read = function(fn2, cb) {
            var ctx = this._ctx;
            return ctx.error ? ctx.table._trans(null, rejection.bind(null, ctx.error)) : ctx.table._trans("readonly", fn2).then(cb);
          };
          Collection2.prototype._write = function(fn2) {
            var ctx = this._ctx;
            return ctx.error ? ctx.table._trans(null, rejection.bind(null, ctx.error)) : ctx.table._trans("readwrite", fn2, "locked");
          };
          Collection2.prototype._addAlgorithm = function(fn2) {
            var ctx = this._ctx;
            ctx.algorithm = combine3(ctx.algorithm, fn2);
          };
          Collection2.prototype._iterate = function(fn2, coreTrans) {
            return iter(this._ctx, fn2, coreTrans, this._ctx.table.core);
          };
          Collection2.prototype.clone = function(props2) {
            var rv = Object.create(this.constructor.prototype), ctx = Object.create(this._ctx);
            if (props2)
              extend(ctx, props2);
            rv._ctx = ctx;
            return rv;
          };
          Collection2.prototype.raw = function() {
            this._ctx.valueMapper = null;
            return this;
          };
          Collection2.prototype.each = function(fn2) {
            var ctx = this._ctx;
            return this._read(function(trans) {
              return iter(ctx, fn2, trans, ctx.table.core);
            });
          };
          Collection2.prototype.count = function(cb) {
            var _this = this;
            return this._read(function(trans) {
              var ctx = _this._ctx;
              var coreTable = ctx.table.core;
              if (isPlainKeyRange(ctx, true)) {
                return coreTable.count({
                  trans,
                  query: {
                    index: getIndexOrStore(ctx, coreTable.schema),
                    range: ctx.range
                  }
                }).then(function(count2) {
                  return Math.min(count2, ctx.limit);
                });
              } else {
                var count = 0;
                return iter(ctx, function() {
                  ++count;
                  return false;
                }, trans, coreTable).then(function() {
                  return count;
                });
              }
            }).then(cb);
          };
          Collection2.prototype.sortBy = function(keyPath, cb) {
            var parts = keyPath.split(".").reverse(), lastPart = parts[0], lastIndex = parts.length - 1;
            function getval(obj, i) {
              if (i)
                return getval(obj[parts[i]], i - 1);
              return obj[lastPart];
            }
            var order2 = this._ctx.dir === "next" ? 1 : -1;
            function sorter(a, b) {
              var aVal = getval(a, lastIndex), bVal = getval(b, lastIndex);
              return cmp2(aVal, bVal) * order2;
            }
            return this.toArray(function(a) {
              return a.sort(sorter);
            }).then(cb);
          };
          Collection2.prototype.toArray = function(cb) {
            var _this = this;
            return this._read(function(trans) {
              var ctx = _this._ctx;
              if (ctx.dir === "next" && isPlainKeyRange(ctx, true) && ctx.limit > 0) {
                var valueMapper_1 = ctx.valueMapper;
                var index2 = getIndexOrStore(ctx, ctx.table.core.schema);
                return ctx.table.core.query({
                  trans,
                  limit: ctx.limit,
                  values: true,
                  query: {
                    index: index2,
                    range: ctx.range
                  }
                }).then(function(_a3) {
                  var result2 = _a3.result;
                  return valueMapper_1 ? result2.map(valueMapper_1) : result2;
                });
              } else {
                var a_1 = [];
                return iter(ctx, function(item) {
                  return a_1.push(item);
                }, trans, ctx.table.core).then(function() {
                  return a_1;
                });
              }
            }, cb);
          };
          Collection2.prototype.offset = function(offset3) {
            var ctx = this._ctx;
            if (offset3 <= 0)
              return this;
            ctx.offset += offset3;
            if (isPlainKeyRange(ctx)) {
              addReplayFilter(ctx, function() {
                var offsetLeft = offset3;
                return function(cursor2, advance) {
                  if (offsetLeft === 0)
                    return true;
                  if (offsetLeft === 1) {
                    --offsetLeft;
                    return false;
                  }
                  advance(function() {
                    cursor2.advance(offsetLeft);
                    offsetLeft = 0;
                  });
                  return false;
                };
              });
            } else {
              addReplayFilter(ctx, function() {
                var offsetLeft = offset3;
                return function() {
                  return --offsetLeft < 0;
                };
              });
            }
            return this;
          };
          Collection2.prototype.limit = function(numRows) {
            this._ctx.limit = Math.min(this._ctx.limit, numRows);
            addReplayFilter(this._ctx, function() {
              var rowsLeft = numRows;
              return function(cursor2, advance, resolve) {
                if (--rowsLeft <= 0)
                  advance(resolve);
                return rowsLeft >= 0;
              };
            }, true);
            return this;
          };
          Collection2.prototype.until = function(filterFunction, bIncludeStopEntry) {
            addFilter(this._ctx, function(cursor2, advance, resolve) {
              if (filterFunction(cursor2.value)) {
                advance(resolve);
                return bIncludeStopEntry;
              } else {
                return true;
              }
            });
            return this;
          };
          Collection2.prototype.first = function(cb) {
            return this.limit(1).toArray(function(a) {
              return a[0];
            }).then(cb);
          };
          Collection2.prototype.last = function(cb) {
            return this.reverse().first(cb);
          };
          Collection2.prototype.filter = function(filterFunction) {
            addFilter(this._ctx, function(cursor2) {
              return filterFunction(cursor2.value);
            });
            addMatchFilter(this._ctx, filterFunction);
            return this;
          };
          Collection2.prototype.and = function(filter) {
            return this.filter(filter);
          };
          Collection2.prototype.or = function(indexName) {
            return new this.db.WhereClause(this._ctx.table, indexName, this);
          };
          Collection2.prototype.reverse = function() {
            this._ctx.dir = this._ctx.dir === "prev" ? "next" : "prev";
            if (this._ondirectionchange)
              this._ondirectionchange(this._ctx.dir);
            return this;
          };
          Collection2.prototype.desc = function() {
            return this.reverse();
          };
          Collection2.prototype.eachKey = function(cb) {
            var ctx = this._ctx;
            ctx.keysOnly = !ctx.isMatch;
            return this.each(function(val, cursor2) {
              cb(cursor2.key, cursor2);
            });
          };
          Collection2.prototype.eachUniqueKey = function(cb) {
            this._ctx.unique = "unique";
            return this.eachKey(cb);
          };
          Collection2.prototype.eachPrimaryKey = function(cb) {
            var ctx = this._ctx;
            ctx.keysOnly = !ctx.isMatch;
            return this.each(function(val, cursor2) {
              cb(cursor2.primaryKey, cursor2);
            });
          };
          Collection2.prototype.keys = function(cb) {
            var ctx = this._ctx;
            ctx.keysOnly = !ctx.isMatch;
            var a = [];
            return this.each(function(item, cursor2) {
              a.push(cursor2.key);
            }).then(function() {
              return a;
            }).then(cb);
          };
          Collection2.prototype.primaryKeys = function(cb) {
            var ctx = this._ctx;
            if (ctx.dir === "next" && isPlainKeyRange(ctx, true) && ctx.limit > 0) {
              return this._read(function(trans) {
                var index2 = getIndexOrStore(ctx, ctx.table.core.schema);
                return ctx.table.core.query({
                  trans,
                  values: false,
                  limit: ctx.limit,
                  query: {
                    index: index2,
                    range: ctx.range
                  }
                });
              }).then(function(_a3) {
                var result2 = _a3.result;
                return result2;
              }).then(cb);
            }
            ctx.keysOnly = !ctx.isMatch;
            var a = [];
            return this.each(function(item, cursor2) {
              a.push(cursor2.primaryKey);
            }).then(function() {
              return a;
            }).then(cb);
          };
          Collection2.prototype.uniqueKeys = function(cb) {
            this._ctx.unique = "unique";
            return this.keys(cb);
          };
          Collection2.prototype.firstKey = function(cb) {
            return this.limit(1).keys(function(a) {
              return a[0];
            }).then(cb);
          };
          Collection2.prototype.lastKey = function(cb) {
            return this.reverse().firstKey(cb);
          };
          Collection2.prototype.distinct = function() {
            var ctx = this._ctx, idx = ctx.index && ctx.table.schema.idxByName[ctx.index];
            if (!idx || !idx.multi)
              return this;
            var set = {};
            addFilter(this._ctx, function(cursor2) {
              var strKey = cursor2.primaryKey.toString();
              var found = hasOwn3(set, strKey);
              set[strKey] = true;
              return !found;
            });
            return this;
          };
          Collection2.prototype.modify = function(changes) {
            var _this = this;
            var ctx = this._ctx;
            return this._write(function(trans) {
              var modifyer;
              if (typeof changes === "function") {
                modifyer = changes;
              } else {
                var keyPaths = keys(changes);
                var numKeys = keyPaths.length;
                modifyer = function(item) {
                  var anythingModified = false;
                  for (var i = 0; i < numKeys; ++i) {
                    var keyPath = keyPaths[i];
                    var val = changes[keyPath];
                    var origVal = getByKeyPath(item, keyPath);
                    if (val instanceof PropModification2) {
                      setByKeyPath(item, keyPath, val.execute(origVal));
                      anythingModified = true;
                    } else if (origVal !== val) {
                      setByKeyPath(item, keyPath, val);
                      anythingModified = true;
                    }
                  }
                  return anythingModified;
                };
              }
              var coreTable = ctx.table.core;
              var _a3 = coreTable.schema.primaryKey, outbound = _a3.outbound, extractKey2 = _a3.extractKey;
              var limit = 200;
              var modifyChunkSize = _this.db._options.modifyChunkSize;
              if (modifyChunkSize) {
                if (typeof modifyChunkSize == "object") {
                  limit = modifyChunkSize[coreTable.name] || modifyChunkSize["*"] || 200;
                } else {
                  limit = modifyChunkSize;
                }
              }
              var totalFailures = [];
              var successCount = 0;
              var failedKeys = [];
              var applyMutateResult = function(expectedCount, res) {
                var failures = res.failures, numFailures = res.numFailures;
                successCount += expectedCount - numFailures;
                for (var _i = 0, _a4 = keys(failures); _i < _a4.length; _i++) {
                  var pos = _a4[_i];
                  totalFailures.push(failures[pos]);
                }
              };
              return _this.clone().primaryKeys().then(function(keys2) {
                var criteria = isPlainKeyRange(ctx) && ctx.limit === Infinity && (typeof changes !== "function" || changes === deleteCallback) && {
                  index: ctx.index,
                  range: ctx.range
                };
                var nextChunk = function(offset3) {
                  var count = Math.min(limit, keys2.length - offset3);
                  return coreTable.getMany({
                    trans,
                    keys: keys2.slice(offset3, offset3 + count),
                    cache: "immutable"
                  }).then(function(values) {
                    var addValues = [];
                    var putValues = [];
                    var putKeys = outbound ? [] : null;
                    var deleteKeys = [];
                    for (var i = 0; i < count; ++i) {
                      var origValue = values[i];
                      var ctx_1 = {
                        value: deepClone(origValue),
                        primKey: keys2[offset3 + i]
                      };
                      if (modifyer.call(ctx_1, ctx_1.value, ctx_1) !== false) {
                        if (ctx_1.value == null) {
                          deleteKeys.push(keys2[offset3 + i]);
                        } else if (!outbound && cmp2(extractKey2(origValue), extractKey2(ctx_1.value)) !== 0) {
                          deleteKeys.push(keys2[offset3 + i]);
                          addValues.push(ctx_1.value);
                        } else {
                          putValues.push(ctx_1.value);
                          if (outbound)
                            putKeys.push(keys2[offset3 + i]);
                        }
                      }
                    }
                    return Promise.resolve(addValues.length > 0 && coreTable.mutate({ trans, type: "add", values: addValues }).then(function(res) {
                      for (var pos in res.failures) {
                        deleteKeys.splice(parseInt(pos), 1);
                      }
                      applyMutateResult(addValues.length, res);
                    })).then(function() {
                      return (putValues.length > 0 || criteria && typeof changes === "object") && coreTable.mutate({
                        trans,
                        type: "put",
                        keys: putKeys,
                        values: putValues,
                        criteria,
                        changeSpec: typeof changes !== "function" && changes,
                        isAdditionalChunk: offset3 > 0
                      }).then(function(res) {
                        return applyMutateResult(putValues.length, res);
                      });
                    }).then(function() {
                      return (deleteKeys.length > 0 || criteria && changes === deleteCallback) && coreTable.mutate({
                        trans,
                        type: "delete",
                        keys: deleteKeys,
                        criteria,
                        isAdditionalChunk: offset3 > 0
                      }).then(function(res) {
                        return applyMutateResult(deleteKeys.length, res);
                      });
                    }).then(function() {
                      return keys2.length > offset3 + count && nextChunk(offset3 + limit);
                    });
                  });
                };
                return nextChunk(0).then(function() {
                  if (totalFailures.length > 0)
                    throw new ModifyError("Error modifying one or more objects", totalFailures, successCount, failedKeys);
                  return keys2.length;
                });
              });
            });
          };
          Collection2.prototype.delete = function() {
            var ctx = this._ctx, range = ctx.range;
            if (isPlainKeyRange(ctx) && (ctx.isPrimKey || range.type === 3)) {
              return this._write(function(trans) {
                var primaryKey = ctx.table.core.schema.primaryKey;
                var coreRange = range;
                return ctx.table.core.count({ trans, query: { index: primaryKey, range: coreRange } }).then(function(count) {
                  return ctx.table.core.mutate({ trans, type: "deleteRange", range: coreRange }).then(function(_a3) {
                    var failures = _a3.failures;
                    _a3.lastResult;
                    _a3.results;
                    var numFailures = _a3.numFailures;
                    if (numFailures)
                      throw new ModifyError("Could not delete some values", Object.keys(failures).map(function(pos) {
                        return failures[pos];
                      }), count - numFailures);
                    return count - numFailures;
                  });
                });
              });
            }
            return this.modify(deleteCallback);
          };
          return Collection2;
        })();
        var deleteCallback = function(value, ctx) {
          return ctx.value = null;
        };
        function createCollectionConstructor(db2) {
          return makeClassConstructor(Collection.prototype, function Collection2(whereClause, keyRangeGenerator) {
            this.db = db2;
            var keyRange = AnyRange, error = null;
            if (keyRangeGenerator)
              try {
                keyRange = keyRangeGenerator();
              } catch (ex) {
                error = ex;
              }
            var whereCtx = whereClause._ctx;
            var table = whereCtx.table;
            var readingHook = table.hook.reading.fire;
            this._ctx = {
              table,
              index: whereCtx.index,
              isPrimKey: !whereCtx.index || table.schema.primKey.keyPath && whereCtx.index === table.schema.primKey.name,
              range: keyRange,
              keysOnly: false,
              dir: "next",
              unique: "",
              algorithm: null,
              filter: null,
              replayFilter: null,
              justLimit: true,
              isMatch: null,
              offset: 0,
              limit: Infinity,
              error,
              or: whereCtx.or,
              valueMapper: readingHook !== mirror ? readingHook : null
            };
          });
        }
        function simpleCompare(a, b) {
          return a < b ? -1 : a === b ? 0 : 1;
        }
        function simpleCompareReverse(a, b) {
          return a > b ? -1 : a === b ? 0 : 1;
        }
        function fail(collectionOrWhereClause, err, T) {
          var collection = collectionOrWhereClause instanceof WhereClause ? new collectionOrWhereClause.Collection(collectionOrWhereClause) : collectionOrWhereClause;
          collection._ctx.error = T ? new T(err) : new TypeError(err);
          return collection;
        }
        function emptyCollection(whereClause) {
          return new whereClause.Collection(whereClause, function() {
            return rangeEqual("");
          }).limit(0);
        }
        function upperFactory(dir) {
          return dir === "next" ? function(s) {
            return s.toUpperCase();
          } : function(s) {
            return s.toLowerCase();
          };
        }
        function lowerFactory(dir) {
          return dir === "next" ? function(s) {
            return s.toLowerCase();
          } : function(s) {
            return s.toUpperCase();
          };
        }
        function nextCasing(key, lowerKey, upperNeedle, lowerNeedle, cmp3, dir) {
          var length2 = Math.min(key.length, lowerNeedle.length);
          var llp = -1;
          for (var i = 0; i < length2; ++i) {
            var lwrKeyChar = lowerKey[i];
            if (lwrKeyChar !== lowerNeedle[i]) {
              if (cmp3(key[i], upperNeedle[i]) < 0)
                return key.substr(0, i) + upperNeedle[i] + upperNeedle.substr(i + 1);
              if (cmp3(key[i], lowerNeedle[i]) < 0)
                return key.substr(0, i) + lowerNeedle[i] + upperNeedle.substr(i + 1);
              if (llp >= 0)
                return key.substr(0, llp) + lowerKey[llp] + upperNeedle.substr(llp + 1);
              return null;
            }
            if (cmp3(key[i], lwrKeyChar) < 0)
              llp = i;
          }
          if (length2 < lowerNeedle.length && dir === "next")
            return key + upperNeedle.substr(key.length);
          if (length2 < key.length && dir === "prev")
            return key.substr(0, upperNeedle.length);
          return llp < 0 ? null : key.substr(0, llp) + lowerNeedle[llp] + upperNeedle.substr(llp + 1);
        }
        function addIgnoreCaseAlgorithm(whereClause, match3, needles, suffix) {
          var upper, lower, compare, upperNeedles, lowerNeedles, direction, nextKeySuffix, needlesLen = needles.length;
          if (!needles.every(function(s) {
            return typeof s === "string";
          })) {
            return fail(whereClause, STRING_EXPECTED);
          }
          function initDirection(dir) {
            upper = upperFactory(dir);
            lower = lowerFactory(dir);
            compare = dir === "next" ? simpleCompare : simpleCompareReverse;
            var needleBounds = needles.map(function(needle) {
              return { lower: lower(needle), upper: upper(needle) };
            }).sort(function(a, b) {
              return compare(a.lower, b.lower);
            });
            upperNeedles = needleBounds.map(function(nb) {
              return nb.upper;
            });
            lowerNeedles = needleBounds.map(function(nb) {
              return nb.lower;
            });
            direction = dir;
            nextKeySuffix = dir === "next" ? "" : suffix;
          }
          initDirection("next");
          var c = new whereClause.Collection(whereClause, function() {
            return createRange(upperNeedles[0], lowerNeedles[needlesLen - 1] + suffix);
          });
          c._ondirectionchange = function(direction2) {
            initDirection(direction2);
          };
          var firstPossibleNeedle = 0;
          c._addAlgorithm(function(cursor2, advance, resolve) {
            var key = cursor2.key;
            if (typeof key !== "string")
              return false;
            var lowerKey = lower(key);
            if (match3(lowerKey, lowerNeedles, firstPossibleNeedle)) {
              return true;
            } else {
              var lowestPossibleCasing = null;
              for (var i = firstPossibleNeedle; i < needlesLen; ++i) {
                var casing = nextCasing(key, lowerKey, upperNeedles[i], lowerNeedles[i], compare, direction);
                if (casing === null && lowestPossibleCasing === null)
                  firstPossibleNeedle = i + 1;
                else if (lowestPossibleCasing === null || compare(lowestPossibleCasing, casing) > 0) {
                  lowestPossibleCasing = casing;
                }
              }
              if (lowestPossibleCasing !== null) {
                advance(function() {
                  cursor2.continue(lowestPossibleCasing + nextKeySuffix);
                });
              } else {
                advance(resolve);
              }
              return false;
            }
          });
          return c;
        }
        function createRange(lower, upper, lowerOpen, upperOpen) {
          return {
            type: 2,
            lower,
            upper,
            lowerOpen,
            upperOpen
          };
        }
        function rangeEqual(value) {
          return {
            type: 1,
            lower: value,
            upper: value
          };
        }
        var WhereClause = (function() {
          function WhereClause2() {
          }
          Object.defineProperty(WhereClause2.prototype, "Collection", {
            get: function() {
              return this._ctx.table.db.Collection;
            },
            enumerable: false,
            configurable: true
          });
          WhereClause2.prototype.between = function(lower, upper, includeLower, includeUpper) {
            includeLower = includeLower !== false;
            includeUpper = includeUpper === true;
            try {
              if (this._cmp(lower, upper) > 0 || this._cmp(lower, upper) === 0 && (includeLower || includeUpper) && !(includeLower && includeUpper))
                return emptyCollection(this);
              return new this.Collection(this, function() {
                return createRange(lower, upper, !includeLower, !includeUpper);
              });
            } catch (e) {
              return fail(this, INVALID_KEY_ARGUMENT);
            }
          };
          WhereClause2.prototype.equals = function(value) {
            if (value == null)
              return fail(this, INVALID_KEY_ARGUMENT);
            return new this.Collection(this, function() {
              return rangeEqual(value);
            });
          };
          WhereClause2.prototype.above = function(value) {
            if (value == null)
              return fail(this, INVALID_KEY_ARGUMENT);
            return new this.Collection(this, function() {
              return createRange(value, void 0, true);
            });
          };
          WhereClause2.prototype.aboveOrEqual = function(value) {
            if (value == null)
              return fail(this, INVALID_KEY_ARGUMENT);
            return new this.Collection(this, function() {
              return createRange(value, void 0, false);
            });
          };
          WhereClause2.prototype.below = function(value) {
            if (value == null)
              return fail(this, INVALID_KEY_ARGUMENT);
            return new this.Collection(this, function() {
              return createRange(void 0, value, false, true);
            });
          };
          WhereClause2.prototype.belowOrEqual = function(value) {
            if (value == null)
              return fail(this, INVALID_KEY_ARGUMENT);
            return new this.Collection(this, function() {
              return createRange(void 0, value);
            });
          };
          WhereClause2.prototype.startsWith = function(str) {
            if (typeof str !== "string")
              return fail(this, STRING_EXPECTED);
            return this.between(str, str + maxString, true, true);
          };
          WhereClause2.prototype.startsWithIgnoreCase = function(str) {
            if (str === "")
              return this.startsWith(str);
            return addIgnoreCaseAlgorithm(this, function(x, a) {
              return x.indexOf(a[0]) === 0;
            }, [str], maxString);
          };
          WhereClause2.prototype.equalsIgnoreCase = function(str) {
            return addIgnoreCaseAlgorithm(this, function(x, a) {
              return x === a[0];
            }, [str], "");
          };
          WhereClause2.prototype.anyOfIgnoreCase = function() {
            var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
            if (set.length === 0)
              return emptyCollection(this);
            return addIgnoreCaseAlgorithm(this, function(x, a) {
              return a.indexOf(x) !== -1;
            }, set, "");
          };
          WhereClause2.prototype.startsWithAnyOfIgnoreCase = function() {
            var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
            if (set.length === 0)
              return emptyCollection(this);
            return addIgnoreCaseAlgorithm(this, function(x, a) {
              return a.some(function(n) {
                return x.indexOf(n) === 0;
              });
            }, set, maxString);
          };
          WhereClause2.prototype.anyOf = function() {
            var _this = this;
            var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
            var compare = this._cmp;
            try {
              set.sort(compare);
            } catch (e) {
              return fail(this, INVALID_KEY_ARGUMENT);
            }
            if (set.length === 0)
              return emptyCollection(this);
            var c = new this.Collection(this, function() {
              return createRange(set[0], set[set.length - 1]);
            });
            c._ondirectionchange = function(direction) {
              compare = direction === "next" ? _this._ascending : _this._descending;
              set.sort(compare);
            };
            var i = 0;
            c._addAlgorithm(function(cursor2, advance, resolve) {
              var key = cursor2.key;
              while (compare(key, set[i]) > 0) {
                ++i;
                if (i === set.length) {
                  advance(resolve);
                  return false;
                }
              }
              if (compare(key, set[i]) === 0) {
                return true;
              } else {
                advance(function() {
                  cursor2.continue(set[i]);
                });
                return false;
              }
            });
            return c;
          };
          WhereClause2.prototype.notEqual = function(value) {
            return this.inAnyRange([[minKey, value], [value, this.db._maxKey]], { includeLowers: false, includeUppers: false });
          };
          WhereClause2.prototype.noneOf = function() {
            var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
            if (set.length === 0)
              return new this.Collection(this);
            try {
              set.sort(this._ascending);
            } catch (e) {
              return fail(this, INVALID_KEY_ARGUMENT);
            }
            var ranges = set.reduce(function(res, val) {
              return res ? res.concat([[res[res.length - 1][1], val]]) : [[minKey, val]];
            }, null);
            ranges.push([set[set.length - 1], this.db._maxKey]);
            return this.inAnyRange(ranges, { includeLowers: false, includeUppers: false });
          };
          WhereClause2.prototype.inAnyRange = function(ranges, options2) {
            var _this = this;
            var cmp3 = this._cmp, ascending = this._ascending, descending = this._descending, min3 = this._min, max3 = this._max;
            if (ranges.length === 0)
              return emptyCollection(this);
            if (!ranges.every(function(range) {
              return range[0] !== void 0 && range[1] !== void 0 && ascending(range[0], range[1]) <= 0;
            })) {
              return fail(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", exceptions.InvalidArgument);
            }
            var includeLowers = !options2 || options2.includeLowers !== false;
            var includeUppers = options2 && options2.includeUppers === true;
            function addRange2(ranges2, newRange) {
              var i = 0, l = ranges2.length;
              for (; i < l; ++i) {
                var range = ranges2[i];
                if (cmp3(newRange[0], range[1]) < 0 && cmp3(newRange[1], range[0]) > 0) {
                  range[0] = min3(range[0], newRange[0]);
                  range[1] = max3(range[1], newRange[1]);
                  break;
                }
              }
              if (i === l)
                ranges2.push(newRange);
              return ranges2;
            }
            var sortDirection = ascending;
            function rangeSorter(a, b) {
              return sortDirection(a[0], b[0]);
            }
            var set;
            try {
              set = ranges.reduce(addRange2, []);
              set.sort(rangeSorter);
            } catch (ex) {
              return fail(this, INVALID_KEY_ARGUMENT);
            }
            var rangePos = 0;
            var keyIsBeyondCurrentEntry = includeUppers ? function(key) {
              return ascending(key, set[rangePos][1]) > 0;
            } : function(key) {
              return ascending(key, set[rangePos][1]) >= 0;
            };
            var keyIsBeforeCurrentEntry = includeLowers ? function(key) {
              return descending(key, set[rangePos][0]) > 0;
            } : function(key) {
              return descending(key, set[rangePos][0]) >= 0;
            };
            function keyWithinCurrentRange(key) {
              return !keyIsBeyondCurrentEntry(key) && !keyIsBeforeCurrentEntry(key);
            }
            var checkKey = keyIsBeyondCurrentEntry;
            var c = new this.Collection(this, function() {
              return createRange(set[0][0], set[set.length - 1][1], !includeLowers, !includeUppers);
            });
            c._ondirectionchange = function(direction) {
              if (direction === "next") {
                checkKey = keyIsBeyondCurrentEntry;
                sortDirection = ascending;
              } else {
                checkKey = keyIsBeforeCurrentEntry;
                sortDirection = descending;
              }
              set.sort(rangeSorter);
            };
            c._addAlgorithm(function(cursor2, advance, resolve) {
              var key = cursor2.key;
              while (checkKey(key)) {
                ++rangePos;
                if (rangePos === set.length) {
                  advance(resolve);
                  return false;
                }
              }
              if (keyWithinCurrentRange(key)) {
                return true;
              } else if (_this._cmp(key, set[rangePos][1]) === 0 || _this._cmp(key, set[rangePos][0]) === 0) {
                return false;
              } else {
                advance(function() {
                  if (sortDirection === ascending)
                    cursor2.continue(set[rangePos][0]);
                  else
                    cursor2.continue(set[rangePos][1]);
                });
                return false;
              }
            });
            return c;
          };
          WhereClause2.prototype.startsWithAnyOf = function() {
            var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
            if (!set.every(function(s) {
              return typeof s === "string";
            })) {
              return fail(this, "startsWithAnyOf() only works with strings");
            }
            if (set.length === 0)
              return emptyCollection(this);
            return this.inAnyRange(set.map(function(str) {
              return [str, str + maxString];
            }));
          };
          return WhereClause2;
        })();
        function createWhereClauseConstructor(db2) {
          return makeClassConstructor(WhereClause.prototype, function WhereClause2(table, index2, orCollection) {
            this.db = db2;
            this._ctx = {
              table,
              index: index2 === ":id" ? null : index2,
              or: orCollection
            };
            this._cmp = this._ascending = cmp2;
            this._descending = function(a, b) {
              return cmp2(b, a);
            };
            this._max = function(a, b) {
              return cmp2(a, b) > 0 ? a : b;
            };
            this._min = function(a, b) {
              return cmp2(a, b) < 0 ? a : b;
            };
            this._IDBKeyRange = db2._deps.IDBKeyRange;
            if (!this._IDBKeyRange)
              throw new exceptions.MissingAPI();
          });
        }
        function eventRejectHandler(reject) {
          return wrap4(function(event) {
            preventDefault(event);
            reject(event.target.error);
            return false;
          });
        }
        function preventDefault(event) {
          if (event.stopPropagation)
            event.stopPropagation();
          if (event.preventDefault)
            event.preventDefault();
        }
        var DEXIE_STORAGE_MUTATED_EVENT_NAME = "storagemutated";
        var STORAGE_MUTATED_DOM_EVENT_NAME = "x-storagemutated-1";
        var globalEvents = Events(null, DEXIE_STORAGE_MUTATED_EVENT_NAME);
        var Transaction = (function() {
          function Transaction2() {
          }
          Transaction2.prototype._lock = function() {
            assert2(!PSD.global);
            ++this._reculock;
            if (this._reculock === 1 && !PSD.global)
              PSD.lockOwnerFor = this;
            return this;
          };
          Transaction2.prototype._unlock = function() {
            assert2(!PSD.global);
            if (--this._reculock === 0) {
              if (!PSD.global)
                PSD.lockOwnerFor = null;
              while (this._blockedFuncs.length > 0 && !this._locked()) {
                var fnAndPSD = this._blockedFuncs.shift();
                try {
                  usePSD(fnAndPSD[1], fnAndPSD[0]);
                } catch (e) {
                }
              }
            }
            return this;
          };
          Transaction2.prototype._locked = function() {
            return this._reculock && PSD.lockOwnerFor !== this;
          };
          Transaction2.prototype.create = function(idbtrans) {
            var _this = this;
            if (!this.mode)
              return this;
            var idbdb = this.db.idbdb;
            var dbOpenError = this.db._state.dbOpenError;
            assert2(!this.idbtrans);
            if (!idbtrans && !idbdb) {
              switch (dbOpenError && dbOpenError.name) {
                case "DatabaseClosedError":
                  throw new exceptions.DatabaseClosed(dbOpenError);
                case "MissingAPIError":
                  throw new exceptions.MissingAPI(dbOpenError.message, dbOpenError);
                default:
                  throw new exceptions.OpenFailed(dbOpenError);
              }
            }
            if (!this.active)
              throw new exceptions.TransactionInactive();
            assert2(this._completion._state === null);
            idbtrans = this.idbtrans = idbtrans || (this.db.core ? this.db.core.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability }) : idbdb.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability }));
            idbtrans.onerror = wrap4(function(ev) {
              preventDefault(ev);
              _this._reject(idbtrans.error);
            });
            idbtrans.onabort = wrap4(function(ev) {
              preventDefault(ev);
              _this.active && _this._reject(new exceptions.Abort(idbtrans.error));
              _this.active = false;
              _this.on("abort").fire(ev);
            });
            idbtrans.oncomplete = wrap4(function() {
              _this.active = false;
              _this._resolve();
              if ("mutatedParts" in idbtrans) {
                globalEvents.storagemutated.fire(idbtrans["mutatedParts"]);
              }
            });
            return this;
          };
          Transaction2.prototype._promise = function(mode, fn2, bWriteLock) {
            var _this = this;
            if (mode === "readwrite" && this.mode !== "readwrite")
              return rejection(new exceptions.ReadOnly("Transaction is readonly"));
            if (!this.active)
              return rejection(new exceptions.TransactionInactive());
            if (this._locked()) {
              return new DexiePromise(function(resolve, reject) {
                _this._blockedFuncs.push([function() {
                  _this._promise(mode, fn2, bWriteLock).then(resolve, reject);
                }, PSD]);
              });
            } else if (bWriteLock) {
              return newScope(function() {
                var p2 = new DexiePromise(function(resolve, reject) {
                  _this._lock();
                  var rv = fn2(resolve, reject, _this);
                  if (rv && rv.then)
                    rv.then(resolve, reject);
                });
                p2.finally(function() {
                  return _this._unlock();
                });
                p2._lib = true;
                return p2;
              });
            } else {
              var p = new DexiePromise(function(resolve, reject) {
                var rv = fn2(resolve, reject, _this);
                if (rv && rv.then)
                  rv.then(resolve, reject);
              });
              p._lib = true;
              return p;
            }
          };
          Transaction2.prototype._root = function() {
            return this.parent ? this.parent._root() : this;
          };
          Transaction2.prototype.waitFor = function(promiseLike) {
            var root2 = this._root();
            var promise = DexiePromise.resolve(promiseLike);
            if (root2._waitingFor) {
              root2._waitingFor = root2._waitingFor.then(function() {
                return promise;
              });
            } else {
              root2._waitingFor = promise;
              root2._waitingQueue = [];
              var store = root2.idbtrans.objectStore(root2.storeNames[0]);
              (function spin() {
                ++root2._spinCount;
                while (root2._waitingQueue.length)
                  root2._waitingQueue.shift()();
                if (root2._waitingFor)
                  store.get(-Infinity).onsuccess = spin;
              })();
            }
            var currentWaitPromise = root2._waitingFor;
            return new DexiePromise(function(resolve, reject) {
              promise.then(function(res) {
                return root2._waitingQueue.push(wrap4(resolve.bind(null, res)));
              }, function(err) {
                return root2._waitingQueue.push(wrap4(reject.bind(null, err)));
              }).finally(function() {
                if (root2._waitingFor === currentWaitPromise) {
                  root2._waitingFor = null;
                }
              });
            });
          };
          Transaction2.prototype.abort = function() {
            if (this.active) {
              this.active = false;
              if (this.idbtrans)
                this.idbtrans.abort();
              this._reject(new exceptions.Abort());
            }
          };
          Transaction2.prototype.table = function(tableName) {
            var memoizedTables = this._memoizedTables || (this._memoizedTables = {});
            if (hasOwn3(memoizedTables, tableName))
              return memoizedTables[tableName];
            var tableSchema = this.schema[tableName];
            if (!tableSchema) {
              throw new exceptions.NotFound("Table " + tableName + " not part of transaction");
            }
            var transactionBoundTable = new this.db.Table(tableName, tableSchema, this);
            transactionBoundTable.core = this.db.core.table(tableName);
            memoizedTables[tableName] = transactionBoundTable;
            return transactionBoundTable;
          };
          return Transaction2;
        })();
        function createTransactionConstructor(db2) {
          return makeClassConstructor(Transaction.prototype, function Transaction2(mode, storeNames, dbschema, chromeTransactionDurability, parent) {
            var _this = this;
            this.db = db2;
            this.mode = mode;
            this.storeNames = storeNames;
            this.schema = dbschema;
            this.chromeTransactionDurability = chromeTransactionDurability;
            this.idbtrans = null;
            this.on = Events(this, "complete", "error", "abort");
            this.parent = parent || null;
            this.active = true;
            this._reculock = 0;
            this._blockedFuncs = [];
            this._resolve = null;
            this._reject = null;
            this._waitingFor = null;
            this._waitingQueue = null;
            this._spinCount = 0;
            this._completion = new DexiePromise(function(resolve, reject) {
              _this._resolve = resolve;
              _this._reject = reject;
            });
            this._completion.then(function() {
              _this.active = false;
              _this.on.complete.fire();
            }, function(e) {
              var wasActive = _this.active;
              _this.active = false;
              _this.on.error.fire(e);
              _this.parent ? _this.parent._reject(e) : wasActive && _this.idbtrans && _this.idbtrans.abort();
              return rejection(e);
            });
          });
        }
        function createIndexSpec(name, keyPath, unique, multi, auto2, compound, isPrimKey) {
          return {
            name,
            keyPath,
            unique,
            multi,
            auto: auto2,
            compound,
            src: (unique && !isPrimKey ? "&" : "") + (multi ? "*" : "") + (auto2 ? "++" : "") + nameFromKeyPath(keyPath)
          };
        }
        function nameFromKeyPath(keyPath) {
          return typeof keyPath === "string" ? keyPath : keyPath ? "[" + [].join.call(keyPath, "+") + "]" : "";
        }
        function createTableSchema(name, primKey, indexes) {
          return {
            name,
            primKey,
            indexes,
            mappedClass: null,
            idxByName: arrayToObject(indexes, function(index2) {
              return [index2.name, index2];
            })
          };
        }
        function safariMultiStoreFix(storeNames) {
          return storeNames.length === 1 ? storeNames[0] : storeNames;
        }
        var getMaxKey = function(IdbKeyRange) {
          try {
            IdbKeyRange.only([[]]);
            getMaxKey = function() {
              return [[]];
            };
            return [[]];
          } catch (e) {
            getMaxKey = function() {
              return maxString;
            };
            return maxString;
          }
        };
        function getKeyExtractor(keyPath) {
          if (keyPath == null) {
            return function() {
              return void 0;
            };
          } else if (typeof keyPath === "string") {
            return getSinglePathKeyExtractor(keyPath);
          } else {
            return function(obj) {
              return getByKeyPath(obj, keyPath);
            };
          }
        }
        function getSinglePathKeyExtractor(keyPath) {
          var split = keyPath.split(".");
          if (split.length === 1) {
            return function(obj) {
              return obj[keyPath];
            };
          } else {
            return function(obj) {
              return getByKeyPath(obj, keyPath);
            };
          }
        }
        function arrayify(arrayLike) {
          return [].slice.call(arrayLike);
        }
        var _id_counter = 0;
        function getKeyPathAlias(keyPath) {
          return keyPath == null ? ":id" : typeof keyPath === "string" ? keyPath : "[".concat(keyPath.join("+"), "]");
        }
        function createDBCore(db2, IdbKeyRange, tmpTrans) {
          function extractSchema(db3, trans) {
            var tables2 = arrayify(db3.objectStoreNames);
            return {
              schema: {
                name: db3.name,
                tables: tables2.map(function(table) {
                  return trans.objectStore(table);
                }).map(function(store) {
                  var keyPath = store.keyPath, autoIncrement = store.autoIncrement;
                  var compound = isArray3(keyPath);
                  var outbound = keyPath == null;
                  var indexByKeyPath = {};
                  var result2 = {
                    name: store.name,
                    primaryKey: {
                      name: null,
                      isPrimaryKey: true,
                      outbound,
                      compound,
                      keyPath,
                      autoIncrement,
                      unique: true,
                      extractKey: getKeyExtractor(keyPath)
                    },
                    indexes: arrayify(store.indexNames).map(function(indexName) {
                      return store.index(indexName);
                    }).map(function(index2) {
                      var name = index2.name, unique = index2.unique, multiEntry = index2.multiEntry, keyPath2 = index2.keyPath;
                      var compound2 = isArray3(keyPath2);
                      var result3 = {
                        name,
                        compound: compound2,
                        keyPath: keyPath2,
                        unique,
                        multiEntry,
                        extractKey: getKeyExtractor(keyPath2)
                      };
                      indexByKeyPath[getKeyPathAlias(keyPath2)] = result3;
                      return result3;
                    }),
                    getIndexByKeyPath: function(keyPath2) {
                      return indexByKeyPath[getKeyPathAlias(keyPath2)];
                    }
                  };
                  indexByKeyPath[":id"] = result2.primaryKey;
                  if (keyPath != null) {
                    indexByKeyPath[getKeyPathAlias(keyPath)] = result2.primaryKey;
                  }
                  return result2;
                })
              },
              hasGetAll: tables2.length > 0 && "getAll" in trans.objectStore(tables2[0]) && !(typeof navigator !== "undefined" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604)
            };
          }
          function makeIDBKeyRange(range) {
            if (range.type === 3)
              return null;
            if (range.type === 4)
              throw new Error("Cannot convert never type to IDBKeyRange");
            var lower = range.lower, upper = range.upper, lowerOpen = range.lowerOpen, upperOpen = range.upperOpen;
            var idbRange = lower === void 0 ? upper === void 0 ? null : IdbKeyRange.upperBound(upper, !!upperOpen) : upper === void 0 ? IdbKeyRange.lowerBound(lower, !!lowerOpen) : IdbKeyRange.bound(lower, upper, !!lowerOpen, !!upperOpen);
            return idbRange;
          }
          function createDbCoreTable(tableSchema) {
            var tableName = tableSchema.name;
            function mutate(_a4) {
              var trans = _a4.trans, type2 = _a4.type, keys2 = _a4.keys, values = _a4.values, range = _a4.range;
              return new Promise(function(resolve, reject) {
                resolve = wrap4(resolve);
                var store = trans.objectStore(tableName);
                var outbound = store.keyPath == null;
                var isAddOrPut = type2 === "put" || type2 === "add";
                if (!isAddOrPut && type2 !== "delete" && type2 !== "deleteRange")
                  throw new Error("Invalid operation type: " + type2);
                var length2 = (keys2 || values || { length: 1 }).length;
                if (keys2 && values && keys2.length !== values.length) {
                  throw new Error("Given keys array must have same length as given values array.");
                }
                if (length2 === 0)
                  return resolve({ numFailures: 0, failures: {}, results: [], lastResult: void 0 });
                var req;
                var reqs = [];
                var failures = [];
                var numFailures = 0;
                var errorHandler = function(event) {
                  ++numFailures;
                  preventDefault(event);
                };
                if (type2 === "deleteRange") {
                  if (range.type === 4)
                    return resolve({ numFailures, failures, results: [], lastResult: void 0 });
                  if (range.type === 3)
                    reqs.push(req = store.clear());
                  else
                    reqs.push(req = store.delete(makeIDBKeyRange(range)));
                } else {
                  var _a5 = isAddOrPut ? outbound ? [values, keys2] : [values, null] : [keys2, null], args1 = _a5[0], args2 = _a5[1];
                  if (isAddOrPut) {
                    for (var i = 0; i < length2; ++i) {
                      reqs.push(req = args2 && args2[i] !== void 0 ? store[type2](args1[i], args2[i]) : store[type2](args1[i]));
                      req.onerror = errorHandler;
                    }
                  } else {
                    for (var i = 0; i < length2; ++i) {
                      reqs.push(req = store[type2](args1[i]));
                      req.onerror = errorHandler;
                    }
                  }
                }
                var done = function(event) {
                  var lastResult = event.target.result;
                  reqs.forEach(function(req2, i2) {
                    return req2.error != null && (failures[i2] = req2.error);
                  });
                  resolve({
                    numFailures,
                    failures,
                    results: type2 === "delete" ? keys2 : reqs.map(function(req2) {
                      return req2.result;
                    }),
                    lastResult
                  });
                };
                req.onerror = function(event) {
                  errorHandler(event);
                  done(event);
                };
                req.onsuccess = done;
              });
            }
            function openCursor2(_a4) {
              var trans = _a4.trans, values = _a4.values, query2 = _a4.query, reverse = _a4.reverse, unique = _a4.unique;
              return new Promise(function(resolve, reject) {
                resolve = wrap4(resolve);
                var index2 = query2.index, range = query2.range;
                var store = trans.objectStore(tableName);
                var source2 = index2.isPrimaryKey ? store : store.index(index2.name);
                var direction = reverse ? unique ? "prevunique" : "prev" : unique ? "nextunique" : "next";
                var req = values || !("openKeyCursor" in source2) ? source2.openCursor(makeIDBKeyRange(range), direction) : source2.openKeyCursor(makeIDBKeyRange(range), direction);
                req.onerror = eventRejectHandler(reject);
                req.onsuccess = wrap4(function(ev) {
                  var cursor2 = req.result;
                  if (!cursor2) {
                    resolve(null);
                    return;
                  }
                  cursor2.___id = ++_id_counter;
                  cursor2.done = false;
                  var _cursorContinue = cursor2.continue.bind(cursor2);
                  var _cursorContinuePrimaryKey = cursor2.continuePrimaryKey;
                  if (_cursorContinuePrimaryKey)
                    _cursorContinuePrimaryKey = _cursorContinuePrimaryKey.bind(cursor2);
                  var _cursorAdvance = cursor2.advance.bind(cursor2);
                  var doThrowCursorIsNotStarted = function() {
                    throw new Error("Cursor not started");
                  };
                  var doThrowCursorIsStopped = function() {
                    throw new Error("Cursor not stopped");
                  };
                  cursor2.trans = trans;
                  cursor2.stop = cursor2.continue = cursor2.continuePrimaryKey = cursor2.advance = doThrowCursorIsNotStarted;
                  cursor2.fail = wrap4(reject);
                  cursor2.next = function() {
                    var _this = this;
                    var gotOne = 1;
                    return this.start(function() {
                      return gotOne-- ? _this.continue() : _this.stop();
                    }).then(function() {
                      return _this;
                    });
                  };
                  cursor2.start = function(callback) {
                    var iterationPromise = new Promise(function(resolveIteration, rejectIteration) {
                      resolveIteration = wrap4(resolveIteration);
                      req.onerror = eventRejectHandler(rejectIteration);
                      cursor2.fail = rejectIteration;
                      cursor2.stop = function(value) {
                        cursor2.stop = cursor2.continue = cursor2.continuePrimaryKey = cursor2.advance = doThrowCursorIsStopped;
                        resolveIteration(value);
                      };
                    });
                    var guardedCallback = function() {
                      if (req.result) {
                        try {
                          callback();
                        } catch (err) {
                          cursor2.fail(err);
                        }
                      } else {
                        cursor2.done = true;
                        cursor2.start = function() {
                          throw new Error("Cursor behind last entry");
                        };
                        cursor2.stop();
                      }
                    };
                    req.onsuccess = wrap4(function(ev2) {
                      req.onsuccess = guardedCallback;
                      guardedCallback();
                    });
                    cursor2.continue = _cursorContinue;
                    cursor2.continuePrimaryKey = _cursorContinuePrimaryKey;
                    cursor2.advance = _cursorAdvance;
                    guardedCallback();
                    return iterationPromise;
                  };
                  resolve(cursor2);
                }, reject);
              });
            }
            function query(hasGetAll2) {
              return function(request) {
                return new Promise(function(resolve, reject) {
                  resolve = wrap4(resolve);
                  var trans = request.trans, values = request.values, limit = request.limit, query2 = request.query;
                  var nonInfinitLimit = limit === Infinity ? void 0 : limit;
                  var index2 = query2.index, range = query2.range;
                  var store = trans.objectStore(tableName);
                  var source2 = index2.isPrimaryKey ? store : store.index(index2.name);
                  var idbKeyRange = makeIDBKeyRange(range);
                  if (limit === 0)
                    return resolve({ result: [] });
                  if (hasGetAll2) {
                    var req = values ? source2.getAll(idbKeyRange, nonInfinitLimit) : source2.getAllKeys(idbKeyRange, nonInfinitLimit);
                    req.onsuccess = function(event) {
                      return resolve({ result: event.target.result });
                    };
                    req.onerror = eventRejectHandler(reject);
                  } else {
                    var count_1 = 0;
                    var req_1 = values || !("openKeyCursor" in source2) ? source2.openCursor(idbKeyRange) : source2.openKeyCursor(idbKeyRange);
                    var result_1 = [];
                    req_1.onsuccess = function(event) {
                      var cursor2 = req_1.result;
                      if (!cursor2)
                        return resolve({ result: result_1 });
                      result_1.push(values ? cursor2.value : cursor2.primaryKey);
                      if (++count_1 === limit)
                        return resolve({ result: result_1 });
                      cursor2.continue();
                    };
                    req_1.onerror = eventRejectHandler(reject);
                  }
                });
              };
            }
            return {
              name: tableName,
              schema: tableSchema,
              mutate,
              getMany: function(_a4) {
                var trans = _a4.trans, keys2 = _a4.keys;
                return new Promise(function(resolve, reject) {
                  resolve = wrap4(resolve);
                  var store = trans.objectStore(tableName);
                  var length2 = keys2.length;
                  var result2 = new Array(length2);
                  var keyCount = 0;
                  var callbackCount = 0;
                  var req;
                  var successHandler = function(event) {
                    var req2 = event.target;
                    if ((result2[req2._pos] = req2.result) != null)
                      ;
                    if (++callbackCount === keyCount)
                      resolve(result2);
                  };
                  var errorHandler = eventRejectHandler(reject);
                  for (var i = 0; i < length2; ++i) {
                    var key = keys2[i];
                    if (key != null) {
                      req = store.get(keys2[i]);
                      req._pos = i;
                      req.onsuccess = successHandler;
                      req.onerror = errorHandler;
                      ++keyCount;
                    }
                  }
                  if (keyCount === 0)
                    resolve(result2);
                });
              },
              get: function(_a4) {
                var trans = _a4.trans, key = _a4.key;
                return new Promise(function(resolve, reject) {
                  resolve = wrap4(resolve);
                  var store = trans.objectStore(tableName);
                  var req = store.get(key);
                  req.onsuccess = function(event) {
                    return resolve(event.target.result);
                  };
                  req.onerror = eventRejectHandler(reject);
                });
              },
              query: query(hasGetAll),
              openCursor: openCursor2,
              count: function(_a4) {
                var query2 = _a4.query, trans = _a4.trans;
                var index2 = query2.index, range = query2.range;
                return new Promise(function(resolve, reject) {
                  var store = trans.objectStore(tableName);
                  var source2 = index2.isPrimaryKey ? store : store.index(index2.name);
                  var idbKeyRange = makeIDBKeyRange(range);
                  var req = idbKeyRange ? source2.count(idbKeyRange) : source2.count();
                  req.onsuccess = wrap4(function(ev) {
                    return resolve(ev.target.result);
                  });
                  req.onerror = eventRejectHandler(reject);
                });
              }
            };
          }
          var _a3 = extractSchema(db2, tmpTrans), schema = _a3.schema, hasGetAll = _a3.hasGetAll;
          var tables = schema.tables.map(function(tableSchema) {
            return createDbCoreTable(tableSchema);
          });
          var tableMap = {};
          tables.forEach(function(table) {
            return tableMap[table.name] = table;
          });
          return {
            stack: "dbcore",
            transaction: db2.transaction.bind(db2),
            table: function(name) {
              var result2 = tableMap[name];
              if (!result2)
                throw new Error("Table '".concat(name, "' not found"));
              return tableMap[name];
            },
            MIN_KEY: -Infinity,
            MAX_KEY: getMaxKey(IdbKeyRange),
            schema
          };
        }
        function createMiddlewareStack(stackImpl, middlewares) {
          return middlewares.reduce(function(down, _a3) {
            var create = _a3.create;
            return __assign2(__assign2({}, down), create(down));
          }, stackImpl);
        }
        function createMiddlewareStacks(middlewares, idbdb, _a3, tmpTrans) {
          var IDBKeyRange = _a3.IDBKeyRange;
          _a3.indexedDB;
          var dbcore = createMiddlewareStack(createDBCore(idbdb, IDBKeyRange, tmpTrans), middlewares.dbcore);
          return {
            dbcore
          };
        }
        function generateMiddlewareStacks(db2, tmpTrans) {
          var idbdb = tmpTrans.db;
          var stacks = createMiddlewareStacks(db2._middlewares, idbdb, db2._deps, tmpTrans);
          db2.core = stacks.dbcore;
          db2.tables.forEach(function(table) {
            var tableName = table.name;
            if (db2.core.schema.tables.some(function(tbl) {
              return tbl.name === tableName;
            })) {
              table.core = db2.core.table(tableName);
              if (db2[tableName] instanceof db2.Table) {
                db2[tableName].core = table.core;
              }
            }
          });
        }
        function setApiOnPlace(db2, objs, tableNames, dbschema) {
          tableNames.forEach(function(tableName) {
            var schema = dbschema[tableName];
            objs.forEach(function(obj) {
              var propDesc = getPropertyDescriptor(obj, tableName);
              if (!propDesc || "value" in propDesc && propDesc.value === void 0) {
                if (obj === db2.Transaction.prototype || obj instanceof db2.Transaction) {
                  setProp(obj, tableName, {
                    get: function() {
                      return this.table(tableName);
                    },
                    set: function(value) {
                      defineProperty(this, tableName, { value, writable: true, configurable: true, enumerable: true });
                    }
                  });
                } else {
                  obj[tableName] = new db2.Table(tableName, schema);
                }
              }
            });
          });
        }
        function removeTablesApi(db2, objs) {
          objs.forEach(function(obj) {
            for (var key in obj) {
              if (obj[key] instanceof db2.Table)
                delete obj[key];
            }
          });
        }
        function lowerVersionFirst(a, b) {
          return a._cfg.version - b._cfg.version;
        }
        function runUpgraders(db2, oldVersion, idbUpgradeTrans, reject) {
          var globalSchema = db2._dbSchema;
          if (idbUpgradeTrans.objectStoreNames.contains("$meta") && !globalSchema.$meta) {
            globalSchema.$meta = createTableSchema("$meta", parseIndexSyntax("")[0], []);
            db2._storeNames.push("$meta");
          }
          var trans = db2._createTransaction("readwrite", db2._storeNames, globalSchema);
          trans.create(idbUpgradeTrans);
          trans._completion.catch(reject);
          var rejectTransaction = trans._reject.bind(trans);
          var transless = PSD.transless || PSD;
          newScope(function() {
            PSD.trans = trans;
            PSD.transless = transless;
            if (oldVersion === 0) {
              keys(globalSchema).forEach(function(tableName) {
                createTable(idbUpgradeTrans, tableName, globalSchema[tableName].primKey, globalSchema[tableName].indexes);
              });
              generateMiddlewareStacks(db2, idbUpgradeTrans);
              DexiePromise.follow(function() {
                return db2.on.populate.fire(trans);
              }).catch(rejectTransaction);
            } else {
              generateMiddlewareStacks(db2, idbUpgradeTrans);
              return getExistingVersion(db2, trans, oldVersion).then(function(oldVersion2) {
                return updateTablesAndIndexes(db2, oldVersion2, trans, idbUpgradeTrans);
              }).catch(rejectTransaction);
            }
          });
        }
        function patchCurrentVersion(db2, idbUpgradeTrans) {
          createMissingTables(db2._dbSchema, idbUpgradeTrans);
          if (idbUpgradeTrans.db.version % 10 === 0 && !idbUpgradeTrans.objectStoreNames.contains("$meta")) {
            idbUpgradeTrans.db.createObjectStore("$meta").add(Math.ceil(idbUpgradeTrans.db.version / 10 - 1), "version");
          }
          var globalSchema = buildGlobalSchema(db2, db2.idbdb, idbUpgradeTrans);
          adjustToExistingIndexNames(db2, db2._dbSchema, idbUpgradeTrans);
          var diff = getSchemaDiff(globalSchema, db2._dbSchema);
          var _loop_1 = function(tableChange2) {
            if (tableChange2.change.length || tableChange2.recreate) {
              console.warn("Unable to patch indexes of table ".concat(tableChange2.name, " because it has changes on the type of index or primary key."));
              return { value: void 0 };
            }
            var store = idbUpgradeTrans.objectStore(tableChange2.name);
            tableChange2.add.forEach(function(idx) {
              if (debug)
                console.debug("Dexie upgrade patch: Creating missing index ".concat(tableChange2.name, ".").concat(idx.src));
              addIndex(store, idx);
            });
          };
          for (var _i = 0, _a3 = diff.change; _i < _a3.length; _i++) {
            var tableChange = _a3[_i];
            var state_1 = _loop_1(tableChange);
            if (typeof state_1 === "object")
              return state_1.value;
          }
        }
        function getExistingVersion(db2, trans, oldVersion) {
          if (trans.storeNames.includes("$meta")) {
            return trans.table("$meta").get("version").then(function(metaVersion) {
              return metaVersion != null ? metaVersion : oldVersion;
            });
          } else {
            return DexiePromise.resolve(oldVersion);
          }
        }
        function updateTablesAndIndexes(db2, oldVersion, trans, idbUpgradeTrans) {
          var queue = [];
          var versions = db2._versions;
          var globalSchema = db2._dbSchema = buildGlobalSchema(db2, db2.idbdb, idbUpgradeTrans);
          var versToRun = versions.filter(function(v) {
            return v._cfg.version >= oldVersion;
          });
          if (versToRun.length === 0) {
            return DexiePromise.resolve();
          }
          versToRun.forEach(function(version2) {
            queue.push(function() {
              var oldSchema = globalSchema;
              var newSchema = version2._cfg.dbschema;
              adjustToExistingIndexNames(db2, oldSchema, idbUpgradeTrans);
              adjustToExistingIndexNames(db2, newSchema, idbUpgradeTrans);
              globalSchema = db2._dbSchema = newSchema;
              var diff = getSchemaDiff(oldSchema, newSchema);
              diff.add.forEach(function(tuple) {
                createTable(idbUpgradeTrans, tuple[0], tuple[1].primKey, tuple[1].indexes);
              });
              diff.change.forEach(function(change) {
                if (change.recreate) {
                  throw new exceptions.Upgrade("Not yet support for changing primary key");
                } else {
                  var store_1 = idbUpgradeTrans.objectStore(change.name);
                  change.add.forEach(function(idx) {
                    return addIndex(store_1, idx);
                  });
                  change.change.forEach(function(idx) {
                    store_1.deleteIndex(idx.name);
                    addIndex(store_1, idx);
                  });
                  change.del.forEach(function(idxName) {
                    return store_1.deleteIndex(idxName);
                  });
                }
              });
              var contentUpgrade = version2._cfg.contentUpgrade;
              if (contentUpgrade && version2._cfg.version > oldVersion) {
                generateMiddlewareStacks(db2, idbUpgradeTrans);
                trans._memoizedTables = {};
                var upgradeSchema_1 = shallowClone(newSchema);
                diff.del.forEach(function(table) {
                  upgradeSchema_1[table] = oldSchema[table];
                });
                removeTablesApi(db2, [db2.Transaction.prototype]);
                setApiOnPlace(db2, [db2.Transaction.prototype], keys(upgradeSchema_1), upgradeSchema_1);
                trans.schema = upgradeSchema_1;
                var contentUpgradeIsAsync_1 = isAsyncFunction(contentUpgrade);
                if (contentUpgradeIsAsync_1) {
                  incrementExpectedAwaits();
                }
                var returnValue_1;
                var promiseFollowed = DexiePromise.follow(function() {
                  returnValue_1 = contentUpgrade(trans);
                  if (returnValue_1) {
                    if (contentUpgradeIsAsync_1) {
                      var decrementor = decrementExpectedAwaits.bind(null, null);
                      returnValue_1.then(decrementor, decrementor);
                    }
                  }
                });
                return returnValue_1 && typeof returnValue_1.then === "function" ? DexiePromise.resolve(returnValue_1) : promiseFollowed.then(function() {
                  return returnValue_1;
                });
              }
            });
            queue.push(function(idbtrans) {
              var newSchema = version2._cfg.dbschema;
              deleteRemovedTables(newSchema, idbtrans);
              removeTablesApi(db2, [db2.Transaction.prototype]);
              setApiOnPlace(db2, [db2.Transaction.prototype], db2._storeNames, db2._dbSchema);
              trans.schema = db2._dbSchema;
            });
            queue.push(function(idbtrans) {
              if (db2.idbdb.objectStoreNames.contains("$meta")) {
                if (Math.ceil(db2.idbdb.version / 10) === version2._cfg.version) {
                  db2.idbdb.deleteObjectStore("$meta");
                  delete db2._dbSchema.$meta;
                  db2._storeNames = db2._storeNames.filter(function(name) {
                    return name !== "$meta";
                  });
                } else {
                  idbtrans.objectStore("$meta").put(version2._cfg.version, "version");
                }
              }
            });
          });
          function runQueue() {
            return queue.length ? DexiePromise.resolve(queue.shift()(trans.idbtrans)).then(runQueue) : DexiePromise.resolve();
          }
          return runQueue().then(function() {
            createMissingTables(globalSchema, idbUpgradeTrans);
          });
        }
        function getSchemaDiff(oldSchema, newSchema) {
          var diff = {
            del: [],
            add: [],
            change: []
          };
          var table;
          for (table in oldSchema) {
            if (!newSchema[table])
              diff.del.push(table);
          }
          for (table in newSchema) {
            var oldDef = oldSchema[table], newDef = newSchema[table];
            if (!oldDef) {
              diff.add.push([table, newDef]);
            } else {
              var change = {
                name: table,
                def: newDef,
                recreate: false,
                del: [],
                add: [],
                change: []
              };
              if ("" + (oldDef.primKey.keyPath || "") !== "" + (newDef.primKey.keyPath || "") || oldDef.primKey.auto !== newDef.primKey.auto) {
                change.recreate = true;
                diff.change.push(change);
              } else {
                var oldIndexes = oldDef.idxByName;
                var newIndexes = newDef.idxByName;
                var idxName = void 0;
                for (idxName in oldIndexes) {
                  if (!newIndexes[idxName])
                    change.del.push(idxName);
                }
                for (idxName in newIndexes) {
                  var oldIdx = oldIndexes[idxName], newIdx = newIndexes[idxName];
                  if (!oldIdx)
                    change.add.push(newIdx);
                  else if (oldIdx.src !== newIdx.src)
                    change.change.push(newIdx);
                }
                if (change.del.length > 0 || change.add.length > 0 || change.change.length > 0) {
                  diff.change.push(change);
                }
              }
            }
          }
          return diff;
        }
        function createTable(idbtrans, tableName, primKey, indexes) {
          var store = idbtrans.db.createObjectStore(tableName, primKey.keyPath ? { keyPath: primKey.keyPath, autoIncrement: primKey.auto } : { autoIncrement: primKey.auto });
          indexes.forEach(function(idx) {
            return addIndex(store, idx);
          });
          return store;
        }
        function createMissingTables(newSchema, idbtrans) {
          keys(newSchema).forEach(function(tableName) {
            if (!idbtrans.db.objectStoreNames.contains(tableName)) {
              if (debug)
                console.debug("Dexie: Creating missing table", tableName);
              createTable(idbtrans, tableName, newSchema[tableName].primKey, newSchema[tableName].indexes);
            }
          });
        }
        function deleteRemovedTables(newSchema, idbtrans) {
          [].slice.call(idbtrans.db.objectStoreNames).forEach(function(storeName) {
            return newSchema[storeName] == null && idbtrans.db.deleteObjectStore(storeName);
          });
        }
        function addIndex(store, idx) {
          store.createIndex(idx.name, idx.keyPath, { unique: idx.unique, multiEntry: idx.multi });
        }
        function buildGlobalSchema(db2, idbdb, tmpTrans) {
          var globalSchema = {};
          var dbStoreNames = slice3(idbdb.objectStoreNames, 0);
          dbStoreNames.forEach(function(storeName) {
            var store = tmpTrans.objectStore(storeName);
            var keyPath = store.keyPath;
            var primKey = createIndexSpec(nameFromKeyPath(keyPath), keyPath || "", true, false, !!store.autoIncrement, keyPath && typeof keyPath !== "string", true);
            var indexes = [];
            for (var j = 0; j < store.indexNames.length; ++j) {
              var idbindex = store.index(store.indexNames[j]);
              keyPath = idbindex.keyPath;
              var index2 = createIndexSpec(idbindex.name, keyPath, !!idbindex.unique, !!idbindex.multiEntry, false, keyPath && typeof keyPath !== "string", false);
              indexes.push(index2);
            }
            globalSchema[storeName] = createTableSchema(storeName, primKey, indexes);
          });
          return globalSchema;
        }
        function readGlobalSchema(db2, idbdb, tmpTrans) {
          db2.verno = idbdb.version / 10;
          var globalSchema = db2._dbSchema = buildGlobalSchema(db2, idbdb, tmpTrans);
          db2._storeNames = slice3(idbdb.objectStoreNames, 0);
          setApiOnPlace(db2, [db2._allTables], keys(globalSchema), globalSchema);
        }
        function verifyInstalledSchema(db2, tmpTrans) {
          var installedSchema = buildGlobalSchema(db2, db2.idbdb, tmpTrans);
          var diff = getSchemaDiff(installedSchema, db2._dbSchema);
          return !(diff.add.length || diff.change.some(function(ch) {
            return ch.add.length || ch.change.length;
          }));
        }
        function adjustToExistingIndexNames(db2, schema, idbtrans) {
          var storeNames = idbtrans.db.objectStoreNames;
          for (var i = 0; i < storeNames.length; ++i) {
            var storeName = storeNames[i];
            var store = idbtrans.objectStore(storeName);
            db2._hasGetAll = "getAll" in store;
            for (var j = 0; j < store.indexNames.length; ++j) {
              var indexName = store.indexNames[j];
              var keyPath = store.index(indexName).keyPath;
              var dexieName = typeof keyPath === "string" ? keyPath : "[" + slice3(keyPath).join("+") + "]";
              if (schema[storeName]) {
                var indexSpec = schema[storeName].idxByName[dexieName];
                if (indexSpec) {
                  indexSpec.name = indexName;
                  delete schema[storeName].idxByName[dexieName];
                  schema[storeName].idxByName[indexName] = indexSpec;
                }
              }
            }
          }
          if (typeof navigator !== "undefined" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && _global.WorkerGlobalScope && _global instanceof _global.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604) {
            db2._hasGetAll = false;
          }
        }
        function parseIndexSyntax(primKeyAndIndexes) {
          return primKeyAndIndexes.split(",").map(function(index2, indexNum) {
            index2 = index2.trim();
            var name = index2.replace(/([&*]|\+\+)/g, "");
            var keyPath = /^\[/.test(name) ? name.match(/^\[(.*)\]$/)[1].split("+") : name;
            return createIndexSpec(name, keyPath || null, /\&/.test(index2), /\*/.test(index2), /\+\+/.test(index2), isArray3(keyPath), indexNum === 0);
          });
        }
        var Version = (function() {
          function Version2() {
          }
          Version2.prototype._parseStoresSpec = function(stores, outSchema) {
            keys(stores).forEach(function(tableName) {
              if (stores[tableName] !== null) {
                var indexes = parseIndexSyntax(stores[tableName]);
                var primKey = indexes.shift();
                primKey.unique = true;
                if (primKey.multi)
                  throw new exceptions.Schema("Primary key cannot be multi-valued");
                indexes.forEach(function(idx) {
                  if (idx.auto)
                    throw new exceptions.Schema("Only primary key can be marked as autoIncrement (++)");
                  if (!idx.keyPath)
                    throw new exceptions.Schema("Index must have a name and cannot be an empty string");
                });
                outSchema[tableName] = createTableSchema(tableName, primKey, indexes);
              }
            });
          };
          Version2.prototype.stores = function(stores) {
            var db2 = this.db;
            this._cfg.storesSource = this._cfg.storesSource ? extend(this._cfg.storesSource, stores) : stores;
            var versions = db2._versions;
            var storesSpec = {};
            var dbschema = {};
            versions.forEach(function(version2) {
              extend(storesSpec, version2._cfg.storesSource);
              dbschema = version2._cfg.dbschema = {};
              version2._parseStoresSpec(storesSpec, dbschema);
            });
            db2._dbSchema = dbschema;
            removeTablesApi(db2, [db2._allTables, db2, db2.Transaction.prototype]);
            setApiOnPlace(db2, [db2._allTables, db2, db2.Transaction.prototype, this._cfg.tables], keys(dbschema), dbschema);
            db2._storeNames = keys(dbschema);
            return this;
          };
          Version2.prototype.upgrade = function(upgradeFunction) {
            this._cfg.contentUpgrade = promisableChain(this._cfg.contentUpgrade || nop, upgradeFunction);
            return this;
          };
          return Version2;
        })();
        function createVersionConstructor(db2) {
          return makeClassConstructor(Version.prototype, function Version2(versionNumber) {
            this.db = db2;
            this._cfg = {
              version: versionNumber,
              storesSource: null,
              dbschema: {},
              tables: {},
              contentUpgrade: null
            };
          });
        }
        function getDbNamesTable(indexedDB2, IDBKeyRange) {
          var dbNamesDB = indexedDB2["_dbNamesDB"];
          if (!dbNamesDB) {
            dbNamesDB = indexedDB2["_dbNamesDB"] = new Dexie$1(DBNAMES_DB, {
              addons: [],
              indexedDB: indexedDB2,
              IDBKeyRange
            });
            dbNamesDB.version(1).stores({ dbnames: "name" });
          }
          return dbNamesDB.table("dbnames");
        }
        function hasDatabasesNative(indexedDB2) {
          return indexedDB2 && typeof indexedDB2.databases === "function";
        }
        function getDatabaseNames(_a3) {
          var indexedDB2 = _a3.indexedDB, IDBKeyRange = _a3.IDBKeyRange;
          return hasDatabasesNative(indexedDB2) ? Promise.resolve(indexedDB2.databases()).then(function(infos) {
            return infos.map(function(info) {
              return info.name;
            }).filter(function(name) {
              return name !== DBNAMES_DB;
            });
          }) : getDbNamesTable(indexedDB2, IDBKeyRange).toCollection().primaryKeys();
        }
        function _onDatabaseCreated(_a3, name) {
          var indexedDB2 = _a3.indexedDB, IDBKeyRange = _a3.IDBKeyRange;
          !hasDatabasesNative(indexedDB2) && name !== DBNAMES_DB && getDbNamesTable(indexedDB2, IDBKeyRange).put({ name }).catch(nop);
        }
        function _onDatabaseDeleted(_a3, name) {
          var indexedDB2 = _a3.indexedDB, IDBKeyRange = _a3.IDBKeyRange;
          !hasDatabasesNative(indexedDB2) && name !== DBNAMES_DB && getDbNamesTable(indexedDB2, IDBKeyRange).delete(name).catch(nop);
        }
        function vip(fn2) {
          return newScope(function() {
            PSD.letThrough = true;
            return fn2();
          });
        }
        function idbReady() {
          var isSafari4 = !navigator.userAgentData && /Safari\//.test(navigator.userAgent) && !/Chrom(e|ium)\//.test(navigator.userAgent);
          if (!isSafari4 || !indexedDB.databases)
            return Promise.resolve();
          var intervalId;
          return new Promise(function(resolve) {
            var tryIdb = function() {
              return indexedDB.databases().finally(resolve);
            };
            intervalId = setInterval(tryIdb, 100);
            tryIdb();
          }).finally(function() {
            return clearInterval(intervalId);
          });
        }
        var _a2;
        function isEmptyRange(node2) {
          return !("from" in node2);
        }
        var RangeSet2 = function(fromOrTree, to) {
          if (this) {
            extend(this, arguments.length ? { d: 1, from: fromOrTree, to: arguments.length > 1 ? to : fromOrTree } : { d: 0 });
          } else {
            var rv = new RangeSet2();
            if (fromOrTree && "d" in fromOrTree) {
              extend(rv, fromOrTree);
            }
            return rv;
          }
        };
        props(RangeSet2.prototype, (_a2 = {
          add: function(rangeSet) {
            mergeRanges2(this, rangeSet);
            return this;
          },
          addKey: function(key) {
            addRange(this, key, key);
            return this;
          },
          addKeys: function(keys2) {
            var _this = this;
            keys2.forEach(function(key) {
              return addRange(_this, key, key);
            });
            return this;
          },
          hasKey: function(key) {
            var node2 = getRangeSetIterator(this).next(key).value;
            return node2 && cmp2(node2.from, key) <= 0 && cmp2(node2.to, key) >= 0;
          }
        }, _a2[iteratorSymbol] = function() {
          return getRangeSetIterator(this);
        }, _a2));
        function addRange(target, from2, to) {
          var diff = cmp2(from2, to);
          if (isNaN(diff))
            return;
          if (diff > 0)
            throw RangeError();
          if (isEmptyRange(target))
            return extend(target, { from: from2, to, d: 1 });
          var left2 = target.l;
          var right2 = target.r;
          if (cmp2(to, target.from) < 0) {
            left2 ? addRange(left2, from2, to) : target.l = { from: from2, to, d: 1, l: null, r: null };
            return rebalance(target);
          }
          if (cmp2(from2, target.to) > 0) {
            right2 ? addRange(right2, from2, to) : target.r = { from: from2, to, d: 1, l: null, r: null };
            return rebalance(target);
          }
          if (cmp2(from2, target.from) < 0) {
            target.from = from2;
            target.l = null;
            target.d = right2 ? right2.d + 1 : 1;
          }
          if (cmp2(to, target.to) > 0) {
            target.to = to;
            target.r = null;
            target.d = target.l ? target.l.d + 1 : 1;
          }
          var rightWasCutOff = !target.r;
          if (left2 && !target.l) {
            mergeRanges2(target, left2);
          }
          if (right2 && rightWasCutOff) {
            mergeRanges2(target, right2);
          }
        }
        function mergeRanges2(target, newSet) {
          function _addRangeSet(target2, _a3) {
            var from2 = _a3.from, to = _a3.to, l = _a3.l, r = _a3.r;
            addRange(target2, from2, to);
            if (l)
              _addRangeSet(target2, l);
            if (r)
              _addRangeSet(target2, r);
          }
          if (!isEmptyRange(newSet))
            _addRangeSet(target, newSet);
        }
        function rangesOverlap2(rangeSet1, rangeSet2) {
          var i1 = getRangeSetIterator(rangeSet2);
          var nextResult1 = i1.next();
          if (nextResult1.done)
            return false;
          var a = nextResult1.value;
          var i2 = getRangeSetIterator(rangeSet1);
          var nextResult2 = i2.next(a.from);
          var b = nextResult2.value;
          while (!nextResult1.done && !nextResult2.done) {
            if (cmp2(b.from, a.to) <= 0 && cmp2(b.to, a.from) >= 0)
              return true;
            cmp2(a.from, b.from) < 0 ? a = (nextResult1 = i1.next(b.from)).value : b = (nextResult2 = i2.next(a.from)).value;
          }
          return false;
        }
        function getRangeSetIterator(node2) {
          var state = isEmptyRange(node2) ? null : { s: 0, n: node2 };
          return {
            next: function(key) {
              var keyProvided = arguments.length > 0;
              while (state) {
                switch (state.s) {
                  case 0:
                    state.s = 1;
                    if (keyProvided) {
                      while (state.n.l && cmp2(key, state.n.from) < 0)
                        state = { up: state, n: state.n.l, s: 1 };
                    } else {
                      while (state.n.l)
                        state = { up: state, n: state.n.l, s: 1 };
                    }
                  case 1:
                    state.s = 2;
                    if (!keyProvided || cmp2(key, state.n.to) <= 0)
                      return { value: state.n, done: false };
                  case 2:
                    if (state.n.r) {
                      state.s = 3;
                      state = { up: state, n: state.n.r, s: 0 };
                      continue;
                    }
                  case 3:
                    state = state.up;
                }
              }
              return { done: true };
            }
          };
        }
        function rebalance(target) {
          var _a3, _b;
          var diff = (((_a3 = target.r) === null || _a3 === void 0 ? void 0 : _a3.d) || 0) - (((_b = target.l) === null || _b === void 0 ? void 0 : _b.d) || 0);
          var r = diff > 1 ? "r" : diff < -1 ? "l" : "";
          if (r) {
            var l = r === "r" ? "l" : "r";
            var rootClone = __assign2({}, target);
            var oldRootRight = target[r];
            target.from = oldRootRight.from;
            target.to = oldRootRight.to;
            target[r] = oldRootRight[r];
            rootClone[r] = oldRootRight[l];
            target[l] = rootClone;
            rootClone.d = computeDepth(rootClone);
          }
          target.d = computeDepth(target);
        }
        function computeDepth(_a3) {
          var r = _a3.r, l = _a3.l;
          return (r ? l ? Math.max(r.d, l.d) : r.d : l ? l.d : 0) + 1;
        }
        function extendObservabilitySet(target, newSet) {
          keys(newSet).forEach(function(part) {
            if (target[part])
              mergeRanges2(target[part], newSet[part]);
            else
              target[part] = cloneSimpleObjectTree(newSet[part]);
          });
          return target;
        }
        function obsSetsOverlap(os1, os2) {
          return os1.all || os2.all || Object.keys(os1).some(function(key) {
            return os2[key] && rangesOverlap2(os2[key], os1[key]);
          });
        }
        var cache = {};
        var unsignaledParts = {};
        var isTaskEnqueued = false;
        function signalSubscribersLazily(part, optimistic) {
          extendObservabilitySet(unsignaledParts, part);
          if (!isTaskEnqueued) {
            isTaskEnqueued = true;
            setTimeout(function() {
              isTaskEnqueued = false;
              var parts = unsignaledParts;
              unsignaledParts = {};
              signalSubscribersNow(parts, false);
            }, 0);
          }
        }
        function signalSubscribersNow(updatedParts, deleteAffectedCacheEntries) {
          if (deleteAffectedCacheEntries === void 0) {
            deleteAffectedCacheEntries = false;
          }
          var queriesToSignal = /* @__PURE__ */ new Set();
          if (updatedParts.all) {
            for (var _i = 0, _a3 = Object.values(cache); _i < _a3.length; _i++) {
              var tblCache = _a3[_i];
              collectTableSubscribers(tblCache, updatedParts, queriesToSignal, deleteAffectedCacheEntries);
            }
          } else {
            for (var key in updatedParts) {
              var parts = /^idb\:\/\/(.*)\/(.*)\//.exec(key);
              if (parts) {
                var dbName = parts[1], tableName = parts[2];
                var tblCache = cache["idb://".concat(dbName, "/").concat(tableName)];
                if (tblCache)
                  collectTableSubscribers(tblCache, updatedParts, queriesToSignal, deleteAffectedCacheEntries);
              }
            }
          }
          queriesToSignal.forEach(function(requery) {
            return requery();
          });
        }
        function collectTableSubscribers(tblCache, updatedParts, outQueriesToSignal, deleteAffectedCacheEntries) {
          var updatedEntryLists = [];
          for (var _i = 0, _a3 = Object.entries(tblCache.queries.query); _i < _a3.length; _i++) {
            var _b = _a3[_i], indexName = _b[0], entries = _b[1];
            var filteredEntries = [];
            for (var _c = 0, entries_1 = entries; _c < entries_1.length; _c++) {
              var entry = entries_1[_c];
              if (obsSetsOverlap(updatedParts, entry.obsSet)) {
                entry.subscribers.forEach(function(requery) {
                  return outQueriesToSignal.add(requery);
                });
              } else if (deleteAffectedCacheEntries) {
                filteredEntries.push(entry);
              }
            }
            if (deleteAffectedCacheEntries)
              updatedEntryLists.push([indexName, filteredEntries]);
          }
          if (deleteAffectedCacheEntries) {
            for (var _d = 0, updatedEntryLists_1 = updatedEntryLists; _d < updatedEntryLists_1.length; _d++) {
              var _e = updatedEntryLists_1[_d], indexName = _e[0], filteredEntries = _e[1];
              tblCache.queries.query[indexName] = filteredEntries;
            }
          }
        }
        function dexieOpen(db2) {
          var state = db2._state;
          var indexedDB2 = db2._deps.indexedDB;
          if (state.isBeingOpened || db2.idbdb)
            return state.dbReadyPromise.then(function() {
              return state.dbOpenError ? rejection(state.dbOpenError) : db2;
            });
          state.isBeingOpened = true;
          state.dbOpenError = null;
          state.openComplete = false;
          var openCanceller = state.openCanceller;
          var nativeVerToOpen = Math.round(db2.verno * 10);
          var schemaPatchMode = false;
          function throwIfCancelled() {
            if (state.openCanceller !== openCanceller)
              throw new exceptions.DatabaseClosed("db.open() was cancelled");
          }
          var resolveDbReady = state.dbReadyResolve, upgradeTransaction = null, wasCreated = false;
          var tryOpenDB = function() {
            return new DexiePromise(function(resolve, reject) {
              throwIfCancelled();
              if (!indexedDB2)
                throw new exceptions.MissingAPI();
              var dbName = db2.name;
              var req = state.autoSchema || !nativeVerToOpen ? indexedDB2.open(dbName) : indexedDB2.open(dbName, nativeVerToOpen);
              if (!req)
                throw new exceptions.MissingAPI();
              req.onerror = eventRejectHandler(reject);
              req.onblocked = wrap4(db2._fireOnBlocked);
              req.onupgradeneeded = wrap4(function(e) {
                upgradeTransaction = req.transaction;
                if (state.autoSchema && !db2._options.allowEmptyDB) {
                  req.onerror = preventDefault;
                  upgradeTransaction.abort();
                  req.result.close();
                  var delreq = indexedDB2.deleteDatabase(dbName);
                  delreq.onsuccess = delreq.onerror = wrap4(function() {
                    reject(new exceptions.NoSuchDatabase("Database ".concat(dbName, " doesnt exist")));
                  });
                } else {
                  upgradeTransaction.onerror = eventRejectHandler(reject);
                  var oldVer = e.oldVersion > Math.pow(2, 62) ? 0 : e.oldVersion;
                  wasCreated = oldVer < 1;
                  db2.idbdb = req.result;
                  if (schemaPatchMode) {
                    patchCurrentVersion(db2, upgradeTransaction);
                  }
                  runUpgraders(db2, oldVer / 10, upgradeTransaction, reject);
                }
              }, reject);
              req.onsuccess = wrap4(function() {
                upgradeTransaction = null;
                var idbdb = db2.idbdb = req.result;
                var objectStoreNames = slice3(idbdb.objectStoreNames);
                if (objectStoreNames.length > 0)
                  try {
                    var tmpTrans = idbdb.transaction(safariMultiStoreFix(objectStoreNames), "readonly");
                    if (state.autoSchema)
                      readGlobalSchema(db2, idbdb, tmpTrans);
                    else {
                      adjustToExistingIndexNames(db2, db2._dbSchema, tmpTrans);
                      if (!verifyInstalledSchema(db2, tmpTrans) && !schemaPatchMode) {
                        console.warn("Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Dexie will add missing parts and increment native version number to workaround this.");
                        idbdb.close();
                        nativeVerToOpen = idbdb.version + 1;
                        schemaPatchMode = true;
                        return resolve(tryOpenDB());
                      }
                    }
                    generateMiddlewareStacks(db2, tmpTrans);
                  } catch (e) {
                  }
                connections.push(db2);
                idbdb.onversionchange = wrap4(function(ev) {
                  state.vcFired = true;
                  db2.on("versionchange").fire(ev);
                });
                idbdb.onclose = wrap4(function(ev) {
                  db2.on("close").fire(ev);
                });
                if (wasCreated)
                  _onDatabaseCreated(db2._deps, dbName);
                resolve();
              }, reject);
            }).catch(function(err) {
              switch (err === null || err === void 0 ? void 0 : err.name) {
                case "UnknownError":
                  if (state.PR1398_maxLoop > 0) {
                    state.PR1398_maxLoop--;
                    console.warn("Dexie: Workaround for Chrome UnknownError on open()");
                    return tryOpenDB();
                  }
                  break;
                case "VersionError":
                  if (nativeVerToOpen > 0) {
                    nativeVerToOpen = 0;
                    return tryOpenDB();
                  }
                  break;
              }
              return DexiePromise.reject(err);
            });
          };
          return DexiePromise.race([
            openCanceller,
            (typeof navigator === "undefined" ? DexiePromise.resolve() : idbReady()).then(tryOpenDB)
          ]).then(function() {
            throwIfCancelled();
            state.onReadyBeingFired = [];
            return DexiePromise.resolve(vip(function() {
              return db2.on.ready.fire(db2.vip);
            })).then(function fireRemainders() {
              if (state.onReadyBeingFired.length > 0) {
                var remainders_1 = state.onReadyBeingFired.reduce(promisableChain, nop);
                state.onReadyBeingFired = [];
                return DexiePromise.resolve(vip(function() {
                  return remainders_1(db2.vip);
                })).then(fireRemainders);
              }
            });
          }).finally(function() {
            if (state.openCanceller === openCanceller) {
              state.onReadyBeingFired = null;
              state.isBeingOpened = false;
            }
          }).catch(function(err) {
            state.dbOpenError = err;
            try {
              upgradeTransaction && upgradeTransaction.abort();
            } catch (_a3) {
            }
            if (openCanceller === state.openCanceller) {
              db2._close();
            }
            return rejection(err);
          }).finally(function() {
            state.openComplete = true;
            resolveDbReady();
          }).then(function() {
            if (wasCreated) {
              var everything_1 = {};
              db2.tables.forEach(function(table) {
                table.schema.indexes.forEach(function(idx) {
                  if (idx.name)
                    everything_1["idb://".concat(db2.name, "/").concat(table.name, "/").concat(idx.name)] = new RangeSet2(-Infinity, [[[]]]);
                });
                everything_1["idb://".concat(db2.name, "/").concat(table.name, "/")] = everything_1["idb://".concat(db2.name, "/").concat(table.name, "/:dels")] = new RangeSet2(-Infinity, [[[]]]);
              });
              globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME).fire(everything_1);
              signalSubscribersNow(everything_1, true);
            }
            return db2;
          });
        }
        function awaitIterator(iterator) {
          var callNext = function(result2) {
            return iterator.next(result2);
          }, doThrow = function(error) {
            return iterator.throw(error);
          }, onSuccess = step(callNext), onError = step(doThrow);
          function step(getNext) {
            return function(val) {
              var next2 = getNext(val), value = next2.value;
              return next2.done ? value : !value || typeof value.then !== "function" ? isArray3(value) ? Promise.all(value).then(onSuccess, onError) : onSuccess(value) : value.then(onSuccess, onError);
            };
          }
          return step(callNext)();
        }
        function extractTransactionArgs(mode, _tableArgs_, scopeFunc) {
          var i = arguments.length;
          if (i < 2)
            throw new exceptions.InvalidArgument("Too few arguments");
          var args = new Array(i - 1);
          while (--i)
            args[i - 1] = arguments[i];
          scopeFunc = args.pop();
          var tables = flatten(args);
          return [mode, tables, scopeFunc];
        }
        function enterTransactionScope(db2, mode, storeNames, parentTransaction, scopeFunc) {
          return DexiePromise.resolve().then(function() {
            var transless = PSD.transless || PSD;
            var trans = db2._createTransaction(mode, storeNames, db2._dbSchema, parentTransaction);
            trans.explicit = true;
            var zoneProps = {
              trans,
              transless
            };
            if (parentTransaction) {
              trans.idbtrans = parentTransaction.idbtrans;
            } else {
              try {
                trans.create();
                trans.idbtrans._explicit = true;
                db2._state.PR1398_maxLoop = 3;
              } catch (ex) {
                if (ex.name === errnames.InvalidState && db2.isOpen() && --db2._state.PR1398_maxLoop > 0) {
                  console.warn("Dexie: Need to reopen db");
                  db2.close({ disableAutoOpen: false });
                  return db2.open().then(function() {
                    return enterTransactionScope(db2, mode, storeNames, null, scopeFunc);
                  });
                }
                return rejection(ex);
              }
            }
            var scopeFuncIsAsync = isAsyncFunction(scopeFunc);
            if (scopeFuncIsAsync) {
              incrementExpectedAwaits();
            }
            var returnValue;
            var promiseFollowed = DexiePromise.follow(function() {
              returnValue = scopeFunc.call(trans, trans);
              if (returnValue) {
                if (scopeFuncIsAsync) {
                  var decrementor = decrementExpectedAwaits.bind(null, null);
                  returnValue.then(decrementor, decrementor);
                } else if (typeof returnValue.next === "function" && typeof returnValue.throw === "function") {
                  returnValue = awaitIterator(returnValue);
                }
              }
            }, zoneProps);
            return (returnValue && typeof returnValue.then === "function" ? DexiePromise.resolve(returnValue).then(function(x) {
              return trans.active ? x : rejection(new exceptions.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn"));
            }) : promiseFollowed.then(function() {
              return returnValue;
            })).then(function(x) {
              if (parentTransaction)
                trans._resolve();
              return trans._completion.then(function() {
                return x;
              });
            }).catch(function(e) {
              trans._reject(e);
              return rejection(e);
            });
          });
        }
        function pad(a, value, count) {
          var result2 = isArray3(a) ? a.slice() : [a];
          for (var i = 0; i < count; ++i)
            result2.push(value);
          return result2;
        }
        function createVirtualIndexMiddleware(down) {
          return __assign2(__assign2({}, down), { table: function(tableName) {
            var table = down.table(tableName);
            var schema = table.schema;
            var indexLookup = {};
            var allVirtualIndexes = [];
            function addVirtualIndexes(keyPath, keyTail, lowLevelIndex) {
              var keyPathAlias = getKeyPathAlias(keyPath);
              var indexList = indexLookup[keyPathAlias] = indexLookup[keyPathAlias] || [];
              var keyLength = keyPath == null ? 0 : typeof keyPath === "string" ? 1 : keyPath.length;
              var isVirtual = keyTail > 0;
              var virtualIndex = __assign2(__assign2({}, lowLevelIndex), { name: isVirtual ? "".concat(keyPathAlias, "(virtual-from:").concat(lowLevelIndex.name, ")") : lowLevelIndex.name, lowLevelIndex, isVirtual, keyTail, keyLength, extractKey: getKeyExtractor(keyPath), unique: !isVirtual && lowLevelIndex.unique });
              indexList.push(virtualIndex);
              if (!virtualIndex.isPrimaryKey) {
                allVirtualIndexes.push(virtualIndex);
              }
              if (keyLength > 1) {
                var virtualKeyPath = keyLength === 2 ? keyPath[0] : keyPath.slice(0, keyLength - 1);
                addVirtualIndexes(virtualKeyPath, keyTail + 1, lowLevelIndex);
              }
              indexList.sort(function(a, b) {
                return a.keyTail - b.keyTail;
              });
              return virtualIndex;
            }
            var primaryKey = addVirtualIndexes(schema.primaryKey.keyPath, 0, schema.primaryKey);
            indexLookup[":id"] = [primaryKey];
            for (var _i = 0, _a3 = schema.indexes; _i < _a3.length; _i++) {
              var index2 = _a3[_i];
              addVirtualIndexes(index2.keyPath, 0, index2);
            }
            function findBestIndex(keyPath) {
              var result3 = indexLookup[getKeyPathAlias(keyPath)];
              return result3 && result3[0];
            }
            function translateRange(range, keyTail) {
              return {
                type: range.type === 1 ? 2 : range.type,
                lower: pad(range.lower, range.lowerOpen ? down.MAX_KEY : down.MIN_KEY, keyTail),
                lowerOpen: true,
                upper: pad(range.upper, range.upperOpen ? down.MIN_KEY : down.MAX_KEY, keyTail),
                upperOpen: true
              };
            }
            function translateRequest(req) {
              var index3 = req.query.index;
              return index3.isVirtual ? __assign2(__assign2({}, req), { query: {
                index: index3.lowLevelIndex,
                range: translateRange(req.query.range, index3.keyTail)
              } }) : req;
            }
            var result2 = __assign2(__assign2({}, table), { schema: __assign2(__assign2({}, schema), { primaryKey, indexes: allVirtualIndexes, getIndexByKeyPath: findBestIndex }), count: function(req) {
              return table.count(translateRequest(req));
            }, query: function(req) {
              return table.query(translateRequest(req));
            }, openCursor: function(req) {
              var _a4 = req.query.index, keyTail = _a4.keyTail, isVirtual = _a4.isVirtual, keyLength = _a4.keyLength;
              if (!isVirtual)
                return table.openCursor(req);
              function createVirtualCursor(cursor2) {
                function _continue(key) {
                  key != null ? cursor2.continue(pad(key, req.reverse ? down.MAX_KEY : down.MIN_KEY, keyTail)) : req.unique ? cursor2.continue(cursor2.key.slice(0, keyLength).concat(req.reverse ? down.MIN_KEY : down.MAX_KEY, keyTail)) : cursor2.continue();
                }
                var virtualCursor = Object.create(cursor2, {
                  continue: { value: _continue },
                  continuePrimaryKey: {
                    value: function(key, primaryKey2) {
                      cursor2.continuePrimaryKey(pad(key, down.MAX_KEY, keyTail), primaryKey2);
                    }
                  },
                  primaryKey: {
                    get: function() {
                      return cursor2.primaryKey;
                    }
                  },
                  key: {
                    get: function() {
                      var key = cursor2.key;
                      return keyLength === 1 ? key[0] : key.slice(0, keyLength);
                    }
                  },
                  value: {
                    get: function() {
                      return cursor2.value;
                    }
                  }
                });
                return virtualCursor;
              }
              return table.openCursor(translateRequest(req)).then(function(cursor2) {
                return cursor2 && createVirtualCursor(cursor2);
              });
            } });
            return result2;
          } });
        }
        var virtualIndexMiddleware = {
          stack: "dbcore",
          name: "VirtualIndexMiddleware",
          level: 1,
          create: createVirtualIndexMiddleware
        };
        function getObjectDiff(a, b, rv, prfx) {
          rv = rv || {};
          prfx = prfx || "";
          keys(a).forEach(function(prop) {
            if (!hasOwn3(b, prop)) {
              rv[prfx + prop] = void 0;
            } else {
              var ap = a[prop], bp = b[prop];
              if (typeof ap === "object" && typeof bp === "object" && ap && bp) {
                var apTypeName = toStringTag(ap);
                var bpTypeName = toStringTag(bp);
                if (apTypeName !== bpTypeName) {
                  rv[prfx + prop] = b[prop];
                } else if (apTypeName === "Object") {
                  getObjectDiff(ap, bp, rv, prfx + prop + ".");
                } else if (ap !== bp) {
                  rv[prfx + prop] = b[prop];
                }
              } else if (ap !== bp)
                rv[prfx + prop] = b[prop];
            }
          });
          keys(b).forEach(function(prop) {
            if (!hasOwn3(a, prop)) {
              rv[prfx + prop] = b[prop];
            }
          });
          return rv;
        }
        function getEffectiveKeys(primaryKey, req) {
          if (req.type === "delete")
            return req.keys;
          return req.keys || req.values.map(primaryKey.extractKey);
        }
        var hooksMiddleware = {
          stack: "dbcore",
          name: "HooksMiddleware",
          level: 2,
          create: function(downCore) {
            return __assign2(__assign2({}, downCore), { table: function(tableName) {
              var downTable = downCore.table(tableName);
              var primaryKey = downTable.schema.primaryKey;
              var tableMiddleware = __assign2(__assign2({}, downTable), { mutate: function(req) {
                var dxTrans = PSD.trans;
                var _a3 = dxTrans.table(tableName).hook, deleting = _a3.deleting, creating = _a3.creating, updating = _a3.updating;
                switch (req.type) {
                  case "add":
                    if (creating.fire === nop)
                      break;
                    return dxTrans._promise("readwrite", function() {
                      return addPutOrDelete(req);
                    }, true);
                  case "put":
                    if (creating.fire === nop && updating.fire === nop)
                      break;
                    return dxTrans._promise("readwrite", function() {
                      return addPutOrDelete(req);
                    }, true);
                  case "delete":
                    if (deleting.fire === nop)
                      break;
                    return dxTrans._promise("readwrite", function() {
                      return addPutOrDelete(req);
                    }, true);
                  case "deleteRange":
                    if (deleting.fire === nop)
                      break;
                    return dxTrans._promise("readwrite", function() {
                      return deleteRange(req);
                    }, true);
                }
                return downTable.mutate(req);
                function addPutOrDelete(req2) {
                  var dxTrans2 = PSD.trans;
                  var keys2 = req2.keys || getEffectiveKeys(primaryKey, req2);
                  if (!keys2)
                    throw new Error("Keys missing");
                  req2 = req2.type === "add" || req2.type === "put" ? __assign2(__assign2({}, req2), { keys: keys2 }) : __assign2({}, req2);
                  if (req2.type !== "delete")
                    req2.values = __spreadArray2([], req2.values, true);
                  if (req2.keys)
                    req2.keys = __spreadArray2([], req2.keys, true);
                  return getExistingValues(downTable, req2, keys2).then(function(existingValues) {
                    var contexts = keys2.map(function(key, i) {
                      var existingValue = existingValues[i];
                      var ctx = { onerror: null, onsuccess: null };
                      if (req2.type === "delete") {
                        deleting.fire.call(ctx, key, existingValue, dxTrans2);
                      } else if (req2.type === "add" || existingValue === void 0) {
                        var generatedPrimaryKey = creating.fire.call(ctx, key, req2.values[i], dxTrans2);
                        if (key == null && generatedPrimaryKey != null) {
                          key = generatedPrimaryKey;
                          req2.keys[i] = key;
                          if (!primaryKey.outbound) {
                            setByKeyPath(req2.values[i], primaryKey.keyPath, key);
                          }
                        }
                      } else {
                        var objectDiff = getObjectDiff(existingValue, req2.values[i]);
                        var additionalChanges_1 = updating.fire.call(ctx, objectDiff, key, existingValue, dxTrans2);
                        if (additionalChanges_1) {
                          var requestedValue_1 = req2.values[i];
                          Object.keys(additionalChanges_1).forEach(function(keyPath) {
                            if (hasOwn3(requestedValue_1, keyPath)) {
                              requestedValue_1[keyPath] = additionalChanges_1[keyPath];
                            } else {
                              setByKeyPath(requestedValue_1, keyPath, additionalChanges_1[keyPath]);
                            }
                          });
                        }
                      }
                      return ctx;
                    });
                    return downTable.mutate(req2).then(function(_a4) {
                      var failures = _a4.failures, results = _a4.results, numFailures = _a4.numFailures, lastResult = _a4.lastResult;
                      for (var i = 0; i < keys2.length; ++i) {
                        var primKey = results ? results[i] : keys2[i];
                        var ctx = contexts[i];
                        if (primKey == null) {
                          ctx.onerror && ctx.onerror(failures[i]);
                        } else {
                          ctx.onsuccess && ctx.onsuccess(
                            req2.type === "put" && existingValues[i] ? req2.values[i] : primKey
                          );
                        }
                      }
                      return { failures, results, numFailures, lastResult };
                    }).catch(function(error) {
                      contexts.forEach(function(ctx) {
                        return ctx.onerror && ctx.onerror(error);
                      });
                      return Promise.reject(error);
                    });
                  });
                }
                function deleteRange(req2) {
                  return deleteNextChunk(req2.trans, req2.range, 1e4);
                }
                function deleteNextChunk(trans, range, limit) {
                  return downTable.query({ trans, values: false, query: { index: primaryKey, range }, limit }).then(function(_a4) {
                    var result2 = _a4.result;
                    return addPutOrDelete({ type: "delete", keys: result2, trans }).then(function(res) {
                      if (res.numFailures > 0)
                        return Promise.reject(res.failures[0]);
                      if (result2.length < limit) {
                        return { failures: [], numFailures: 0, lastResult: void 0 };
                      } else {
                        return deleteNextChunk(trans, __assign2(__assign2({}, range), { lower: result2[result2.length - 1], lowerOpen: true }), limit);
                      }
                    });
                  });
                }
              } });
              return tableMiddleware;
            } });
          }
        };
        function getExistingValues(table, req, effectiveKeys) {
          return req.type === "add" ? Promise.resolve([]) : table.getMany({ trans: req.trans, keys: effectiveKeys, cache: "immutable" });
        }
        function getFromTransactionCache(keys2, cache2, clone) {
          try {
            if (!cache2)
              return null;
            if (cache2.keys.length < keys2.length)
              return null;
            var result2 = [];
            for (var i = 0, j = 0; i < cache2.keys.length && j < keys2.length; ++i) {
              if (cmp2(cache2.keys[i], keys2[j]) !== 0)
                continue;
              result2.push(clone ? deepClone(cache2.values[i]) : cache2.values[i]);
              ++j;
            }
            return result2.length === keys2.length ? result2 : null;
          } catch (_a3) {
            return null;
          }
        }
        var cacheExistingValuesMiddleware = {
          stack: "dbcore",
          level: -1,
          create: function(core) {
            return {
              table: function(tableName) {
                var table = core.table(tableName);
                return __assign2(__assign2({}, table), { getMany: function(req) {
                  if (!req.cache) {
                    return table.getMany(req);
                  }
                  var cachedResult = getFromTransactionCache(req.keys, req.trans["_cache"], req.cache === "clone");
                  if (cachedResult) {
                    return DexiePromise.resolve(cachedResult);
                  }
                  return table.getMany(req).then(function(res) {
                    req.trans["_cache"] = {
                      keys: req.keys,
                      values: req.cache === "clone" ? deepClone(res) : res
                    };
                    return res;
                  });
                }, mutate: function(req) {
                  if (req.type !== "add")
                    req.trans["_cache"] = null;
                  return table.mutate(req);
                } });
              }
            };
          }
        };
        function isCachableContext(ctx, table) {
          return ctx.trans.mode === "readonly" && !!ctx.subscr && !ctx.trans.explicit && ctx.trans.db._options.cache !== "disabled" && !table.schema.primaryKey.outbound;
        }
        function isCachableRequest(type2, req) {
          switch (type2) {
            case "query":
              return req.values && !req.unique;
            case "get":
              return false;
            case "getMany":
              return false;
            case "count":
              return false;
            case "openCursor":
              return false;
          }
        }
        var observabilityMiddleware = {
          stack: "dbcore",
          level: 0,
          name: "Observability",
          create: function(core) {
            var dbName = core.schema.name;
            var FULL_RANGE = new RangeSet2(core.MIN_KEY, core.MAX_KEY);
            return __assign2(__assign2({}, core), { transaction: function(stores, mode, options2) {
              if (PSD.subscr && mode !== "readonly") {
                throw new exceptions.ReadOnly("Readwrite transaction in liveQuery context. Querier source: ".concat(PSD.querier));
              }
              return core.transaction(stores, mode, options2);
            }, table: function(tableName) {
              var table = core.table(tableName);
              var schema = table.schema;
              var primaryKey = schema.primaryKey, indexes = schema.indexes;
              var extractKey2 = primaryKey.extractKey, outbound = primaryKey.outbound;
              var indexesWithAutoIncPK = primaryKey.autoIncrement && indexes.filter(function(index2) {
                return index2.compound && index2.keyPath.includes(primaryKey.keyPath);
              });
              var tableClone = __assign2(__assign2({}, table), { mutate: function(req) {
                var _a3, _b;
                var trans = req.trans;
                var mutatedParts = req.mutatedParts || (req.mutatedParts = {});
                var getRangeSet = function(indexName) {
                  var part = "idb://".concat(dbName, "/").concat(tableName, "/").concat(indexName);
                  return mutatedParts[part] || (mutatedParts[part] = new RangeSet2());
                };
                var pkRangeSet = getRangeSet("");
                var delsRangeSet = getRangeSet(":dels");
                var type2 = req.type;
                var _c = req.type === "deleteRange" ? [req.range] : req.type === "delete" ? [req.keys] : req.values.length < 50 ? [getEffectiveKeys(primaryKey, req).filter(function(id) {
                  return id;
                }), req.values] : [], keys2 = _c[0], newObjs = _c[1];
                var oldCache = req.trans["_cache"];
                if (isArray3(keys2)) {
                  pkRangeSet.addKeys(keys2);
                  var oldObjs = type2 === "delete" || keys2.length === newObjs.length ? getFromTransactionCache(keys2, oldCache) : null;
                  if (!oldObjs) {
                    delsRangeSet.addKeys(keys2);
                  }
                  if (oldObjs || newObjs) {
                    trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs);
                  }
                } else if (keys2) {
                  var range = {
                    from: (_a3 = keys2.lower) !== null && _a3 !== void 0 ? _a3 : core.MIN_KEY,
                    to: (_b = keys2.upper) !== null && _b !== void 0 ? _b : core.MAX_KEY
                  };
                  delsRangeSet.add(range);
                  pkRangeSet.add(range);
                } else {
                  pkRangeSet.add(FULL_RANGE);
                  delsRangeSet.add(FULL_RANGE);
                  schema.indexes.forEach(function(idx) {
                    return getRangeSet(idx.name).add(FULL_RANGE);
                  });
                }
                return table.mutate(req).then(function(res) {
                  if (keys2 && (req.type === "add" || req.type === "put")) {
                    pkRangeSet.addKeys(res.results);
                    if (indexesWithAutoIncPK) {
                      indexesWithAutoIncPK.forEach(function(idx) {
                        var idxVals = req.values.map(function(v) {
                          return idx.extractKey(v);
                        });
                        var pkPos = idx.keyPath.findIndex(function(prop) {
                          return prop === primaryKey.keyPath;
                        });
                        for (var i = 0, len = res.results.length; i < len; ++i) {
                          idxVals[i][pkPos] = res.results[i];
                        }
                        getRangeSet(idx.name).addKeys(idxVals);
                      });
                    }
                  }
                  trans.mutatedParts = extendObservabilitySet(trans.mutatedParts || {}, mutatedParts);
                  return res;
                });
              } });
              var getRange = function(_a3) {
                var _b, _c;
                var _d = _a3.query, index2 = _d.index, range = _d.range;
                return [
                  index2,
                  new RangeSet2((_b = range.lower) !== null && _b !== void 0 ? _b : core.MIN_KEY, (_c = range.upper) !== null && _c !== void 0 ? _c : core.MAX_KEY)
                ];
              };
              var readSubscribers = {
                get: function(req) {
                  return [primaryKey, new RangeSet2(req.key)];
                },
                getMany: function(req) {
                  return [primaryKey, new RangeSet2().addKeys(req.keys)];
                },
                count: getRange,
                query: getRange,
                openCursor: getRange
              };
              keys(readSubscribers).forEach(function(method) {
                tableClone[method] = function(req) {
                  var subscr = PSD.subscr;
                  var isLiveQuery = !!subscr;
                  var cachable = isCachableContext(PSD, table) && isCachableRequest(method, req);
                  var obsSet = cachable ? req.obsSet = {} : subscr;
                  if (isLiveQuery) {
                    var getRangeSet = function(indexName) {
                      var part = "idb://".concat(dbName, "/").concat(tableName, "/").concat(indexName);
                      return obsSet[part] || (obsSet[part] = new RangeSet2());
                    };
                    var pkRangeSet_1 = getRangeSet("");
                    var delsRangeSet_1 = getRangeSet(":dels");
                    var _a3 = readSubscribers[method](req), queriedIndex = _a3[0], queriedRanges = _a3[1];
                    if (method === "query" && queriedIndex.isPrimaryKey && !req.values) {
                      delsRangeSet_1.add(queriedRanges);
                    } else {
                      getRangeSet(queriedIndex.name || "").add(queriedRanges);
                    }
                    if (!queriedIndex.isPrimaryKey) {
                      if (method === "count") {
                        delsRangeSet_1.add(FULL_RANGE);
                      } else {
                        var keysPromise_1 = method === "query" && outbound && req.values && table.query(__assign2(__assign2({}, req), { values: false }));
                        return table[method].apply(this, arguments).then(function(res) {
                          if (method === "query") {
                            if (outbound && req.values) {
                              return keysPromise_1.then(function(_a4) {
                                var resultingKeys = _a4.result;
                                pkRangeSet_1.addKeys(resultingKeys);
                                return res;
                              });
                            }
                            var pKeys = req.values ? res.result.map(extractKey2) : res.result;
                            if (req.values) {
                              pkRangeSet_1.addKeys(pKeys);
                            } else {
                              delsRangeSet_1.addKeys(pKeys);
                            }
                          } else if (method === "openCursor") {
                            var cursor_1 = res;
                            var wantValues_1 = req.values;
                            return cursor_1 && Object.create(cursor_1, {
                              key: {
                                get: function() {
                                  delsRangeSet_1.addKey(cursor_1.primaryKey);
                                  return cursor_1.key;
                                }
                              },
                              primaryKey: {
                                get: function() {
                                  var pkey = cursor_1.primaryKey;
                                  delsRangeSet_1.addKey(pkey);
                                  return pkey;
                                }
                              },
                              value: {
                                get: function() {
                                  wantValues_1 && pkRangeSet_1.addKey(cursor_1.primaryKey);
                                  return cursor_1.value;
                                }
                              }
                            });
                          }
                          return res;
                        });
                      }
                    }
                  }
                  return table[method].apply(this, arguments);
                };
              });
              return tableClone;
            } });
          }
        };
        function trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs) {
          function addAffectedIndex(ix) {
            var rangeSet = getRangeSet(ix.name || "");
            function extractKey2(obj) {
              return obj != null ? ix.extractKey(obj) : null;
            }
            var addKeyOrKeys = function(key) {
              return ix.multiEntry && isArray3(key) ? key.forEach(function(key2) {
                return rangeSet.addKey(key2);
              }) : rangeSet.addKey(key);
            };
            (oldObjs || newObjs).forEach(function(_, i) {
              var oldKey = oldObjs && extractKey2(oldObjs[i]);
              var newKey = newObjs && extractKey2(newObjs[i]);
              if (cmp2(oldKey, newKey) !== 0) {
                if (oldKey != null)
                  addKeyOrKeys(oldKey);
                if (newKey != null)
                  addKeyOrKeys(newKey);
              }
            });
          }
          schema.indexes.forEach(addAffectedIndex);
        }
        function adjustOptimisticFromFailures(tblCache, req, res) {
          if (res.numFailures === 0)
            return req;
          if (req.type === "deleteRange") {
            return null;
          }
          var numBulkOps = req.keys ? req.keys.length : "values" in req && req.values ? req.values.length : 1;
          if (res.numFailures === numBulkOps) {
            return null;
          }
          var clone = __assign2({}, req);
          if (isArray3(clone.keys)) {
            clone.keys = clone.keys.filter(function(_, i) {
              return !(i in res.failures);
            });
          }
          if ("values" in clone && isArray3(clone.values)) {
            clone.values = clone.values.filter(function(_, i) {
              return !(i in res.failures);
            });
          }
          return clone;
        }
        function isAboveLower(key, range) {
          return range.lower === void 0 ? true : range.lowerOpen ? cmp2(key, range.lower) > 0 : cmp2(key, range.lower) >= 0;
        }
        function isBelowUpper(key, range) {
          return range.upper === void 0 ? true : range.upperOpen ? cmp2(key, range.upper) < 0 : cmp2(key, range.upper) <= 0;
        }
        function isWithinRange(key, range) {
          return isAboveLower(key, range) && isBelowUpper(key, range);
        }
        function applyOptimisticOps(result2, req, ops, table, cacheEntry, immutable) {
          if (!ops || ops.length === 0)
            return result2;
          var index2 = req.query.index;
          var multiEntry = index2.multiEntry;
          var queryRange = req.query.range;
          var primaryKey = table.schema.primaryKey;
          var extractPrimKey = primaryKey.extractKey;
          var extractIndex = index2.extractKey;
          var extractLowLevelIndex = (index2.lowLevelIndex || index2).extractKey;
          var finalResult = ops.reduce(function(result3, op) {
            var modifedResult = result3;
            var includedValues = [];
            if (op.type === "add" || op.type === "put") {
              var includedPKs = new RangeSet2();
              for (var i = op.values.length - 1; i >= 0; --i) {
                var value = op.values[i];
                var pk = extractPrimKey(value);
                if (includedPKs.hasKey(pk))
                  continue;
                var key = extractIndex(value);
                if (multiEntry && isArray3(key) ? key.some(function(k) {
                  return isWithinRange(k, queryRange);
                }) : isWithinRange(key, queryRange)) {
                  includedPKs.addKey(pk);
                  includedValues.push(value);
                }
              }
            }
            switch (op.type) {
              case "add": {
                var existingKeys_1 = new RangeSet2().addKeys(req.values ? result3.map(function(v) {
                  return extractPrimKey(v);
                }) : result3);
                modifedResult = result3.concat(req.values ? includedValues.filter(function(v) {
                  var key2 = extractPrimKey(v);
                  if (existingKeys_1.hasKey(key2))
                    return false;
                  existingKeys_1.addKey(key2);
                  return true;
                }) : includedValues.map(function(v) {
                  return extractPrimKey(v);
                }).filter(function(k) {
                  if (existingKeys_1.hasKey(k))
                    return false;
                  existingKeys_1.addKey(k);
                  return true;
                }));
                break;
              }
              case "put": {
                var keySet_1 = new RangeSet2().addKeys(op.values.map(function(v) {
                  return extractPrimKey(v);
                }));
                modifedResult = result3.filter(
                  function(item) {
                    return !keySet_1.hasKey(req.values ? extractPrimKey(item) : item);
                  }
                ).concat(
                  req.values ? includedValues : includedValues.map(function(v) {
                    return extractPrimKey(v);
                  })
                );
                break;
              }
              case "delete":
                var keysToDelete_1 = new RangeSet2().addKeys(op.keys);
                modifedResult = result3.filter(function(item) {
                  return !keysToDelete_1.hasKey(req.values ? extractPrimKey(item) : item);
                });
                break;
              case "deleteRange":
                var range_1 = op.range;
                modifedResult = result3.filter(function(item) {
                  return !isWithinRange(extractPrimKey(item), range_1);
                });
                break;
            }
            return modifedResult;
          }, result2);
          if (finalResult === result2)
            return result2;
          finalResult.sort(function(a, b) {
            return cmp2(extractLowLevelIndex(a), extractLowLevelIndex(b)) || cmp2(extractPrimKey(a), extractPrimKey(b));
          });
          if (req.limit && req.limit < Infinity) {
            if (finalResult.length > req.limit) {
              finalResult.length = req.limit;
            } else if (result2.length === req.limit && finalResult.length < req.limit) {
              cacheEntry.dirty = true;
            }
          }
          return immutable ? Object.freeze(finalResult) : finalResult;
        }
        function areRangesEqual(r1, r2) {
          return cmp2(r1.lower, r2.lower) === 0 && cmp2(r1.upper, r2.upper) === 0 && !!r1.lowerOpen === !!r2.lowerOpen && !!r1.upperOpen === !!r2.upperOpen;
        }
        function compareLowers(lower1, lower2, lowerOpen1, lowerOpen2) {
          if (lower1 === void 0)
            return lower2 !== void 0 ? -1 : 0;
          if (lower2 === void 0)
            return 1;
          var c = cmp2(lower1, lower2);
          if (c === 0) {
            if (lowerOpen1 && lowerOpen2)
              return 0;
            if (lowerOpen1)
              return 1;
            if (lowerOpen2)
              return -1;
          }
          return c;
        }
        function compareUppers(upper1, upper2, upperOpen1, upperOpen2) {
          if (upper1 === void 0)
            return upper2 !== void 0 ? 1 : 0;
          if (upper2 === void 0)
            return -1;
          var c = cmp2(upper1, upper2);
          if (c === 0) {
            if (upperOpen1 && upperOpen2)
              return 0;
            if (upperOpen1)
              return -1;
            if (upperOpen2)
              return 1;
          }
          return c;
        }
        function isSuperRange(r1, r2) {
          return compareLowers(r1.lower, r2.lower, r1.lowerOpen, r2.lowerOpen) <= 0 && compareUppers(r1.upper, r2.upper, r1.upperOpen, r2.upperOpen) >= 0;
        }
        function findCompatibleQuery(dbName, tableName, type2, req) {
          var tblCache = cache["idb://".concat(dbName, "/").concat(tableName)];
          if (!tblCache)
            return [];
          var queries2 = tblCache.queries[type2];
          if (!queries2)
            return [null, false, tblCache, null];
          var indexName = req.query ? req.query.index.name : null;
          var entries = queries2[indexName || ""];
          if (!entries)
            return [null, false, tblCache, null];
          switch (type2) {
            case "query":
              var equalEntry = entries.find(function(entry) {
                return entry.req.limit === req.limit && entry.req.values === req.values && areRangesEqual(entry.req.query.range, req.query.range);
              });
              if (equalEntry)
                return [
                  equalEntry,
                  true,
                  tblCache,
                  entries
                ];
              var superEntry = entries.find(function(entry) {
                var limit = "limit" in entry.req ? entry.req.limit : Infinity;
                return limit >= req.limit && (req.values ? entry.req.values : true) && isSuperRange(entry.req.query.range, req.query.range);
              });
              return [superEntry, false, tblCache, entries];
            case "count":
              var countQuery = entries.find(function(entry) {
                return areRangesEqual(entry.req.query.range, req.query.range);
              });
              return [countQuery, !!countQuery, tblCache, entries];
          }
        }
        function subscribeToCacheEntry(cacheEntry, container, requery, signal) {
          cacheEntry.subscribers.add(requery);
          signal.addEventListener("abort", function() {
            cacheEntry.subscribers.delete(requery);
            if (cacheEntry.subscribers.size === 0) {
              enqueForDeletion(cacheEntry, container);
            }
          });
        }
        function enqueForDeletion(cacheEntry, container) {
          setTimeout(function() {
            if (cacheEntry.subscribers.size === 0) {
              delArrayItem(container, cacheEntry);
            }
          }, 3e3);
        }
        var cacheMiddleware = {
          stack: "dbcore",
          level: 0,
          name: "Cache",
          create: function(core) {
            var dbName = core.schema.name;
            var coreMW = __assign2(__assign2({}, core), { transaction: function(stores, mode, options2) {
              var idbtrans = core.transaction(stores, mode, options2);
              if (mode === "readwrite") {
                var ac_1 = new AbortController();
                var signal = ac_1.signal;
                var endTransaction = function(wasCommitted) {
                  return function() {
                    ac_1.abort();
                    if (mode === "readwrite") {
                      var affectedSubscribers_1 = /* @__PURE__ */ new Set();
                      for (var _i = 0, stores_1 = stores; _i < stores_1.length; _i++) {
                        var storeName = stores_1[_i];
                        var tblCache = cache["idb://".concat(dbName, "/").concat(storeName)];
                        if (tblCache) {
                          var table = core.table(storeName);
                          var ops = tblCache.optimisticOps.filter(function(op) {
                            return op.trans === idbtrans;
                          });
                          if (idbtrans._explicit && wasCommitted && idbtrans.mutatedParts) {
                            for (var _a3 = 0, _b = Object.values(tblCache.queries.query); _a3 < _b.length; _a3++) {
                              var entries = _b[_a3];
                              for (var _c = 0, _d = entries.slice(); _c < _d.length; _c++) {
                                var entry = _d[_c];
                                if (obsSetsOverlap(entry.obsSet, idbtrans.mutatedParts)) {
                                  delArrayItem(entries, entry);
                                  entry.subscribers.forEach(function(requery) {
                                    return affectedSubscribers_1.add(requery);
                                  });
                                }
                              }
                            }
                          } else if (ops.length > 0) {
                            tblCache.optimisticOps = tblCache.optimisticOps.filter(function(op) {
                              return op.trans !== idbtrans;
                            });
                            for (var _e = 0, _f = Object.values(tblCache.queries.query); _e < _f.length; _e++) {
                              var entries = _f[_e];
                              for (var _g = 0, _h = entries.slice(); _g < _h.length; _g++) {
                                var entry = _h[_g];
                                if (entry.res != null && idbtrans.mutatedParts) {
                                  if (wasCommitted && !entry.dirty) {
                                    var freezeResults = Object.isFrozen(entry.res);
                                    var modRes = applyOptimisticOps(entry.res, entry.req, ops, table, entry, freezeResults);
                                    if (entry.dirty) {
                                      delArrayItem(entries, entry);
                                      entry.subscribers.forEach(function(requery) {
                                        return affectedSubscribers_1.add(requery);
                                      });
                                    } else if (modRes !== entry.res) {
                                      entry.res = modRes;
                                      entry.promise = DexiePromise.resolve({ result: modRes });
                                    }
                                  } else {
                                    if (entry.dirty) {
                                      delArrayItem(entries, entry);
                                    }
                                    entry.subscribers.forEach(function(requery) {
                                      return affectedSubscribers_1.add(requery);
                                    });
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                      affectedSubscribers_1.forEach(function(requery) {
                        return requery();
                      });
                    }
                  };
                };
                idbtrans.addEventListener("abort", endTransaction(false), {
                  signal
                });
                idbtrans.addEventListener("error", endTransaction(false), {
                  signal
                });
                idbtrans.addEventListener("complete", endTransaction(true), {
                  signal
                });
              }
              return idbtrans;
            }, table: function(tableName) {
              var downTable = core.table(tableName);
              var primKey = downTable.schema.primaryKey;
              var tableMW = __assign2(__assign2({}, downTable), { mutate: function(req) {
                var trans = PSD.trans;
                if (primKey.outbound || trans.db._options.cache === "disabled" || trans.explicit || trans.idbtrans.mode !== "readwrite") {
                  return downTable.mutate(req);
                }
                var tblCache = cache["idb://".concat(dbName, "/").concat(tableName)];
                if (!tblCache)
                  return downTable.mutate(req);
                var promise = downTable.mutate(req);
                if ((req.type === "add" || req.type === "put") && (req.values.length >= 50 || getEffectiveKeys(primKey, req).some(function(key) {
                  return key == null;
                }))) {
                  promise.then(function(res) {
                    var reqWithResolvedKeys = __assign2(__assign2({}, req), { values: req.values.map(function(value, i) {
                      var _a3;
                      if (res.failures[i])
                        return value;
                      var valueWithKey = ((_a3 = primKey.keyPath) === null || _a3 === void 0 ? void 0 : _a3.includes(".")) ? deepClone(value) : __assign2({}, value);
                      setByKeyPath(valueWithKey, primKey.keyPath, res.results[i]);
                      return valueWithKey;
                    }) });
                    var adjustedReq = adjustOptimisticFromFailures(tblCache, reqWithResolvedKeys, res);
                    tblCache.optimisticOps.push(adjustedReq);
                    queueMicrotask(function() {
                      return req.mutatedParts && signalSubscribersLazily(req.mutatedParts);
                    });
                  });
                } else {
                  tblCache.optimisticOps.push(req);
                  req.mutatedParts && signalSubscribersLazily(req.mutatedParts);
                  promise.then(function(res) {
                    if (res.numFailures > 0) {
                      delArrayItem(tblCache.optimisticOps, req);
                      var adjustedReq = adjustOptimisticFromFailures(tblCache, req, res);
                      if (adjustedReq) {
                        tblCache.optimisticOps.push(adjustedReq);
                      }
                      req.mutatedParts && signalSubscribersLazily(req.mutatedParts);
                    }
                  });
                  promise.catch(function() {
                    delArrayItem(tblCache.optimisticOps, req);
                    req.mutatedParts && signalSubscribersLazily(req.mutatedParts);
                  });
                }
                return promise;
              }, query: function(req) {
                var _a3;
                if (!isCachableContext(PSD, downTable) || !isCachableRequest("query", req))
                  return downTable.query(req);
                var freezeResults = ((_a3 = PSD.trans) === null || _a3 === void 0 ? void 0 : _a3.db._options.cache) === "immutable";
                var _b = PSD, requery = _b.requery, signal = _b.signal;
                var _c = findCompatibleQuery(dbName, tableName, "query", req), cacheEntry = _c[0], exactMatch = _c[1], tblCache = _c[2], container = _c[3];
                if (cacheEntry && exactMatch) {
                  cacheEntry.obsSet = req.obsSet;
                } else {
                  var promise = downTable.query(req).then(function(res) {
                    var result2 = res.result;
                    if (cacheEntry)
                      cacheEntry.res = result2;
                    if (freezeResults) {
                      for (var i = 0, l = result2.length; i < l; ++i) {
                        Object.freeze(result2[i]);
                      }
                      Object.freeze(result2);
                    } else {
                      res.result = deepClone(result2);
                    }
                    return res;
                  }).catch(function(error) {
                    if (container && cacheEntry)
                      delArrayItem(container, cacheEntry);
                    return Promise.reject(error);
                  });
                  cacheEntry = {
                    obsSet: req.obsSet,
                    promise,
                    subscribers: /* @__PURE__ */ new Set(),
                    type: "query",
                    req,
                    dirty: false
                  };
                  if (container) {
                    container.push(cacheEntry);
                  } else {
                    container = [cacheEntry];
                    if (!tblCache) {
                      tblCache = cache["idb://".concat(dbName, "/").concat(tableName)] = {
                        queries: {
                          query: {},
                          count: {}
                        },
                        objs: /* @__PURE__ */ new Map(),
                        optimisticOps: [],
                        unsignaledParts: {}
                      };
                    }
                    tblCache.queries.query[req.query.index.name || ""] = container;
                  }
                }
                subscribeToCacheEntry(cacheEntry, container, requery, signal);
                return cacheEntry.promise.then(function(res) {
                  return {
                    result: applyOptimisticOps(res.result, req, tblCache === null || tblCache === void 0 ? void 0 : tblCache.optimisticOps, downTable, cacheEntry, freezeResults)
                  };
                });
              } });
              return tableMW;
            } });
            return coreMW;
          }
        };
        function vipify(target, vipDb) {
          return new Proxy(target, {
            get: function(target2, prop, receiver) {
              if (prop === "db")
                return vipDb;
              return Reflect.get(target2, prop, receiver);
            }
          });
        }
        var Dexie$1 = (function() {
          function Dexie3(name, options2) {
            var _this = this;
            this._middlewares = {};
            this.verno = 0;
            var deps = Dexie3.dependencies;
            this._options = options2 = __assign2({
              addons: Dexie3.addons,
              autoOpen: true,
              indexedDB: deps.indexedDB,
              IDBKeyRange: deps.IDBKeyRange,
              cache: "cloned"
            }, options2);
            this._deps = {
              indexedDB: options2.indexedDB,
              IDBKeyRange: options2.IDBKeyRange
            };
            var addons = options2.addons;
            this._dbSchema = {};
            this._versions = [];
            this._storeNames = [];
            this._allTables = {};
            this.idbdb = null;
            this._novip = this;
            var state = {
              dbOpenError: null,
              isBeingOpened: false,
              onReadyBeingFired: null,
              openComplete: false,
              dbReadyResolve: nop,
              dbReadyPromise: null,
              cancelOpen: nop,
              openCanceller: null,
              autoSchema: true,
              PR1398_maxLoop: 3,
              autoOpen: options2.autoOpen
            };
            state.dbReadyPromise = new DexiePromise(function(resolve) {
              state.dbReadyResolve = resolve;
            });
            state.openCanceller = new DexiePromise(function(_, reject) {
              state.cancelOpen = reject;
            });
            this._state = state;
            this.name = name;
            this.on = Events(this, "populate", "blocked", "versionchange", "close", { ready: [promisableChain, nop] });
            this.on.ready.subscribe = override(this.on.ready.subscribe, function(subscribe) {
              return function(subscriber, bSticky) {
                Dexie3.vip(function() {
                  var state2 = _this._state;
                  if (state2.openComplete) {
                    if (!state2.dbOpenError)
                      DexiePromise.resolve().then(subscriber);
                    if (bSticky)
                      subscribe(subscriber);
                  } else if (state2.onReadyBeingFired) {
                    state2.onReadyBeingFired.push(subscriber);
                    if (bSticky)
                      subscribe(subscriber);
                  } else {
                    subscribe(subscriber);
                    var db_1 = _this;
                    if (!bSticky)
                      subscribe(function unsubscribe() {
                        db_1.on.ready.unsubscribe(subscriber);
                        db_1.on.ready.unsubscribe(unsubscribe);
                      });
                  }
                });
              };
            });
            this.Collection = createCollectionConstructor(this);
            this.Table = createTableConstructor(this);
            this.Transaction = createTransactionConstructor(this);
            this.Version = createVersionConstructor(this);
            this.WhereClause = createWhereClauseConstructor(this);
            this.on("versionchange", function(ev) {
              if (ev.newVersion > 0)
                console.warn("Another connection wants to upgrade database '".concat(_this.name, "'. Closing db now to resume the upgrade."));
              else
                console.warn("Another connection wants to delete database '".concat(_this.name, "'. Closing db now to resume the delete request."));
              _this.close({ disableAutoOpen: false });
            });
            this.on("blocked", function(ev) {
              if (!ev.newVersion || ev.newVersion < ev.oldVersion)
                console.warn("Dexie.delete('".concat(_this.name, "') was blocked"));
              else
                console.warn("Upgrade '".concat(_this.name, "' blocked by other connection holding version ").concat(ev.oldVersion / 10));
            });
            this._maxKey = getMaxKey(options2.IDBKeyRange);
            this._createTransaction = function(mode, storeNames, dbschema, parentTransaction) {
              return new _this.Transaction(mode, storeNames, dbschema, _this._options.chromeTransactionDurability, parentTransaction);
            };
            this._fireOnBlocked = function(ev) {
              _this.on("blocked").fire(ev);
              connections.filter(function(c) {
                return c.name === _this.name && c !== _this && !c._state.vcFired;
              }).map(function(c) {
                return c.on("versionchange").fire(ev);
              });
            };
            this.use(cacheExistingValuesMiddleware);
            this.use(cacheMiddleware);
            this.use(observabilityMiddleware);
            this.use(virtualIndexMiddleware);
            this.use(hooksMiddleware);
            var vipDB = new Proxy(this, {
              get: function(_, prop, receiver) {
                if (prop === "_vip")
                  return true;
                if (prop === "table")
                  return function(tableName) {
                    return vipify(_this.table(tableName), vipDB);
                  };
                var rv = Reflect.get(_, prop, receiver);
                if (rv instanceof Table)
                  return vipify(rv, vipDB);
                if (prop === "tables")
                  return rv.map(function(t) {
                    return vipify(t, vipDB);
                  });
                if (prop === "_createTransaction")
                  return function() {
                    var tx = rv.apply(this, arguments);
                    return vipify(tx, vipDB);
                  };
                return rv;
              }
            });
            this.vip = vipDB;
            addons.forEach(function(addon) {
              return addon(_this);
            });
          }
          Dexie3.prototype.version = function(versionNumber) {
            if (isNaN(versionNumber) || versionNumber < 0.1)
              throw new exceptions.Type("Given version is not a positive number");
            versionNumber = Math.round(versionNumber * 10) / 10;
            if (this.idbdb || this._state.isBeingOpened)
              throw new exceptions.Schema("Cannot add version when database is open");
            this.verno = Math.max(this.verno, versionNumber);
            var versions = this._versions;
            var versionInstance = versions.filter(function(v) {
              return v._cfg.version === versionNumber;
            })[0];
            if (versionInstance)
              return versionInstance;
            versionInstance = new this.Version(versionNumber);
            versions.push(versionInstance);
            versions.sort(lowerVersionFirst);
            versionInstance.stores({});
            this._state.autoSchema = false;
            return versionInstance;
          };
          Dexie3.prototype._whenReady = function(fn2) {
            var _this = this;
            return this.idbdb && (this._state.openComplete || PSD.letThrough || this._vip) ? fn2() : new DexiePromise(function(resolve, reject) {
              if (_this._state.openComplete) {
                return reject(new exceptions.DatabaseClosed(_this._state.dbOpenError));
              }
              if (!_this._state.isBeingOpened) {
                if (!_this._state.autoOpen) {
                  reject(new exceptions.DatabaseClosed());
                  return;
                }
                _this.open().catch(nop);
              }
              _this._state.dbReadyPromise.then(resolve, reject);
            }).then(fn2);
          };
          Dexie3.prototype.use = function(_a3) {
            var stack = _a3.stack, create = _a3.create, level = _a3.level, name = _a3.name;
            if (name)
              this.unuse({ stack, name });
            var middlewares = this._middlewares[stack] || (this._middlewares[stack] = []);
            middlewares.push({ stack, create, level: level == null ? 10 : level, name });
            middlewares.sort(function(a, b) {
              return a.level - b.level;
            });
            return this;
          };
          Dexie3.prototype.unuse = function(_a3) {
            var stack = _a3.stack, name = _a3.name, create = _a3.create;
            if (stack && this._middlewares[stack]) {
              this._middlewares[stack] = this._middlewares[stack].filter(function(mw) {
                return create ? mw.create !== create : name ? mw.name !== name : false;
              });
            }
            return this;
          };
          Dexie3.prototype.open = function() {
            var _this = this;
            return usePSD(
              globalPSD,
              function() {
                return dexieOpen(_this);
              }
            );
          };
          Dexie3.prototype._close = function() {
            var state = this._state;
            var idx = connections.indexOf(this);
            if (idx >= 0)
              connections.splice(idx, 1);
            if (this.idbdb) {
              try {
                this.idbdb.close();
              } catch (e) {
              }
              this.idbdb = null;
            }
            if (!state.isBeingOpened) {
              state.dbReadyPromise = new DexiePromise(function(resolve) {
                state.dbReadyResolve = resolve;
              });
              state.openCanceller = new DexiePromise(function(_, reject) {
                state.cancelOpen = reject;
              });
            }
          };
          Dexie3.prototype.close = function(_a3) {
            var _b = _a3 === void 0 ? { disableAutoOpen: true } : _a3, disableAutoOpen = _b.disableAutoOpen;
            var state = this._state;
            if (disableAutoOpen) {
              if (state.isBeingOpened) {
                state.cancelOpen(new exceptions.DatabaseClosed());
              }
              this._close();
              state.autoOpen = false;
              state.dbOpenError = new exceptions.DatabaseClosed();
            } else {
              this._close();
              state.autoOpen = this._options.autoOpen || state.isBeingOpened;
              state.openComplete = false;
              state.dbOpenError = null;
            }
          };
          Dexie3.prototype.delete = function(closeOptions) {
            var _this = this;
            if (closeOptions === void 0) {
              closeOptions = { disableAutoOpen: true };
            }
            var hasInvalidArguments = arguments.length > 0 && typeof arguments[0] !== "object";
            var state = this._state;
            return new DexiePromise(function(resolve, reject) {
              var doDelete = function() {
                _this.close(closeOptions);
                var req = _this._deps.indexedDB.deleteDatabase(_this.name);
                req.onsuccess = wrap4(function() {
                  _onDatabaseDeleted(_this._deps, _this.name);
                  resolve();
                });
                req.onerror = eventRejectHandler(reject);
                req.onblocked = _this._fireOnBlocked;
              };
              if (hasInvalidArguments)
                throw new exceptions.InvalidArgument("Invalid closeOptions argument to db.delete()");
              if (state.isBeingOpened) {
                state.dbReadyPromise.then(doDelete);
              } else {
                doDelete();
              }
            });
          };
          Dexie3.prototype.backendDB = function() {
            return this.idbdb;
          };
          Dexie3.prototype.isOpen = function() {
            return this.idbdb !== null;
          };
          Dexie3.prototype.hasBeenClosed = function() {
            var dbOpenError = this._state.dbOpenError;
            return dbOpenError && dbOpenError.name === "DatabaseClosed";
          };
          Dexie3.prototype.hasFailed = function() {
            return this._state.dbOpenError !== null;
          };
          Dexie3.prototype.dynamicallyOpened = function() {
            return this._state.autoSchema;
          };
          Object.defineProperty(Dexie3.prototype, "tables", {
            get: function() {
              var _this = this;
              return keys(this._allTables).map(function(name) {
                return _this._allTables[name];
              });
            },
            enumerable: false,
            configurable: true
          });
          Dexie3.prototype.transaction = function() {
            var args = extractTransactionArgs.apply(this, arguments);
            return this._transaction.apply(this, args);
          };
          Dexie3.prototype._transaction = function(mode, tables, scopeFunc) {
            var _this = this;
            var parentTransaction = PSD.trans;
            if (!parentTransaction || parentTransaction.db !== this || mode.indexOf("!") !== -1)
              parentTransaction = null;
            var onlyIfCompatible = mode.indexOf("?") !== -1;
            mode = mode.replace("!", "").replace("?", "");
            var idbMode, storeNames;
            try {
              storeNames = tables.map(function(table) {
                var storeName = table instanceof _this.Table ? table.name : table;
                if (typeof storeName !== "string")
                  throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");
                return storeName;
              });
              if (mode == "r" || mode === READONLY)
                idbMode = READONLY;
              else if (mode == "rw" || mode == READWRITE)
                idbMode = READWRITE;
              else
                throw new exceptions.InvalidArgument("Invalid transaction mode: " + mode);
              if (parentTransaction) {
                if (parentTransaction.mode === READONLY && idbMode === READWRITE) {
                  if (onlyIfCompatible) {
                    parentTransaction = null;
                  } else
                    throw new exceptions.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");
                }
                if (parentTransaction) {
                  storeNames.forEach(function(storeName) {
                    if (parentTransaction && parentTransaction.storeNames.indexOf(storeName) === -1) {
                      if (onlyIfCompatible) {
                        parentTransaction = null;
                      } else
                        throw new exceptions.SubTransaction("Table " + storeName + " not included in parent transaction.");
                    }
                  });
                }
                if (onlyIfCompatible && parentTransaction && !parentTransaction.active) {
                  parentTransaction = null;
                }
              }
            } catch (e) {
              return parentTransaction ? parentTransaction._promise(null, function(_, reject) {
                reject(e);
              }) : rejection(e);
            }
            var enterTransaction = enterTransactionScope.bind(null, this, idbMode, storeNames, parentTransaction, scopeFunc);
            return parentTransaction ? parentTransaction._promise(idbMode, enterTransaction, "lock") : PSD.trans ? usePSD(PSD.transless, function() {
              return _this._whenReady(enterTransaction);
            }) : this._whenReady(enterTransaction);
          };
          Dexie3.prototype.table = function(tableName) {
            if (!hasOwn3(this._allTables, tableName)) {
              throw new exceptions.InvalidTable("Table ".concat(tableName, " does not exist"));
            }
            return this._allTables[tableName];
          };
          return Dexie3;
        })();
        var symbolObservable = typeof Symbol !== "undefined" && "observable" in Symbol ? Symbol.observable : "@@observable";
        var Observable2 = (function() {
          function Observable3(subscribe) {
            this._subscribe = subscribe;
          }
          Observable3.prototype.subscribe = function(x, error, complete) {
            return this._subscribe(!x || typeof x === "function" ? { next: x, error, complete } : x);
          };
          Observable3.prototype[symbolObservable] = function() {
            return this;
          };
          return Observable3;
        })();
        var domDeps;
        try {
          domDeps = {
            indexedDB: _global.indexedDB || _global.mozIndexedDB || _global.webkitIndexedDB || _global.msIndexedDB,
            IDBKeyRange: _global.IDBKeyRange || _global.webkitIDBKeyRange
          };
        } catch (e) {
          domDeps = { indexedDB: null, IDBKeyRange: null };
        }
        function liveQuery2(querier) {
          var hasValue = false;
          var currentValue;
          var observable = new Observable2(function(observer) {
            var scopeFuncIsAsync = isAsyncFunction(querier);
            function execute2(ctx) {
              var wasRootExec = beginMicroTickScope();
              try {
                if (scopeFuncIsAsync) {
                  incrementExpectedAwaits();
                }
                var rv = newScope(querier, ctx);
                if (scopeFuncIsAsync) {
                  rv = rv.finally(decrementExpectedAwaits);
                }
                return rv;
              } finally {
                wasRootExec && endMicroTickScope();
              }
            }
            var closed = false;
            var abortController;
            var accumMuts = {};
            var currentObs = {};
            var subscription = {
              get closed() {
                return closed;
              },
              unsubscribe: function() {
                if (closed)
                  return;
                closed = true;
                if (abortController)
                  abortController.abort();
                if (startedListening)
                  globalEvents.storagemutated.unsubscribe(mutationListener);
              }
            };
            observer.start && observer.start(subscription);
            var startedListening = false;
            var doQuery = function() {
              return execInGlobalContext(_doQuery);
            };
            function shouldNotify() {
              return obsSetsOverlap(currentObs, accumMuts);
            }
            var mutationListener = function(parts) {
              extendObservabilitySet(accumMuts, parts);
              if (shouldNotify()) {
                doQuery();
              }
            };
            var _doQuery = function() {
              if (closed || !domDeps.indexedDB) {
                return;
              }
              accumMuts = {};
              var subscr = {};
              if (abortController)
                abortController.abort();
              abortController = new AbortController();
              var ctx = {
                subscr,
                signal: abortController.signal,
                requery: doQuery,
                querier,
                trans: null
              };
              var ret = execute2(ctx);
              Promise.resolve(ret).then(function(result2) {
                hasValue = true;
                currentValue = result2;
                if (closed || ctx.signal.aborted) {
                  return;
                }
                accumMuts = {};
                currentObs = subscr;
                if (!objectIsEmpty(currentObs) && !startedListening) {
                  globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, mutationListener);
                  startedListening = true;
                }
                execInGlobalContext(function() {
                  return !closed && observer.next && observer.next(result2);
                });
              }, function(err) {
                hasValue = false;
                if (!["DatabaseClosedError", "AbortError"].includes(err === null || err === void 0 ? void 0 : err.name)) {
                  if (!closed)
                    execInGlobalContext(function() {
                      if (closed)
                        return;
                      observer.error && observer.error(err);
                    });
                }
              });
            };
            setTimeout(doQuery, 0);
            return subscription;
          });
          observable.hasValue = function() {
            return hasValue;
          };
          observable.getValue = function() {
            return currentValue;
          };
          return observable;
        }
        var Dexie2 = Dexie$1;
        props(Dexie2, __assign2(__assign2({}, fullNameExceptions), {
          delete: function(databaseName) {
            var db2 = new Dexie2(databaseName, { addons: [] });
            return db2.delete();
          },
          exists: function(name) {
            return new Dexie2(name, { addons: [] }).open().then(function(db2) {
              db2.close();
              return true;
            }).catch("NoSuchDatabaseError", function() {
              return false;
            });
          },
          getDatabaseNames: function(cb) {
            try {
              return getDatabaseNames(Dexie2.dependencies).then(cb);
            } catch (_a3) {
              return rejection(new exceptions.MissingAPI());
            }
          },
          defineClass: function() {
            function Class(content) {
              extend(this, content);
            }
            return Class;
          },
          ignoreTransaction: function(scopeFunc) {
            return PSD.trans ? usePSD(PSD.transless, scopeFunc) : scopeFunc();
          },
          vip,
          async: function(generatorFn) {
            return function() {
              try {
                var rv = awaitIterator(generatorFn.apply(this, arguments));
                if (!rv || typeof rv.then !== "function")
                  return DexiePromise.resolve(rv);
                return rv;
              } catch (e) {
                return rejection(e);
              }
            };
          },
          spawn: function(generatorFn, args, thiz) {
            try {
              var rv = awaitIterator(generatorFn.apply(thiz, args || []));
              if (!rv || typeof rv.then !== "function")
                return DexiePromise.resolve(rv);
              return rv;
            } catch (e) {
              return rejection(e);
            }
          },
          currentTransaction: {
            get: function() {
              return PSD.trans || null;
            }
          },
          waitFor: function(promiseOrFunction, optionalTimeout) {
            var promise = DexiePromise.resolve(typeof promiseOrFunction === "function" ? Dexie2.ignoreTransaction(promiseOrFunction) : promiseOrFunction).timeout(optionalTimeout || 6e4);
            return PSD.trans ? PSD.trans.waitFor(promise) : promise;
          },
          Promise: DexiePromise,
          debug: {
            get: function() {
              return debug;
            },
            set: function(value) {
              setDebug(value);
            }
          },
          derive,
          extend,
          props,
          override,
          Events,
          on: globalEvents,
          liveQuery: liveQuery2,
          extendObservabilitySet,
          getByKeyPath,
          setByKeyPath,
          delByKeyPath,
          shallowClone,
          deepClone,
          getObjectDiff,
          cmp: cmp2,
          asap: asap$1,
          minKey,
          addons: [],
          connections,
          errnames,
          dependencies: domDeps,
          cache,
          semVer: DEXIE_VERSION,
          version: DEXIE_VERSION.split(".").map(function(n) {
            return parseInt(n);
          }).reduce(function(p, c, i) {
            return p + c / Math.pow(10, i * 2);
          })
        }));
        Dexie2.maxKey = getMaxKey(Dexie2.dependencies.IDBKeyRange);
        if (typeof dispatchEvent !== "undefined" && typeof addEventListener !== "undefined") {
          globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, function(updatedParts) {
            if (!propagatingLocally) {
              var event_1;
              event_1 = new CustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, {
                detail: updatedParts
              });
              propagatingLocally = true;
              dispatchEvent(event_1);
              propagatingLocally = false;
            }
          });
          addEventListener(STORAGE_MUTATED_DOM_EVENT_NAME, function(_a3) {
            var detail = _a3.detail;
            if (!propagatingLocally) {
              propagateLocally(detail);
            }
          });
        }
        function propagateLocally(updateParts) {
          var wasMe = propagatingLocally;
          try {
            propagatingLocally = true;
            globalEvents.storagemutated.fire(updateParts);
            signalSubscribersNow(updateParts, true);
          } finally {
            propagatingLocally = wasMe;
          }
        }
        var propagatingLocally = false;
        var bc;
        var createBC = function() {
        };
        if (typeof BroadcastChannel !== "undefined") {
          createBC = function() {
            bc = new BroadcastChannel(STORAGE_MUTATED_DOM_EVENT_NAME);
            bc.onmessage = function(ev) {
              return ev.data && propagateLocally(ev.data);
            };
          };
          createBC();
          if (typeof bc.unref === "function") {
            bc.unref();
          }
          globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, function(changedParts) {
            if (!propagatingLocally) {
              bc.postMessage(changedParts);
            }
          });
        }
        if (typeof addEventListener !== "undefined") {
          addEventListener("pagehide", function(event) {
            if (!Dexie$1.disableBfCache && event.persisted) {
              if (debug)
                console.debug("Dexie: handling persisted pagehide");
              bc === null || bc === void 0 ? void 0 : bc.close();
              for (var _i = 0, connections_1 = connections; _i < connections_1.length; _i++) {
                var db2 = connections_1[_i];
                db2.close({ disableAutoOpen: false });
              }
            }
          });
          addEventListener("pageshow", function(event) {
            if (!Dexie$1.disableBfCache && event.persisted) {
              if (debug)
                console.debug("Dexie: handling persisted pageshow");
              createBC();
              propagateLocally({ all: new RangeSet2(-Infinity, [[]]) });
            }
          });
        }
        function add2(value) {
          return new PropModification2({ add: value });
        }
        function remove2(value) {
          return new PropModification2({ remove: value });
        }
        function replacePrefix2(a, b) {
          return new PropModification2({ replacePrefix: [a, b] });
        }
        DexiePromise.rejectionMapper = mapError;
        setDebug(debug);
        var namedExports = /* @__PURE__ */ Object.freeze({
          __proto__: null,
          Dexie: Dexie$1,
          liveQuery: liveQuery2,
          Entity: Entity2,
          cmp: cmp2,
          PropModification: PropModification2,
          replacePrefix: replacePrefix2,
          add: add2,
          remove: remove2,
          "default": Dexie$1,
          RangeSet: RangeSet2,
          mergeRanges: mergeRanges2,
          rangesOverlap: rangesOverlap2
        });
        __assign2(Dexie$1, namedExports, { default: Dexie$1 });
        return Dexie$1;
      }));
    }
  });

  // node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js
  function _arrayWithHoles(r) {
    if (Array.isArray(r)) return r;
  }
  var init_arrayWithHoles = __esm({
    "node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js"() {
    }
  });

  // node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js
  function _iterableToArrayLimit(r, l) {
    var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
    if (null != t) {
      var e, n, i, u, a = [], f = true, o = false;
      try {
        if (i = (t = t.call(r)).next, 0 === l) {
          if (Object(t) !== t) return;
          f = false;
        } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
      } catch (r2) {
        o = true, n = r2;
      } finally {
        try {
          if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
        } finally {
          if (o) throw n;
        }
      }
      return a;
    }
  }
  var init_iterableToArrayLimit = __esm({
    "node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js"() {
    }
  });

  // node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js
  function _arrayLikeToArray(r, a) {
    (null == a || a > r.length) && (a = r.length);
    for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
    return n;
  }
  var init_arrayLikeToArray = __esm({
    "node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js"() {
    }
  });

  // node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js
  function _unsupportedIterableToArray(r, a) {
    if (r) {
      if ("string" == typeof r) return _arrayLikeToArray(r, a);
      var t = {}.toString.call(r).slice(8, -1);
      return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
    }
  }
  var init_unsupportedIterableToArray = __esm({
    "node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js"() {
      init_arrayLikeToArray();
    }
  });

  // node_modules/@babel/runtime/helpers/esm/nonIterableRest.js
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var init_nonIterableRest = __esm({
    "node_modules/@babel/runtime/helpers/esm/nonIterableRest.js"() {
    }
  });

  // node_modules/@babel/runtime/helpers/esm/slicedToArray.js
  function _slicedToArray(r, e) {
    return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();
  }
  var init_slicedToArray = __esm({
    "node_modules/@babel/runtime/helpers/esm/slicedToArray.js"() {
      init_arrayWithHoles();
      init_iterableToArrayLimit();
      init_unsupportedIterableToArray();
      init_nonIterableRest();
    }
  });

  // node_modules/@babel/runtime/helpers/esm/typeof.js
  function _typeof(o) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
      return typeof o2;
    } : function(o2) {
      return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
    }, _typeof(o);
  }
  var init_typeof = __esm({
    "node_modules/@babel/runtime/helpers/esm/typeof.js"() {
    }
  });

  // node_modules/@babel/runtime/helpers/esm/toPrimitive.js
  function toPrimitive(t, r) {
    if ("object" != _typeof(t) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r || "default");
      if ("object" != _typeof(i)) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
  }
  var init_toPrimitive = __esm({
    "node_modules/@babel/runtime/helpers/esm/toPrimitive.js"() {
      init_typeof();
    }
  });

  // node_modules/@babel/runtime/helpers/esm/toPropertyKey.js
  function toPropertyKey(t) {
    var i = toPrimitive(t, "string");
    return "symbol" == _typeof(i) ? i : i + "";
  }
  var init_toPropertyKey = __esm({
    "node_modules/@babel/runtime/helpers/esm/toPropertyKey.js"() {
      init_typeof();
      init_toPrimitive();
    }
  });

  // node_modules/@babel/runtime/helpers/esm/defineProperty.js
  function _defineProperty(e, r, t) {
    return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
      value: t,
      enumerable: true,
      configurable: true,
      writable: true
    }) : e[r] = t, e;
  }
  var init_defineProperty = __esm({
    "node_modules/@babel/runtime/helpers/esm/defineProperty.js"() {
      init_toPropertyKey();
    }
  });

  // node_modules/bind-event-listener/dist/bind.js
  var require_bind = __commonJS({
    "node_modules/bind-event-listener/dist/bind.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.bind = void 0;
      function bind13(target, _a2) {
        var type = _a2.type, listener = _a2.listener, options2 = _a2.options;
        target.addEventListener(type, listener, options2);
        return function unbind() {
          target.removeEventListener(type, listener, options2);
        };
      }
      exports.bind = bind13;
    }
  });

  // node_modules/bind-event-listener/dist/bind-all.js
  var require_bind_all = __commonJS({
    "node_modules/bind-event-listener/dist/bind-all.js"(exports) {
      "use strict";
      var __assign2 = exports && exports.__assign || function() {
        __assign2 = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
          }
          return t;
        };
        return __assign2.apply(this, arguments);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.bindAll = void 0;
      var bind_1 = require_bind();
      function toOptions(value) {
        if (typeof value === "undefined") {
          return void 0;
        }
        if (typeof value === "boolean") {
          return {
            capture: value
          };
        }
        return value;
      }
      function getBinding(original, sharedOptions) {
        if (sharedOptions == null) {
          return original;
        }
        var binding = __assign2(__assign2({}, original), { options: __assign2(__assign2({}, toOptions(sharedOptions)), toOptions(original.options)) });
        return binding;
      }
      function bindAll11(target, bindings, sharedOptions) {
        var unbinds = bindings.map(function(original) {
          var binding = getBinding(original, sharedOptions);
          return (0, bind_1.bind)(target, binding);
        });
        return function unbindAll() {
          unbinds.forEach(function(unbind) {
            return unbind();
          });
        };
      }
      exports.bindAll = bindAll11;
    }
  });

  // node_modules/bind-event-listener/dist/index.js
  var require_dist = __commonJS({
    "node_modules/bind-event-listener/dist/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.bindAll = exports.bind = void 0;
      var bind_1 = require_bind();
      Object.defineProperty(exports, "bind", { enumerable: true, get: function() {
        return bind_1.bind;
      } });
      var bind_all_1 = require_bind_all();
      Object.defineProperty(exports, "bindAll", { enumerable: true, get: function() {
        return bind_all_1.bindAll;
      } });
    }
  });

  // node_modules/@babel/runtime/helpers/esm/classCallCheck.js
  function _classCallCheck(a, n) {
    if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
  }
  var init_classCallCheck = __esm({
    "node_modules/@babel/runtime/helpers/esm/classCallCheck.js"() {
    }
  });

  // node_modules/@babel/runtime/helpers/esm/createClass.js
  function _defineProperties(e, r) {
    for (var t = 0; t < r.length; t++) {
      var o = r[t];
      o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, toPropertyKey(o.key), o);
    }
  }
  function _createClass(e, r, t) {
    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
      writable: false
    }), e;
  }
  var init_createClass = __esm({
    "node_modules/@babel/runtime/helpers/esm/createClass.js"() {
      init_toPropertyKey();
    }
  });

  // node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js
  function _arrayWithoutHoles(r) {
    if (Array.isArray(r)) return _arrayLikeToArray(r);
  }
  var init_arrayWithoutHoles = __esm({
    "node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js"() {
      init_arrayLikeToArray();
    }
  });

  // node_modules/@babel/runtime/helpers/esm/iterableToArray.js
  function _iterableToArray(r) {
    if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
  }
  var init_iterableToArray = __esm({
    "node_modules/@babel/runtime/helpers/esm/iterableToArray.js"() {
    }
  });

  // node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js
  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var init_nonIterableSpread = __esm({
    "node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js"() {
    }
  });

  // node_modules/@babel/runtime/helpers/esm/toConsumableArray.js
  function _toConsumableArray(r) {
    return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();
  }
  var init_toConsumableArray = __esm({
    "node_modules/@babel/runtime/helpers/esm/toConsumableArray.js"() {
      init_arrayWithoutHoles();
      init_iterableToArray();
      init_unsupportedIterableToArray();
      init_nonIterableSpread();
    }
  });

  // node_modules/@babel/runtime/helpers/interopRequireDefault.js
  var require_interopRequireDefault = __commonJS({
    "node_modules/@babel/runtime/helpers/interopRequireDefault.js"(exports, module2) {
      function _interopRequireDefault(e) {
        return e && e.__esModule ? e : {
          "default": e
        };
      }
      module2.exports = _interopRequireDefault, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/typeof.js
  var require_typeof = __commonJS({
    "node_modules/@babel/runtime/helpers/typeof.js"(exports, module2) {
      function _typeof2(o) {
        "@babel/helpers - typeof";
        return module2.exports = _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
          return typeof o2;
        } : function(o2) {
          return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
        }, module2.exports.__esModule = true, module2.exports["default"] = module2.exports, _typeof2(o);
      }
      module2.exports = _typeof2, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/classCallCheck.js
  var require_classCallCheck = __commonJS({
    "node_modules/@babel/runtime/helpers/classCallCheck.js"(exports, module2) {
      function _classCallCheck2(a, n) {
        if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
      }
      module2.exports = _classCallCheck2, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/toPrimitive.js
  var require_toPrimitive = __commonJS({
    "node_modules/@babel/runtime/helpers/toPrimitive.js"(exports, module2) {
      var _typeof2 = require_typeof()["default"];
      function toPrimitive2(t, r) {
        if ("object" != _typeof2(t) || !t) return t;
        var e = t[Symbol.toPrimitive];
        if (void 0 !== e) {
          var i = e.call(t, r || "default");
          if ("object" != _typeof2(i)) return i;
          throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return ("string" === r ? String : Number)(t);
      }
      module2.exports = toPrimitive2, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/toPropertyKey.js
  var require_toPropertyKey = __commonJS({
    "node_modules/@babel/runtime/helpers/toPropertyKey.js"(exports, module2) {
      var _typeof2 = require_typeof()["default"];
      var toPrimitive2 = require_toPrimitive();
      function toPropertyKey2(t) {
        var i = toPrimitive2(t, "string");
        return "symbol" == _typeof2(i) ? i : i + "";
      }
      module2.exports = toPropertyKey2, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/createClass.js
  var require_createClass = __commonJS({
    "node_modules/@babel/runtime/helpers/createClass.js"(exports, module2) {
      var toPropertyKey2 = require_toPropertyKey();
      function _defineProperties3(e, r) {
        for (var t = 0; t < r.length; t++) {
          var o = r[t];
          o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, toPropertyKey2(o.key), o);
        }
      }
      function _createClass3(e, r, t) {
        return r && _defineProperties3(e.prototype, r), t && _defineProperties3(e, t), Object.defineProperty(e, "prototype", {
          writable: false
        }), e;
      }
      module2.exports = _createClass3, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/defineProperty.js
  var require_defineProperty = __commonJS({
    "node_modules/@babel/runtime/helpers/defineProperty.js"(exports, module2) {
      var toPropertyKey2 = require_toPropertyKey();
      function _defineProperty2(e, r, t) {
        return (r = toPropertyKey2(r)) in e ? Object.defineProperty(e, r, {
          value: t,
          enumerable: true,
          configurable: true,
          writable: true
        }) : e[r] = t, e;
      }
      module2.exports = _defineProperty2, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js
  var require_objectWithoutPropertiesLoose = __commonJS({
    "node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js"(exports, module2) {
      function _objectWithoutPropertiesLoose2(r, e) {
        if (null == r) return {};
        var t = {};
        for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
          if (-1 !== e.indexOf(n)) continue;
          t[n] = r[n];
        }
        return t;
      }
      module2.exports = _objectWithoutPropertiesLoose2, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/objectWithoutProperties.js
  var require_objectWithoutProperties = __commonJS({
    "node_modules/@babel/runtime/helpers/objectWithoutProperties.js"(exports, module2) {
      var objectWithoutPropertiesLoose = require_objectWithoutPropertiesLoose();
      function _objectWithoutProperties2(e, t) {
        if (null == e) return {};
        var o, r, i = objectWithoutPropertiesLoose(e, t);
        if (Object.getOwnPropertySymbols) {
          var n = Object.getOwnPropertySymbols(e);
          for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
        }
        return i;
      }
      module2.exports = _objectWithoutProperties2, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/OverloadYield.js
  var require_OverloadYield = __commonJS({
    "node_modules/@babel/runtime/helpers/OverloadYield.js"(exports, module2) {
      function _OverloadYield(e, d) {
        this.v = e, this.k = d;
      }
      module2.exports = _OverloadYield, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/regeneratorDefine.js
  var require_regeneratorDefine = __commonJS({
    "node_modules/@babel/runtime/helpers/regeneratorDefine.js"(exports, module2) {
      function _regeneratorDefine(e, r, n, t) {
        var i = Object.defineProperty;
        try {
          i({}, "", {});
        } catch (e2) {
          i = 0;
        }
        module2.exports = _regeneratorDefine = function regeneratorDefine(e2, r2, n2, t2) {
          function o(r3, n3) {
            _regeneratorDefine(e2, r3, function(e3) {
              return this._invoke(r3, n3, e3);
            });
          }
          r2 ? i ? i(e2, r2, {
            value: n2,
            enumerable: !t2,
            configurable: !t2,
            writable: !t2
          }) : e2[r2] = n2 : (o("next", 0), o("throw", 1), o("return", 2));
        }, module2.exports.__esModule = true, module2.exports["default"] = module2.exports, _regeneratorDefine(e, r, n, t);
      }
      module2.exports = _regeneratorDefine, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/regenerator.js
  var require_regenerator = __commonJS({
    "node_modules/@babel/runtime/helpers/regenerator.js"(exports, module2) {
      var regeneratorDefine = require_regeneratorDefine();
      function _regenerator() {
        var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag";
        function i(r2, n2, o2, i2) {
          var c2 = n2 && n2.prototype instanceof Generator ? n2 : Generator, u2 = Object.create(c2.prototype);
          return regeneratorDefine(u2, "_invoke", (function(r3, n3, o3) {
            var i3, c3, u3, f2 = 0, p = o3 || [], y = false, G = {
              p: 0,
              n: 0,
              v: e,
              a: d,
              f: d.bind(e, 4),
              d: function d2(t2, r4) {
                return i3 = t2, c3 = 0, u3 = e, G.n = r4, a;
              }
            };
            function d(r4, n4) {
              for (c3 = r4, u3 = n4, t = 0; !y && f2 && !o4 && t < p.length; t++) {
                var o4, i4 = p[t], d2 = G.p, l = i4[2];
                r4 > 3 ? (o4 = l === n4) && (u3 = i4[(c3 = i4[4]) ? 5 : (c3 = 3, 3)], i4[4] = i4[5] = e) : i4[0] <= d2 && ((o4 = r4 < 2 && d2 < i4[1]) ? (c3 = 0, G.v = n4, G.n = i4[1]) : d2 < l && (o4 = r4 < 3 || i4[0] > n4 || n4 > l) && (i4[4] = r4, i4[5] = n4, G.n = l, c3 = 0));
              }
              if (o4 || r4 > 1) return a;
              throw y = true, n4;
            }
            return function(o4, p2, l) {
              if (f2 > 1) throw TypeError("Generator is already running");
              for (y && 1 === p2 && d(p2, l), c3 = p2, u3 = l; (t = c3 < 2 ? e : u3) || !y; ) {
                i3 || (c3 ? c3 < 3 ? (c3 > 1 && (G.n = -1), d(c3, u3)) : G.n = u3 : G.v = u3);
                try {
                  if (f2 = 2, i3) {
                    if (c3 || (o4 = "next"), t = i3[o4]) {
                      if (!(t = t.call(i3, u3))) throw TypeError("iterator result is not an object");
                      if (!t.done) return t;
                      u3 = t.value, c3 < 2 && (c3 = 0);
                    } else 1 === c3 && (t = i3["return"]) && t.call(i3), c3 < 2 && (u3 = TypeError("The iterator does not provide a '" + o4 + "' method"), c3 = 1);
                    i3 = e;
                  } else if ((t = (y = G.n < 0) ? u3 : r3.call(n3, G)) !== a) break;
                } catch (t2) {
                  i3 = e, c3 = 1, u3 = t2;
                } finally {
                  f2 = 1;
                }
              }
              return {
                value: t,
                done: y
              };
            };
          })(r2, o2, i2), true), u2;
        }
        var a = {};
        function Generator() {
        }
        function GeneratorFunction() {
        }
        function GeneratorFunctionPrototype() {
        }
        t = Object.getPrototypeOf;
        var c = [][n] ? t(t([][n]())) : (regeneratorDefine(t = {}, n, function() {
          return this;
        }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c);
        function f(e2) {
          return Object.setPrototypeOf ? Object.setPrototypeOf(e2, GeneratorFunctionPrototype) : (e2.__proto__ = GeneratorFunctionPrototype, regeneratorDefine(e2, o, "GeneratorFunction")), e2.prototype = Object.create(u), e2;
        }
        return GeneratorFunction.prototype = GeneratorFunctionPrototype, regeneratorDefine(u, "constructor", GeneratorFunctionPrototype), regeneratorDefine(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", regeneratorDefine(GeneratorFunctionPrototype, o, "GeneratorFunction"), regeneratorDefine(u), regeneratorDefine(u, o, "Generator"), regeneratorDefine(u, n, function() {
          return this;
        }), regeneratorDefine(u, "toString", function() {
          return "[object Generator]";
        }), (module2.exports = _regenerator = function _regenerator2() {
          return {
            w: i,
            m: f
          };
        }, module2.exports.__esModule = true, module2.exports["default"] = module2.exports)();
      }
      module2.exports = _regenerator, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/regeneratorAsyncIterator.js
  var require_regeneratorAsyncIterator = __commonJS({
    "node_modules/@babel/runtime/helpers/regeneratorAsyncIterator.js"(exports, module2) {
      var OverloadYield = require_OverloadYield();
      var regeneratorDefine = require_regeneratorDefine();
      function AsyncIterator2(t, e) {
        function n(r2, o, i, f) {
          try {
            var c = t[r2](o), u = c.value;
            return u instanceof OverloadYield ? e.resolve(u.v).then(function(t2) {
              n("next", t2, i, f);
            }, function(t2) {
              n("throw", t2, i, f);
            }) : e.resolve(u).then(function(t2) {
              c.value = t2, i(c);
            }, function(t2) {
              return n("throw", t2, i, f);
            });
          } catch (t2) {
            f(t2);
          }
        }
        var r;
        this.next || (regeneratorDefine(AsyncIterator2.prototype), regeneratorDefine(AsyncIterator2.prototype, "function" == typeof Symbol && Symbol.asyncIterator || "@asyncIterator", function() {
          return this;
        })), regeneratorDefine(this, "_invoke", function(t2, o, i) {
          function f() {
            return new e(function(e2, r2) {
              n(t2, i, e2, r2);
            });
          }
          return r = r ? r.then(f, f) : f();
        }, true);
      }
      module2.exports = AsyncIterator2, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/regeneratorAsyncGen.js
  var require_regeneratorAsyncGen = __commonJS({
    "node_modules/@babel/runtime/helpers/regeneratorAsyncGen.js"(exports, module2) {
      var regenerator = require_regenerator();
      var regeneratorAsyncIterator = require_regeneratorAsyncIterator();
      function _regeneratorAsyncGen(r, e, t, o, n) {
        return new regeneratorAsyncIterator(regenerator().w(r, e, t, o), n || Promise);
      }
      module2.exports = _regeneratorAsyncGen, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/regeneratorAsync.js
  var require_regeneratorAsync = __commonJS({
    "node_modules/@babel/runtime/helpers/regeneratorAsync.js"(exports, module2) {
      var regeneratorAsyncGen = require_regeneratorAsyncGen();
      function _regeneratorAsync(n, e, r, t, o) {
        var a = regeneratorAsyncGen(n, e, r, t, o);
        return a.next().then(function(n2) {
          return n2.done ? n2.value : a.next();
        });
      }
      module2.exports = _regeneratorAsync, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/regeneratorKeys.js
  var require_regeneratorKeys = __commonJS({
    "node_modules/@babel/runtime/helpers/regeneratorKeys.js"(exports, module2) {
      function _regeneratorKeys(e) {
        var n = Object(e), r = [];
        for (var t in n) r.unshift(t);
        return function e2() {
          for (; r.length; ) if ((t = r.pop()) in n) return e2.value = t, e2.done = false, e2;
          return e2.done = true, e2;
        };
      }
      module2.exports = _regeneratorKeys, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/regeneratorValues.js
  var require_regeneratorValues = __commonJS({
    "node_modules/@babel/runtime/helpers/regeneratorValues.js"(exports, module2) {
      var _typeof2 = require_typeof()["default"];
      function _regeneratorValues(e) {
        if (null != e) {
          var t = e["function" == typeof Symbol && Symbol.iterator || "@@iterator"], r = 0;
          if (t) return t.call(e);
          if ("function" == typeof e.next) return e;
          if (!isNaN(e.length)) return {
            next: function next2() {
              return e && r >= e.length && (e = void 0), {
                value: e && e[r++],
                done: !e
              };
            }
          };
        }
        throw new TypeError(_typeof2(e) + " is not iterable");
      }
      module2.exports = _regeneratorValues, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/regeneratorRuntime.js
  var require_regeneratorRuntime = __commonJS({
    "node_modules/@babel/runtime/helpers/regeneratorRuntime.js"(exports, module2) {
      var OverloadYield = require_OverloadYield();
      var regenerator = require_regenerator();
      var regeneratorAsync = require_regeneratorAsync();
      var regeneratorAsyncGen = require_regeneratorAsyncGen();
      var regeneratorAsyncIterator = require_regeneratorAsyncIterator();
      var regeneratorKeys = require_regeneratorKeys();
      var regeneratorValues = require_regeneratorValues();
      function _regeneratorRuntime() {
        "use strict";
        var r = regenerator(), e = r.m(_regeneratorRuntime), t = (Object.getPrototypeOf ? Object.getPrototypeOf(e) : e.__proto__).constructor;
        function n(r2) {
          var e2 = "function" == typeof r2 && r2.constructor;
          return !!e2 && (e2 === t || "GeneratorFunction" === (e2.displayName || e2.name));
        }
        var o = {
          "throw": 1,
          "return": 2,
          "break": 3,
          "continue": 3
        };
        function a(r2) {
          var e2, t2;
          return function(n2) {
            e2 || (e2 = {
              stop: function stop() {
                return t2(n2.a, 2);
              },
              "catch": function _catch() {
                return n2.v;
              },
              abrupt: function abrupt(r3, e3) {
                return t2(n2.a, o[r3], e3);
              },
              delegateYield: function delegateYield(r3, o2, a2) {
                return e2.resultName = o2, t2(n2.d, regeneratorValues(r3), a2);
              },
              finish: function finish(r3) {
                return t2(n2.f, r3);
              }
            }, t2 = function t3(r3, _t, o2) {
              n2.p = e2.prev, n2.n = e2.next;
              try {
                return r3(_t, o2);
              } finally {
                e2.next = n2.n;
              }
            }), e2.resultName && (e2[e2.resultName] = n2.v, e2.resultName = void 0), e2.sent = n2.v, e2.next = n2.n;
            try {
              return r2.call(this, e2);
            } finally {
              n2.p = e2.prev, n2.n = e2.next;
            }
          };
        }
        return (module2.exports = _regeneratorRuntime = function _regeneratorRuntime2() {
          return {
            wrap: function wrap4(e2, t2, n2, o2) {
              return r.w(a(e2), t2, n2, o2 && o2.reverse());
            },
            isGeneratorFunction: n,
            mark: r.m,
            awrap: function awrap(r2, e2) {
              return new OverloadYield(r2, e2);
            },
            AsyncIterator: regeneratorAsyncIterator,
            async: function async(r2, e2, t2, o2, u) {
              return (n(e2) ? regeneratorAsyncGen : regeneratorAsync)(a(r2), e2, t2, o2, u);
            },
            keys: regeneratorKeys,
            values: regeneratorValues
          };
        }, module2.exports.__esModule = true, module2.exports["default"] = module2.exports)();
      }
      module2.exports = _regeneratorRuntime, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
    }
  });

  // node_modules/@babel/runtime/regenerator/index.js
  var require_regenerator2 = __commonJS({
    "node_modules/@babel/runtime/regenerator/index.js"(exports, module2) {
      var runtime = require_regeneratorRuntime()();
      module2.exports = runtime;
      try {
        regeneratorRuntime = runtime;
      } catch (accidentalStrictMode) {
        if (typeof globalThis === "object") {
          globalThis.regeneratorRuntime = runtime;
        } else {
          Function("r", "regeneratorRuntime = r")(runtime);
        }
      }
    }
  });

  // node_modules/@babel/runtime/helpers/arrayWithHoles.js
  var require_arrayWithHoles = __commonJS({
    "node_modules/@babel/runtime/helpers/arrayWithHoles.js"(exports, module2) {
      function _arrayWithHoles2(r) {
        if (Array.isArray(r)) return r;
      }
      module2.exports = _arrayWithHoles2, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/iterableToArrayLimit.js
  var require_iterableToArrayLimit = __commonJS({
    "node_modules/@babel/runtime/helpers/iterableToArrayLimit.js"(exports, module2) {
      function _iterableToArrayLimit2(r, l) {
        var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
        if (null != t) {
          var e, n, i, u, a = [], f = true, o = false;
          try {
            if (i = (t = t.call(r)).next, 0 === l) {
              if (Object(t) !== t) return;
              f = false;
            } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
          } catch (r2) {
            o = true, n = r2;
          } finally {
            try {
              if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
            } finally {
              if (o) throw n;
            }
          }
          return a;
        }
      }
      module2.exports = _iterableToArrayLimit2, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/arrayLikeToArray.js
  var require_arrayLikeToArray = __commonJS({
    "node_modules/@babel/runtime/helpers/arrayLikeToArray.js"(exports, module2) {
      function _arrayLikeToArray6(r, a) {
        (null == a || a > r.length) && (a = r.length);
        for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
        return n;
      }
      module2.exports = _arrayLikeToArray6, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js
  var require_unsupportedIterableToArray = __commonJS({
    "node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js"(exports, module2) {
      var arrayLikeToArray = require_arrayLikeToArray();
      function _unsupportedIterableToArray6(r, a) {
        if (r) {
          if ("string" == typeof r) return arrayLikeToArray(r, a);
          var t = {}.toString.call(r).slice(8, -1);
          return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? arrayLikeToArray(r, a) : void 0;
        }
      }
      module2.exports = _unsupportedIterableToArray6, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/nonIterableRest.js
  var require_nonIterableRest = __commonJS({
    "node_modules/@babel/runtime/helpers/nonIterableRest.js"(exports, module2) {
      function _nonIterableRest2() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      module2.exports = _nonIterableRest2, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/slicedToArray.js
  var require_slicedToArray = __commonJS({
    "node_modules/@babel/runtime/helpers/slicedToArray.js"(exports, module2) {
      var arrayWithHoles = require_arrayWithHoles();
      var iterableToArrayLimit = require_iterableToArrayLimit();
      var unsupportedIterableToArray = require_unsupportedIterableToArray();
      var nonIterableRest = require_nonIterableRest();
      function _slicedToArray2(r, e) {
        return arrayWithHoles(r) || iterableToArrayLimit(r, e) || unsupportedIterableToArray(r, e) || nonIterableRest();
      }
      module2.exports = _slicedToArray2, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/asyncToGenerator.js
  var require_asyncToGenerator = __commonJS({
    "node_modules/@babel/runtime/helpers/asyncToGenerator.js"(exports, module2) {
      function asyncGeneratorStep(n, t, e, r, o, a, c) {
        try {
          var i = n[a](c), u = i.value;
        } catch (n2) {
          return void e(n2);
        }
        i.done ? t(u) : Promise.resolve(u).then(r, o);
      }
      function _asyncToGenerator(n) {
        return function() {
          var t = this, e = arguments;
          return new Promise(function(r, o) {
            var a = n.apply(t, e);
            function _next(n2) {
              asyncGeneratorStep(a, r, o, _next, _throw, "next", n2);
            }
            function _throw(n2) {
              asyncGeneratorStep(a, r, o, _next, _throw, "throw", n2);
            }
            _next(void 0);
          });
        };
      }
      module2.exports = _asyncToGenerator, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
    }
  });

  // node_modules/@statsig/client-core/src/Log.js
  var require_Log = __commonJS({
    "node_modules/@statsig/client-core/src/Log.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Log = exports.LogLevel = void 0;
      var DEBUG = " DEBUG ";
      var _INFO = "  INFO ";
      var _WARN = "  WARN ";
      var ERROR = " ERROR ";
      function addTag(args) {
        args.unshift("[Statsig]");
        return args;
      }
      exports.LogLevel = {
        None: 0,
        Error: 1,
        Warn: 2,
        Info: 3,
        Debug: 4
      };
      var Log = class _Log {
        static info(...args) {
          if (_Log.level >= exports.LogLevel.Info) {
            console.info(_INFO, ...addTag(args));
          }
        }
        static debug(...args) {
          if (_Log.level >= exports.LogLevel.Debug) {
            console.debug(DEBUG, ...addTag(args));
          }
        }
        static warn(...args) {
          if (_Log.level >= exports.LogLevel.Warn) {
            console.warn(_WARN, ...addTag(args));
          }
        }
        static error(...args) {
          if (_Log.level >= exports.LogLevel.Error) {
            console.error(ERROR, ...addTag(args));
          }
        }
      };
      exports.Log = Log;
      Log.level = exports.LogLevel.Warn;
    }
  });

  // node_modules/@statsig/client-core/src/$_StatsigGlobal.js
  var require_StatsigGlobal = __commonJS({
    "node_modules/@statsig/client-core/src/$_StatsigGlobal.js"(exports) {
      "use strict";
      var _a2;
      var _b;
      var _c;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports._getInstance = exports._getStatsigGlobalFlag = exports._getStatsigGlobal = void 0;
      var Log_1 = require_Log();
      var _getStatsigGlobal = () => {
        try {
          return typeof __STATSIG__ !== "undefined" ? __STATSIG__ : statsigGlobal;
        } catch (e) {
          return statsigGlobal;
        }
      };
      exports._getStatsigGlobal = _getStatsigGlobal;
      var _getStatsigGlobalFlag = (flag2) => {
        return (0, exports._getStatsigGlobal)()[flag2];
      };
      exports._getStatsigGlobalFlag = _getStatsigGlobalFlag;
      var _getInstance = (sdkKey) => {
        const gbl = (0, exports._getStatsigGlobal)();
        if (!sdkKey) {
          if (gbl.instances && Object.keys(gbl.instances).length > 1) {
            Log_1.Log.warn("Call made to Statsig global instance without an SDK key but there is more than one client instance. If you are using mulitple clients, please specify the SDK key.");
          }
          return gbl.firstInstance;
        }
        return gbl.instances && gbl.instances[sdkKey];
      };
      exports._getInstance = _getInstance;
      var GLOBAL_KEY = "__STATSIG__";
      var _window10 = typeof window !== "undefined" ? window : {};
      var _global = typeof global !== "undefined" ? global : {};
      var _globalThis = typeof globalThis !== "undefined" ? globalThis : {};
      var statsigGlobal = (_c = (_b = (_a2 = _window10[GLOBAL_KEY]) !== null && _a2 !== void 0 ? _a2 : _global[GLOBAL_KEY]) !== null && _b !== void 0 ? _b : _globalThis[GLOBAL_KEY]) !== null && _c !== void 0 ? _c : {
        instance: exports._getInstance
      };
      _window10[GLOBAL_KEY] = statsigGlobal;
      _global[GLOBAL_KEY] = statsigGlobal;
      _globalThis[GLOBAL_KEY] = statsigGlobal;
    }
  });

  // node_modules/@statsig/client-core/src/Diagnostics.js
  var require_Diagnostics = __commonJS({
    "node_modules/@statsig/client-core/src/Diagnostics.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Diagnostics = void 0;
      var MARKER_MAP = /* @__PURE__ */ new Map();
      var ACT_START = "start";
      var ACT_END = "end";
      var DIAGNOSTICS_EVENT = "statsig::diagnostics";
      exports.Diagnostics = {
        _getMarkers: (sdkKey) => {
          return MARKER_MAP.get(sdkKey);
        },
        _markInitOverallStart: (sdkKey) => {
          _addMarker(sdkKey, _createMarker({}, ACT_START, "overall"));
        },
        _markInitOverallEnd: (sdkKey, success, evaluationDetails) => {
          _addMarker(sdkKey, _createMarker({
            success,
            error: success ? void 0 : { name: "InitializeError", message: "Failed to initialize" },
            evaluationDetails
          }, ACT_END, "overall"));
        },
        _markInitNetworkReqStart: (sdkKey, data) => {
          _addMarker(sdkKey, _createMarker(data, ACT_START, "initialize", "network_request"));
        },
        _markInitNetworkReqEnd: (sdkKey, data) => {
          _addMarker(sdkKey, _createMarker(data, ACT_END, "initialize", "network_request"));
        },
        _markInitProcessStart: (sdkKey) => {
          _addMarker(sdkKey, _createMarker({}, ACT_START, "initialize", "process"));
        },
        _markInitProcessEnd: (sdkKey, data) => {
          _addMarker(sdkKey, _createMarker(data, ACT_END, "initialize", "process"));
        },
        _clearMarkers: (sdkKey) => {
          MARKER_MAP.delete(sdkKey);
        },
        _formatError(e) {
          if (!(e && typeof e === "object")) {
            return;
          }
          return {
            code: _safeGetField(e, "code"),
            name: _safeGetField(e, "name"),
            message: _safeGetField(e, "message")
          };
        },
        _getDiagnosticsData(res, attempt, body, e) {
          var _a2;
          return {
            success: (res === null || res === void 0 ? void 0 : res.ok) === true,
            statusCode: res === null || res === void 0 ? void 0 : res.status,
            sdkRegion: (_a2 = res === null || res === void 0 ? void 0 : res.headers) === null || _a2 === void 0 ? void 0 : _a2.get("x-statsig-region"),
            isDelta: body.includes('"is_delta":true') === true ? true : void 0,
            attempt,
            error: exports.Diagnostics._formatError(e)
          };
        },
        _enqueueDiagnosticsEvent(user, logger, sdk, options2) {
          const markers = exports.Diagnostics._getMarkers(sdk);
          if (markers == null || markers.length <= 0) {
            return -1;
          }
          const overallInitDuration = markers[markers.length - 1].timestamp - markers[0].timestamp;
          exports.Diagnostics._clearMarkers(sdk);
          const event = _makeDiagnosticsEvent(user, {
            context: "initialize",
            markers: markers.slice(),
            statsigOptions: options2
          });
          logger.enqueue(event);
          return overallInitDuration;
        }
      };
      function _createMarker(data, action, key, step) {
        return Object.assign({ key, action, step, timestamp: Date.now() }, data);
      }
      function _makeDiagnosticsEvent(user, data) {
        const latencyEvent = {
          eventName: DIAGNOSTICS_EVENT,
          user,
          value: null,
          metadata: data,
          time: Date.now()
        };
        return latencyEvent;
      }
      function _addMarker(sdkKey, marker) {
        var _a2;
        const markers = (_a2 = MARKER_MAP.get(sdkKey)) !== null && _a2 !== void 0 ? _a2 : [];
        markers.push(marker);
        MARKER_MAP.set(sdkKey, markers);
      }
      function _safeGetField(data, field) {
        if (field in data) {
          return data[field];
        }
        return void 0;
      }
    }
  });

  // node_modules/@statsig/client-core/src/TypingUtils.js
  var require_TypingUtils = __commonJS({
    "node_modules/@statsig/client-core/src/TypingUtils.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports._isTypeMatch = exports._typeOf = void 0;
      function _typeOf(input) {
        return Array.isArray(input) ? "array" : typeof input;
      }
      exports._typeOf = _typeOf;
      function _isTypeMatch(a, b) {
        const typeOf = (x) => Array.isArray(x) ? "array" : x === null ? "null" : typeof x;
        return typeOf(a) === typeOf(b);
      }
      exports._isTypeMatch = _isTypeMatch;
    }
  });

  // node_modules/@statsig/client-core/src/Hashing.js
  var require_Hashing = __commonJS({
    "node_modules/@statsig/client-core/src/Hashing.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports._getSortedObject = exports._DJB2Object = exports._DJB2 = void 0;
      var TypingUtils_1 = require_TypingUtils();
      var _DJB2 = (value) => {
        let hash4 = 0;
        for (let i = 0; i < value.length; i++) {
          const character2 = value.charCodeAt(i);
          hash4 = (hash4 << 5) - hash4 + character2;
          hash4 = hash4 & hash4;
        }
        return String(hash4 >>> 0);
      };
      exports._DJB2 = _DJB2;
      var _DJB2Object = (value, maxLevels) => {
        return (0, exports._DJB2)(JSON.stringify((0, exports._getSortedObject)(value, maxLevels)));
      };
      exports._DJB2Object = _DJB2Object;
      var _getSortedObject = (object, maxDepth) => {
        if (object == null) {
          return null;
        }
        const keys = Object.keys(object).sort();
        const sortedObject = {};
        keys.forEach((key) => {
          const value = object[key];
          if (maxDepth === 0 || (0, TypingUtils_1._typeOf)(value) !== "object") {
            sortedObject[key] = value;
            return;
          }
          sortedObject[key] = (0, exports._getSortedObject)(value, maxDepth != null ? maxDepth - 1 : maxDepth);
        });
        return sortedObject;
      };
      exports._getSortedObject = _getSortedObject;
    }
  });

  // node_modules/@statsig/client-core/src/CacheKey.js
  var require_CacheKey = __commonJS({
    "node_modules/@statsig/client-core/src/CacheKey.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports._getStorageKey = exports._getUserStorageKey = void 0;
      var Hashing_1 = require_Hashing();
      function _getUserStorageKey(sdkKey, user, customKeyGenerator) {
        var _a2;
        if (customKeyGenerator) {
          return customKeyGenerator(sdkKey, user);
        }
        const cids = user && user.customIDs ? user.customIDs : {};
        const parts = [
          `uid:${(_a2 = user === null || user === void 0 ? void 0 : user.userID) !== null && _a2 !== void 0 ? _a2 : ""}`,
          `cids:${Object.keys(cids).sort((leftKey, rightKey) => leftKey.localeCompare(rightKey)).map((key) => `${key}-${cids[key]}`).join(",")}`,
          `k:${sdkKey}`
        ];
        return (0, Hashing_1._DJB2)(parts.join("|"));
      }
      exports._getUserStorageKey = _getUserStorageKey;
      function _getStorageKey(sdkKey, user, customKeyGenerator) {
        if (user) {
          return _getUserStorageKey(sdkKey, user, customKeyGenerator);
        }
        return (0, Hashing_1._DJB2)(`k:${sdkKey}`);
      }
      exports._getStorageKey = _getStorageKey;
    }
  });

  // node_modules/@statsig/client-core/src/NetworkConfig.js
  var require_NetworkConfig = __commonJS({
    "node_modules/@statsig/client-core/src/NetworkConfig.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.NetworkParam = exports.NetworkDefault = exports.Endpoint = void 0;
      exports.Endpoint = {
        _initialize: "initialize",
        _rgstr: "rgstr",
        _download_config_specs: "download_config_specs"
      };
      exports.NetworkDefault = {
        [exports.Endpoint._rgstr]: "https://prodregistryv2.org/v1",
        [exports.Endpoint._initialize]: "https://featureassets.org/v1",
        [exports.Endpoint._download_config_specs]: "https://api.statsigcdn.com/v1"
      };
      exports.NetworkParam = {
        EventCount: "ec",
        SdkKey: "k",
        SdkType: "st",
        SdkVersion: "sv",
        Time: "t",
        SessionID: "sid",
        StatsigEncoded: "se",
        IsGzipped: "gz"
      };
    }
  });

  // node_modules/@statsig/client-core/src/SafeJs.js
  var require_SafeJs = __commonJS({
    "node_modules/@statsig/client-core/src/SafeJs.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports._getUnloadEvent = exports._getCurrentPageUrlSafe = exports._addDocumentEventListenerSafe = exports._addWindowEventListenerSafe = exports._isServerEnv = exports._getDocumentSafe = exports._getWindowSafe = void 0;
      var _getWindowSafe = () => {
        return typeof window !== "undefined" ? window : null;
      };
      exports._getWindowSafe = _getWindowSafe;
      var _getDocumentSafe = () => {
        var _a2;
        const win = (0, exports._getWindowSafe)();
        return (_a2 = win === null || win === void 0 ? void 0 : win.document) !== null && _a2 !== void 0 ? _a2 : null;
      };
      exports._getDocumentSafe = _getDocumentSafe;
      var _isServerEnv = () => {
        if ((0, exports._getDocumentSafe)() !== null) {
          return false;
        }
        const isNode3 = typeof process !== "undefined" && process.versions != null && process.versions.node != null;
        const isVercel = typeof EdgeRuntime === "string";
        return isVercel || isNode3;
      };
      exports._isServerEnv = _isServerEnv;
      var _addWindowEventListenerSafe = (key, listener) => {
        const win = (0, exports._getWindowSafe)();
        if (typeof (win === null || win === void 0 ? void 0 : win.addEventListener) === "function") {
          win.addEventListener(key, listener);
        }
      };
      exports._addWindowEventListenerSafe = _addWindowEventListenerSafe;
      var _addDocumentEventListenerSafe = (key, listener) => {
        const doc = (0, exports._getDocumentSafe)();
        if (typeof (doc === null || doc === void 0 ? void 0 : doc.addEventListener) === "function") {
          doc.addEventListener(key, listener);
        }
      };
      exports._addDocumentEventListenerSafe = _addDocumentEventListenerSafe;
      var _getCurrentPageUrlSafe = () => {
        var _a2;
        try {
          return (_a2 = (0, exports._getWindowSafe)()) === null || _a2 === void 0 ? void 0 : _a2.location.href.split(/[?#]/)[0];
        } catch (_b) {
          return;
        }
      };
      exports._getCurrentPageUrlSafe = _getCurrentPageUrlSafe;
      var _getUnloadEvent = () => {
        const win = (0, exports._getWindowSafe)();
        if (!win) {
          return "beforeunload";
        }
        const eventType = "onpagehide" in win ? "pagehide" : "beforeunload";
        return eventType;
      };
      exports._getUnloadEvent = _getUnloadEvent;
    }
  });

  // node_modules/@statsig/client-core/src/StatsigEvent.js
  var require_StatsigEvent = __commonJS({
    "node_modules/@statsig/client-core/src/StatsigEvent.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports._createLayerParameterExposure = exports._createConfigExposure = exports._mapExposures = exports._createGateExposure = exports._isExposureEvent = void 0;
      var CONFIG_EXPOSURE_NAME = "statsig::config_exposure";
      var GATE_EXPOSURE_NAME = "statsig::gate_exposure";
      var LAYER_EXPOSURE_NAME = "statsig::layer_exposure";
      var _createExposure = (eventName, user, details, metadata, secondaryExposures) => {
        if (details.bootstrapMetadata) {
          metadata["bootstrapMetadata"] = details.bootstrapMetadata;
        }
        return {
          eventName,
          user,
          value: null,
          metadata: _addEvaluationDetailsToMetadata(details, metadata),
          secondaryExposures,
          time: Date.now()
        };
      };
      var _isExposureEvent = ({ eventName }) => {
        return eventName === GATE_EXPOSURE_NAME || eventName === CONFIG_EXPOSURE_NAME || eventName === LAYER_EXPOSURE_NAME;
      };
      exports._isExposureEvent = _isExposureEvent;
      var _createGateExposure = (user, gate, exposureMapping) => {
        var _a2, _b, _c;
        const metadata = {
          gate: gate.name,
          gateValue: String(gate.value),
          ruleID: gate.ruleID
        };
        if (((_a2 = gate.__evaluation) === null || _a2 === void 0 ? void 0 : _a2.version) != null) {
          metadata["configVersion"] = gate.__evaluation.version;
        }
        return _createExposure(GATE_EXPOSURE_NAME, user, gate.details, metadata, _mapExposures((_c = (_b = gate.__evaluation) === null || _b === void 0 ? void 0 : _b.secondary_exposures) !== null && _c !== void 0 ? _c : [], exposureMapping));
      };
      exports._createGateExposure = _createGateExposure;
      function _mapExposures(exposures, exposureMapping) {
        return exposures.map((exposure) => {
          if (typeof exposure === "string") {
            return (exposureMapping !== null && exposureMapping !== void 0 ? exposureMapping : {})[exposure];
          }
          return exposure;
        }).filter((exposure) => exposure != null);
      }
      exports._mapExposures = _mapExposures;
      var _createConfigExposure = (user, config, exposureMapping) => {
        var _a2, _b, _c, _d;
        const metadata = {
          config: config.name,
          ruleID: config.ruleID
        };
        if (((_a2 = config.__evaluation) === null || _a2 === void 0 ? void 0 : _a2.version) != null) {
          metadata["configVersion"] = config.__evaluation.version;
        }
        if (((_b = config.__evaluation) === null || _b === void 0 ? void 0 : _b.passed) != null) {
          metadata["rulePassed"] = String(config.__evaluation.passed);
        }
        return _createExposure(CONFIG_EXPOSURE_NAME, user, config.details, metadata, _mapExposures((_d = (_c = config.__evaluation) === null || _c === void 0 ? void 0 : _c.secondary_exposures) !== null && _d !== void 0 ? _d : [], exposureMapping));
      };
      exports._createConfigExposure = _createConfigExposure;
      var _createLayerParameterExposure = (user, layer2, parameterName, exposureMapping) => {
        var _a2, _b, _c, _d, _e, _f, _g;
        const evaluation = layer2.__evaluation;
        const isExplicit = ((_a2 = evaluation === null || evaluation === void 0 ? void 0 : evaluation.explicit_parameters) === null || _a2 === void 0 ? void 0 : _a2.includes(parameterName)) === true;
        let allocatedExperiment = "";
        let secondaryExposures = (_b = evaluation === null || evaluation === void 0 ? void 0 : evaluation.undelegated_secondary_exposures) !== null && _b !== void 0 ? _b : [];
        if (isExplicit) {
          allocatedExperiment = (_c = evaluation.allocated_experiment_name) !== null && _c !== void 0 ? _c : "";
          secondaryExposures = (_d = evaluation.secondary_exposures) !== null && _d !== void 0 ? _d : [];
        }
        const parameterRuleIDs = (_e = layer2.__evaluation) === null || _e === void 0 ? void 0 : _e.parameter_rule_ids;
        const metadata = {
          config: layer2.name,
          parameterName,
          ruleID: (_f = parameterRuleIDs === null || parameterRuleIDs === void 0 ? void 0 : parameterRuleIDs[parameterName]) !== null && _f !== void 0 ? _f : layer2.ruleID,
          allocatedExperiment,
          isExplicitParameter: String(isExplicit)
        };
        if (((_g = layer2.__evaluation) === null || _g === void 0 ? void 0 : _g.version) != null) {
          metadata["configVersion"] = layer2.__evaluation.version;
        }
        return _createExposure(LAYER_EXPOSURE_NAME, user, layer2.details, metadata, _mapExposures(secondaryExposures, exposureMapping));
      };
      exports._createLayerParameterExposure = _createLayerParameterExposure;
      var _addEvaluationDetailsToMetadata = (details, metadata) => {
        metadata["reason"] = details.reason;
        if (details.lcut) {
          metadata["lcut"] = String(details.lcut);
        }
        if (details.receivedAt) {
          metadata["receivedAt"] = String(details.receivedAt);
        }
        return metadata;
      };
    }
  });

  // node_modules/@statsig/client-core/src/StatsigOptionsCommon.js
  var require_StatsigOptionsCommon = __commonJS({
    "node_modules/@statsig/client-core/src/StatsigOptionsCommon.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.LoggingEnabledOption = exports.LogEventCompressionMode = void 0;
      exports.LogEventCompressionMode = {
        /** Do not compress request bodies */
        Disabled: "d",
        /** Compress request bodies unless a network proxy is configured */
        Enabled: "e",
        /** Always compress request bodies, even when a proxy is configured */
        Forced: "f"
      };
      exports.LoggingEnabledOption = {
        disabled: "disabled",
        browserOnly: "browser-only",
        always: "always"
      };
    }
  });

  // node_modules/@statsig/client-core/src/StorageProvider.js
  var require_StorageProvider = __commonJS({
    "node_modules/@statsig/client-core/src/StorageProvider.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports._setObjectInStorage = exports._getObjectFromStorage = exports.Storage = void 0;
      var Log_1 = require_Log();
      var SafeJs_1 = require_SafeJs();
      var inMemoryStore = {};
      var _inMemoryProvider = {
        isReady: () => true,
        isReadyResolver: () => null,
        getProviderName: () => "InMemory",
        getItem: (key) => inMemoryStore[key] ? inMemoryStore[key] : null,
        setItem: (key, value) => {
          inMemoryStore[key] = value;
        },
        removeItem: (key) => {
          delete inMemoryStore[key];
        },
        getAllKeys: () => Object.keys(inMemoryStore)
      };
      var _localStorageProvider = null;
      try {
        const win = (0, SafeJs_1._getWindowSafe)();
        if (win && win.localStorage && typeof win.localStorage.getItem === "function") {
          _localStorageProvider = {
            isReady: () => true,
            isReadyResolver: () => null,
            getProviderName: () => "LocalStorage",
            getItem: (key) => win.localStorage.getItem(key),
            setItem: (key, value) => win.localStorage.setItem(key, value),
            removeItem: (key) => win.localStorage.removeItem(key),
            getAllKeys: () => Object.keys(win.localStorage)
          };
        }
      } catch (error) {
        Log_1.Log.warn("Failed to setup localStorageProvider.");
      }
      var _main = _localStorageProvider !== null && _localStorageProvider !== void 0 ? _localStorageProvider : _inMemoryProvider;
      var _current = _main;
      function _inMemoryBreaker(action) {
        try {
          return action();
        } catch (error) {
          if (error instanceof Error && error.name === "SecurityError") {
            exports.Storage._setProvider(_inMemoryProvider);
            return null;
          }
          if (error instanceof Error && error.name === "QuotaExceededError") {
            const allKeys = exports.Storage.getAllKeys();
            const statsigKeys = allKeys.filter((key) => key.startsWith("statsig."));
            error.message = `${error.message}. Statsig Keys: ${statsigKeys.length}`;
          }
          throw error;
        }
      }
      exports.Storage = {
        isReady: () => _current.isReady(),
        isReadyResolver: () => _current.isReadyResolver(),
        getProviderName: () => _current.getProviderName(),
        getItem: (key) => _inMemoryBreaker(() => _current.getItem(key)),
        setItem: (key, value) => _inMemoryBreaker(() => _current.setItem(key, value)),
        removeItem: (key) => _current.removeItem(key),
        getAllKeys: () => _current.getAllKeys(),
        // StorageProviderManagment
        _setProvider: (newProvider) => {
          _main = newProvider;
          _current = newProvider;
        },
        _setDisabled: (isDisabled) => {
          if (isDisabled) {
            _current = _inMemoryProvider;
          } else {
            _current = _main;
          }
        }
      };
      function _getObjectFromStorage(key) {
        const value = exports.Storage.getItem(key);
        return JSON.parse(value !== null && value !== void 0 ? value : "null");
      }
      exports._getObjectFromStorage = _getObjectFromStorage;
      function _setObjectInStorage(key, obj) {
        exports.Storage.setItem(key, JSON.stringify(obj));
      }
      exports._setObjectInStorage = _setObjectInStorage;
    }
  });

  // node_modules/@statsig/client-core/src/UrlConfiguration.js
  var require_UrlConfiguration = __commonJS({
    "node_modules/@statsig/client-core/src/UrlConfiguration.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.UrlConfiguration = void 0;
      var Hashing_1 = require_Hashing();
      var NetworkConfig_1 = require_NetworkConfig();
      var ENDPOINT_DNS_KEY_MAP = {
        [NetworkConfig_1.Endpoint._initialize]: "i",
        [NetworkConfig_1.Endpoint._rgstr]: "e",
        [NetworkConfig_1.Endpoint._download_config_specs]: "d"
      };
      var UrlConfiguration = class {
        constructor(endpoint, customUrl, customApi, fallbackUrls) {
          this.customUrl = null;
          this.fallbackUrls = null;
          this.endpoint = endpoint;
          this.endpointDnsKey = ENDPOINT_DNS_KEY_MAP[endpoint];
          if (customUrl) {
            this.customUrl = customUrl;
          }
          if (!customUrl && customApi) {
            this.customUrl = customApi.endsWith("/") ? `${customApi}${endpoint}` : `${customApi}/${endpoint}`;
          }
          if (fallbackUrls) {
            this.fallbackUrls = fallbackUrls;
          }
          const defaultApi = NetworkConfig_1.NetworkDefault[endpoint];
          this.defaultUrl = `${defaultApi}/${endpoint}`;
        }
        getUrl() {
          var _a2;
          return (_a2 = this.customUrl) !== null && _a2 !== void 0 ? _a2 : this.defaultUrl;
        }
        getChecksum() {
          var _a2;
          const fallbacks = ((_a2 = this.fallbackUrls) !== null && _a2 !== void 0 ? _a2 : []).sort().join(",");
          return (0, Hashing_1._DJB2)(this.customUrl + fallbacks);
        }
      };
      exports.UrlConfiguration = UrlConfiguration;
    }
  });

  // node_modules/@statsig/client-core/src/VisibilityObserving.js
  var require_VisibilityObserving = __commonJS({
    "node_modules/@statsig/client-core/src/VisibilityObserving.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports._notifyVisibilityChanged = exports._subscribeToVisiblityChanged = exports._isUnloading = exports._isCurrentlyVisible = void 0;
      var SafeJs_1 = require_SafeJs();
      var FOREGROUND = "foreground";
      var BACKGROUND = "background";
      var LISTENERS = [];
      var current = FOREGROUND;
      var isUnloading = false;
      var _isCurrentlyVisible = () => {
        return current === FOREGROUND;
      };
      exports._isCurrentlyVisible = _isCurrentlyVisible;
      var _isUnloading = () => isUnloading;
      exports._isUnloading = _isUnloading;
      var _subscribeToVisiblityChanged = (listener) => {
        LISTENERS.unshift(listener);
      };
      exports._subscribeToVisiblityChanged = _subscribeToVisiblityChanged;
      var _notifyVisibilityChanged = (visibility) => {
        if (visibility === current) {
          return;
        }
        current = visibility;
        LISTENERS.forEach((l) => l(visibility));
      };
      exports._notifyVisibilityChanged = _notifyVisibilityChanged;
      (0, SafeJs_1._addWindowEventListenerSafe)("focus", () => {
        isUnloading = false;
        (0, exports._notifyVisibilityChanged)(FOREGROUND);
      });
      (0, SafeJs_1._addWindowEventListenerSafe)("blur", () => (0, exports._notifyVisibilityChanged)(BACKGROUND));
      (0, SafeJs_1._addDocumentEventListenerSafe)("visibilitychange", () => {
        (0, exports._notifyVisibilityChanged)(document.visibilityState === "visible" ? FOREGROUND : BACKGROUND);
      });
      (0, SafeJs_1._addWindowEventListenerSafe)((0, SafeJs_1._getUnloadEvent)(), () => {
        isUnloading = true;
        (0, exports._notifyVisibilityChanged)(BACKGROUND);
      });
    }
  });

  // node_modules/@statsig/client-core/src/EventLogger.js
  var require_EventLogger = __commonJS({
    "node_modules/@statsig/client-core/src/EventLogger.js"(exports) {
      "use strict";
      var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result2) {
            result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.EventLogger = void 0;
      var CacheKey_1 = require_CacheKey();
      var Hashing_1 = require_Hashing();
      var Log_1 = require_Log();
      var NetworkConfig_1 = require_NetworkConfig();
      var SafeJs_1 = require_SafeJs();
      var StatsigEvent_1 = require_StatsigEvent();
      var StatsigOptionsCommon_1 = require_StatsigOptionsCommon();
      var StorageProvider_1 = require_StorageProvider();
      var UrlConfiguration_1 = require_UrlConfiguration();
      var VisibilityObserving_1 = require_VisibilityObserving();
      var DEFAULT_QUEUE_SIZE = 100;
      var DEFAULT_FLUSH_INTERVAL_MS = 1e4;
      var MAX_DEDUPER_KEYS = 1e3;
      var DEDUPER_WINDOW_DURATION_MS = 6e5;
      var MAX_FAILED_LOGS = 500;
      var QUICK_FLUSH_WINDOW_MS = 200;
      var EVENT_LOGGER_MAP = {};
      var RetryFailedLogsTrigger = {
        Startup: "startup",
        GainedFocus: "gained_focus"
      };
      var EventLogger = class _EventLogger {
        static _safeFlushAndForget(sdkKey) {
          var _a2;
          (_a2 = EVENT_LOGGER_MAP[sdkKey]) === null || _a2 === void 0 ? void 0 : _a2.flush().catch(() => {
          });
        }
        static _safeRetryFailedLogs(sdkKey) {
          var _a2;
          (_a2 = EVENT_LOGGER_MAP[sdkKey]) === null || _a2 === void 0 ? void 0 : _a2._retryFailedLogs(RetryFailedLogsTrigger.GainedFocus);
        }
        constructor(_sdkKey, _emitter, _network, _options) {
          var _a2, _b;
          this._sdkKey = _sdkKey;
          this._emitter = _emitter;
          this._network = _network;
          this._options = _options;
          this._queue = [];
          this._lastExposureTimeMap = {};
          this._nonExposedChecks = {};
          this._hasRunQuickFlush = false;
          this._creationTime = Date.now();
          this._loggingEnabled = (_a2 = _options === null || _options === void 0 ? void 0 : _options.loggingEnabled) !== null && _a2 !== void 0 ? _a2 : (_options === null || _options === void 0 ? void 0 : _options.disableLogging) === true ? StatsigOptionsCommon_1.LoggingEnabledOption.disabled : StatsigOptionsCommon_1.LoggingEnabledOption.browserOnly;
          if ((_options === null || _options === void 0 ? void 0 : _options.loggingEnabled) && _options.disableLogging !== void 0) {
            Log_1.Log.warn("Detected both loggingEnabled and disableLogging options. loggingEnabled takes precedence - please remove disableLogging.");
          }
          this._maxQueueSize = (_b = _options === null || _options === void 0 ? void 0 : _options.loggingBufferMaxSize) !== null && _b !== void 0 ? _b : DEFAULT_QUEUE_SIZE;
          const config = _options === null || _options === void 0 ? void 0 : _options.networkConfig;
          this._logEventUrlConfig = new UrlConfiguration_1.UrlConfiguration(NetworkConfig_1.Endpoint._rgstr, config === null || config === void 0 ? void 0 : config.logEventUrl, config === null || config === void 0 ? void 0 : config.api, config === null || config === void 0 ? void 0 : config.logEventFallbackUrls);
        }
        setLogEventCompressionMode(mode) {
          this._network.setLogEventCompressionMode(mode);
        }
        setLoggingEnabled(loggingEnabled) {
          this._loggingEnabled = loggingEnabled;
        }
        enqueue(event) {
          if (!this._shouldLogEvent(event)) {
            return;
          }
          this._normalizeAndAppendEvent(event);
          this._quickFlushIfNeeded();
          if (this._queue.length > this._maxQueueSize) {
            _EventLogger._safeFlushAndForget(this._sdkKey);
          }
        }
        incrementNonExposureCount(name) {
          var _a2;
          const current = (_a2 = this._nonExposedChecks[name]) !== null && _a2 !== void 0 ? _a2 : 0;
          this._nonExposedChecks[name] = current + 1;
        }
        reset() {
          this.flush().catch(() => {
          });
          this._lastExposureTimeMap = {};
        }
        start() {
          var _a2;
          const isServerEnv = (0, SafeJs_1._isServerEnv)();
          if (isServerEnv && ((_a2 = this._options) === null || _a2 === void 0 ? void 0 : _a2.loggingEnabled) !== "always") {
            return;
          }
          EVENT_LOGGER_MAP[this._sdkKey] = this;
          if (!isServerEnv) {
            (0, VisibilityObserving_1._subscribeToVisiblityChanged)((visibility) => {
              if (visibility === "background") {
                _EventLogger._safeFlushAndForget(this._sdkKey);
              } else if (visibility === "foreground") {
                _EventLogger._safeRetryFailedLogs(this._sdkKey);
              }
            });
          }
          this._retryFailedLogs(RetryFailedLogsTrigger.Startup);
          this._startBackgroundFlushInterval();
        }
        stop() {
          return __awaiter2(this, void 0, void 0, function* () {
            if (this._flushIntervalId) {
              clearInterval(this._flushIntervalId);
              this._flushIntervalId = null;
            }
            delete EVENT_LOGGER_MAP[this._sdkKey];
            yield this.flush();
          });
        }
        flush() {
          return __awaiter2(this, void 0, void 0, function* () {
            this._appendAndResetNonExposedChecks();
            if (this._queue.length === 0) {
              return;
            }
            const events = this._queue;
            this._queue = [];
            yield this._sendEvents(events);
          });
        }
        /**
         * We 'Quick Flush' following the very first event enqueued
         * within the quick flush window
         */
        _quickFlushIfNeeded() {
          if (this._hasRunQuickFlush) {
            return;
          }
          this._hasRunQuickFlush = true;
          if (Date.now() - this._creationTime > QUICK_FLUSH_WINDOW_MS) {
            return;
          }
          setTimeout(() => _EventLogger._safeFlushAndForget(this._sdkKey), QUICK_FLUSH_WINDOW_MS);
        }
        _shouldLogEvent(event) {
          var _a2;
          if (((_a2 = this._options) === null || _a2 === void 0 ? void 0 : _a2.loggingEnabled) !== "always" && (0, SafeJs_1._isServerEnv)()) {
            return false;
          }
          if (!(0, StatsigEvent_1._isExposureEvent)(event)) {
            return true;
          }
          const user = event.user ? event.user : { statsigEnvironment: void 0 };
          const userKey = (0, CacheKey_1._getUserStorageKey)(this._sdkKey, user);
          const metadata = event.metadata ? event.metadata : {};
          const key = [
            event.eventName,
            userKey,
            metadata["gate"],
            metadata["config"],
            metadata["ruleID"],
            metadata["allocatedExperiment"],
            metadata["parameterName"],
            String(metadata["isExplicitParameter"]),
            metadata["reason"]
          ].join("|");
          const previous = this._lastExposureTimeMap[key];
          const now2 = Date.now();
          if (previous && now2 - previous < DEDUPER_WINDOW_DURATION_MS) {
            return false;
          }
          if (Object.keys(this._lastExposureTimeMap).length > MAX_DEDUPER_KEYS) {
            this._lastExposureTimeMap = {};
          }
          this._lastExposureTimeMap[key] = now2;
          return true;
        }
        _sendEvents(events) {
          return __awaiter2(this, void 0, void 0, function* () {
            var _a2, _b;
            if (this._loggingEnabled === "disabled") {
              this._saveFailedLogsToStorage(events);
              return false;
            }
            try {
              const isClosing = (0, VisibilityObserving_1._isUnloading)();
              const shouldUseBeacon = isClosing && this._network.isBeaconSupported() && ((_b = (_a2 = this._options) === null || _a2 === void 0 ? void 0 : _a2.networkConfig) === null || _b === void 0 ? void 0 : _b.networkOverrideFunc) == null;
              this._emitter({
                name: "pre_logs_flushed",
                events
              });
              const response = shouldUseBeacon ? this._sendEventsViaBeacon(events) : yield this._sendEventsViaPost(events);
              if (response.success) {
                this._emitter({
                  name: "logs_flushed",
                  events
                });
                return true;
              } else {
                Log_1.Log.warn("Failed to flush events.");
                this._saveFailedLogsToStorage(events);
                return false;
              }
            } catch (_c) {
              Log_1.Log.warn("Failed to flush events.");
              return false;
            }
          });
        }
        _sendEventsViaPost(events) {
          return __awaiter2(this, void 0, void 0, function* () {
            var _a2;
            const result2 = yield this._network.post(this._getRequestData(events));
            const code = (_a2 = result2 === null || result2 === void 0 ? void 0 : result2.code) !== null && _a2 !== void 0 ? _a2 : -1;
            return { success: code >= 200 && code < 300 };
          });
        }
        _sendEventsViaBeacon(events) {
          return {
            success: this._network.beacon(this._getRequestData(events))
          };
        }
        _getRequestData(events) {
          return {
            sdkKey: this._sdkKey,
            data: {
              events
            },
            urlConfig: this._logEventUrlConfig,
            retries: 3,
            isCompressable: true,
            params: {
              [NetworkConfig_1.NetworkParam.EventCount]: String(events.length)
            },
            credentials: "same-origin"
          };
        }
        _saveFailedLogsToStorage(events) {
          while (events.length > MAX_FAILED_LOGS) {
            events.shift();
          }
          const storageKey = this._getStorageKey();
          try {
            (0, StorageProvider_1._setObjectInStorage)(storageKey, events);
          } catch (_a2) {
            Log_1.Log.warn("Unable to save failed logs to storage");
          }
        }
        _retryFailedLogs(trigger) {
          const storageKey = this._getStorageKey();
          (() => __awaiter2(this, void 0, void 0, function* () {
            if (!StorageProvider_1.Storage.isReady()) {
              yield StorageProvider_1.Storage.isReadyResolver();
            }
            const events = (0, StorageProvider_1._getObjectFromStorage)(storageKey);
            if (!events) {
              return;
            }
            if (trigger === RetryFailedLogsTrigger.Startup) {
              StorageProvider_1.Storage.removeItem(storageKey);
            }
            const isSuccess = yield this._sendEvents(events);
            if (isSuccess && trigger === RetryFailedLogsTrigger.GainedFocus) {
              StorageProvider_1.Storage.removeItem(storageKey);
            }
          }))().catch(() => {
            Log_1.Log.warn("Failed to flush stored logs");
          });
        }
        _getStorageKey() {
          return `statsig.failed_logs.${(0, Hashing_1._DJB2)(this._sdkKey)}`;
        }
        _normalizeAndAppendEvent(event) {
          if (event.user) {
            event.user = Object.assign({}, event.user);
            delete event.user.privateAttributes;
          }
          const extras2 = {};
          const currentPage = this._getCurrentPageUrl();
          if (currentPage) {
            extras2.statsigMetadata = { currentPage };
          }
          const final = Object.assign(Object.assign({}, event), extras2);
          Log_1.Log.debug("Enqueued Event:", final);
          this._queue.push(final);
        }
        _appendAndResetNonExposedChecks() {
          if (Object.keys(this._nonExposedChecks).length === 0) {
            return;
          }
          this._normalizeAndAppendEvent({
            eventName: "statsig::non_exposed_checks",
            user: null,
            time: Date.now(),
            metadata: {
              checks: Object.assign({}, this._nonExposedChecks)
            }
          });
          this._nonExposedChecks = {};
        }
        _getCurrentPageUrl() {
          var _a2;
          if (((_a2 = this._options) === null || _a2 === void 0 ? void 0 : _a2.includeCurrentPageUrlWithEvents) === false) {
            return;
          }
          return (0, SafeJs_1._getCurrentPageUrlSafe)();
        }
        _startBackgroundFlushInterval() {
          var _a2, _b;
          const flushInterval = (_b = (_a2 = this._options) === null || _a2 === void 0 ? void 0 : _a2.loggingIntervalMs) !== null && _b !== void 0 ? _b : DEFAULT_FLUSH_INTERVAL_MS;
          const intervalId = setInterval(() => {
            const logger = EVENT_LOGGER_MAP[this._sdkKey];
            if (!logger || logger._flushIntervalId !== intervalId) {
              clearInterval(intervalId);
            } else {
              _EventLogger._safeFlushAndForget(this._sdkKey);
            }
          }, flushInterval);
          this._flushIntervalId = intervalId;
        }
      };
      exports.EventLogger = EventLogger;
    }
  });

  // node_modules/@statsig/client-core/src/StatsigMetadata.js
  var require_StatsigMetadata = __commonJS({
    "node_modules/@statsig/client-core/src/StatsigMetadata.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.StatsigMetadataProvider = exports.SDK_VERSION = void 0;
      exports.SDK_VERSION = "3.22.0";
      var metadata = {
        sdkVersion: exports.SDK_VERSION,
        sdkType: "js-mono"
        // js-mono is overwritten by Precomp and OnDevice clients
      };
      exports.StatsigMetadataProvider = {
        get: () => metadata,
        add: (additions) => {
          metadata = Object.assign(Object.assign({}, metadata), additions);
        }
      };
    }
  });

  // node_modules/@statsig/client-core/src/ClientInterfaces.js
  var require_ClientInterfaces = __commonJS({
    "node_modules/@statsig/client-core/src/ClientInterfaces.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
    }
  });

  // node_modules/@statsig/client-core/src/UUID.js
  var require_UUID = __commonJS({
    "node_modules/@statsig/client-core/src/UUID.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getUUID = void 0;
      function getUUID() {
        if (typeof crypto !== "undefined" && typeof crypto.randomUUID === "function") {
          return crypto.randomUUID();
        }
        let d = (/* @__PURE__ */ new Date()).getTime();
        let d2 = typeof performance !== "undefined" && performance.now && performance.now() * 1e3 || 0;
        const y = "89ab"[Math.floor(Math.random() * 4)];
        return `xxxxxxxx-xxxx-4xxx-${y}xxx-xxxxxxxxxxxx`.replace(/[xy]/g, (c) => {
          let r = Math.random() * 16;
          if (d > 0) {
            r = (d + r) % 16 | 0;
            d = Math.floor(d / 16);
          } else {
            r = (d2 + r) % 16 | 0;
            d2 = Math.floor(d2 / 16);
          }
          return (c === "x" ? r : r & 7 | 8).toString(16);
        });
      }
      exports.getUUID = getUUID;
    }
  });

  // node_modules/@statsig/client-core/src/StableID.js
  var require_StableID = __commonJS({
    "node_modules/@statsig/client-core/src/StableID.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.StableID = void 0;
      var CacheKey_1 = require_CacheKey();
      var Log_1 = require_Log();
      var SafeJs_1 = require_SafeJs();
      var StorageProvider_1 = require_StorageProvider();
      var UUID_1 = require_UUID();
      var PROMISE_MAP = {};
      var COOKIE_ENABLED_MAP = {};
      var DISABLED_MAP = {};
      exports.StableID = {
        cookiesEnabled: false,
        randomID: Math.random().toString(36),
        get: (sdkKey) => {
          if (DISABLED_MAP[sdkKey]) {
            return null;
          }
          if (PROMISE_MAP[sdkKey] != null) {
            return PROMISE_MAP[sdkKey];
          }
          let stableID = null;
          stableID = _loadFromCookie(sdkKey);
          if (stableID != null) {
            PROMISE_MAP[sdkKey] = stableID;
            _persistToStorage(stableID, sdkKey);
            return stableID;
          }
          stableID = _loadFromStorage(sdkKey);
          if (stableID == null) {
            stableID = (0, UUID_1.getUUID)();
          }
          _persistToStorage(stableID, sdkKey);
          _persistToCookie(stableID, sdkKey);
          PROMISE_MAP[sdkKey] = stableID;
          return stableID;
        },
        setOverride: (override, sdkKey) => {
          PROMISE_MAP[sdkKey] = override;
          _persistToStorage(override, sdkKey);
          _persistToCookie(override, sdkKey);
        },
        _setCookiesEnabled: (sdkKey, cookiesEnabled) => {
          COOKIE_ENABLED_MAP[sdkKey] = cookiesEnabled;
        },
        _setDisabled: (sdkKey, disabled) => {
          DISABLED_MAP[sdkKey] = disabled;
        }
      };
      function _getStableIDStorageKey(sdkKey) {
        return `statsig.stable_id.${(0, CacheKey_1._getStorageKey)(sdkKey)}`;
      }
      function _persistToStorage(stableID, sdkKey) {
        const storageKey = _getStableIDStorageKey(sdkKey);
        try {
          (0, StorageProvider_1._setObjectInStorage)(storageKey, stableID);
        } catch (e) {
          Log_1.Log.warn("Failed to save StableID to storage");
        }
      }
      function _loadFromStorage(sdkKey) {
        const storageKey = _getStableIDStorageKey(sdkKey);
        return (0, StorageProvider_1._getObjectFromStorage)(storageKey);
      }
      function _loadFromCookie(sdkKey) {
        if (!COOKIE_ENABLED_MAP[sdkKey] || (0, SafeJs_1._getDocumentSafe)() == null) {
          return null;
        }
        const cookies = document.cookie.split(";");
        for (const cookie of cookies) {
          const [key, value] = cookie.trim().split("=");
          if (key === _getCookieName(sdkKey)) {
            return decodeURIComponent(value);
          }
        }
        return null;
      }
      function _persistToCookie(stableID, sdkKey) {
        if (!COOKIE_ENABLED_MAP[sdkKey] || !document) {
          return;
        }
        const expiryDate = /* @__PURE__ */ new Date();
        expiryDate.setFullYear(expiryDate.getFullYear() + 1);
        document.cookie = `${_getCookieName(sdkKey)}=${encodeURIComponent(stableID)}; expires=${expiryDate.toUTCString()}; path=/`;
      }
      function _getCookieName(sdkKey) {
        return `statsig.stable_id.${(0, CacheKey_1._getStorageKey)(sdkKey)}`;
      }
    }
  });

  // node_modules/@statsig/client-core/src/StatsigUser.js
  var require_StatsigUser = __commonJS({
    "node_modules/@statsig/client-core/src/StatsigUser.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports._getFullUserHash = exports._normalizeUser = void 0;
      var Hashing_1 = require_Hashing();
      var Log_1 = require_Log();
      function _normalizeUser(original, options2, fallbackEnvironment) {
        try {
          const copy2 = JSON.parse(JSON.stringify(original));
          if (options2 != null && options2.environment != null) {
            copy2.statsigEnvironment = options2.environment;
          } else if (fallbackEnvironment != null) {
            copy2.statsigEnvironment = { tier: fallbackEnvironment };
          }
          return copy2;
        } catch (error) {
          Log_1.Log.error("Failed to JSON.stringify user");
          return { statsigEnvironment: void 0 };
        }
      }
      exports._normalizeUser = _normalizeUser;
      function _getFullUserHash(user) {
        return user ? (0, Hashing_1._DJB2Object)(user) : null;
      }
      exports._getFullUserHash = _getFullUserHash;
    }
  });

  // node_modules/@statsig/client-core/src/TypedJsonParse.js
  var require_TypedJsonParse = __commonJS({
    "node_modules/@statsig/client-core/src/TypedJsonParse.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports._typedJsonParse = void 0;
      var Log_1 = require_Log();
      function _typedJsonParse(data, guard, typeName) {
        try {
          const result2 = JSON.parse(data);
          if (result2 && typeof result2 === "object" && guard in result2) {
            return result2;
          }
        } catch (_a2) {
        }
        Log_1.Log.error(`Failed to parse ${typeName}`);
        return null;
      }
      exports._typedJsonParse = _typedJsonParse;
    }
  });

  // node_modules/@statsig/client-core/src/DataAdapterCore.js
  var require_DataAdapterCore = __commonJS({
    "node_modules/@statsig/client-core/src/DataAdapterCore.js"(exports) {
      "use strict";
      var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result2) {
            result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports._makeDataAdapterResult = exports.DataAdapterCore = void 0;
      var Log_1 = require_Log();
      var StableID_1 = require_StableID();
      var StatsigUser_1 = require_StatsigUser();
      var StorageProvider_1 = require_StorageProvider();
      var TypedJsonParse_1 = require_TypedJsonParse();
      var CACHE_LIMIT = 10;
      var DataAdapterCore = class {
        constructor(_adapterName, _cacheSuffix) {
          this._adapterName = _adapterName;
          this._cacheSuffix = _cacheSuffix;
          this._options = null;
          this._sdkKey = null;
          this._lastModifiedStoreKey = `statsig.last_modified_time.${_cacheSuffix}`;
          this._inMemoryCache = new InMemoryCache2();
        }
        attach(sdkKey, options2, _network) {
          this._sdkKey = sdkKey;
          this._options = options2;
        }
        getDataSync(user) {
          const normalized = user && (0, StatsigUser_1._normalizeUser)(user, this._options);
          const cacheKey = this._getCacheKey(normalized);
          const inMem = this._inMemoryCache.get(cacheKey, normalized);
          if (inMem && this._getIsCacheValueValid(inMem)) {
            return inMem;
          }
          const cache = this._loadFromCache(cacheKey);
          if (cache && this._getIsCacheValueValid(cache)) {
            this._inMemoryCache.add(cacheKey, cache);
            return this._inMemoryCache.get(cacheKey, normalized);
          }
          return null;
        }
        setData(data, user) {
          const normalized = user && (0, StatsigUser_1._normalizeUser)(user, this._options);
          const cacheKey = this._getCacheKey(normalized);
          this._inMemoryCache.add(cacheKey, _makeDataAdapterResult("Bootstrap", data, null, normalized));
        }
        _getIsCacheValueValid(current) {
          return current.stableID == null || current.stableID === StableID_1.StableID.get(this._getSdkKey());
        }
        _getDataAsyncImpl(current, user, options2) {
          return __awaiter2(this, void 0, void 0, function* () {
            if (!StorageProvider_1.Storage.isReady()) {
              yield StorageProvider_1.Storage.isReadyResolver();
            }
            const cache = current !== null && current !== void 0 ? current : this.getDataSync(user);
            const ops = [this._fetchAndPrepFromNetwork(cache, user, options2)];
            if (options2 === null || options2 === void 0 ? void 0 : options2.timeoutMs) {
              ops.push(new Promise((r) => setTimeout(r, options2.timeoutMs)).then(() => {
                Log_1.Log.debug("Fetching latest value timed out");
                return null;
              }));
            }
            return yield Promise.race(ops);
          });
        }
        _prefetchDataImpl(user, options2) {
          return __awaiter2(this, void 0, void 0, function* () {
            const normalized = user && (0, StatsigUser_1._normalizeUser)(user, this._options);
            const cacheKey = this._getCacheKey(normalized);
            const result2 = yield this._getDataAsyncImpl(null, normalized, options2);
            if (result2) {
              this._inMemoryCache.add(cacheKey, Object.assign(Object.assign({}, result2), { source: "Prefetch" }));
            }
          });
        }
        _fetchAndPrepFromNetwork(cachedResult, user, options2) {
          return __awaiter2(this, void 0, void 0, function* () {
            var _a2;
            const cachedData = (_a2 = cachedResult === null || cachedResult === void 0 ? void 0 : cachedResult.data) !== null && _a2 !== void 0 ? _a2 : null;
            const isCacheValidFor204 = cachedResult != null && this._isCachedResultValidFor204(cachedResult, user);
            const latest = yield this._fetchFromNetwork(cachedData, user, options2, isCacheValidFor204);
            if (!latest) {
              Log_1.Log.debug("No response returned for latest value");
              return null;
            }
            const response = (0, TypedJsonParse_1._typedJsonParse)(latest, "has_updates", "Response");
            const sdkKey = this._getSdkKey();
            const stableID = StableID_1.StableID.get(sdkKey);
            let result2 = null;
            if ((response === null || response === void 0 ? void 0 : response.has_updates) === true) {
              result2 = _makeDataAdapterResult("Network", latest, stableID, user);
            } else if (cachedData && (response === null || response === void 0 ? void 0 : response.has_updates) === false) {
              result2 = _makeDataAdapterResult("NetworkNotModified", cachedData, stableID, user);
            } else {
              return null;
            }
            const cacheKey = this._getCacheKey(user);
            this._inMemoryCache.add(cacheKey, result2);
            this._writeToCache(cacheKey, result2);
            return result2;
          });
        }
        _getSdkKey() {
          if (this._sdkKey != null) {
            return this._sdkKey;
          }
          Log_1.Log.error(`${this._adapterName} is not attached to a Client`);
          return "";
        }
        _loadFromCache(cacheKey) {
          var _a2;
          const cache = (_a2 = StorageProvider_1.Storage.getItem) === null || _a2 === void 0 ? void 0 : _a2.call(StorageProvider_1.Storage, cacheKey);
          if (cache == null) {
            return null;
          }
          const result2 = (0, TypedJsonParse_1._typedJsonParse)(cache, "source", "Cached Result");
          return result2 ? Object.assign(Object.assign({}, result2), { source: "Cache" }) : null;
        }
        _writeToCache(cacheKey, result2) {
          StorageProvider_1.Storage.setItem(cacheKey, JSON.stringify(result2));
          this._runLocalStorageCacheEviction(cacheKey);
        }
        _runLocalStorageCacheEviction(cacheKey) {
          var _a2;
          const lastModifiedTimeMap = (_a2 = (0, StorageProvider_1._getObjectFromStorage)(this._lastModifiedStoreKey)) !== null && _a2 !== void 0 ? _a2 : {};
          lastModifiedTimeMap[cacheKey] = Date.now();
          const evictable = _getEvictableKey(lastModifiedTimeMap, CACHE_LIMIT);
          if (evictable) {
            delete lastModifiedTimeMap[evictable];
            StorageProvider_1.Storage.removeItem(evictable);
          }
          (0, StorageProvider_1._setObjectInStorage)(this._lastModifiedStoreKey, lastModifiedTimeMap);
        }
      };
      exports.DataAdapterCore = DataAdapterCore;
      function _makeDataAdapterResult(source2, data, stableID, user) {
        return {
          source: source2,
          data,
          receivedAt: Date.now(),
          stableID,
          fullUserHash: (0, StatsigUser_1._getFullUserHash)(user)
        };
      }
      exports._makeDataAdapterResult = _makeDataAdapterResult;
      var InMemoryCache2 = class {
        constructor() {
          this._data = {};
        }
        get(cacheKey, user) {
          var _a2;
          const result2 = this._data[cacheKey];
          const cached = result2 === null || result2 === void 0 ? void 0 : result2.stableID;
          const provided = (_a2 = user === null || user === void 0 ? void 0 : user.customIDs) === null || _a2 === void 0 ? void 0 : _a2.stableID;
          if (provided && cached && provided !== cached) {
            Log_1.Log.warn("'StatsigUser.customIDs.stableID' mismatch");
            return null;
          }
          return result2;
        }
        add(cacheKey, value) {
          const oldest = _getEvictableKey(this._data, CACHE_LIMIT - 1);
          if (oldest) {
            delete this._data[oldest];
          }
          this._data[cacheKey] = value;
        }
        merge(values) {
          this._data = Object.assign(Object.assign({}, this._data), values);
        }
      };
      function _getEvictableKey(data, limit) {
        const keys = Object.keys(data);
        if (keys.length <= limit) {
          return null;
        }
        return keys.reduce((prevKey, currKey) => {
          const prev2 = data[prevKey];
          const current = data[currKey];
          if (typeof prev2 === "object" && typeof current === "object") {
            return current.receivedAt < prev2.receivedAt ? currKey : prevKey;
          }
          return current < prev2 ? currKey : prevKey;
        });
      }
    }
  });

  // node_modules/@statsig/client-core/src/DownloadConfigSpecsResponse.js
  var require_DownloadConfigSpecsResponse = __commonJS({
    "node_modules/@statsig/client-core/src/DownloadConfigSpecsResponse.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
    }
  });

  // node_modules/@statsig/client-core/src/SDKType.js
  var require_SDKType = __commonJS({
    "node_modules/@statsig/client-core/src/SDKType.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SDKType = void 0;
      var SDK_CLIENT = {};
      var suffix;
      exports.SDKType = {
        _get: (sdkKey) => {
          var _a2;
          return ((_a2 = SDK_CLIENT[sdkKey]) !== null && _a2 !== void 0 ? _a2 : "js-mono") + (suffix !== null && suffix !== void 0 ? suffix : "");
        },
        _setClientType(sdkKey, client2) {
          SDK_CLIENT[sdkKey] = client2;
        },
        _setBindingType(binding) {
          if (!suffix || suffix === "-react") {
            suffix = "-" + binding;
          }
        }
      };
    }
  });

  // node_modules/@statsig/client-core/src/ErrorBoundary.js
  var require_ErrorBoundary = __commonJS({
    "node_modules/@statsig/client-core/src/ErrorBoundary.js"(exports) {
      "use strict";
      var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result2) {
            result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ErrorBoundary = exports.EXCEPTION_ENDPOINT = void 0;
      var Log_1 = require_Log();
      var SDKType_1 = require_SDKType();
      var StatsigMetadata_1 = require_StatsigMetadata();
      exports.EXCEPTION_ENDPOINT = "https://statsigapi.net/v1/sdk_exception";
      var UNKNOWN_ERROR = "[Statsig] UnknownError";
      var ErrorBoundary = class {
        constructor(_sdkKey, _options, _emitter, _lastSeenError) {
          this._sdkKey = _sdkKey;
          this._options = _options;
          this._emitter = _emitter;
          this._lastSeenError = _lastSeenError;
          this._seen = /* @__PURE__ */ new Set();
        }
        wrap(instance) {
          try {
            const obj = instance;
            _getAllInstanceMethodNames(obj).forEach((name) => {
              const original = obj[name];
              if ("$EB" in original) {
                return;
              }
              obj[name] = (...args) => {
                return this._capture(name, () => original.apply(instance, args));
              };
              obj[name].$EB = true;
            });
          } catch (err) {
            this._onError("eb:wrap", err);
          }
        }
        logError(tag, error) {
          this._onError(tag, error);
        }
        getLastSeenErrorAndReset() {
          const tempError = this._lastSeenError;
          this._lastSeenError = void 0;
          return tempError !== null && tempError !== void 0 ? tempError : null;
        }
        attachErrorIfNoneExists(error) {
          if (this._lastSeenError) {
            return;
          }
          this._lastSeenError = _resolveError(error);
        }
        _capture(tag, task) {
          try {
            const res = task();
            if (res && res instanceof Promise) {
              return res.catch((err) => this._onError(tag, err));
            }
            return res;
          } catch (error) {
            this._onError(tag, error);
            return null;
          }
        }
        _onError(tag, error) {
          try {
            Log_1.Log.warn(`Caught error in ${tag}`, { error });
            const impl = () => __awaiter2(this, void 0, void 0, function* () {
              var _a2, _b, _c, _d, _e, _f, _g;
              const unwrapped = error ? error : Error(UNKNOWN_ERROR);
              const isError = unwrapped instanceof Error;
              const name = isError ? unwrapped.name : "No Name";
              const resolvedError = _resolveError(unwrapped);
              this._lastSeenError = resolvedError;
              if (this._seen.has(name)) {
                return;
              }
              this._seen.add(name);
              if ((_b = (_a2 = this._options) === null || _a2 === void 0 ? void 0 : _a2.networkConfig) === null || _b === void 0 ? void 0 : _b.preventAllNetworkTraffic) {
                (_c = this._emitter) === null || _c === void 0 ? void 0 : _c.call(this, {
                  name: "error",
                  error,
                  tag
                });
                return;
              }
              const sdkType = SDKType_1.SDKType._get(this._sdkKey);
              const statsigMetadata = StatsigMetadata_1.StatsigMetadataProvider.get();
              const info = isError ? unwrapped.stack : _getDescription(unwrapped);
              const body = Object.assign({ tag, exception: name, info, statsigOptions: _getStatsigOptionLoggingCopy(this._options) }, Object.assign(Object.assign({}, statsigMetadata), { sdkType }));
              const func = (_f = (_e = (_d = this._options) === null || _d === void 0 ? void 0 : _d.networkConfig) === null || _e === void 0 ? void 0 : _e.networkOverrideFunc) !== null && _f !== void 0 ? _f : fetch;
              yield func(exports.EXCEPTION_ENDPOINT, {
                method: "POST",
                headers: {
                  "STATSIG-API-KEY": this._sdkKey,
                  "STATSIG-SDK-TYPE": String(sdkType),
                  "STATSIG-SDK-VERSION": String(statsigMetadata.sdkVersion),
                  "Content-Type": "application/json"
                },
                body: JSON.stringify(body)
              });
              (_g = this._emitter) === null || _g === void 0 ? void 0 : _g.call(this, {
                name: "error",
                error,
                tag
              });
            });
            impl().then(() => {
            }).catch(() => {
            });
          } catch (_error) {
          }
        }
      };
      exports.ErrorBoundary = ErrorBoundary;
      function _resolveError(error) {
        if (error instanceof Error) {
          return error;
        } else if (typeof error === "string") {
          return new Error(error);
        } else {
          return new Error("An unknown error occurred.");
        }
      }
      function _getDescription(obj) {
        try {
          return JSON.stringify(obj);
        } catch (_a2) {
          return UNKNOWN_ERROR;
        }
      }
      function _getAllInstanceMethodNames(instance) {
        const names = /* @__PURE__ */ new Set();
        let proto = Object.getPrototypeOf(instance);
        while (proto && proto !== Object.prototype) {
          Object.getOwnPropertyNames(proto).filter((prop) => typeof (proto === null || proto === void 0 ? void 0 : proto[prop]) === "function").forEach((name) => names.add(name));
          proto = Object.getPrototypeOf(proto);
        }
        return Array.from(names);
      }
      function _getStatsigOptionLoggingCopy(options2) {
        if (!options2) {
          return {};
        }
        const loggingCopy = {};
        Object.entries(options2).forEach(([option, value]) => {
          const valueType = typeof value;
          switch (valueType) {
            case "number":
            case "bigint":
            case "boolean":
              loggingCopy[String(option)] = value;
              break;
            case "string":
              if (value.length < 50) {
                loggingCopy[String(option)] = value;
              } else {
                loggingCopy[String(option)] = "set";
              }
              break;
            case "object":
              if (option === "environment") {
                loggingCopy["environment"] = value;
              } else if (option === "networkConfig") {
                loggingCopy["networkConfig"] = value;
              } else {
                loggingCopy[String(option)] = value != null ? "set" : "unset";
              }
              break;
            default:
          }
        });
        return loggingCopy;
      }
    }
  });

  // node_modules/@statsig/client-core/src/EvaluationOptions.js
  var require_EvaluationOptions = __commonJS({
    "node_modules/@statsig/client-core/src/EvaluationOptions.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
    }
  });

  // node_modules/@statsig/client-core/src/EvaluationTypes.js
  var require_EvaluationTypes = __commonJS({
    "node_modules/@statsig/client-core/src/EvaluationTypes.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
    }
  });

  // node_modules/@statsig/client-core/src/InitializeResponse.js
  var require_InitializeResponse = __commonJS({
    "node_modules/@statsig/client-core/src/InitializeResponse.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
    }
  });

  // node_modules/@statsig/client-core/src/MemoKey.js
  var require_MemoKey = __commonJS({
    "node_modules/@statsig/client-core/src/MemoKey.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.createMemoKey = exports.MemoPrefix = void 0;
      exports.MemoPrefix = {
        _gate: "g",
        _dynamicConfig: "c",
        _experiment: "e",
        _configList: "cl",
        _layer: "l",
        _paramStore: "p"
      };
      var EXIST_KEYS = /* @__PURE__ */ new Set([
        // Add keys that should be memoized based only on their existence, not their value
      ]);
      var DO_NOT_MEMO_KEYS = /* @__PURE__ */ new Set([
        // Add keys that if exist, should not be memoized
        "userPersistedValues"
      ]);
      function createMemoKey(prefix3, name, options2) {
        let cacheKey = `${prefix3}|${name}`;
        if (!options2) {
          return cacheKey;
        }
        for (const key of Object.keys(options2)) {
          if (DO_NOT_MEMO_KEYS.has(key)) {
            return void 0;
          }
          if (EXIST_KEYS.has(key)) {
            cacheKey += `|${key}=true`;
          } else {
            cacheKey += `|${key}=${options2[key]}`;
          }
        }
        return cacheKey;
      }
      exports.createMemoKey = createMemoKey;
    }
  });

  // node_modules/@statsig/client-core/src/DnsTxtQuery.js
  var require_DnsTxtQuery = __commonJS({
    "node_modules/@statsig/client-core/src/DnsTxtQuery.js"(exports) {
      "use strict";
      var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result2) {
            result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports._fetchTxtRecords = void 0;
      var FEATURE_ASSETS_DNS_QUERY = new Uint8Array([
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        13,
        102,
        101,
        97,
        116,
        117,
        114,
        101,
        97,
        115,
        115,
        101,
        116,
        115,
        3,
        111,
        114,
        103,
        0,
        0,
        16,
        0,
        1
      ]);
      var DNS_QUERY_ENDPOINT = "https://cloudflare-dns.com/dns-query";
      var DOMAIN_CHARS = [
        "i",
        // initialize
        "e",
        // events
        "d"
        // dcs
      ];
      var MAX_START_LOOKUP = 200;
      function _fetchTxtRecords(networkFunc) {
        return __awaiter2(this, void 0, void 0, function* () {
          const response = yield networkFunc(DNS_QUERY_ENDPOINT, {
            method: "POST",
            headers: {
              "Content-Type": "application/dns-message",
              Accept: "application/dns-message"
            },
            body: FEATURE_ASSETS_DNS_QUERY
          });
          if (!response.ok) {
            const err = new Error("Failed to fetch TXT records from DNS");
            err.name = "DnsTxtFetchError";
            throw err;
          }
          const data = yield response.arrayBuffer();
          const bytes = new Uint8Array(data);
          return _parseDnsResponse(bytes);
        });
      }
      exports._fetchTxtRecords = _fetchTxtRecords;
      function _parseDnsResponse(input) {
        const start3 = input.findIndex((byte, index2) => index2 < MAX_START_LOOKUP && String.fromCharCode(byte) === "=" && DOMAIN_CHARS.includes(String.fromCharCode(input[index2 - 1])));
        if (start3 === -1) {
          const err = new Error("Failed to parse TXT records from DNS");
          err.name = "DnsTxtParseError";
          throw err;
        }
        let result2 = "";
        for (let i = start3 - 1; i < input.length; i++) {
          result2 += String.fromCharCode(input[i]);
        }
        return result2.split(",");
      }
    }
  });

  // node_modules/@statsig/client-core/src/NetworkFallbackResolver.js
  var require_NetworkFallbackResolver = __commonJS({
    "node_modules/@statsig/client-core/src/NetworkFallbackResolver.js"(exports) {
      "use strict";
      var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result2) {
            result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports._isDomainFailure = exports.NetworkFallbackResolver = void 0;
      var DnsTxtQuery_1 = require_DnsTxtQuery();
      var Hashing_1 = require_Hashing();
      var Log_1 = require_Log();
      var StorageProvider_1 = require_StorageProvider();
      var DEFAULT_TTL_MS = 7 * 24 * 60 * 60 * 1e3;
      var COOLDOWN_TIME_MS = 4 * 60 * 60 * 1e3;
      var NetworkFallbackResolver = class {
        constructor(options2) {
          var _a2;
          this._fallbackInfo = null;
          this._errorBoundary = null;
          this._dnsQueryCooldowns = {};
          this._networkOverrideFunc = (_a2 = options2.networkConfig) === null || _a2 === void 0 ? void 0 : _a2.networkOverrideFunc;
        }
        setErrorBoundary(errorBoundary) {
          this._errorBoundary = errorBoundary;
        }
        tryBumpExpiryTime(sdkKey, urlConfig) {
          var _a2;
          const info = (_a2 = this._fallbackInfo) === null || _a2 === void 0 ? void 0 : _a2[urlConfig.endpoint];
          if (!info) {
            return;
          }
          info.expiryTime = Date.now() + DEFAULT_TTL_MS;
          _tryWriteFallbackInfoToCache(sdkKey, Object.assign(Object.assign({}, this._fallbackInfo), { [urlConfig.endpoint]: info }));
        }
        getActiveFallbackUrl(sdkKey, urlConfig) {
          var _a2, _b;
          if (urlConfig.customUrl != null && urlConfig.fallbackUrls != null) {
            return null;
          }
          let info = this._fallbackInfo;
          if (info == null) {
            info = (_a2 = _readFallbackInfoFromCache(sdkKey)) !== null && _a2 !== void 0 ? _a2 : {};
            this._fallbackInfo = info;
          }
          const entry = info[urlConfig.endpoint];
          if (!entry || Date.now() > ((_b = entry.expiryTime) !== null && _b !== void 0 ? _b : 0) || urlConfig.getChecksum() !== entry.urlConfigChecksum) {
            delete info[urlConfig.endpoint];
            this._fallbackInfo = info;
            _tryWriteFallbackInfoToCache(sdkKey, this._fallbackInfo);
            return null;
          }
          if (entry.url) {
            return entry.url;
          }
          return null;
        }
        tryFetchUpdatedFallbackInfo(sdkKey, urlConfig, errorMessage, timedOut) {
          return __awaiter2(this, void 0, void 0, function* () {
            var _a2, _b;
            try {
              if (!_isDomainFailure(errorMessage, timedOut)) {
                return false;
              }
              const canUseNetworkFallbacks = urlConfig.customUrl == null && urlConfig.fallbackUrls == null;
              const urls = canUseNetworkFallbacks ? yield this._tryFetchFallbackUrlsFromNetwork(urlConfig) : urlConfig.fallbackUrls;
              const newUrl = this._pickNewFallbackUrl((_a2 = this._fallbackInfo) === null || _a2 === void 0 ? void 0 : _a2[urlConfig.endpoint], urls);
              if (!newUrl) {
                return false;
              }
              this._updateFallbackInfoWithNewUrl(sdkKey, urlConfig, newUrl);
              return true;
            } catch (error) {
              (_b = this._errorBoundary) === null || _b === void 0 ? void 0 : _b.logError("tryFetchUpdatedFallbackInfo", error);
              return false;
            }
          });
        }
        _updateFallbackInfoWithNewUrl(sdkKey, urlConfig, newUrl) {
          var _a2, _b, _c;
          const newFallbackInfo = {
            urlConfigChecksum: urlConfig.getChecksum(),
            url: newUrl,
            expiryTime: Date.now() + DEFAULT_TTL_MS,
            previous: []
          };
          const endpoint = urlConfig.endpoint;
          const previousInfo = (_a2 = this._fallbackInfo) === null || _a2 === void 0 ? void 0 : _a2[endpoint];
          if (previousInfo) {
            newFallbackInfo.previous.push(...previousInfo.previous);
          }
          if (newFallbackInfo.previous.length > 10) {
            newFallbackInfo.previous = [];
          }
          const previousUrl = (_c = (_b = this._fallbackInfo) === null || _b === void 0 ? void 0 : _b[endpoint]) === null || _c === void 0 ? void 0 : _c.url;
          if (previousUrl != null) {
            newFallbackInfo.previous.push(previousUrl);
          }
          this._fallbackInfo = Object.assign(Object.assign({}, this._fallbackInfo), { [endpoint]: newFallbackInfo });
          _tryWriteFallbackInfoToCache(sdkKey, this._fallbackInfo);
        }
        _tryFetchFallbackUrlsFromNetwork(urlConfig) {
          return __awaiter2(this, void 0, void 0, function* () {
            var _a2;
            const cooldown = this._dnsQueryCooldowns[urlConfig.endpoint];
            if (cooldown && Date.now() < cooldown) {
              return null;
            }
            this._dnsQueryCooldowns[urlConfig.endpoint] = Date.now() + COOLDOWN_TIME_MS;
            const result2 = [];
            const records = yield (0, DnsTxtQuery_1._fetchTxtRecords)((_a2 = this._networkOverrideFunc) !== null && _a2 !== void 0 ? _a2 : fetch);
            const path = _extractPathFromUrl(urlConfig.defaultUrl);
            for (const record of records) {
              if (!record.startsWith(urlConfig.endpointDnsKey + "=")) {
                continue;
              }
              const parts = record.split("=");
              if (parts.length > 1) {
                let baseUrl = parts[1];
                if (baseUrl.endsWith("/")) {
                  baseUrl = baseUrl.slice(0, -1);
                }
                result2.push(`https://${baseUrl}${path}`);
              }
            }
            return result2;
          });
        }
        _pickNewFallbackUrl(currentFallbackInfo, urls) {
          var _a2;
          if (urls == null) {
            return null;
          }
          const previouslyUsed = new Set((_a2 = currentFallbackInfo === null || currentFallbackInfo === void 0 ? void 0 : currentFallbackInfo.previous) !== null && _a2 !== void 0 ? _a2 : []);
          const currentFallbackUrl = currentFallbackInfo === null || currentFallbackInfo === void 0 ? void 0 : currentFallbackInfo.url;
          let found = null;
          for (const loopUrl of urls) {
            const url = loopUrl.endsWith("/") ? loopUrl.slice(0, -1) : loopUrl;
            if (!previouslyUsed.has(loopUrl) && url !== currentFallbackUrl) {
              found = url;
              break;
            }
          }
          return found;
        }
      };
      exports.NetworkFallbackResolver = NetworkFallbackResolver;
      function _isDomainFailure(errorMsg, timedOut) {
        var _a2;
        const lowerErrorMsg = (_a2 = errorMsg === null || errorMsg === void 0 ? void 0 : errorMsg.toLowerCase()) !== null && _a2 !== void 0 ? _a2 : "";
        return timedOut || lowerErrorMsg.includes("uncaught exception") || lowerErrorMsg.includes("failed to fetch") || lowerErrorMsg.includes("networkerror when attempting to fetch resource");
      }
      exports._isDomainFailure = _isDomainFailure;
      function _getFallbackInfoStorageKey(sdkKey) {
        return `statsig.network_fallback.${(0, Hashing_1._DJB2)(sdkKey)}`;
      }
      function _tryWriteFallbackInfoToCache(sdkKey, info) {
        const hashKey = _getFallbackInfoStorageKey(sdkKey);
        if (!info || Object.keys(info).length === 0) {
          StorageProvider_1.Storage.removeItem(hashKey);
          return;
        }
        StorageProvider_1.Storage.setItem(hashKey, JSON.stringify(info));
      }
      function _readFallbackInfoFromCache(sdkKey) {
        const hashKey = _getFallbackInfoStorageKey(sdkKey);
        const data = StorageProvider_1.Storage.getItem(hashKey);
        if (!data) {
          return null;
        }
        try {
          return JSON.parse(data);
        } catch (_a2) {
          Log_1.Log.error("Failed to parse FallbackInfo");
          return null;
        }
      }
      function _extractPathFromUrl(urlString) {
        try {
          const url = new URL(urlString);
          return url.pathname;
        } catch (error) {
          return null;
        }
      }
    }
  });

  // node_modules/@statsig/client-core/src/SDKFlags.js
  var require_SDKFlags = __commonJS({
    "node_modules/@statsig/client-core/src/SDKFlags.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SDKFlags = void 0;
      var FLAGMAP = {};
      exports.SDKFlags = {
        setFlags: (sdkKey, flags) => {
          FLAGMAP[sdkKey] = flags;
        },
        get: (sdkKey, flagKey) => {
          var _a2, _b;
          return (_b = (_a2 = FLAGMAP[sdkKey]) === null || _a2 === void 0 ? void 0 : _a2[flagKey]) !== null && _b !== void 0 ? _b : false;
        }
      };
    }
  });

  // node_modules/@statsig/client-core/src/SessionID.js
  var require_SessionID = __commonJS({
    "node_modules/@statsig/client-core/src/SessionID.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.StatsigSession = exports.SessionID = void 0;
      var __StatsigGlobal_1 = require_StatsigGlobal();
      var CacheKey_1 = require_CacheKey();
      var Log_1 = require_Log();
      var StorageProvider_1 = require_StorageProvider();
      var UUID_1 = require_UUID();
      var MAX_SESSION_IDLE_TIME = 30 * 60 * 1e3;
      var MAX_SESSION_AGE = 4 * 60 * 60 * 1e3;
      var PROMISE_MAP = {};
      exports.SessionID = {
        get: (sdkKey) => {
          return exports.StatsigSession.get(sdkKey).data.sessionID;
        }
      };
      exports.StatsigSession = {
        get: (sdkKey) => {
          if (PROMISE_MAP[sdkKey] == null) {
            PROMISE_MAP[sdkKey] = _loadSession(sdkKey);
          }
          const session = PROMISE_MAP[sdkKey];
          return _bumpSession(session);
        },
        overrideInitialSessionID: (override, sdkKey) => {
          PROMISE_MAP[sdkKey] = _overrideSessionId(override, sdkKey);
        }
      };
      function _loadSession(sdkKey) {
        let data = _loadFromStorage(sdkKey);
        const now2 = Date.now();
        if (!data) {
          data = {
            sessionID: (0, UUID_1.getUUID)(),
            startTime: now2,
            lastUpdate: now2
          };
        }
        return {
          data,
          sdkKey
        };
      }
      function _overrideSessionId(override, sdkKey) {
        const now2 = Date.now();
        return {
          data: {
            sessionID: override,
            startTime: now2,
            lastUpdate: now2
          },
          sdkKey
        };
      }
      function _bumpSession(session) {
        const now2 = Date.now();
        const data = session.data;
        const sdkKey = session.sdkKey;
        if (_isIdle(data) || _hasRunTooLong(data)) {
          data.sessionID = (0, UUID_1.getUUID)();
          data.startTime = now2;
          const client2 = __STATSIG__ === null || __STATSIG__ === void 0 ? void 0 : __STATSIG__.instance(sdkKey);
          if (client2) {
            client2.$emt({ name: "session_expired" });
          }
        }
        data.lastUpdate = now2;
        _persistToStorage(data, session.sdkKey);
        clearTimeout(session.idleTimeoutID);
        clearTimeout(session.ageTimeoutID);
        const lifetime = now2 - data.startTime;
        session.idleTimeoutID = _createSessionTimeout(sdkKey, MAX_SESSION_IDLE_TIME);
        session.ageTimeoutID = _createSessionTimeout(sdkKey, MAX_SESSION_AGE - lifetime);
        return session;
      }
      function _createSessionTimeout(sdkKey, duration) {
        return setTimeout(() => {
          var _a2;
          const client2 = (_a2 = (0, __StatsigGlobal_1._getStatsigGlobal)()) === null || _a2 === void 0 ? void 0 : _a2.instance(sdkKey);
          if (client2) {
            client2.$emt({ name: "session_expired" });
          }
        }, duration);
      }
      function _isIdle({ lastUpdate }) {
        return Date.now() - lastUpdate > MAX_SESSION_IDLE_TIME;
      }
      function _hasRunTooLong({ startTime }) {
        return Date.now() - startTime > MAX_SESSION_AGE;
      }
      function _getSessionIDStorageKey(sdkKey) {
        return `statsig.session_id.${(0, CacheKey_1._getStorageKey)(sdkKey)}`;
      }
      function _persistToStorage(session, sdkKey) {
        const storageKey = _getSessionIDStorageKey(sdkKey);
        try {
          (0, StorageProvider_1._setObjectInStorage)(storageKey, session);
        } catch (e) {
          Log_1.Log.warn("Failed to save SessionID");
        }
      }
      function _loadFromStorage(sdkKey) {
        const storageKey = _getSessionIDStorageKey(sdkKey);
        return (0, StorageProvider_1._getObjectFromStorage)(storageKey);
      }
    }
  });

  // node_modules/@statsig/client-core/src/StatsigClientEventEmitter.js
  var require_StatsigClientEventEmitter = __commonJS({
    "node_modules/@statsig/client-core/src/StatsigClientEventEmitter.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ErrorTag = void 0;
      exports.ErrorTag = {
        NetworkError: "NetworkError"
      };
    }
  });

  // node_modules/@statsig/client-core/src/NetworkCore.js
  var require_NetworkCore = __commonJS({
    "node_modules/@statsig/client-core/src/NetworkCore.js"(exports) {
      "use strict";
      var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result2) {
            result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.NetworkCore = void 0;
      require_StatsigGlobal();
      var __StatsigGlobal_1 = require_StatsigGlobal();
      var Diagnostics_1 = require_Diagnostics();
      var Log_1 = require_Log();
      var NetworkConfig_1 = require_NetworkConfig();
      var NetworkFallbackResolver_1 = require_NetworkFallbackResolver();
      var SDKFlags_1 = require_SDKFlags();
      var SDKType_1 = require_SDKType();
      var SafeJs_1 = require_SafeJs();
      var SessionID_1 = require_SessionID();
      var StableID_1 = require_StableID();
      var StatsigClientEventEmitter_1 = require_StatsigClientEventEmitter();
      var StatsigMetadata_1 = require_StatsigMetadata();
      var StatsigOptionsCommon_1 = require_StatsigOptionsCommon();
      var VisibilityObserving_1 = require_VisibilityObserving();
      var DEFAULT_TIMEOUT_MS = 1e4;
      var BACKOFF_BASE_MS = 500;
      var BACKOFF_MAX_MS = 3e4;
      var RATE_LIMIT_WINDOW_MS = 1e3;
      var RATE_LIMIT_MAX_REQ_COUNT = 50;
      var LEAK_RATE = RATE_LIMIT_MAX_REQ_COUNT / RATE_LIMIT_WINDOW_MS;
      var RETRYABLE_CODES = /* @__PURE__ */ new Set([408, 500, 502, 503, 504, 522, 524, 599]);
      var NetworkCore = class {
        constructor(options2, _emitter) {
          this._emitter = _emitter;
          this._errorBoundary = null;
          this._timeout = DEFAULT_TIMEOUT_MS;
          this._netConfig = {};
          this._options = {};
          this._leakyBucket = {};
          this._lastUsedInitUrl = null;
          if (options2) {
            this._options = options2;
          }
          if (this._options.networkConfig) {
            this._netConfig = this._options.networkConfig;
          }
          if (this._netConfig.networkTimeoutMs) {
            this._timeout = this._netConfig.networkTimeoutMs;
          }
          this._fallbackResolver = new NetworkFallbackResolver_1.NetworkFallbackResolver(this._options);
          this.setLogEventCompressionMode(this._getLogEventCompressionMode(options2));
        }
        setLogEventCompressionMode(mode) {
          this._options.logEventCompressionMode = mode;
        }
        setErrorBoundary(errorBoundary) {
          this._errorBoundary = errorBoundary;
          this._errorBoundary.wrap(this);
          this._errorBoundary.wrap(this._fallbackResolver);
          this._fallbackResolver.setErrorBoundary(errorBoundary);
        }
        isBeaconSupported() {
          return typeof navigator !== "undefined" && typeof navigator.sendBeacon === "function";
        }
        getLastUsedInitUrlAndReset() {
          const tempUrl = this._lastUsedInitUrl;
          this._lastUsedInitUrl = null;
          return tempUrl;
        }
        beacon(args) {
          if (!_ensureValidSdkKey(args)) {
            return false;
          }
          const argsInternal = this._getInternalRequestArgs("POST", args);
          const url = this._getPopulatedURL(argsInternal);
          const nav = navigator;
          return nav.sendBeacon.bind(nav)(url, argsInternal.body);
        }
        post(args) {
          return __awaiter2(this, void 0, void 0, function* () {
            const argsInternal = this._getInternalRequestArgs("POST", args);
            this._tryEncodeBody(argsInternal);
            yield this._tryToCompressBody(argsInternal);
            return this._sendRequest(argsInternal);
          });
        }
        get(args) {
          const argsInternal = this._getInternalRequestArgs("GET", args);
          return this._sendRequest(argsInternal);
        }
        _sendRequest(args) {
          return __awaiter2(this, void 0, void 0, function* () {
            var _a2, _b, _c, _d;
            if (!_ensureValidSdkKey(args)) {
              return null;
            }
            if (this._netConfig.preventAllNetworkTraffic) {
              return null;
            }
            const { method, body, retries, attempt } = args;
            const endpoint = args.urlConfig.endpoint;
            if (this._isRateLimited(endpoint)) {
              Log_1.Log.warn(`Request to ${endpoint} was blocked because you are making requests too frequently.`);
              return null;
            }
            const currentAttempt = attempt !== null && attempt !== void 0 ? attempt : 1;
            const abortController = typeof AbortController !== "undefined" ? new AbortController() : null;
            const timeoutHandle = setTimeout(() => {
              abortController === null || abortController === void 0 ? void 0 : abortController.abort(`Timeout of ${this._timeout}ms expired.`);
            }, this._timeout);
            const populatedUrl = this._getPopulatedURL(args);
            let response = null;
            const keepalive = (0, VisibilityObserving_1._isUnloading)();
            try {
              const config = {
                method,
                body,
                headers: Object.assign({}, args.headers),
                signal: abortController === null || abortController === void 0 ? void 0 : abortController.signal,
                priority: args.priority,
                keepalive
              };
              _tryMarkInitStart(args, currentAttempt);
              const bucket = this._leakyBucket[endpoint];
              if (bucket) {
                bucket.lastRequestTime = Date.now();
                this._leakyBucket[endpoint] = bucket;
              }
              const func = (_a2 = this._netConfig.networkOverrideFunc) !== null && _a2 !== void 0 ? _a2 : fetch;
              response = yield func(populatedUrl, config);
              clearTimeout(timeoutHandle);
              if (!response.ok) {
                const text2 = yield response.text().catch(() => "No Text");
                const err = new Error(`NetworkError: ${populatedUrl} ${text2}`);
                err.name = "NetworkError";
                throw err;
              }
              const text = yield response.text();
              _tryMarkInitEnd(args, response, currentAttempt, text);
              this._fallbackResolver.tryBumpExpiryTime(args.sdkKey, args.urlConfig);
              return {
                body: text,
                code: response.status
              };
            } catch (error) {
              const errorMessage = _getErrorMessage(abortController, error);
              const timedOut = _didTimeout(abortController);
              _tryMarkInitEnd(args, response, currentAttempt, "", error);
              const fallbackUpdated = yield this._fallbackResolver.tryFetchUpdatedFallbackInfo(args.sdkKey, args.urlConfig, errorMessage, timedOut);
              if (fallbackUpdated) {
                args.fallbackUrl = this._fallbackResolver.getActiveFallbackUrl(args.sdkKey, args.urlConfig);
              }
              if (!retries || currentAttempt > retries || !RETRYABLE_CODES.has((_b = response === null || response === void 0 ? void 0 : response.status) !== null && _b !== void 0 ? _b : 500)) {
                (_c = this._emitter) === null || _c === void 0 ? void 0 : _c.call(this, {
                  name: "error",
                  error,
                  tag: StatsigClientEventEmitter_1.ErrorTag.NetworkError,
                  requestArgs: args
                });
                const formattedErrorMsg = `A networking error occurred during ${method} request to ${populatedUrl}.`;
                Log_1.Log.error(formattedErrorMsg, errorMessage, error);
                (_d = this._errorBoundary) === null || _d === void 0 ? void 0 : _d.attachErrorIfNoneExists(formattedErrorMsg);
                return null;
              }
              yield _exponentialBackoff(currentAttempt);
              return this._sendRequest(Object.assign(Object.assign({}, args), { retries, attempt: currentAttempt + 1 }));
            }
          });
        }
        _getLogEventCompressionMode(options2) {
          let compressionMode = options2 === null || options2 === void 0 ? void 0 : options2.logEventCompressionMode;
          if (!compressionMode && (options2 === null || options2 === void 0 ? void 0 : options2.disableCompression) === true) {
            compressionMode = StatsigOptionsCommon_1.LogEventCompressionMode.Disabled;
          }
          if (!compressionMode) {
            compressionMode = StatsigOptionsCommon_1.LogEventCompressionMode.Enabled;
          }
          return compressionMode;
        }
        _isRateLimited(endpoint) {
          var _a2;
          const now2 = Date.now();
          const bucket = (_a2 = this._leakyBucket[endpoint]) !== null && _a2 !== void 0 ? _a2 : {
            count: 0,
            lastRequestTime: now2
          };
          const elapsed = now2 - bucket.lastRequestTime;
          const leakedRequests = Math.floor(elapsed * LEAK_RATE);
          bucket.count = Math.max(0, bucket.count - leakedRequests);
          if (bucket.count >= RATE_LIMIT_MAX_REQ_COUNT) {
            return true;
          }
          bucket.count += 1;
          bucket.lastRequestTime = now2;
          this._leakyBucket[endpoint] = bucket;
          return false;
        }
        _getPopulatedURL(args) {
          var _a2;
          const url = (_a2 = args.fallbackUrl) !== null && _a2 !== void 0 ? _a2 : args.urlConfig.getUrl();
          if (args.urlConfig.endpoint === NetworkConfig_1.Endpoint._initialize || args.urlConfig.endpoint === NetworkConfig_1.Endpoint._download_config_specs) {
            this._lastUsedInitUrl = url;
          }
          const params = Object.assign({ [NetworkConfig_1.NetworkParam.SdkKey]: args.sdkKey, [NetworkConfig_1.NetworkParam.SdkType]: SDKType_1.SDKType._get(args.sdkKey), [NetworkConfig_1.NetworkParam.SdkVersion]: StatsigMetadata_1.SDK_VERSION, [NetworkConfig_1.NetworkParam.Time]: String(Date.now()), [NetworkConfig_1.NetworkParam.SessionID]: SessionID_1.SessionID.get(args.sdkKey) }, args.params);
          const query = Object.keys(params).map((key) => {
            return `${encodeURIComponent(key)}=${encodeURIComponent(params[key])}`;
          }).join("&");
          return `${url}${query ? `?${query}` : ""}`;
        }
        _tryEncodeBody(args) {
          var _a2;
          const win = (0, SafeJs_1._getWindowSafe)();
          const body = args.body;
          if (!args.isStatsigEncodable || this._options.disableStatsigEncoding || typeof body !== "string" || (0, __StatsigGlobal_1._getStatsigGlobalFlag)("no-encode") != null || !(win === null || win === void 0 ? void 0 : win.btoa)) {
            return;
          }
          try {
            args.body = win.btoa(body).split("").reverse().join("");
            args.params = Object.assign(Object.assign({}, (_a2 = args.params) !== null && _a2 !== void 0 ? _a2 : {}), { [NetworkConfig_1.NetworkParam.StatsigEncoded]: "1" });
          } catch (e) {
            Log_1.Log.warn(`Request encoding failed for ${args.urlConfig.getUrl()}`, e);
          }
        }
        _tryToCompressBody(args) {
          return __awaiter2(this, void 0, void 0, function* () {
            var _a2;
            const body = args.body;
            if (typeof body !== "string" || !_allowCompression(args, this._options)) {
              return;
            }
            try {
              const bytes = new TextEncoder().encode(body);
              const stream = new CompressionStream("gzip");
              const writer = stream.writable.getWriter();
              writer.write(bytes).catch(Log_1.Log.error);
              writer.close().catch(Log_1.Log.error);
              const reader = stream.readable.getReader();
              const chunks = [];
              let result2;
              while (!(result2 = yield reader.read()).done) {
                chunks.push(result2.value);
              }
              const totalLength = chunks.reduce((acc, chunk) => acc + chunk.length, 0);
              const combined = new Uint8Array(totalLength);
              let offset3 = 0;
              for (const chunk of chunks) {
                combined.set(chunk, offset3);
                offset3 += chunk.length;
              }
              args.body = combined;
              args.params = Object.assign(Object.assign({}, (_a2 = args.params) !== null && _a2 !== void 0 ? _a2 : {}), { [NetworkConfig_1.NetworkParam.IsGzipped]: "1" });
            } catch (e) {
              Log_1.Log.warn(`Request compression failed for ${args.urlConfig.getUrl()}`, e);
            }
          });
        }
        _getInternalRequestArgs(method, args) {
          const fallbackUrl = this._fallbackResolver.getActiveFallbackUrl(args.sdkKey, args.urlConfig);
          const result2 = Object.assign(Object.assign({}, args), {
            method,
            fallbackUrl
          });
          if ("data" in args) {
            _populateRequestBody(result2, args.data);
          }
          return result2;
        }
      };
      exports.NetworkCore = NetworkCore;
      var _ensureValidSdkKey = (args) => {
        if (!args.sdkKey) {
          Log_1.Log.warn("Unable to make request without an SDK key");
          return false;
        }
        return true;
      };
      var _populateRequestBody = (args, data) => {
        const { sdkKey, fallbackUrl } = args;
        const stableID = StableID_1.StableID.get(sdkKey);
        const sessionID = SessionID_1.SessionID.get(sdkKey);
        const sdkType = SDKType_1.SDKType._get(sdkKey);
        args.body = JSON.stringify(Object.assign(Object.assign({}, data), { statsigMetadata: Object.assign(Object.assign({}, StatsigMetadata_1.StatsigMetadataProvider.get()), {
          stableID,
          sessionID,
          sdkType,
          fallbackUrl
        }) }));
      };
      function _allowCompression(args, options2) {
        if (!args.isCompressable) {
          return false;
        }
        if ((0, __StatsigGlobal_1._getStatsigGlobalFlag)("no-compress") != null || typeof CompressionStream === "undefined" || typeof TextEncoder === "undefined") {
          return false;
        }
        const isProxy = args.urlConfig.customUrl != null || args.urlConfig.fallbackUrls != null;
        const flagEnabled = SDKFlags_1.SDKFlags.get(args.sdkKey, "enable_log_event_compression") === true;
        switch (options2.logEventCompressionMode) {
          case StatsigOptionsCommon_1.LogEventCompressionMode.Disabled:
            return false;
          case StatsigOptionsCommon_1.LogEventCompressionMode.Enabled:
            if (isProxy && !flagEnabled) {
              return false;
            }
            return true;
          case StatsigOptionsCommon_1.LogEventCompressionMode.Forced:
            return true;
          default:
            return false;
        }
      }
      function _getErrorMessage(controller, error) {
        if ((controller === null || controller === void 0 ? void 0 : controller.signal.aborted) && typeof controller.signal.reason === "string") {
          return controller.signal.reason;
        }
        if (typeof error === "string") {
          return error;
        }
        if (error instanceof Error) {
          return `${error.name}: ${error.message}`;
        }
        return "Unknown Error";
      }
      function _didTimeout(controller) {
        const timeout = (controller === null || controller === void 0 ? void 0 : controller.signal.aborted) && typeof controller.signal.reason === "string" && controller.signal.reason.includes("Timeout");
        return timeout || false;
      }
      function _tryMarkInitStart(args, attempt) {
        if (args.urlConfig.endpoint !== NetworkConfig_1.Endpoint._initialize) {
          return;
        }
        Diagnostics_1.Diagnostics._markInitNetworkReqStart(args.sdkKey, {
          attempt
        });
      }
      function _tryMarkInitEnd(args, response, attempt, body, err) {
        if (args.urlConfig.endpoint !== NetworkConfig_1.Endpoint._initialize) {
          return;
        }
        Diagnostics_1.Diagnostics._markInitNetworkReqEnd(args.sdkKey, Diagnostics_1.Diagnostics._getDiagnosticsData(response, attempt, body, err));
      }
      function _exponentialBackoff(attempt) {
        return __awaiter2(this, void 0, void 0, function* () {
          yield new Promise((r) => setTimeout(r, Math.min(BACKOFF_BASE_MS * (attempt * attempt), BACKOFF_MAX_MS)));
        });
      }
    }
  });

  // node_modules/@statsig/client-core/src/OverrideAdapter.js
  var require_OverrideAdapter = __commonJS({
    "node_modules/@statsig/client-core/src/OverrideAdapter.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
    }
  });

  // node_modules/@statsig/client-core/src/ParamStoreTypes.js
  var require_ParamStoreTypes = __commonJS({
    "node_modules/@statsig/client-core/src/ParamStoreTypes.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
    }
  });

  // node_modules/@statsig/client-core/src/SizeOf.js
  var require_SizeOf = __commonJS({
    "node_modules/@statsig/client-core/src/SizeOf.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports._fastApproxSizeOf = void 0;
      var CURLY_AND_SQUARE_BRACKET_SIZE = 2;
      var APPROX_ADDITIONAL_SIZE = 1;
      var _fastApproxSizeOf = (obj, max3) => {
        let size2 = 0;
        const keys = Object.keys(obj);
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          const value = obj[key];
          size2 += key.length;
          if (typeof value === "object" && value !== null) {
            size2 += (0, exports._fastApproxSizeOf)(value, max3) + CURLY_AND_SQUARE_BRACKET_SIZE;
          } else {
            size2 += String(value).length + APPROX_ADDITIONAL_SIZE;
          }
          if (size2 >= max3) {
            return size2;
          }
        }
        return size2;
      };
      exports._fastApproxSizeOf = _fastApproxSizeOf;
    }
  });

  // node_modules/@statsig/client-core/src/StatsigClientBase.js
  var require_StatsigClientBase = __commonJS({
    "node_modules/@statsig/client-core/src/StatsigClientBase.js"(exports) {
      "use strict";
      var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result2) {
            result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.StatsigClientBase = void 0;
      require_StatsigGlobal();
      var __StatsigGlobal_1 = require_StatsigGlobal();
      var ErrorBoundary_1 = require_ErrorBoundary();
      var EventLogger_1 = require_EventLogger();
      var Log_1 = require_Log();
      var MemoKey_1 = require_MemoKey();
      var SafeJs_1 = require_SafeJs();
      var SessionID_1 = require_SessionID();
      var StableID_1 = require_StableID();
      var StatsigOptionsCommon_1 = require_StatsigOptionsCommon();
      var StorageProvider_1 = require_StorageProvider();
      var MAX_MEMO_CACHE_SIZE = 3e3;
      var StatsigClientBase = class {
        constructor(sdkKey, adapter4, network, options2) {
          var _a2, _b, _c, _d;
          this.loadingStatus = "Uninitialized";
          this._initializePromise = null;
          this._listeners = {};
          const emitter = this.$emt.bind(this);
          (options2 === null || options2 === void 0 ? void 0 : options2.logLevel) != null && (Log_1.Log.level = options2.logLevel);
          (options2 === null || options2 === void 0 ? void 0 : options2.disableStorage) && StorageProvider_1.Storage._setDisabled(true);
          (options2 === null || options2 === void 0 ? void 0 : options2.initialSessionID) && SessionID_1.StatsigSession.overrideInitialSessionID(options2.initialSessionID, sdkKey);
          (options2 === null || options2 === void 0 ? void 0 : options2.storageProvider) && StorageProvider_1.Storage._setProvider(options2.storageProvider);
          (options2 === null || options2 === void 0 ? void 0 : options2.enableCookies) && StableID_1.StableID._setCookiesEnabled(sdkKey, options2.enableCookies);
          (options2 === null || options2 === void 0 ? void 0 : options2.disableStableID) && StableID_1.StableID._setDisabled(sdkKey, true);
          this._sdkKey = sdkKey;
          this._options = options2 !== null && options2 !== void 0 ? options2 : {};
          this._memoCache = {};
          this.overrideAdapter = (_a2 = options2 === null || options2 === void 0 ? void 0 : options2.overrideAdapter) !== null && _a2 !== void 0 ? _a2 : null;
          this._logger = new EventLogger_1.EventLogger(sdkKey, emitter, network, options2);
          this._errorBoundary = new ErrorBoundary_1.ErrorBoundary(sdkKey, options2, emitter);
          this._errorBoundary.wrap(this);
          this._errorBoundary.wrap(adapter4);
          this._errorBoundary.wrap(this._logger);
          network.setErrorBoundary(this._errorBoundary);
          this.dataAdapter = adapter4;
          this.dataAdapter.attach(sdkKey, options2, network);
          this.storageProvider = StorageProvider_1.Storage;
          (_d = (_c = (_b = this.overrideAdapter) === null || _b === void 0 ? void 0 : _b.loadFromStorage) === null || _c === void 0 ? void 0 : _c.call(_b)) === null || _d === void 0 ? void 0 : _d.catch((e) => this._errorBoundary.logError("OA::loadFromStorage", e));
          this._primeReadyRipcord();
          _assignGlobalInstance(sdkKey, this);
        }
        /**
         * Updates runtime configuration options for the SDK, allowing toggling of certain behaviors such as logging and storage to comply with user preferences or regulations such as GDPR.
         *
         * @param {StatsigRuntimeMutableOptions} options - The configuration options that dictate the runtime behavior of the SDK.
         */
        updateRuntimeOptions(options2) {
          if (options2.loggingEnabled) {
            this._options.loggingEnabled = options2.loggingEnabled;
            this._logger.setLoggingEnabled(options2.loggingEnabled);
          } else if (options2.disableLogging != null) {
            this._options.disableLogging = options2.disableLogging;
            this._logger.setLoggingEnabled(options2.disableLogging ? "disabled" : "browser-only");
          }
          if (options2.disableStorage != null) {
            this._options.disableStorage = options2.disableStorage;
            StorageProvider_1.Storage._setDisabled(options2.disableStorage);
          }
          if (options2.enableCookies != null) {
            this._options.enableCookies = options2.enableCookies;
            StableID_1.StableID._setCookiesEnabled(this._sdkKey, options2.enableCookies);
          }
          if (options2.logEventCompressionMode) {
            this._logger.setLogEventCompressionMode(options2.logEventCompressionMode);
          } else if (options2.disableCompression) {
            this._logger.setLogEventCompressionMode(StatsigOptionsCommon_1.LogEventCompressionMode.Disabled);
          }
        }
        /**
         * Flushes any currently queued events.
         */
        flush() {
          return this._logger.flush();
        }
        /**
         * Gracefully shuts down the SDK, ensuring that all pending events are send before the SDK stops.
         * This function emits a 'pre_shutdown' event and then waits for the logger to complete its shutdown process.
         *
         * @returns {Promise<void>} A promise that resolves when all shutdown procedures, including logging shutdown, have been completed.
         */
        shutdown() {
          return __awaiter2(this, void 0, void 0, function* () {
            this.$emt({ name: "pre_shutdown" });
            this._setStatus("Uninitialized", null);
            this._initializePromise = null;
            yield this._logger.stop();
          });
        }
        /**
         * Subscribes a callback function to a specific {@link StatsigClientEvent} or all StatsigClientEvents if the wildcard '*' is used.
         * Once subscribed, the listener callback will be invoked whenever the specified event is emitted.
         *
         * @param {StatsigClientEventName} event - The name of the event to subscribe to, or '*' to subscribe to all events.
         * @param {StatsigClientEventCallback<T>} listener - The callback function to execute when the event occurs. The function receives event-specific data as its parameter.
         * @see {@link off} for unsubscribing from events.
         */
        on(event, listener) {
          if (!this._listeners[event]) {
            this._listeners[event] = [];
          }
          this._listeners[event].push(listener);
        }
        /**
         * Unsubscribes a previously registered callback function from a specific {@link StatsigClientEvent} or all StatsigClientEvents if the wildcard '*' is used.
         *
         * @param {StatsigClientEventName} event - The name of the event from which to unsubscribe, or '*' to unsubscribe from all events.
         * @param {StatsigClientEventCallback<T>} listener - The callback function to remove from the event's notification list.
         * @see {@link on} for subscribing to events.
         */
        off(event, listener) {
          if (this._listeners[event]) {
            const index2 = this._listeners[event].indexOf(listener);
            if (index2 !== -1) {
              this._listeners[event].splice(index2, 1);
            }
          }
        }
        $on(event, listener) {
          listener.__isInternal = true;
          this.on(event, listener);
        }
        $emt(event) {
          var _a2;
          const barrier = (listener) => {
            try {
              listener(event);
            } catch (error) {
              if (listener.__isInternal === true) {
                this._errorBoundary.logError(`__emit:${event.name}`, error);
                return;
              }
              Log_1.Log.error(`An error occurred in a StatsigClientEvent listener. This is not an issue with Statsig.`, event);
            }
          };
          if (this._listeners[event.name]) {
            this._listeners[event.name].forEach((l) => barrier(l));
          }
          (_a2 = this._listeners["*"]) === null || _a2 === void 0 ? void 0 : _a2.forEach(barrier);
        }
        _setStatus(newStatus, values) {
          this.loadingStatus = newStatus;
          this._memoCache = {};
          this.$emt({ name: "values_updated", status: newStatus, values });
        }
        _enqueueExposure(name, exposure, options2) {
          if ((options2 === null || options2 === void 0 ? void 0 : options2.disableExposureLog) === true) {
            this._logger.incrementNonExposureCount(name);
            return;
          }
          this._logger.enqueue(exposure);
        }
        _memoize(prefix3, fn2) {
          return (name, options2) => {
            if (this._options.disableEvaluationMemoization) {
              return fn2(name, options2);
            }
            const memoKey = (0, MemoKey_1.createMemoKey)(prefix3, name, options2);
            if (!memoKey) {
              return fn2(name, options2);
            }
            if (!(memoKey in this._memoCache)) {
              if (Object.keys(this._memoCache).length >= MAX_MEMO_CACHE_SIZE) {
                this._memoCache = {};
              }
              this._memoCache[memoKey] = fn2(name, options2);
            }
            return this._memoCache[memoKey];
          };
        }
      };
      exports.StatsigClientBase = StatsigClientBase;
      function _assignGlobalInstance(sdkKey, client2) {
        var _a2;
        if ((0, SafeJs_1._isServerEnv)()) {
          return;
        }
        const statsigGlobal = (0, __StatsigGlobal_1._getStatsigGlobal)();
        const instances = (_a2 = statsigGlobal.instances) !== null && _a2 !== void 0 ? _a2 : {};
        const inst = client2;
        if (instances[sdkKey] != null) {
          Log_1.Log.warn("Creating multiple Statsig clients with the same SDK key can lead to unexpected behavior. Multi-instance support requires different SDK keys.");
        }
        instances[sdkKey] = inst;
        if (!statsigGlobal.firstInstance) {
          statsigGlobal.firstInstance = inst;
        }
        statsigGlobal.instances = instances;
        __STATSIG__ = statsigGlobal;
      }
    }
  });

  // node_modules/@statsig/client-core/src/StatsigDataAdapter.js
  var require_StatsigDataAdapter = __commonJS({
    "node_modules/@statsig/client-core/src/StatsigDataAdapter.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DataAdapterCachePrefix = void 0;
      exports.DataAdapterCachePrefix = "statsig.cached";
    }
  });

  // node_modules/@statsig/client-core/src/StatsigPlugin.js
  var require_StatsigPlugin = __commonJS({
    "node_modules/@statsig/client-core/src/StatsigPlugin.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
    }
  });

  // node_modules/@statsig/client-core/src/StatsigTypeFactories.js
  var require_StatsigTypeFactories = __commonJS({
    "node_modules/@statsig/client-core/src/StatsigTypeFactories.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports._makeTypedGet = exports._mergeOverride = exports._makeLayer = exports._makeExperiment = exports._makeDynamicConfig = exports._makeFeatureGate = void 0;
      var Log_1 = require_Log();
      var TypingUtils_1 = require_TypingUtils();
      function _makeEvaluation(name, details, evaluation, value) {
        var _a2;
        return {
          name,
          details,
          ruleID: (_a2 = evaluation === null || evaluation === void 0 ? void 0 : evaluation.rule_id) !== null && _a2 !== void 0 ? _a2 : "",
          __evaluation: evaluation,
          value
        };
      }
      function _makeFeatureGate(name, details, evaluation) {
        var _a2;
        return Object.assign(Object.assign({}, _makeEvaluation(name, details, evaluation, (evaluation === null || evaluation === void 0 ? void 0 : evaluation.value) === true)), { idType: (_a2 = evaluation === null || evaluation === void 0 ? void 0 : evaluation.id_type) !== null && _a2 !== void 0 ? _a2 : null });
      }
      exports._makeFeatureGate = _makeFeatureGate;
      function _makeDynamicConfig(name, details, evaluation) {
        var _a2;
        const value = (_a2 = evaluation === null || evaluation === void 0 ? void 0 : evaluation.value) !== null && _a2 !== void 0 ? _a2 : {};
        return Object.assign(Object.assign({}, _makeEvaluation(name, details, evaluation, value)), { get: _makeTypedGet(name, evaluation === null || evaluation === void 0 ? void 0 : evaluation.value) });
      }
      exports._makeDynamicConfig = _makeDynamicConfig;
      function _makeExperiment(name, details, evaluation) {
        var _a2;
        const result2 = _makeDynamicConfig(name, details, evaluation);
        return Object.assign(Object.assign({}, result2), { groupName: (_a2 = evaluation === null || evaluation === void 0 ? void 0 : evaluation.group_name) !== null && _a2 !== void 0 ? _a2 : null });
      }
      exports._makeExperiment = _makeExperiment;
      function _makeLayer(name, details, evaluation, exposeFunc) {
        var _a2, _b;
        return Object.assign(Object.assign({}, _makeEvaluation(name, details, evaluation, void 0)), { get: _makeTypedGet(name, evaluation === null || evaluation === void 0 ? void 0 : evaluation.value, exposeFunc), groupName: (_a2 = evaluation === null || evaluation === void 0 ? void 0 : evaluation.group_name) !== null && _a2 !== void 0 ? _a2 : null, __value: (_b = evaluation === null || evaluation === void 0 ? void 0 : evaluation.value) !== null && _b !== void 0 ? _b : {} });
      }
      exports._makeLayer = _makeLayer;
      function _mergeOverride(original, overridden, value, exposeFunc) {
        return Object.assign(Object.assign(Object.assign({}, original), overridden), { get: _makeTypedGet(original.name, value, exposeFunc) });
      }
      exports._mergeOverride = _mergeOverride;
      function _makeTypedGet(name, value, exposeFunc) {
        return (param, fallback) => {
          var _a2;
          const found = (_a2 = value === null || value === void 0 ? void 0 : value[param]) !== null && _a2 !== void 0 ? _a2 : null;
          if (found == null) {
            return fallback !== null && fallback !== void 0 ? fallback : null;
          }
          if (fallback != null && !(0, TypingUtils_1._isTypeMatch)(found, fallback)) {
            Log_1.Log.warn(`Parameter type mismatch. '${name}.${param}' was found to be type '${typeof found}' but fallback/return type is '${typeof fallback}'. See https://docs.statsig.com/client/javascript-sdk/#typed-getters`);
            return fallback !== null && fallback !== void 0 ? fallback : null;
          }
          exposeFunc === null || exposeFunc === void 0 ? void 0 : exposeFunc(param);
          return found;
        };
      }
      exports._makeTypedGet = _makeTypedGet;
    }
  });

  // node_modules/@statsig/client-core/src/StatsigTypes.js
  var require_StatsigTypes = __commonJS({
    "node_modules/@statsig/client-core/src/StatsigTypes.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
    }
  });

  // node_modules/@statsig/client-core/src/StatsigUpdateDetails.js
  var require_StatsigUpdateDetails = __commonJS({
    "node_modules/@statsig/client-core/src/StatsigUpdateDetails.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.UPDATE_DETAIL_ERROR_MESSAGES = exports.createUpdateDetails = void 0;
      var createUpdateDetails = (success, source2, initDuration, error, sourceUrl, warnings2) => {
        return {
          duration: initDuration,
          source: source2,
          success,
          error,
          sourceUrl,
          warnings: warnings2
        };
      };
      exports.createUpdateDetails = createUpdateDetails;
      exports.UPDATE_DETAIL_ERROR_MESSAGES = {
        NO_NETWORK_DATA: "No data was returned from the network. This may be due to a network timeout if a timeout value was specified in the options or ad blocker error."
      };
    }
  });

  // node_modules/@statsig/client-core/src/index.js
  var require_src = __commonJS({
    "node_modules/@statsig/client-core/src/index.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __exportStar = exports && exports.__exportStar || function(m, exports2) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Storage = exports.Log = exports.EventLogger = exports.Diagnostics = void 0;
      require_StatsigGlobal();
      var __StatsigGlobal_1 = require_StatsigGlobal();
      var Diagnostics_1 = require_Diagnostics();
      Object.defineProperty(exports, "Diagnostics", { enumerable: true, get: function() {
        return Diagnostics_1.Diagnostics;
      } });
      var EventLogger_1 = require_EventLogger();
      Object.defineProperty(exports, "EventLogger", { enumerable: true, get: function() {
        return EventLogger_1.EventLogger;
      } });
      var Log_1 = require_Log();
      Object.defineProperty(exports, "Log", { enumerable: true, get: function() {
        return Log_1.Log;
      } });
      var StatsigMetadata_1 = require_StatsigMetadata();
      var StorageProvider_1 = require_StorageProvider();
      Object.defineProperty(exports, "Storage", { enumerable: true, get: function() {
        return StorageProvider_1.Storage;
      } });
      __exportStar(require_StatsigGlobal(), exports);
      __exportStar(require_CacheKey(), exports);
      __exportStar(require_ClientInterfaces(), exports);
      __exportStar(require_DataAdapterCore(), exports);
      __exportStar(require_Diagnostics(), exports);
      __exportStar(require_DownloadConfigSpecsResponse(), exports);
      __exportStar(require_ErrorBoundary(), exports);
      __exportStar(require_EvaluationOptions(), exports);
      __exportStar(require_EvaluationTypes(), exports);
      __exportStar(require_Hashing(), exports);
      __exportStar(require_InitializeResponse(), exports);
      __exportStar(require_Log(), exports);
      __exportStar(require_MemoKey(), exports);
      __exportStar(require_NetworkConfig(), exports);
      __exportStar(require_NetworkCore(), exports);
      __exportStar(require_OverrideAdapter(), exports);
      __exportStar(require_ParamStoreTypes(), exports);
      __exportStar(require_SafeJs(), exports);
      __exportStar(require_SDKType(), exports);
      __exportStar(require_SessionID(), exports);
      __exportStar(require_SizeOf(), exports);
      __exportStar(require_StableID(), exports);
      __exportStar(require_StatsigClientBase(), exports);
      __exportStar(require_StatsigClientEventEmitter(), exports);
      __exportStar(require_StatsigDataAdapter(), exports);
      __exportStar(require_StatsigEvent(), exports);
      __exportStar(require_StatsigMetadata(), exports);
      __exportStar(require_StatsigOptionsCommon(), exports);
      __exportStar(require_StatsigPlugin(), exports);
      __exportStar(require_StatsigTypeFactories(), exports);
      __exportStar(require_StatsigTypes(), exports);
      __exportStar(require_StatsigUser(), exports);
      __exportStar(require_StorageProvider(), exports);
      __exportStar(require_TypedJsonParse(), exports);
      __exportStar(require_TypingUtils(), exports);
      __exportStar(require_UrlConfiguration(), exports);
      __exportStar(require_UUID(), exports);
      __exportStar(require_VisibilityObserving(), exports);
      __exportStar(require_StatsigUpdateDetails(), exports);
      __exportStar(require_SDKFlags(), exports);
      Object.assign((0, __StatsigGlobal_1._getStatsigGlobal)(), { Log: Log_1.Log, SDK_VERSION: StatsigMetadata_1.SDK_VERSION });
    }
  });

  // node_modules/@statsig/js-client/src/EvaluationStore.js
  var require_EvaluationStore = __commonJS({
    "node_modules/@statsig/js-client/src/EvaluationStore.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var client_core_1 = require_src();
      var EvaluationStore = class {
        constructor(_sdkKey) {
          this._sdkKey = _sdkKey;
          this._rawValues = null;
          this._values = null;
          this._source = "Uninitialized";
          this._lcut = 0;
          this._receivedAt = 0;
          this._bootstrapMetadata = null;
          this._warnings = /* @__PURE__ */ new Set();
        }
        reset() {
          this._values = null;
          this._rawValues = null;
          this._source = "Loading";
          this._lcut = 0;
          this._receivedAt = 0;
          this._bootstrapMetadata = null;
          this._warnings.clear();
        }
        finalize() {
          if (this._values) {
            return;
          }
          this._source = "NoValues";
        }
        getValues() {
          return this._rawValues ? (0, client_core_1._typedJsonParse)(this._rawValues, "has_updates", "EvaluationStoreValues") : null;
        }
        setValues(result2, user) {
          var _a2;
          if (!result2) {
            return false;
          }
          const values = (0, client_core_1._typedJsonParse)(result2.data, "has_updates", "EvaluationResponse");
          if (values == null) {
            return false;
          }
          this._source = result2.source;
          if ((values === null || values === void 0 ? void 0 : values.has_updates) !== true) {
            return true;
          }
          this._rawValues = result2.data;
          this._lcut = values.time;
          this._receivedAt = result2.receivedAt;
          this._values = values;
          this._bootstrapMetadata = this._extractBootstrapMetadata(result2.source, values);
          if (result2.source && values.user) {
            this._setWarningState(user, values);
          }
          client_core_1.SDKFlags.setFlags(this._sdkKey, (_a2 = values.sdk_flags) !== null && _a2 !== void 0 ? _a2 : {});
          return true;
        }
        getWarnings() {
          if (this._warnings.size === 0) {
            return void 0;
          }
          return Array.from(this._warnings);
        }
        getGate(name) {
          var _a2;
          return this._getDetailedStoreResult((_a2 = this._values) === null || _a2 === void 0 ? void 0 : _a2.feature_gates, name);
        }
        getConfig(name) {
          var _a2;
          return this._getDetailedStoreResult((_a2 = this._values) === null || _a2 === void 0 ? void 0 : _a2.dynamic_configs, name);
        }
        getConfigList() {
          var _a2;
          if (!((_a2 = this._values) === null || _a2 === void 0 ? void 0 : _a2.dynamic_configs)) {
            return [];
          }
          return Object.values(this._values.dynamic_configs).map((config) => config.name);
        }
        getLayer(name) {
          var _a2;
          return this._getDetailedStoreResult((_a2 = this._values) === null || _a2 === void 0 ? void 0 : _a2.layer_configs, name);
        }
        getParamStore(name) {
          var _a2;
          return this._getDetailedStoreResult((_a2 = this._values) === null || _a2 === void 0 ? void 0 : _a2.param_stores, name);
        }
        getSource() {
          return this._source;
        }
        getExposureMapping() {
          var _a2;
          return (_a2 = this._values) === null || _a2 === void 0 ? void 0 : _a2.exposures;
        }
        _extractBootstrapMetadata(source2, values) {
          if (source2 !== "Bootstrap") {
            return null;
          }
          const bootstrapMetadata = {};
          if (values.user) {
            bootstrapMetadata.user = values.user;
          }
          if (values.sdkInfo) {
            bootstrapMetadata.generatorSDKInfo = values.sdkInfo;
          }
          bootstrapMetadata.lcut = values.time;
          return bootstrapMetadata;
        }
        _getDetailedStoreResult(lookup, name) {
          let result2 = null;
          if (lookup) {
            result2 = lookup[name] ? lookup[name] : lookup[(0, client_core_1._DJB2)(name)];
          }
          return {
            result: result2,
            details: this._getDetails(result2 == null)
          };
        }
        _setWarningState(user, values) {
          var _a2, _b;
          const stableID = client_core_1.StableID.get(this._sdkKey);
          if (((_a2 = user.customIDs) === null || _a2 === void 0 ? void 0 : _a2.stableID) !== stableID && // don't throw if they're both undefined
          (((_b = user.customIDs) === null || _b === void 0 ? void 0 : _b.stableID) || stableID)) {
            this._warnings.add("StableIDMismatch");
            return;
          }
          if ("user" in values) {
            const bootstrapUser = values["user"];
            const userForComparison = Object.assign(Object.assign({}, user), { analyticsOnlyMetadata: void 0, privateAttributes: void 0 });
            if ((0, client_core_1._getFullUserHash)(userForComparison) !== (0, client_core_1._getFullUserHash)(bootstrapUser)) {
              this._warnings.add("PartialUserMatch");
            }
          }
        }
        getCurrentSourceDetails() {
          if (this._source === "Uninitialized" || this._source === "NoValues") {
            return { reason: this._source };
          }
          const sourceDetails = {
            reason: this._source,
            lcut: this._lcut,
            receivedAt: this._receivedAt
          };
          if (this._warnings.size > 0) {
            sourceDetails.warnings = Array.from(this._warnings);
          }
          return sourceDetails;
        }
        _getDetails(isUnrecognized) {
          var _a2, _b;
          const sourceDetails = this.getCurrentSourceDetails();
          let reason = sourceDetails.reason;
          const warnings2 = (_a2 = sourceDetails.warnings) !== null && _a2 !== void 0 ? _a2 : [];
          if (this._source === "Bootstrap" && warnings2.length > 0) {
            reason = reason + warnings2[0];
          }
          if (reason !== "Uninitialized" && reason !== "NoValues") {
            const subreason = isUnrecognized ? "Unrecognized" : "Recognized";
            reason = `${reason}:${subreason}`;
          }
          const bootstrapMetadata = this._source === "Bootstrap" ? (_b = this._bootstrapMetadata) !== null && _b !== void 0 ? _b : void 0 : void 0;
          if (bootstrapMetadata) {
            sourceDetails.bootstrapMetadata = bootstrapMetadata;
          }
          return Object.assign(Object.assign({}, sourceDetails), { reason });
        }
      };
      exports.default = EvaluationStore;
    }
  });

  // node_modules/@statsig/js-client/src/EvaluationResponseDeltas.js
  var require_EvaluationResponseDeltas = __commonJS({
    "node_modules/@statsig/js-client/src/EvaluationResponseDeltas.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports._resolveDeltasResponse = void 0;
      var client_core_1 = require_src();
      var MAX_DELTAS_SORT_DEPTH = 2;
      function _resolveDeltasResponse(cache, deltasString) {
        const deltas = (0, client_core_1._typedJsonParse)(deltasString, "checksum", "DeltasEvaluationResponse");
        if (!deltas) {
          return {
            hadBadDeltaChecksum: true
          };
        }
        const merged = _mergeDeltasIntoCache(cache, deltas);
        const resolved = _handleDeletedEntries(merged);
        const actualChecksum = (0, client_core_1._DJB2Object)({
          feature_gates: resolved.feature_gates,
          dynamic_configs: resolved.dynamic_configs,
          layer_configs: resolved.layer_configs
        }, MAX_DELTAS_SORT_DEPTH);
        const isMatch = actualChecksum === deltas.checksumV2;
        if (!isMatch) {
          return {
            hadBadDeltaChecksum: true,
            badChecksum: actualChecksum,
            badMergedConfigs: resolved,
            badFullResponse: deltas.deltas_full_response
          };
        }
        return JSON.stringify(resolved);
      }
      exports._resolveDeltasResponse = _resolveDeltasResponse;
      function _mergeDeltasIntoCache(cache, deltas) {
        return Object.assign(Object.assign(Object.assign({}, cache), deltas), { feature_gates: Object.assign(Object.assign({}, cache.feature_gates), deltas.feature_gates), layer_configs: Object.assign(Object.assign({}, cache.layer_configs), deltas.layer_configs), dynamic_configs: Object.assign(Object.assign({}, cache.dynamic_configs), deltas.dynamic_configs) });
      }
      function _handleDeletedEntries(deltas) {
        const result2 = deltas;
        _deleteEntriesInRecord(deltas.deleted_gates, result2.feature_gates);
        delete result2.deleted_gates;
        _deleteEntriesInRecord(deltas.deleted_configs, result2.dynamic_configs);
        delete result2.deleted_configs;
        _deleteEntriesInRecord(deltas.deleted_layers, result2.layer_configs);
        delete result2.deleted_layers;
        return result2;
      }
      function _deleteEntriesInRecord(keys, values) {
        keys === null || keys === void 0 ? void 0 : keys.forEach((key) => {
          delete values[key];
        });
      }
    }
  });

  // node_modules/@statsig/js-client/src/Network.js
  var require_Network = __commonJS({
    "node_modules/@statsig/js-client/src/Network.js"(exports) {
      "use strict";
      var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result2) {
            result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      var client_core_1 = require_src();
      var EvaluationResponseDeltas_1 = require_EvaluationResponseDeltas();
      var StatsigNetwork = class extends client_core_1.NetworkCore {
        constructor(options2, emitter) {
          super(options2, emitter);
          const config = options2 === null || options2 === void 0 ? void 0 : options2.networkConfig;
          this._option = options2;
          this._initializeUrlConfig = new client_core_1.UrlConfiguration(client_core_1.Endpoint._initialize, config === null || config === void 0 ? void 0 : config.initializeUrl, config === null || config === void 0 ? void 0 : config.api, config === null || config === void 0 ? void 0 : config.initializeFallbackUrls);
        }
        fetchEvaluations(sdkKey, current, priority, user, isCacheValidFor204) {
          return __awaiter2(this, void 0, void 0, function* () {
            var _a2, _b, _c, _d, _e, _f;
            const cache = current ? (0, client_core_1._typedJsonParse)(current, "has_updates", "InitializeResponse") : null;
            let data = {
              user,
              hash: (_c = (_b = (_a2 = this._option) === null || _a2 === void 0 ? void 0 : _a2.networkConfig) === null || _b === void 0 ? void 0 : _b.initializeHashAlgorithm) !== null && _c !== void 0 ? _c : "djb2",
              deltasResponseRequested: false,
              full_checksum: null
            };
            if (cache === null || cache === void 0 ? void 0 : cache.has_updates) {
              const hasHashChanged = (cache === null || cache === void 0 ? void 0 : cache.hash_used) !== ((_f = (_e = (_d = this._option) === null || _d === void 0 ? void 0 : _d.networkConfig) === null || _e === void 0 ? void 0 : _e.initializeHashAlgorithm) !== null && _f !== void 0 ? _f : "djb2");
              data = Object.assign(Object.assign({}, data), { sinceTime: isCacheValidFor204 && !hasHashChanged ? cache.time : 0, previousDerivedFields: "derived_fields" in cache && isCacheValidFor204 ? cache.derived_fields : {}, deltasResponseRequested: true, full_checksum: cache.full_checksum, partialUserMatchSinceTime: !hasHashChanged ? cache.time : 0 });
            }
            return this._fetchEvaluations(sdkKey, cache, data, priority);
          });
        }
        _fetchEvaluations(sdkKey, cache, data, priority) {
          return __awaiter2(this, void 0, void 0, function* () {
            var _a2, _b;
            const response = yield this.post({
              sdkKey,
              urlConfig: this._initializeUrlConfig,
              data,
              retries: 2,
              isStatsigEncodable: true,
              priority
            });
            if ((response === null || response === void 0 ? void 0 : response.code) === 204) {
              return '{"has_updates": false}';
            }
            if ((response === null || response === void 0 ? void 0 : response.code) !== 200) {
              return (_a2 = response === null || response === void 0 ? void 0 : response.body) !== null && _a2 !== void 0 ? _a2 : null;
            }
            if ((cache === null || cache === void 0 ? void 0 : cache.has_updates) !== true || ((_b = response.body) === null || _b === void 0 ? void 0 : _b.includes('"is_delta":true')) !== true || data.deltasResponseRequested !== true) {
              return response.body;
            }
            const result2 = (0, EvaluationResponseDeltas_1._resolveDeltasResponse)(cache, response.body);
            if (typeof result2 === "string") {
              return result2;
            }
            return this._fetchEvaluations(sdkKey, cache, Object.assign(Object.assign(Object.assign({}, data), result2), { deltasResponseRequested: false }), priority);
          });
        }
      };
      exports.default = StatsigNetwork;
    }
  });

  // node_modules/@statsig/js-client/src/ParamStoreGetterFactory.js
  var require_ParamStoreGetterFactory = __commonJS({
    "node_modules/@statsig/js-client/src/ParamStoreGetterFactory.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports._makeParamStoreGetter = void 0;
      var client_core_1 = require_src();
      var NO_EXPOSURE_OPT = {
        disableExposureLog: true
      };
      function _shouldLogExposure(options2) {
        return options2 == null || options2.disableExposureLog === false;
      }
      function _shouldReturnFallback(value, fallback) {
        return fallback != null && !(0, client_core_1._isTypeMatch)(value, fallback);
      }
      function _getMappedStaticValue(param, _options) {
        return param.value;
      }
      function _getMappedGateValue(client2, param, options2) {
        const gate = client2.getFeatureGate(param.gate_name, _shouldLogExposure(options2) ? void 0 : NO_EXPOSURE_OPT);
        if (gate.value) {
          return param.pass_value;
        }
        return param.fail_value;
      }
      function _getMappedDynamicConfigValue(client2, param, fallback, options2) {
        const config = client2.getDynamicConfig(param.config_name, _shouldLogExposure(options2) ? void 0 : NO_EXPOSURE_OPT);
        const value = config.get(param.param_name);
        if (_shouldReturnFallback(value, fallback)) {
          return fallback;
        }
        return value;
      }
      function _getMappedExperimentValue(client2, param, fallback, options2) {
        const experiment = client2.getExperiment(param.experiment_name, _shouldLogExposure(options2) ? void 0 : NO_EXPOSURE_OPT);
        const value = experiment.get(param.param_name);
        if (_shouldReturnFallback(value, fallback)) {
          return fallback;
        }
        return value;
      }
      function _getMappedLayerValue(client2, param, fallback, options2) {
        const layer2 = client2.getLayer(param.layer_name, _shouldLogExposure(options2) ? void 0 : NO_EXPOSURE_OPT);
        const value = layer2.get(param.param_name);
        if (_shouldReturnFallback(value, fallback)) {
          return fallback;
        }
        return value;
      }
      function _makeParamStoreGetter(client2, config, options2) {
        return (paramName, fallback) => {
          if (config == null) {
            return fallback;
          }
          const param = config[paramName];
          if (param == null || fallback != null && (0, client_core_1._typeOf)(fallback) !== param.param_type) {
            return fallback;
          }
          switch (param.ref_type) {
            case "static":
              return _getMappedStaticValue(param, options2);
            case "gate":
              return _getMappedGateValue(client2, param, options2);
            case "dynamic_config":
              return _getMappedDynamicConfigValue(client2, param, fallback, options2);
            case "experiment":
              return _getMappedExperimentValue(client2, param, fallback, options2);
            case "layer":
              return _getMappedLayerValue(client2, param, fallback, options2);
            default:
              return fallback;
          }
        };
      }
      exports._makeParamStoreGetter = _makeParamStoreGetter;
    }
  });

  // node_modules/@statsig/js-client/src/StatsigEvaluationsDataAdapter.js
  var require_StatsigEvaluationsDataAdapter = __commonJS({
    "node_modules/@statsig/js-client/src/StatsigEvaluationsDataAdapter.js"(exports) {
      "use strict";
      var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result2) {
            result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.StatsigEvaluationsDataAdapter = void 0;
      var client_core_1 = require_src();
      var Network_1 = require_Network();
      var StatsigEvaluationsDataAdapter = class extends client_core_1.DataAdapterCore {
        constructor() {
          super("EvaluationsDataAdapter", "evaluations");
          this._network = null;
          this._options = null;
        }
        attach(sdkKey, options2, network) {
          super.attach(sdkKey, options2, network);
          if (network !== null && network instanceof Network_1.default) {
            this._network = network;
          } else {
            this._network = new Network_1.default(options2 !== null && options2 !== void 0 ? options2 : {});
          }
        }
        getDataAsync(current, user, options2) {
          return this._getDataAsyncImpl(current, (0, client_core_1._normalizeUser)(user, this._options), options2);
        }
        prefetchData(user, options2) {
          return this._prefetchDataImpl(user, options2);
        }
        setData(data) {
          const values = (0, client_core_1._typedJsonParse)(data, "has_updates", "data");
          if (values && "user" in values) {
            super.setData(data, values.user);
          } else {
            client_core_1.Log.error("StatsigUser not found. You may be using an older server SDK version. Please upgrade your SDK or use setDataLegacy.");
          }
        }
        setDataLegacy(data, user) {
          super.setData(data, user);
        }
        _fetchFromNetwork(current, user, options2, isCacheValidFor204) {
          return __awaiter2(this, void 0, void 0, function* () {
            var _a2;
            const result2 = yield (_a2 = this._network) === null || _a2 === void 0 ? void 0 : _a2.fetchEvaluations(this._getSdkKey(), current, options2 === null || options2 === void 0 ? void 0 : options2.priority, user, isCacheValidFor204);
            return result2 !== null && result2 !== void 0 ? result2 : null;
          });
        }
        _getCacheKey(user) {
          var _a2;
          const key = (0, client_core_1._getStorageKey)(this._getSdkKey(), user, (_a2 = this._options) === null || _a2 === void 0 ? void 0 : _a2.customUserCacheKeyFunc);
          return `${client_core_1.DataAdapterCachePrefix}.${this._cacheSuffix}.${key}`;
        }
        _isCachedResultValidFor204(result2, user) {
          return result2.fullUserHash != null && result2.fullUserHash === (0, client_core_1._getFullUserHash)(user);
        }
      };
      exports.StatsigEvaluationsDataAdapter = StatsigEvaluationsDataAdapter;
    }
  });

  // node_modules/@statsig/js-client/src/StatsigClient.js
  var require_StatsigClient = __commonJS({
    "node_modules/@statsig/js-client/src/StatsigClient.js"(exports) {
      "use strict";
      var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result2) {
            result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      var client_core_1 = require_src();
      var EvaluationStore_1 = require_EvaluationStore();
      var Network_1 = require_Network();
      var ParamStoreGetterFactory_1 = require_ParamStoreGetterFactory();
      var StatsigEvaluationsDataAdapter_1 = require_StatsigEvaluationsDataAdapter();
      var StatsigClient = class _StatsigClient extends client_core_1.StatsigClientBase {
        /**
         * Retrieves an instance of the StatsigClient based on the provided SDK key.
         *  If no SDK key is provided, the method returns the most recently created instance of the StatsigClient.
         *  The method ensures that each unique SDK key corresponds to a single instance of StatsigClient, effectively implementing a singleton pattern for each key.
         *  If no instance exists for the given SDK key, a new StatsigClient instance will be created and returned.
         *
         * @param {string} [sdkKey] - Optional. The SDK key used to identify a specific instance of the StatsigClient. If omitted, the method returns the last created instance.
         * @returns {StatsigClient} Returns the StatsigClient instance associated with the given SDK key, creating a new one if needed.
         */
        static instance(sdkKey) {
          const instance = (0, client_core_1._getStatsigGlobal)().instance(sdkKey);
          if (instance instanceof _StatsigClient) {
            return instance;
          }
          client_core_1.Log.warn((0, client_core_1._isServerEnv)() ? "StatsigClient.instance is not supported in server environments" : "Unable to find StatsigClient instance");
          return new _StatsigClient(sdkKey !== null && sdkKey !== void 0 ? sdkKey : "", {});
        }
        /**
         * StatsigClient constructor
         *
         * @param {string} sdkKey A Statsig client SDK key. eg "client-xyz123..."
         * @param {StatsigUser} user StatsigUser object containing various attributes related to a user.
         * @param {StatsigOptions | null} options StatsigOptions, used to customize the behavior of the SDK.
         */
        constructor(sdkKey, user, options2 = null) {
          var _a2, _b;
          client_core_1.SDKType._setClientType(sdkKey, "javascript-client");
          const network = new Network_1.default(options2, (e) => {
            this.$emt(e);
          });
          super(sdkKey, (_a2 = options2 === null || options2 === void 0 ? void 0 : options2.dataAdapter) !== null && _a2 !== void 0 ? _a2 : new StatsigEvaluationsDataAdapter_1.StatsigEvaluationsDataAdapter(), network, options2);
          this._possibleFirstTouchMetadata = {};
          this.getFeatureGate = this._memoize(client_core_1.MemoPrefix._gate, this._getFeatureGateImpl.bind(this));
          this.getDynamicConfig = this._memoize(client_core_1.MemoPrefix._dynamicConfig, this._getDynamicConfigImpl.bind(this));
          this.getExperiment = this._memoize(client_core_1.MemoPrefix._experiment, this._getExperimentImpl.bind(this));
          this.getConfigList = this._memoize(client_core_1.MemoPrefix._configList, this._getConfigListImpl.bind(this));
          this.getLayer = this._memoize(client_core_1.MemoPrefix._layer, this._getLayerImpl.bind(this));
          this.getParameterStore = this._memoize(client_core_1.MemoPrefix._paramStore, this._getParameterStoreImpl.bind(this));
          this._store = new EvaluationStore_1.default(sdkKey);
          this._network = network;
          this._user = this._configureUser(user, options2);
          this._sdkInstanceID = (0, client_core_1.getUUID)();
          const plugins = (_b = options2 === null || options2 === void 0 ? void 0 : options2.plugins) !== null && _b !== void 0 ? _b : [];
          for (const plugin of plugins) {
            plugin.bind(this);
          }
        }
        /**
         * Initializes the StatsigClient using cached values. This method sets up the client synchronously by utilizing previously cached values.
         * After initialization, cache values are updated in the background for future use, either in subsequent sessions or when `updateUser` is called.
         * This is useful for quickly starting with the last-known-good configurations while refreshing data to keep settings up-to-date.
         *
         * @see {@link initializeAsync} for the asynchronous version of this method.
         */
        initializeSync(options2) {
          var _a2;
          if (this.loadingStatus !== "Uninitialized") {
            return (0, client_core_1.createUpdateDetails)(true, this._store.getSource(), -1, null, null, ["MultipleInitializations", ...(_a2 = this._store.getWarnings()) !== null && _a2 !== void 0 ? _a2 : []]);
          }
          this._logger.start();
          return this.updateUserSync(this._user, options2);
        }
        /**
         * Initializes the StatsigClient asynchronously by first using cached values and then updating to the latest values from the network.
         * Once the network values are fetched, they replace the existing cached values. If this method's promise is not awaited,
         * there might be a transition from cached to network values during the session, which can affect consistency.
         * This method is useful when it's acceptable to begin with potentially stale data and switch to the latest configuration as it becomes available.
         *
         * @param {AsyncUpdateOptions} [options] - Optional. Additional options to customize the method call.
         * @returns {Promise<void>} A promise that resolves once the client is fully initialized with the latest values from the network or a timeout (if set) is hit.
         * @see {@link initializeSync} for the synchronous version of this method.
         */
        initializeAsync(options2) {
          return __awaiter2(this, void 0, void 0, function* () {
            if (this._initializePromise) {
              return this._initializePromise;
            }
            this._initializePromise = this._initializeAsyncImpl(options2);
            return this._initializePromise;
          });
        }
        /**
         * Synchronously updates the user in the Statsig client and switches the internal state to use cached values for the newly specified user.
         * After the initial switch to cached values, this method updates these values in the background, preparing them for future sessions or subsequent calls to updateUser.
         * This method ensures the client is quickly ready with available data.
         *
         * @param {StatsigUser} user - The new StatsigUser for which the client should update its internal state.
         * @see {@link updateUserAsync} for the asynchronous version of this method.
         */
        updateUserSync(user, options2) {
          const startTime = performance.now();
          try {
            return this._updateUserSyncImpl(user, options2, startTime);
          } catch (e) {
            const err = e instanceof Error ? e : new Error(String(e));
            return this._createErrorUpdateDetails(err, startTime);
          }
        }
        _updateUserSyncImpl(user, options2, startTime) {
          var _a2;
          const warnings2 = [...(_a2 = this._store.getWarnings()) !== null && _a2 !== void 0 ? _a2 : []];
          this._resetForUser(user);
          const result2 = this.dataAdapter.getDataSync(this._user);
          if (result2 == null) {
            warnings2.push("NoCachedValues");
          }
          this._store.setValues(result2, this._user);
          this._finalizeUpdate(result2);
          const disable = options2 === null || options2 === void 0 ? void 0 : options2.disableBackgroundCacheRefresh;
          if (disable === true || disable == null && (result2 === null || result2 === void 0 ? void 0 : result2.source) === "Bootstrap") {
            return (0, client_core_1.createUpdateDetails)(true, this._store.getSource(), performance.now() - startTime, this._errorBoundary.getLastSeenErrorAndReset(), this._network.getLastUsedInitUrlAndReset(), warnings2);
          }
          this._runPostUpdate(result2 !== null && result2 !== void 0 ? result2 : null, this._user);
          return (0, client_core_1.createUpdateDetails)(true, this._store.getSource(), performance.now() - startTime, this._errorBoundary.getLastSeenErrorAndReset(), this._network.getLastUsedInitUrlAndReset(), warnings2);
        }
        /**
         * Asynchronously updates the user in the Statsig client by initially using cached values and then fetching the latest values from the network.
         * When the latest values are fetched, they replace the cached values. If the promise returned by this method is not awaited,
         * the client's state may shift from cached to updated network values during the session, potentially affecting consistency.
         * This method is best used in scenarios where up-to-date configuration is critical and initial delays are acceptable.
         *
         * @param {StatsigUser} user - The new StatsigUser for which the client should update its internal state.
         * @param {AsyncUpdateOptions} [options] - Optional. Additional options to customize the method call.
         * @returns {Promise<void>} A promise that resolves once the client is fully updated with the latest values from the network or a timeout (if set) is hit.
         * @see {@link updateUserSync} for the synchronous version of this method.
         */
        updateUserAsync(user, options2) {
          return __awaiter2(this, void 0, void 0, function* () {
            const startTime = performance.now();
            try {
              return yield this._updateUserAsyncImpl(user, options2);
            } catch (e) {
              const err = e instanceof Error ? e : new Error(String(e));
              return this._createErrorUpdateDetails(err, startTime);
            }
          });
        }
        _updateUserAsyncImpl(user, options2) {
          return __awaiter2(this, void 0, void 0, function* () {
            this._resetForUser(user);
            const initiator = this._user;
            client_core_1.Diagnostics._markInitOverallStart(this._sdkKey);
            let result2 = this.dataAdapter.getDataSync(initiator);
            this._store.setValues(result2, this._user);
            this._setStatus("Loading", result2);
            result2 = yield this.dataAdapter.getDataAsync(result2, initiator, options2);
            if (initiator !== this._user) {
              return (0, client_core_1.createUpdateDetails)(false, this._store.getSource(), -1, new Error("User changed during update"), this._network.getLastUsedInitUrlAndReset());
            }
            let isUsingNetworkValues = false;
            if (result2 != null) {
              client_core_1.Diagnostics._markInitProcessStart(this._sdkKey);
              isUsingNetworkValues = this._store.setValues(result2, this._user);
              client_core_1.Diagnostics._markInitProcessEnd(this._sdkKey, {
                success: isUsingNetworkValues
              });
            }
            this._finalizeUpdate(result2);
            if (!isUsingNetworkValues) {
              this._errorBoundary.attachErrorIfNoneExists(client_core_1.UPDATE_DETAIL_ERROR_MESSAGES.NO_NETWORK_DATA);
              this.$emt({ name: "initialization_failure" });
            }
            client_core_1.Diagnostics._markInitOverallEnd(this._sdkKey, isUsingNetworkValues, this._store.getCurrentSourceDetails());
            const initDuration = client_core_1.Diagnostics._enqueueDiagnosticsEvent(this._user, this._logger, this._sdkKey, this._options);
            return (0, client_core_1.createUpdateDetails)(isUsingNetworkValues, this._store.getSource(), initDuration, this._errorBoundary.getLastSeenErrorAndReset(), this._network.getLastUsedInitUrlAndReset(), this._store.getWarnings());
          });
        }
        /**
         * Retrieves a synchronous context containing data currently being used by the SDK. Represented as a {@link PrecomputedEvaluationsContext} object.
         *
         * @returns {PrecomputedEvaluationsContext} The current synchronous context for the this StatsigClient instance.
         */
        getContext() {
          return {
            sdkKey: this._sdkKey,
            options: this._options,
            values: this._store.getValues(),
            user: JSON.parse(JSON.stringify(this._user)),
            errorBoundary: this._errorBoundary,
            session: client_core_1.StatsigSession.get(this._sdkKey),
            stableID: client_core_1.StableID.get(this._sdkKey),
            sdkInstanceID: this._sdkInstanceID
          };
        }
        /**
         * Retrieves the value of a feature gate for the current user, represented as a simple boolean.
         *
         * @param {string} name - The name of the feature gate to retrieve.
         * @param {FeatureGateEvaluationOptions} [options] - Optional. Additional options to customize the method call.
         * @returns {boolean} - The boolean value representing the gate's current evaluation results for the user.
         */
        checkGate(name, options2) {
          return this.getFeatureGate(name, options2).value;
        }
        /**
         * Logs an event to the internal logging system. This function allows logging by either passing a fully formed event object or by specifying the event name with optional value and metadata.
         *
         * @param {StatsigEvent|string} eventOrName - The event object conforming to the StatsigEvent interface, or the name of the event as a string.
         * @param {string|number} value - Optional. The value associated with the event, which can be a string or a number. This parameter is ignored if the first parameter is a StatsigEvent object.
         * @param {Record<string, string>} metadata - Optional. A key-value record containing metadata about the event. This is also ignored if the first parameter is an event object.
         */
        logEvent(eventOrName, value, metadata) {
          const event = typeof eventOrName === "string" ? {
            eventName: eventOrName,
            value,
            metadata
          } : eventOrName;
          this.$emt({
            name: "log_event_called",
            event
          });
          this._logger.enqueue(Object.assign(Object.assign({}, event), { user: this._user, time: Date.now() }));
        }
        /**
         * Updates the user with analytics only metadata. This will override any existing analytics only metadata.
         *
         * @param {Record<string, string | number | boolean>} metadata - The metadata to add to the user.
         */
        updateUserWithAnalyticsOnlyMetadata(metadata) {
          this._user = this._configureUser(Object.assign(Object.assign({}, this._user), { analyticsOnlyMetadata: metadata }), this._options);
        }
        _primeReadyRipcord() {
          this.$on("error", () => {
            this.loadingStatus === "Loading" && this._finalizeUpdate(null);
          });
        }
        _initializeAsyncImpl(options2) {
          return __awaiter2(this, void 0, void 0, function* () {
            if (!client_core_1.Storage.isReady()) {
              yield client_core_1.Storage.isReadyResolver();
            }
            this._logger.start();
            return this.updateUserAsync(this._user, options2);
          });
        }
        _createErrorUpdateDetails(error, startTime) {
          var _a2;
          return (0, client_core_1.createUpdateDetails)(false, this._store.getSource(), performance.now() - startTime, error, null, [...(_a2 = this._store.getWarnings()) !== null && _a2 !== void 0 ? _a2 : []]);
        }
        _finalizeUpdate(values) {
          this._store.finalize();
          this._setStatus("Ready", values);
        }
        _runPostUpdate(current, user) {
          this.dataAdapter.getDataAsync(current, user, { priority: "low" }).catch((err) => {
            client_core_1.Log.error("An error occurred after update.", err);
          });
        }
        _resetForUser(user) {
          this._logger.reset();
          this._store.reset();
          this._user = this._configureUser(user, this._options);
        }
        _configureUser(originalUser, options2) {
          var _a2;
          const user = (0, client_core_1._normalizeUser)(originalUser, options2);
          const stableIdOverride = (_a2 = user.customIDs) === null || _a2 === void 0 ? void 0 : _a2.stableID;
          if (stableIdOverride) {
            client_core_1.StableID.setOverride(stableIdOverride, this._sdkKey);
          }
          if (Object.keys(this._possibleFirstTouchMetadata).length > 0) {
            user.analyticsOnlyMetadata = Object.assign(Object.assign({}, user.analyticsOnlyMetadata), this._possibleFirstTouchMetadata);
          }
          return user;
        }
        _getFeatureGateImpl(name, options2) {
          var _a2, _b;
          const { result: evaluation, details } = this._store.getGate(name);
          const gate = (0, client_core_1._makeFeatureGate)(name, details, evaluation);
          const overridden = (_b = (_a2 = this.overrideAdapter) === null || _a2 === void 0 ? void 0 : _a2.getGateOverride) === null || _b === void 0 ? void 0 : _b.call(_a2, gate, this._user, options2);
          const result2 = overridden !== null && overridden !== void 0 ? overridden : gate;
          this._enqueueExposure(name, (0, client_core_1._createGateExposure)(this._user, result2, this._store.getExposureMapping()), options2);
          this.$emt({ name: "gate_evaluation", gate: result2 });
          return result2;
        }
        _getDynamicConfigImpl(name, options2) {
          var _a2, _b;
          const { result: evaluation, details } = this._store.getConfig(name);
          const config = (0, client_core_1._makeDynamicConfig)(name, details, evaluation);
          const overridden = (_b = (_a2 = this.overrideAdapter) === null || _a2 === void 0 ? void 0 : _a2.getDynamicConfigOverride) === null || _b === void 0 ? void 0 : _b.call(_a2, config, this._user, options2);
          const result2 = overridden !== null && overridden !== void 0 ? overridden : config;
          this._enqueueExposure(name, (0, client_core_1._createConfigExposure)(this._user, result2, this._store.getExposureMapping()), options2);
          this.$emt({ name: "dynamic_config_evaluation", dynamicConfig: result2 });
          return result2;
        }
        _getExperimentImpl(name, options2) {
          var _a2, _b, _c, _d;
          const { result: evaluation, details } = this._store.getConfig(name);
          const experiment = (0, client_core_1._makeExperiment)(name, details, evaluation);
          if (experiment.__evaluation != null) {
            experiment.__evaluation.secondary_exposures = (0, client_core_1._mapExposures)((_b = (_a2 = experiment.__evaluation) === null || _a2 === void 0 ? void 0 : _a2.secondary_exposures) !== null && _b !== void 0 ? _b : [], this._store.getExposureMapping());
          }
          const overridden = (_d = (_c = this.overrideAdapter) === null || _c === void 0 ? void 0 : _c.getExperimentOverride) === null || _d === void 0 ? void 0 : _d.call(_c, experiment, this._user, options2);
          const result2 = overridden !== null && overridden !== void 0 ? overridden : experiment;
          this._enqueueExposure(name, (0, client_core_1._createConfigExposure)(this._user, result2, this._store.getExposureMapping()), options2);
          this.$emt({ name: "experiment_evaluation", experiment: result2 });
          return result2;
        }
        _getConfigListImpl() {
          return this._store.getConfigList();
        }
        _getLayerImpl(name, options2) {
          var _a2, _b, _c;
          const { result: evaluation, details } = this._store.getLayer(name);
          const layer2 = (0, client_core_1._makeLayer)(name, details, evaluation);
          const overridden = (_b = (_a2 = this.overrideAdapter) === null || _a2 === void 0 ? void 0 : _a2.getLayerOverride) === null || _b === void 0 ? void 0 : _b.call(_a2, layer2, this._user, options2);
          if (options2 === null || options2 === void 0 ? void 0 : options2.disableExposureLog) {
            this._logger.incrementNonExposureCount(name);
          }
          const result2 = (0, client_core_1._mergeOverride)(layer2, overridden, (_c = overridden === null || overridden === void 0 ? void 0 : overridden.__value) !== null && _c !== void 0 ? _c : layer2.__value, (param) => {
            if (options2 === null || options2 === void 0 ? void 0 : options2.disableExposureLog) {
              return;
            }
            this._enqueueExposure(name, (0, client_core_1._createLayerParameterExposure)(this._user, result2, param, this._store.getExposureMapping()), options2);
          });
          this.$emt({ name: "layer_evaluation", layer: result2 });
          return result2;
        }
        _getParameterStoreImpl(name, options2) {
          var _a2, _b;
          const { result: configuration2, details } = this._store.getParamStore(name);
          this._logger.incrementNonExposureCount(name);
          const paramStore = {
            name,
            details,
            __configuration: configuration2,
            get: (0, ParamStoreGetterFactory_1._makeParamStoreGetter)(this, configuration2, options2)
          };
          const overridden = (_b = (_a2 = this.overrideAdapter) === null || _a2 === void 0 ? void 0 : _a2.getParamStoreOverride) === null || _b === void 0 ? void 0 : _b.call(_a2, paramStore, options2);
          if (overridden != null) {
            paramStore.__configuration = overridden.config;
            paramStore.details = overridden.details;
            paramStore.get = (0, ParamStoreGetterFactory_1._makeParamStoreGetter)(this, overridden.config, options2);
          }
          return paramStore;
        }
      };
      exports.default = StatsigClient;
    }
  });

  // node_modules/@statsig/js-client/src/index.js
  var require_src2 = __commonJS({
    "node_modules/@statsig/js-client/src/index.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __exportStar = exports && exports.__exportStar || function(m, exports2) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.StatsigClient = void 0;
      var client_core_1 = require_src();
      var StatsigClient_1 = require_StatsigClient();
      exports.StatsigClient = StatsigClient_1.default;
      __exportStar(require_src(), exports);
      var __STATSIG__2 = Object.assign((0, client_core_1._getStatsigGlobal)(), {
        StatsigClient: StatsigClient_1.default
      });
      exports.default = __STATSIG__2;
    }
  });

  // node_modules/eventemitter3/index.js
  var require_eventemitter3 = __commonJS({
    "node_modules/eventemitter3/index.js"(exports, module2) {
      "use strict";
      var has = Object.prototype.hasOwnProperty;
      var prefix3 = "~";
      function Events() {
      }
      if (Object.create) {
        Events.prototype = /* @__PURE__ */ Object.create(null);
        if (!new Events().__proto__) prefix3 = false;
      }
      function EE(fn2, context, once2) {
        this.fn = fn2;
        this.context = context;
        this.once = once2 || false;
      }
      function addListener(emitter, event, fn2, context, once2) {
        if (typeof fn2 !== "function") {
          throw new TypeError("The listener must be a function");
        }
        var listener = new EE(fn2, context || emitter, once2), evt = prefix3 ? prefix3 + event : event;
        if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
        else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
        else emitter._events[evt] = [emitter._events[evt], listener];
        return emitter;
      }
      function clearEvent(emitter, evt) {
        if (--emitter._eventsCount === 0) emitter._events = new Events();
        else delete emitter._events[evt];
      }
      function EventEmitter() {
        this._events = new Events();
        this._eventsCount = 0;
      }
      EventEmitter.prototype.eventNames = function eventNames() {
        var names = [], events, name;
        if (this._eventsCount === 0) return names;
        for (name in events = this._events) {
          if (has.call(events, name)) names.push(prefix3 ? name.slice(1) : name);
        }
        if (Object.getOwnPropertySymbols) {
          return names.concat(Object.getOwnPropertySymbols(events));
        }
        return names;
      };
      EventEmitter.prototype.listeners = function listeners(event) {
        var evt = prefix3 ? prefix3 + event : event, handlers = this._events[evt];
        if (!handlers) return [];
        if (handlers.fn) return [handlers.fn];
        for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
          ee[i] = handlers[i].fn;
        }
        return ee;
      };
      EventEmitter.prototype.listenerCount = function listenerCount(event) {
        var evt = prefix3 ? prefix3 + event : event, listeners = this._events[evt];
        if (!listeners) return 0;
        if (listeners.fn) return 1;
        return listeners.length;
      };
      EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
        var evt = prefix3 ? prefix3 + event : event;
        if (!this._events[evt]) return false;
        var listeners = this._events[evt], len = arguments.length, args, i;
        if (listeners.fn) {
          if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
          switch (len) {
            case 1:
              return listeners.fn.call(listeners.context), true;
            case 2:
              return listeners.fn.call(listeners.context, a1), true;
            case 3:
              return listeners.fn.call(listeners.context, a1, a2), true;
            case 4:
              return listeners.fn.call(listeners.context, a1, a2, a3), true;
            case 5:
              return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
            case 6:
              return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
          }
          for (i = 1, args = new Array(len - 1); i < len; i++) {
            args[i - 1] = arguments[i];
          }
          listeners.fn.apply(listeners.context, args);
        } else {
          var length2 = listeners.length, j;
          for (i = 0; i < length2; i++) {
            if (listeners[i].once) this.removeListener(event, listeners[i].fn, void 0, true);
            switch (len) {
              case 1:
                listeners[i].fn.call(listeners[i].context);
                break;
              case 2:
                listeners[i].fn.call(listeners[i].context, a1);
                break;
              case 3:
                listeners[i].fn.call(listeners[i].context, a1, a2);
                break;
              case 4:
                listeners[i].fn.call(listeners[i].context, a1, a2, a3);
                break;
              default:
                if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
                  args[j - 1] = arguments[j];
                }
                listeners[i].fn.apply(listeners[i].context, args);
            }
          }
        }
        return true;
      };
      EventEmitter.prototype.on = function on(event, fn2, context) {
        return addListener(this, event, fn2, context, false);
      };
      EventEmitter.prototype.once = function once2(event, fn2, context) {
        return addListener(this, event, fn2, context, true);
      };
      EventEmitter.prototype.removeListener = function removeListener(event, fn2, context, once2) {
        var evt = prefix3 ? prefix3 + event : event;
        if (!this._events[evt]) return this;
        if (!fn2) {
          clearEvent(this, evt);
          return this;
        }
        var listeners = this._events[evt];
        if (listeners.fn) {
          if (listeners.fn === fn2 && (!once2 || listeners.once) && (!context || listeners.context === context)) {
            clearEvent(this, evt);
          }
        } else {
          for (var i = 0, events = [], length2 = listeners.length; i < length2; i++) {
            if (listeners[i].fn !== fn2 || once2 && !listeners[i].once || context && listeners[i].context !== context) {
              events.push(listeners[i]);
            }
          }
          if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
          else clearEvent(this, evt);
        }
        return this;
      };
      EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
        var evt;
        if (event) {
          evt = prefix3 ? prefix3 + event : event;
          if (this._events[evt]) clearEvent(this, evt);
        } else {
          this._events = new Events();
          this._eventsCount = 0;
        }
        return this;
      };
      EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
      EventEmitter.prototype.addListener = EventEmitter.prototype.on;
      EventEmitter.prefixed = prefix3;
      EventEmitter.EventEmitter = EventEmitter;
      if ("undefined" !== typeof module2) {
        module2.exports = EventEmitter;
      }
    }
  });

  // node_modules/@atlaskit/feature-gate-js-client/dist/cjs/subscriptions/Subscriptions.js
  var require_Subscriptions = __commonJS({
    "node_modules/@atlaskit/feature-gate-js-client/dist/cjs/subscriptions/Subscriptions.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = exports.ALL_FEATURE_VALUES = void 0;
      var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
      var _createClass22 = _interopRequireDefault(require_createClass());
      var _defineProperty2 = _interopRequireDefault(require_defineProperty());
      var _eventemitter = _interopRequireDefault(require_eventemitter3());
      function ownKeys25(e, r) {
        var t = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
          var o = Object.getOwnPropertySymbols(e);
          r && (o = o.filter(function(r2) {
            return Object.getOwnPropertyDescriptor(e, r2).enumerable;
          })), t.push.apply(t, o);
        }
        return t;
      }
      function _objectSpread25(e) {
        for (var r = 1; r < arguments.length; r++) {
          var t = null != arguments[r] ? arguments[r] : {};
          r % 2 ? ownKeys25(Object(t), true).forEach(function(r2) {
            (0, _defineProperty2.default)(e, r2, t[r2]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys25(Object(t)).forEach(function(r2) {
            Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
          });
        }
        return e;
      }
      var ALL_FEATURE_VALUES = exports.ALL_FEATURE_VALUES = "@all-features";
      var Subscriptions = exports.default = /* @__PURE__ */ (function() {
        function Subscriptions2() {
          (0, _classCallCheck2.default)(this, Subscriptions2);
          (0, _defineProperty2.default)(this, "eventToValue", /* @__PURE__ */ new Map());
          this.emitter = new _eventemitter.default();
        }
        return (0, _createClass22.default)(Subscriptions2, [{
          key: "onGateUpdated",
          value: function onGateUpdated(gateName, callback, checkGate, options2) {
            var _this = this;
            var value = checkGate(gateName, _objectSpread25(_objectSpread25({}, options2), {}, {
              fireGateExposure: false
            }));
            if (this.eventToValue.get(callback) === void 0) {
              this.eventToValue.set(callback, value);
            }
            var wrapCallback = function wrapCallback2() {
              var value2 = checkGate(gateName, _objectSpread25(_objectSpread25({}, options2), {}, {
                fireGateExposure: false
              }));
              var existingValue = _this.eventToValue.get(callback);
              if (existingValue !== value2) {
                _this.eventToValue.set(callback, value2);
                callback(value2);
              }
            };
            this.emitter.on(gateName, wrapCallback);
            return function() {
              _this.emitter.off(gateName, wrapCallback);
            };
          }
        }, {
          key: "onExperimentValueUpdated",
          value: function onExperimentValueUpdated(experimentName, parameterName, defaultValue, callback, getExperimentValue, options2) {
            var _this2 = this;
            var experimentEventName = "".concat(experimentName, ".").concat(parameterName);
            var value = getExperimentValue(experimentName, parameterName, defaultValue, _objectSpread25(_objectSpread25({}, options2), {}, {
              fireExperimentExposure: false
            }));
            if (this.eventToValue.get(callback) === void 0) {
              this.eventToValue.set(callback, value);
            }
            var wrapCallback = function wrapCallback2() {
              var value2 = getExperimentValue(experimentName, parameterName, defaultValue, _objectSpread25(_objectSpread25({}, options2), {}, {
                fireExperimentExposure: false
              }));
              var existingValue = _this2.eventToValue.get(callback);
              if (existingValue !== value2) {
                _this2.eventToValue.set(callback, value2);
                callback(value2);
              }
            };
            this.emitter.on(experimentEventName, wrapCallback);
            return function() {
              _this2.emitter.off(experimentEventName, wrapCallback);
            };
          }
        }, {
          key: "onAnyUpdated",
          value: function onAnyUpdated(callback) {
            var _this3 = this;
            this.emitter.on(ALL_FEATURE_VALUES, callback);
            return function() {
              _this3.emitter.off(ALL_FEATURE_VALUES, callback);
            };
          }
        }, {
          key: "anyUpdated",
          value: function anyUpdated() {
            var _this4 = this;
            this.emitter.emit(ALL_FEATURE_VALUES);
            this.emitter.eventNames().filter(function(name) {
              return name !== ALL_FEATURE_VALUES;
            }).forEach(function(event) {
              _this4.emitter.emit(event);
            });
          }
        }]);
      })();
    }
  });

  // node_modules/@atlaskit/feature-gate-js-client/dist/cjs/subscriptions/index.js
  var require_subscriptions = __commonJS({
    "node_modules/@atlaskit/feature-gate-js-client/dist/cjs/subscriptions/index.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "default", {
        enumerable: true,
        get: function get() {
          return _Subscriptions.default;
        }
      });
      var _Subscriptions = _interopRequireDefault(require_Subscriptions());
    }
  });

  // node_modules/@atlaskit/atlassian-context/dist/cjs/common/constants/host-based-lookup/constants/index.js
  var require_constants = __commonJS({
    "node_modules/@atlaskit/atlassian-context/dist/cjs/common/constants/host-based-lookup/constants/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.STAGING = exports.PRODUCTION = exports.FEDRAMP_MODERATE = exports.FEDRAMP_FEDEX = exports.DEV = exports.COMMERCIAL = void 0;
      var FEDRAMP_MODERATE = exports.FEDRAMP_MODERATE = "fedramp-moderate";
      var COMMERCIAL = exports.COMMERCIAL = "commercial";
      var FEDRAMP_FEDEX = exports.FEDRAMP_FEDEX = "fedramp-fedex";
      var STAGING = exports.STAGING = "stg";
      var PRODUCTION = exports.PRODUCTION = "prod";
      var DEV2 = exports.DEV = "dev";
    }
  });

  // node_modules/@atlaskit/atlassian-context/dist/cjs/services/host-based-lookup/is-fedramp/index.js
  var require_is_fedramp = __commonJS({
    "node_modules/@atlaskit/atlassian-context/dist/cjs/services/host-based-lookup/is-fedramp/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.isFedRamp = isFedRamp;
      var _constants = require_constants();
      function isFedRamp() {
        var _global$location;
        var global2 = globalThis;
        var env = global2.MICROS_PERIMETER || global2.UNSAFE_ATL_CONTEXT_BOUNDARY;
        if (env) {
          return env === _constants.FEDRAMP_MODERATE;
        }
        var matches = (_global$location = global2.location) === null || _global$location === void 0 || (_global$location = _global$location.hostname) === null || _global$location === void 0 ? void 0 : _global$location.match(/atlassian-us-gov-mod\.(com|net)|atlassian-us-gov\.(com|net)|atlassian-fex\.(com|net)|atlassian-stg-fedm\.(com|net)/);
        return matches ? matches.length > 0 : false;
      }
    }
  });

  // node_modules/@atlaskit/atlassian-context/dist/cjs/common/constants/host-based-lookup/constants/domains.js
  var require_domains = __commonJS({
    "node_modules/@atlaskit/atlassian-context/dist/cjs/common/constants/host-based-lookup/constants/domains.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.subdomainOverride = exports.fullDomainOverride = exports.domainMap = void 0;
      var _defineProperty2 = _interopRequireDefault(require_defineProperty());
      var _index = require_constants();
      var domainMap = exports.domainMap = (0, _defineProperty2.default)((0, _defineProperty2.default)((0, _defineProperty2.default)({}, _index.COMMERCIAL, (0, _defineProperty2.default)((0, _defineProperty2.default)({}, _index.STAGING, "stg.atlassian.com"), _index.PRODUCTION, "atlassian.com")), _index.FEDRAMP_FEDEX, (0, _defineProperty2.default)({}, _index.STAGING, "atlassian-fex.com")), _index.FEDRAMP_MODERATE, (0, _defineProperty2.default)((0, _defineProperty2.default)({}, _index.STAGING, "stg.atlassian-us-gov-mod.com"), _index.PRODUCTION, "atlassian-us-gov-mod.com"));
      var subdomainOverride = exports.subdomainOverride = {};
      var fullDomainOverride = exports.fullDomainOverride = {
        analytics: (0, _defineProperty2.default)({}, _index.COMMERCIAL, (0, _defineProperty2.default)({}, _index.PRODUCTION, "analytics.atlassian.com")),
        // Marketing site
        confluence: (0, _defineProperty2.default)({}, _index.COMMERCIAL, (0, _defineProperty2.default)({}, _index.PRODUCTION, "confluence.atlassian.com")),
        // Atlassian design system documentation
        design: (0, _defineProperty2.default)({}, _index.COMMERCIAL, (0, _defineProperty2.default)({}, _index.PRODUCTION, "design.atlassian.com")),
        // Old staff intranet (now hello.atlassian.net)
        extranet: (0, _defineProperty2.default)({}, _index.COMMERCIAL, (0, _defineProperty2.default)({}, _index.PRODUCTION, "extranet.atlassian.com")),
        // Go links
        go: (0, _defineProperty2.default)({}, _index.COMMERCIAL, (0, _defineProperty2.default)({}, _index.PRODUCTION, "go.atlassian.com")),
        my: (0, _defineProperty2.default)({}, _index.COMMERCIAL, (0, _defineProperty2.default)({}, _index.PRODUCTION, "my.atlassian.com")),
        schema: (0, _defineProperty2.default)({}, _index.COMMERCIAL, (0, _defineProperty2.default)({}, _index.PRODUCTION, "schema.atlassian.com")),
        start: (0, _defineProperty2.default)((0, _defineProperty2.default)({}, _index.COMMERCIAL, (0, _defineProperty2.default)((0, _defineProperty2.default)({}, _index.PRODUCTION, "start.atlassian.com"), _index.STAGING, "start.stg.atlassian.com")), _index.FEDRAMP_MODERATE, (0, _defineProperty2.default)((0, _defineProperty2.default)({}, _index.PRODUCTION, "start.atlassian-us-gov-mod.com"), _index.STAGING, "start.stg.atlassian-us-gov-mod.com")),
        surveys: (0, _defineProperty2.default)({}, _index.COMMERCIAL, (0, _defineProperty2.default)({}, _index.PRODUCTION, "surveys.atlassian.com")),
        "wac-cdn": (0, _defineProperty2.default)({}, _index.COMMERCIAL, (0, _defineProperty2.default)({}, _index.PRODUCTION, "wac-cdn.atlassian.com")),
        integrations: (0, _defineProperty2.default)({}, _index.COMMERCIAL, (0, _defineProperty2.default)({}, _index.PRODUCTION, "integrations.atlassian.com")),
        permalink: (0, _defineProperty2.default)({}, _index.COMMERCIAL, (0, _defineProperty2.default)({}, _index.PRODUCTION, "permalink.atlassian.com")),
        id: (0, _defineProperty2.default)((0, _defineProperty2.default)({}, _index.COMMERCIAL, (0, _defineProperty2.default)((0, _defineProperty2.default)((0, _defineProperty2.default)({}, _index.PRODUCTION, "id.atlassian.com"), _index.STAGING, "id.stg.internal.atlassian.com"), _index.DEV, "id.dev.internal.atlassian.com")), _index.FEDRAMP_MODERATE, (0, _defineProperty2.default)((0, _defineProperty2.default)({}, _index.PRODUCTION, "id.atlassian-us-gov-mod.com"), _index.STAGING, "id.stg.atlassian-us-gov-mod.com")),
        support: (0, _defineProperty2.default)({}, _index.COMMERCIAL, (0, _defineProperty2.default)({}, _index.PRODUCTION, "support.atlassian.com"))
      };
    }
  });

  // node_modules/@atlaskit/atlassian-context/dist/cjs/common/constants/host-based-lookup/types.js
  var require_types = __commonJS({
    "node_modules/@atlaskit/atlassian-context/dist/cjs/common/constants/host-based-lookup/types.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.AllowedDomains = void 0;
      var AllowedDomains = exports.AllowedDomains = ["admin", "analytics", "api", "api.media", "api-private", "as", "atl-global", "atlaskit", "auth", "automation", "cassi.internal", "cc-import-sources.services", "confluence", "confluence-chats-integr.services", "confluence-cloud-bamboo.internal", "confluence-questions.services", "data-portal.internal", "design", "developer", "extranet", "go", "id", "id-mail-assets", "integrations", "ja", "jira", "jsd-widget", "jsd-widget-staging", "marketplace", "my", "my-reminders.services", "partners", "permalink", "permalink.stg", "schema", "start", "support", "surveys", "team", "wac-cdn", "xxid", "home"];
    }
  });

  // node_modules/@atlaskit/atlassian-context/dist/cjs/services/host-based-lookup/domain-lookup/index.js
  var require_domain_lookup = __commonJS({
    "node_modules/@atlaskit/atlassian-context/dist/cjs/services/host-based-lookup/domain-lookup/index.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports._getEnvironmentFromDomain = _getEnvironmentFromDomain;
      exports.configure = configure;
      exports.getATLContextDomain = getATLContextDomain;
      exports.getATLContextUrl = getATLContextUrl;
      var _slicedToArray2 = _interopRequireDefault(require_slicedToArray());
      var _constants = require_constants();
      var _domains = require_domains();
      var _types = require_types();
      function configure(data) {
        if (!data || Object.keys(data).length < 1) {
          throw new Error("Data are not available");
        }
        globalThis.ATL_CONTEXT_DOMAIN = data;
      }
      function isValidDomainKey(domainKey) {
        if (!_types.AllowedDomains.includes(domainKey)) {
          return false;
        }
        return true;
      }
      function getATLContextDomain(domain, environment) {
        var _domainMap$perimeter$, _domainMap$perimeter, _subdomainOverride$do;
        if (!isValidDomainKey(domain)) {
          throw new Error("Domain ".concat(domain, " is not supported.\n      Supported domains: ").concat(_types.AllowedDomains.join(", ")));
        }
        var data = globalThis.ATL_CONTEXT_DOMAIN;
        if (data) {
          return data[domain];
        }
        var _ref2 = environment !== null && environment !== void 0 ? environment : _getEnvironmentFromDomain(), _ref22 = (0, _slicedToArray2.default)(_ref2, 2), env = _ref22[0], perimeter = _ref22[1];
        var override = _domains.fullDomainOverride[domain];
        if (override) {
          var _override$perimeter$e, _override$perimeter;
          return (
            // Exact match preferred
            (_override$perimeter$e = (_override$perimeter = override[perimeter]) === null || _override$perimeter === void 0 ? void 0 : _override$perimeter[env]) !== null && _override$perimeter$e !== void 0 ? _override$perimeter$e : override[_constants.COMMERCIAL][_constants.PRODUCTION]
          );
        }
        var tld = (_domainMap$perimeter$ = (_domainMap$perimeter = _domains.domainMap[perimeter]) === null || _domainMap$perimeter === void 0 ? void 0 : _domainMap$perimeter[env]) !== null && _domainMap$perimeter$ !== void 0 ? _domainMap$perimeter$ : _domains.domainMap[_constants.COMMERCIAL][_constants.PRODUCTION];
        var subdomain = (_subdomainOverride$do = _domains.subdomainOverride[domain]) !== null && _subdomainOverride$do !== void 0 ? _subdomainOverride$do : domain;
        return "".concat(subdomain, ".").concat(tld);
      }
      function getATLContextUrl(domain) {
        return "".concat(globalThis.location.protocol, "//").concat(getATLContextDomain(domain));
      }
      function _getEnvironmentFromDomain() {
        var _globalThis$location;
        var hostname = (_globalThis$location = globalThis.location) === null || _globalThis$location === void 0 ? void 0 : _globalThis$location.hostname;
        if (!hostname) {
          return [_constants.PRODUCTION, _constants.COMMERCIAL];
        }
        if (hostname.match(/atlassian-fex\.com/)) {
          return [_constants.STAGING, _constants.FEDRAMP_FEDEX];
        }
        if (hostname.match(/stg\.atlassian-us-gov-mod\.(com|net)/)) {
          return [_constants.STAGING, _constants.FEDRAMP_MODERATE];
        }
        if (hostname.match(/atlassian-stg-fedm\.net/)) {
          return [_constants.STAGING, _constants.FEDRAMP_MODERATE];
        }
        if (hostname.match(/atlassian-us-gov-mod\.(com|net)/)) {
          return [_constants.PRODUCTION, _constants.FEDRAMP_MODERATE];
        }
        if (hostname.match(/stg(\.internal)?\.atlassian\.com/)) {
          return [_constants.STAGING, _constants.COMMERCIAL];
        }
        if (hostname.match(/jira-dev\.com/)) {
          return [_constants.STAGING, _constants.COMMERCIAL];
        }
        return [_constants.PRODUCTION, _constants.COMMERCIAL];
      }
    }
  });

  // node_modules/@atlaskit/atlassian-context/dist/cjs/common/constants/index.js
  var require_constants2 = __commonJS({
    "node_modules/@atlaskit/atlassian-context/dist/cjs/common/constants/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.STAGING = exports.PRODUCTION = exports.NON_ISOLATED_CLOUD_PERIMETERS = exports.ISOLATED_CLOUD_PERIMETERS = exports.FEDRAMP_MODERATE = exports.DEV = exports.COMMERCIAL = exports.ATL_CTX_PERIMETER = exports.ATL_CTX_ISOLATION_CONTEXT_ID = exports.ATL_CTX_ISOLATION_CONTEXT_DOMAIN = void 0;
      var FEDRAMP_MODERATE = exports.FEDRAMP_MODERATE = "fedramp-moderate";
      var COMMERCIAL = exports.COMMERCIAL = "commercial";
      var STAGING = exports.STAGING = "staging";
      var PRODUCTION = exports.PRODUCTION = "prod";
      var DEV2 = exports.DEV = "dev";
      var ISOLATED_CLOUD_PERIMETERS = exports.ISOLATED_CLOUD_PERIMETERS = [COMMERCIAL];
      var NON_ISOLATED_CLOUD_PERIMETERS = exports.NON_ISOLATED_CLOUD_PERIMETERS = [COMMERCIAL, FEDRAMP_MODERATE];
      var ATL_CTX_PERIMETER = exports.ATL_CTX_PERIMETER = "Atl-Ctx-Perimeter";
      var ATL_CTX_ISOLATION_CONTEXT_DOMAIN = exports.ATL_CTX_ISOLATION_CONTEXT_DOMAIN = "Atl-Ctx-Isolation-Context-Domain";
      var ATL_CTX_ISOLATION_CONTEXT_ID = exports.ATL_CTX_ISOLATION_CONTEXT_ID = "Atl-Ctx-Isolation-Context-Id";
    }
  });

  // node_modules/@atlaskit/atlassian-context/dist/cjs/services/atl-cookies-lookup/index.js
  var require_atl_cookies_lookup = __commonJS({
    "node_modules/@atlaskit/atlassian-context/dist/cjs/services/atl-cookies-lookup/index.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.parseAtlCtxCookies = parseAtlCtxCookies;
      var _slicedToArray2 = _interopRequireDefault(require_slicedToArray());
      var _constants = require_constants2();
      function _createForOfIteratorHelper4(r, e) {
        var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
        if (!t) {
          if (Array.isArray(r) || (t = _unsupportedIterableToArray6(r)) || e && r && "number" == typeof r.length) {
            t && (r = t);
            var _n = 0, F = function F2() {
            };
            return { s: F, n: function n() {
              return _n >= r.length ? { done: true } : { done: false, value: r[_n++] };
            }, e: function e2(r2) {
              throw r2;
            }, f: F };
          }
          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var o, a = true, u = false;
        return { s: function s() {
          t = t.call(r);
        }, n: function n() {
          var r2 = t.next();
          return a = r2.done, r2;
        }, e: function e2(r2) {
          u = true, o = r2;
        }, f: function f() {
          try {
            a || null == t.return || t.return();
          } finally {
            if (u) throw o;
          }
        } };
      }
      function _unsupportedIterableToArray6(r, a) {
        if (r) {
          if ("string" == typeof r) return _arrayLikeToArray6(r, a);
          var t = {}.toString.call(r).slice(8, -1);
          return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray6(r, a) : void 0;
        }
      }
      function _arrayLikeToArray6(r, a) {
        (null == a || a > r.length) && (a = r.length);
        for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
        return n;
      }
      function getRawCookieValue(cookieName, cookieString) {
        if (!cookieString) {
          return void 0;
        }
        var cookies = cookieString.split(";");
        var _iterator = _createForOfIteratorHelper4(cookies), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var cookie = _step.value;
            var _cookie$trim$split = cookie.trim().split("="), _cookie$trim$split2 = (0, _slicedToArray2.default)(_cookie$trim$split, 2), name = _cookie$trim$split2[0], value = _cookie$trim$split2[1];
            if (name === cookieName) {
              return value;
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        return void 0;
      }
      function parseAtlCtxCookies() {
        var global2 = globalThis;
        try {
          if (typeof globalThis.document === "undefined") {
            return void 0;
          }
          var cookies = global2.document.cookie;
          var perimeter = getRawCookieValue(_constants.ATL_CTX_PERIMETER, cookies);
          if (!perimeter) {
            return void 0;
          }
          var icDomain = getRawCookieValue(_constants.ATL_CTX_ISOLATION_CONTEXT_DOMAIN, cookies);
          var icId = getRawCookieValue(_constants.ATL_CTX_ISOLATION_CONTEXT_ID, cookies);
          var emptyIcDomain = !icDomain || icDomain.length === 0;
          var emptyIcId = !icId || icId.length === 0;
          return {
            perimeter,
            icDomain: emptyIcDomain ? void 0 : icDomain,
            icId: emptyIcId ? void 0 : icId
          };
        } catch (e) {
          console.warn("Failed to parse atl-ctx cookies:", e);
          return void 0;
        }
      }
    }
  });

  // node_modules/@atlaskit/atlassian-context/dist/cjs/services/perimeter/index.js
  var require_perimeter = __commonJS({
    "node_modules/@atlaskit/atlassian-context/dist/cjs/services/perimeter/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.isFedrampModerate = isFedrampModerate;
      exports.isIsolatedCloud = isIsolatedCloud;
      exports.isolatedCloudDomain = isolatedCloudDomain;
      exports.isolationContextId = isolationContextId;
      var _constants = require_constants2();
      var _atlCookiesLookup = require_atl_cookies_lookup();
      function isIsolatedCloud() {
        var atlCtxCookieValues = (0, _atlCookiesLookup.parseAtlCtxCookies)();
        if (!atlCtxCookieValues) {
          return false;
        }
        return _constants.ISOLATED_CLOUD_PERIMETERS.includes(atlCtxCookieValues.perimeter) && atlCtxCookieValues.icDomain !== void 0;
      }
      function isFedrampModerate() {
        var atlCtxCookieValues = (0, _atlCookiesLookup.parseAtlCtxCookies)();
        if (!atlCtxCookieValues) {
          return false;
        }
        return atlCtxCookieValues.perimeter === _constants.FEDRAMP_MODERATE;
      }
      function isolatedCloudDomain() {
        var atlCtxCookieValues = (0, _atlCookiesLookup.parseAtlCtxCookies)();
        return atlCtxCookieValues === null || atlCtxCookieValues === void 0 ? void 0 : atlCtxCookieValues.icDomain;
      }
      function isolationContextId() {
        var atlCtxCookieValues = (0, _atlCookiesLookup.parseAtlCtxCookies)();
        return atlCtxCookieValues === null || atlCtxCookieValues === void 0 ? void 0 : atlCtxCookieValues.icId;
      }
    }
  });

  // node_modules/@atlaskit/atlassian-context/dist/cjs/common/constants/domains.js
  var require_domains2 = __commonJS({
    "node_modules/@atlaskit/atlassian-context/dist/cjs/common/constants/domains.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.globalDomains = exports.fullDomainOverride = void 0;
      var _defineProperty2 = _interopRequireDefault(require_defineProperty());
      var _index = require_constants2();
      var globalDomains = exports.globalDomains = {
        confluence: "confluence.atlassian.com",
        // Atlassian design system documentation
        design: "design.atlassian.com",
        // Atlassian design system documentation
        extranet: "extranet.atlassian.com",
        // Old staff intranet (now hello.atlassian.net)
        go: "go.atlassian.com",
        // Go links
        my: "my.atlassian.com",
        surveys: "surveys.atlassian.com",
        "wac-cdn": "wac-cdn.atlassian.com",
        // WAC CDN links
        integrations: "integrations.atlassian.com",
        // Integrations links
        permalink: "permalink.atlassian.com",
        support: "support.atlassian.com"
      };
      var fullDomainOverride = exports.fullDomainOverride = {
        id: (0, _defineProperty2.default)((0, _defineProperty2.default)({}, _index.COMMERCIAL, (0, _defineProperty2.default)((0, _defineProperty2.default)((0, _defineProperty2.default)({}, _index.PRODUCTION, "id.atlassian.com"), _index.STAGING, "id.stg.internal.atlassian.com"), _index.DEV, "id.dev.internal.atlassian.com")), _index.FEDRAMP_MODERATE, (0, _defineProperty2.default)((0, _defineProperty2.default)({}, _index.PRODUCTION, "id.atlassian-us-gov-mod.com"), _index.STAGING, "id.stg.atlassian-us-gov-mod.com"))
      };
    }
  });

  // node_modules/@atlaskit/atlassian-context/dist/cjs/services/generalized-domain-lookup/constants.js
  var require_constants3 = __commonJS({
    "node_modules/@atlaskit/atlassian-context/dist/cjs/services/generalized-domain-lookup/constants.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.nonIsolatedCloudFunctions = exports.isolatedCloudFunctions = exports.ReservedNameMapping = exports.AtlDomainMapping = void 0;
      var _defineProperty2 = _interopRequireDefault(require_defineProperty());
      var _constants = require_constants2();
      var ReservedNameMapping = exports.ReservedNameMapping = (0, _defineProperty2.default)({}, _constants.COMMERCIAL, ["home", "start", "id", "api", "admin", "auth", "bitbucket"]);
      var AtlDomainMapping = exports.AtlDomainMapping = (0, _defineProperty2.default)({}, _constants.COMMERCIAL, ["packages"]);
      var isolatedCloudFunctions = exports.isolatedCloudFunctions = (0, _defineProperty2.default)({}, _constants.COMMERCIAL, {
        isolatedCloudReservedNameDomain: function isolatedCloudReservedNameDomain(subdomain, isolatedCloudDomain) {
          return "".concat(subdomain, ".").concat(isolatedCloudDomain);
        },
        isolatedCloudAtlDomain: function isolatedCloudAtlDomain(subdomain, isolatedCloudDomain) {
          return "".concat(subdomain, ".atl.").concat(isolatedCloudDomain);
        },
        isolatedCloudVanityDomain: function isolatedCloudVanityDomain(subdomain, isolatedCloudDomain) {
          return "".concat(subdomain, ".services.").concat(isolatedCloudDomain);
        }
      });
      var nonIsolatedCloudFunctions = exports.nonIsolatedCloudFunctions = (0, _defineProperty2.default)((0, _defineProperty2.default)({}, _constants.COMMERCIAL, {
        defaultDomainEnding: function defaultDomainEnding(subdomain, envType) {
          switch (envType) {
            case _constants.PRODUCTION:
              return "".concat(subdomain, ".atlassian.com");
            case _constants.STAGING:
              return "".concat(subdomain, ".stg.atlassian.com");
            case _constants.DEV:
              return "".concat(subdomain, ".dev.atlassian.com");
            default:
              console.warn("Cannot get non-isolated commercial domain for provided environment, ".concat(envType, " is unsupported"));
              return "";
          }
        }
      }), _constants.FEDRAMP_MODERATE, {
        defaultDomainEnding: function defaultDomainEnding(subdomain, envType) {
          switch (envType) {
            case _constants.PRODUCTION:
              return "".concat(subdomain, ".atlassian-us-gov-mod.com");
            case _constants.STAGING:
              return "".concat(subdomain, ".stg.atlassian-us-gov-mod.com");
            default:
              console.warn("Cannot get fedramp-moderate domain for provided environment, ".concat(envType, " is unsupported"));
              return "";
          }
        }
      });
    }
  });

  // node_modules/@atlaskit/atlassian-context/dist/cjs/services/generalized-domain-lookup/index.js
  var require_generalized_domain_lookup = __commonJS({
    "node_modules/@atlaskit/atlassian-context/dist/cjs/services/generalized-domain-lookup/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.getDomainInContext = getDomainInContext;
      exports.getUrlForDomainInContext = getUrlForDomainInContext;
      var _constants = require_constants2();
      var _domains = require_domains2();
      var _atlCookiesLookup = require_atl_cookies_lookup();
      var _constants2 = require_constants3();
      function getDomainInContext(subdomain, envType) {
        var atlCtxCookieValues = (0, _atlCookiesLookup.parseAtlCtxCookies)();
        if (atlCtxCookieValues === void 0) {
          return getDomainForNonIsolatedCloud(subdomain, _constants.COMMERCIAL, envType);
        }
        var isIsolatedCloudPerimeterType = _constants.ISOLATED_CLOUD_PERIMETERS.includes(atlCtxCookieValues.perimeter);
        var isNonIsolatedCloudPerimeterType = _constants.NON_ISOLATED_CLOUD_PERIMETERS.includes(atlCtxCookieValues.perimeter);
        if (!isIsolatedCloudPerimeterType && !isNonIsolatedCloudPerimeterType) {
          console.warn("Atl Ctx cookies are passing in invalid perimeter ".concat(atlCtxCookieValues.perimeter));
          return void 0;
        }
        var isIsolatedCloud = isIsolatedCloudPerimeterType && atlCtxCookieValues.icDomain !== void 0;
        if (isIsolatedCloud) {
          var _perimeter = atlCtxCookieValues.perimeter;
          return getDomainForIsolatedCloud(subdomain, _perimeter, atlCtxCookieValues);
        }
        var perimeter = atlCtxCookieValues.perimeter;
        return getDomainForNonIsolatedCloud(subdomain, perimeter, envType);
      }
      function getDomainForIsolatedCloud(subdomain, perimeter, atlCtxCookieValues) {
        var domainMappings = _constants2.isolatedCloudFunctions[perimeter];
        var isolatedCloudDomain = atlCtxCookieValues.icDomain;
        if (!isolatedCloudDomain) {
          console.warn("No isolated cloud domain found in atl-ctx cookie values");
          return void 0;
        }
        if (_constants2.ReservedNameMapping[perimeter].includes(subdomain)) {
          return domainMappings.isolatedCloudReservedNameDomain(subdomain, isolatedCloudDomain);
        }
        if (_constants2.AtlDomainMapping[perimeter].includes(subdomain)) {
          return domainMappings.isolatedCloudAtlDomain(subdomain, isolatedCloudDomain);
        }
        return domainMappings.isolatedCloudVanityDomain(subdomain, isolatedCloudDomain);
      }
      function getDomainForNonIsolatedCloud(subdomain, perimeter, envType) {
        if (_domains.globalDomains[subdomain]) {
          return _domains.globalDomains[subdomain];
        }
        var override = _domains.fullDomainOverride[subdomain];
        if (override) {
          var _override$perimeter$e, _override$perimeter;
          return (_override$perimeter$e = (_override$perimeter = override[perimeter]) === null || _override$perimeter === void 0 ? void 0 : _override$perimeter[envType]) !== null && _override$perimeter$e !== void 0 ? _override$perimeter$e : override[_constants.COMMERCIAL][_constants.PRODUCTION];
        }
        var domainMappings = _constants2.nonIsolatedCloudFunctions[perimeter];
        return domainMappings.defaultDomainEnding(subdomain, envType);
      }
      function getUrlForDomainInContext(subdomain, envType) {
        var domain = getDomainInContext(subdomain, envType);
        if (!domain) {
          console.warn("Domain could not be determined for requested subdomain: ".concat(subdomain));
          return void 0;
        }
        return "".concat(globalThis.location.protocol, "//").concat(domain);
      }
    }
  });

  // node_modules/@atlaskit/atlassian-context/dist/cjs/index.js
  var require_cjs = __commonJS({
    "node_modules/@atlaskit/atlassian-context/dist/cjs/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "getATLContextDomain", {
        enumerable: true,
        get: function get() {
          return _domainLookup.getATLContextDomain;
        }
      });
      Object.defineProperty(exports, "getATLContextUrl", {
        enumerable: true,
        get: function get() {
          return _domainLookup.getATLContextUrl;
        }
      });
      Object.defineProperty(exports, "getDomainInContext", {
        enumerable: true,
        get: function get() {
          return _generalizedDomainLookup.getDomainInContext;
        }
      });
      Object.defineProperty(exports, "getUrlForDomainInContext", {
        enumerable: true,
        get: function get() {
          return _generalizedDomainLookup.getUrlForDomainInContext;
        }
      });
      Object.defineProperty(exports, "isFedRamp", {
        enumerable: true,
        get: function get() {
          return _isFedramp.isFedRamp;
        }
      });
      Object.defineProperty(exports, "isFedrampModerate", {
        enumerable: true,
        get: function get() {
          return _perimeter.isFedrampModerate;
        }
      });
      Object.defineProperty(exports, "isIsolatedCloud", {
        enumerable: true,
        get: function get() {
          return _perimeter.isIsolatedCloud;
        }
      });
      Object.defineProperty(exports, "isolatedCloudDomain", {
        enumerable: true,
        get: function get() {
          return _perimeter.isolatedCloudDomain;
        }
      });
      Object.defineProperty(exports, "isolationContextId", {
        enumerable: true,
        get: function get() {
          return _perimeter.isolationContextId;
        }
      });
      var _isFedramp = require_is_fedramp();
      var _domainLookup = require_domain_lookup();
      var _perimeter = require_perimeter();
      var _generalizedDomainLookup = require_generalized_domain_lookup();
    }
  });

  // node_modules/@atlaskit/feature-gate-js-client/dist/cjs/client/compat/types.js
  var require_types2 = __commonJS({
    "node_modules/@atlaskit/feature-gate-js-client/dist/cjs/client/compat/types.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.EvaluationReason = void 0;
      var EvaluationReason = exports.EvaluationReason = /* @__PURE__ */ (function(EvaluationReason2) {
        EvaluationReason2["Error"] = "Error";
        EvaluationReason2["LocalOverride"] = "LocalOverride";
        EvaluationReason2["Unrecognized"] = "Unrecognized";
        EvaluationReason2["Uninitialized"] = "Uninitialized";
        EvaluationReason2["NetworkNotModified"] = "NetworkNotModified";
        EvaluationReason2["Network"] = "Network";
        EvaluationReason2["InvalidBootstrap"] = "InvalidBootstrap";
        EvaluationReason2["Bootstrap"] = "Bootstrap";
        EvaluationReason2["Cache"] = "Cache";
        EvaluationReason2["Unknown"] = "Unknown";
        return EvaluationReason2;
      })({});
    }
  });

  // node_modules/@atlaskit/feature-gate-js-client/dist/cjs/client/types.js
  var require_types3 = __commonJS({
    "node_modules/@atlaskit/feature-gate-js-client/dist/cjs/client/types.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.PerimeterType = exports.NON_BOOLEAN_VALUE = exports.FeatureGateEnvironment = void 0;
      var FeatureGateEnvironment = exports.FeatureGateEnvironment = /* @__PURE__ */ (function(FeatureGateEnvironment2) {
        FeatureGateEnvironment2["Development"] = "development";
        FeatureGateEnvironment2["Staging"] = "staging";
        FeatureGateEnvironment2["Production"] = "production";
        return FeatureGateEnvironment2;
      })({});
      var PerimeterType = exports.PerimeterType = /* @__PURE__ */ (function(PerimeterType2) {
        PerimeterType2["COMMERCIAL"] = "commercial";
        PerimeterType2["FEDRAMP_MODERATE"] = "fedramp-moderate";
        return PerimeterType2;
      })({});
      var NON_BOOLEAN_VALUE = exports.NON_BOOLEAN_VALUE = "non_boolean";
    }
  });

  // node_modules/@atlaskit/feature-gate-js-client/dist/cjs/client/utils.js
  var require_utils = __commonJS({
    "node_modules/@atlaskit/feature-gate-js-client/dist/cjs/client/utils.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.toStatsigUser = exports.shallowEquals = exports.migrateSecondaryExposures = exports.migrateInitializationOptions = exports.migrateEvaluationDetails = exports.getOptionsWithDefaults = void 0;
      var _objectWithoutProperties2 = _interopRequireDefault(require_objectWithoutProperties());
      var _slicedToArray2 = _interopRequireDefault(require_slicedToArray());
      var _defineProperty2 = _interopRequireDefault(require_defineProperty());
      var _atlassianContext = require_cjs();
      var _types = require_types2();
      var _types2 = require_types3();
      var _excluded30 = ["api", "disableCurrentPageLogging", "loggingIntervalMillis", "loggingBufferMaxSize", "localMode", "eventLoggingApi", "eventLoggingApiForRetries", "disableLocalStorage", "ignoreWindowUndefined", "disableAllLogging", "initTimeoutMs", "disableNetworkKeepalive", "overrideStableID", "disableErrorLogging", "disableAutoMetricsLogging"];
      function ownKeys25(e, r) {
        var t = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
          var o = Object.getOwnPropertySymbols(e);
          r && (o = o.filter(function(r2) {
            return Object.getOwnPropertyDescriptor(e, r2).enumerable;
          })), t.push.apply(t, o);
        }
        return t;
      }
      function _objectSpread25(e) {
        for (var r = 1; r < arguments.length; r++) {
          var t = null != arguments[r] ? arguments[r] : {};
          r % 2 ? ownKeys25(Object(t), true).forEach(function(r2) {
            (0, _defineProperty2.default)(e, r2, t[r2]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys25(Object(t)).forEach(function(r2) {
            Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
          });
        }
        return e;
      }
      var getOptionsWithDefaults = exports.getOptionsWithDefaults = function getOptionsWithDefaults2(options2) {
        return _objectSpread25({
          /**
           * If more federal PerimeterTypes are added in the future, this should be updated so
           * that isFedRamp() === true always returns the strictest perimeter.
           */
          perimeter: (0, _atlassianContext.isFedRamp)() ? _types2.PerimeterType.FEDRAMP_MODERATE : _types2.PerimeterType.COMMERCIAL
        }, options2);
      };
      var shallowEquals = exports.shallowEquals = function shallowEquals2(objectA, objectB) {
        if (!objectA && !objectB) {
          return true;
        }
        if (!objectA || !objectB) {
          return false;
        }
        var aEntries = Object.entries(objectA);
        var bEntries = Object.entries(objectB);
        if (aEntries.length !== bEntries.length) {
          return false;
        }
        var ascendingKeyOrder = function ascendingKeyOrder2(_ref2, _ref22) {
          var _ref3 = (0, _slicedToArray2.default)(_ref2, 1), key1 = _ref3[0];
          var _ref4 = (0, _slicedToArray2.default)(_ref22, 1), key2 = _ref4[0];
          return key1.localeCompare(key2);
        };
        aEntries.sort(ascendingKeyOrder);
        bEntries.sort(ascendingKeyOrder);
        for (var i = 0; i < aEntries.length; i++) {
          var _aEntries$i = (0, _slicedToArray2.default)(aEntries[i], 2), aValue = _aEntries$i[1];
          var _bEntries$i = (0, _slicedToArray2.default)(bEntries[i], 2), bValue = _bEntries$i[1];
          if (aValue !== bValue) {
            return false;
          }
        }
        return true;
      };
      var toStatsigUser = exports.toStatsigUser = function toStatsigUser2(identifiers, customAttributes) {
        var user = {
          customIDs: identifiers,
          custom: customAttributes
        };
        if (identifiers.atlassianAccountId) {
          user.userID = identifiers.atlassianAccountId;
        }
        return user;
      };
      var migrateInitializationOptions = exports.migrateInitializationOptions = function migrateInitializationOptions2(options2) {
        var api4 = options2.api, disableCurrentPageLogging = options2.disableCurrentPageLogging, loggingIntervalMillis = options2.loggingIntervalMillis, loggingBufferMaxSize = options2.loggingBufferMaxSize, localMode = options2.localMode, eventLoggingApi = options2.eventLoggingApi, eventLoggingApiForRetries = options2.eventLoggingApiForRetries, disableLocalStorage = options2.disableLocalStorage, ignoreWindowUndefined = options2.ignoreWindowUndefined, disableAllLogging = options2.disableAllLogging, _initTimeoutMs = options2.initTimeoutMs, _disableNetworkKeepalive = options2.disableNetworkKeepalive, _overrideStableID = options2.overrideStableID, _disableErrorLogging = options2.disableErrorLogging, _disableAutoMetricsLogging = options2.disableAutoMetricsLogging, rest = (0, _objectWithoutProperties2.default)(options2, _excluded30);
        return _objectSpread25(_objectSpread25({}, rest), {}, {
          networkConfig: {
            api: api4,
            logEventUrl: eventLoggingApi ? eventLoggingApi + "rgstr" : void 0,
            logEventFallbackUrls: eventLoggingApiForRetries ? [eventLoggingApiForRetries] : void 0,
            preventAllNetworkTraffic: localMode || !ignoreWindowUndefined && typeof window === "undefined"
          },
          includeCurrentPageUrlWithEvents: !disableCurrentPageLogging,
          loggingIntervalMs: loggingIntervalMillis,
          loggingBufferMaxSize,
          disableStorage: disableLocalStorage === void 0 ? localMode : disableLocalStorage,
          disableLogging: disableAllLogging === void 0 ? localMode : disableAllLogging
        });
      };
      var evaluationReasonMappings = Object.entries(_types.EvaluationReason).map(function(_ref5) {
        var _ref6 = (0, _slicedToArray2.default)(_ref5, 2), key = _ref6[0], value = _ref6[1];
        return [key.toLowerCase(), value];
      });
      var migrateEvaluationDetails = exports.migrateEvaluationDetails = function migrateEvaluationDetails2(details) {
        var _evaluationReasonMapp, _evaluationReasonMapp2, _details$receivedAt;
        var reasonLower = details.reason.toLowerCase();
        return {
          reason: (_evaluationReasonMapp = (_evaluationReasonMapp2 = evaluationReasonMappings.find(function(_ref7) {
            var _ref8 = (0, _slicedToArray2.default)(_ref7, 1), key = _ref8[0];
            return reasonLower.includes(key);
          })) === null || _evaluationReasonMapp2 === void 0 ? void 0 : _evaluationReasonMapp2[1]) !== null && _evaluationReasonMapp !== void 0 ? _evaluationReasonMapp : _types.EvaluationReason.Unknown,
          time: (_details$receivedAt = details.receivedAt) !== null && _details$receivedAt !== void 0 ? _details$receivedAt : Date.now()
        };
      };
      var migrateSecondaryExposures = exports.migrateSecondaryExposures = function migrateSecondaryExposures2(secondaryExposures) {
        return secondaryExposures.map(function(exposure) {
          if (typeof exposure === "string") {
            return {
              gate: exposure
            };
          }
          return exposure;
        });
      };
    }
  });

  // node_modules/@atlaskit/feature-gate-js-client/dist/cjs/client/compat/DynamicConfig.js
  var require_DynamicConfig = __commonJS({
    "node_modules/@atlaskit/feature-gate-js-client/dist/cjs/client/compat/DynamicConfig.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.DynamicConfig = void 0;
      var _typeof2 = _interopRequireDefault(require_typeof());
      var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
      var _createClass22 = _interopRequireDefault(require_createClass());
      var _utils = require_utils();
      var DynamicConfig = exports.DynamicConfig = /* @__PURE__ */ (function() {
        function DynamicConfig2(configName, configValue, ruleID, evaluationDetails) {
          var secondaryExposures = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : [];
          var allocatedExperimentName = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : "";
          var onDefaultValueFallback = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : null;
          (0, _classCallCheck2.default)(this, DynamicConfig2);
          this.value = configValue;
          this._name = configName;
          this._ruleID = ruleID;
          this._secondaryExposures = secondaryExposures;
          this._allocatedExperimentName = allocatedExperimentName;
          this._evaluationDetails = evaluationDetails;
          this._onDefaultValueFallback = onDefaultValueFallback;
        }
        return (0, _createClass22.default)(DynamicConfig2, [{
          key: "get",
          value: function get(key, defaultValue, typeGuard) {
            var _this$_onDefaultValue2;
            var val = this.getValue(key, defaultValue);
            if (val == null) {
              return defaultValue;
            }
            var expectedType = Array.isArray(defaultValue) ? "array" : (0, _typeof2.default)(defaultValue);
            var actualType = Array.isArray(val) ? "array" : (0, _typeof2.default)(val);
            if (typeGuard) {
              var _this$_onDefaultValue;
              if (typeGuard(val)) {
                this.fireExposure(key);
                return val;
              }
              (_this$_onDefaultValue = this._onDefaultValueFallback) === null || _this$_onDefaultValue === void 0 || _this$_onDefaultValue.call(this, this, key, expectedType, actualType);
              return defaultValue;
            }
            if (defaultValue == null || expectedType === actualType) {
              this.fireExposure(key);
              return val;
            }
            (_this$_onDefaultValue2 = this._onDefaultValueFallback) === null || _this$_onDefaultValue2 === void 0 || _this$_onDefaultValue2.call(this, this, key, expectedType, actualType);
            return defaultValue;
          }
        }, {
          key: "getValue",
          value: function getValue(key, defaultValue) {
            if (key == null) {
              return this.value;
            }
            if (defaultValue == null) {
              defaultValue = null;
            }
            if (this.value[key] == null) {
              return defaultValue;
            }
            this.fireExposure(key);
            return this.value[key];
          }
        }, {
          key: "fireExposure",
          value: function fireExposure(key) {
            if (this.experiment) {
              this.experiment.get(key);
            }
          }
        }], [{
          key: "fromExperiment",
          value: function fromExperiment(experiment) {
            var _experiment$__evaluat, _experiment$__evaluat2, _experiment$groupName;
            var config = new DynamicConfig2(experiment.name, experiment.value, experiment.ruleID, (0, _utils.migrateEvaluationDetails)(experiment.details), (0, _utils.migrateSecondaryExposures)((_experiment$__evaluat = (_experiment$__evaluat2 = experiment.__evaluation) === null || _experiment$__evaluat2 === void 0 ? void 0 : _experiment$__evaluat2.secondary_exposures) !== null && _experiment$__evaluat !== void 0 ? _experiment$__evaluat : []), (_experiment$groupName = experiment.groupName) !== null && _experiment$groupName !== void 0 ? _experiment$groupName : void 0);
            config.experiment = experiment;
            return config;
          }
          /** @deprecated - do not use, this is still exported for backwards compatibility but will be removed in the next major version  */
        }]);
      })();
    }
  });

  // node_modules/@atlaskit/feature-gate-js-client/dist/cjs/client/compat/Layer.js
  var require_Layer = __commonJS({
    "node_modules/@atlaskit/feature-gate-js-client/dist/cjs/client/compat/Layer.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.Layer = void 0;
      var _typeof2 = _interopRequireDefault(require_typeof());
      var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
      var _createClass22 = _interopRequireDefault(require_createClass());
      var _utils = require_utils();
      var Layer2 = exports.Layer = /* @__PURE__ */ (function() {
        function Layer3(name, layerValue, ruleID, evaluationDetails) {
          var logParameterFunction = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null;
          var secondaryExposures = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : [];
          var undelegatedSecondaryExposures = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : [];
          var allocatedExperimentName = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : "";
          var explicitParameters = arguments.length > 8 && arguments[8] !== void 0 ? arguments[8] : [];
          (0, _classCallCheck2.default)(this, Layer3);
          this._logParameterFunction = logParameterFunction;
          this._name = name;
          this._value = JSON.parse(JSON.stringify(layerValue !== null && layerValue !== void 0 ? layerValue : {}));
          this._ruleID = ruleID !== null && ruleID !== void 0 ? ruleID : "";
          this._evaluationDetails = evaluationDetails;
          this._secondaryExposures = secondaryExposures;
          this._undelegatedSecondaryExposures = undelegatedSecondaryExposures;
          this._allocatedExperimentName = allocatedExperimentName;
          this._explicitParameters = explicitParameters;
        }
        return (0, _createClass22.default)(Layer3, [{
          key: "get",
          value: function get(key, defaultValue, typeGuard) {
            var _this = this;
            var val = this._value[key];
            if (val == null) {
              return defaultValue;
            }
            var logAndReturn = function logAndReturn2() {
              _this._logLayerParameterExposure(key);
              return val;
            };
            if (typeGuard) {
              return typeGuard(val) ? logAndReturn() : defaultValue;
            }
            if (defaultValue == null) {
              return logAndReturn();
            }
            if ((0, _typeof2.default)(val) === (0, _typeof2.default)(defaultValue) && Array.isArray(defaultValue) === Array.isArray(val)) {
              return logAndReturn();
            }
            return defaultValue;
          }
        }, {
          key: "getValue",
          value: function getValue(key, defaultValue) {
            if (defaultValue == void 0) {
              defaultValue = null;
            }
            var val = this._value[key];
            if (val != null) {
              this._logLayerParameterExposure(key);
            }
            return val !== null && val !== void 0 ? val : defaultValue;
          }
        }, {
          key: "_logLayerParameterExposure",
          value: function _logLayerParameterExposure(parameterName) {
            var _this$_logParameterFu;
            (_this$_logParameterFu = this._logParameterFunction) === null || _this$_logParameterFu === void 0 || _this$_logParameterFu.call(this, this, parameterName);
          }
        }], [{
          key: "fromLayer",
          value: function fromLayer(layer2) {
            var _layer$__evaluation$s, _layer$__evaluation, _layer$__evaluation$u, _layer$__evaluation2, _layer$__evaluation3, _layer$__evaluation4;
            var value = new Layer3(layer2.name, layer2.__value, layer2.ruleID, (0, _utils.migrateEvaluationDetails)(layer2.details), function(_layer, parameterName) {
              return layer2.get(parameterName);
            }, (0, _utils.migrateSecondaryExposures)((_layer$__evaluation$s = (_layer$__evaluation = layer2.__evaluation) === null || _layer$__evaluation === void 0 ? void 0 : _layer$__evaluation.secondary_exposures) !== null && _layer$__evaluation$s !== void 0 ? _layer$__evaluation$s : []), (0, _utils.migrateSecondaryExposures)((_layer$__evaluation$u = (_layer$__evaluation2 = layer2.__evaluation) === null || _layer$__evaluation2 === void 0 ? void 0 : _layer$__evaluation2.undelegated_secondary_exposures) !== null && _layer$__evaluation$u !== void 0 ? _layer$__evaluation$u : []), (_layer$__evaluation3 = layer2.__evaluation) === null || _layer$__evaluation3 === void 0 ? void 0 : _layer$__evaluation3.allocated_experiment_name, (_layer$__evaluation4 = layer2.__evaluation) === null || _layer$__evaluation4 === void 0 ? void 0 : _layer$__evaluation4.explicit_parameters);
            return value;
          }
          /** @deprecated - do not use, this is still exported for backwards compatibility but will be removed in the next major version  */
          /** @deprecated - do not use, this is still exported for backwards compatibility but will be removed in the next major version  */
        }]);
      })();
    }
  });

  // node_modules/@atlaskit/feature-gate-js-client/dist/cjs/client/version.js
  var require_version = __commonJS({
    "node_modules/@atlaskit/feature-gate-js-client/dist/cjs/client/version.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.CLIENT_VERSION = void 0;
      var CLIENT_VERSION = exports.CLIENT_VERSION = "5.5.3";
    }
  });

  // node_modules/@babel/runtime/helpers/assertThisInitialized.js
  var require_assertThisInitialized = __commonJS({
    "node_modules/@babel/runtime/helpers/assertThisInitialized.js"(exports, module2) {
      function _assertThisInitialized2(e) {
        if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return e;
      }
      module2.exports = _assertThisInitialized2, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/possibleConstructorReturn.js
  var require_possibleConstructorReturn = __commonJS({
    "node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"(exports, module2) {
      var _typeof2 = require_typeof()["default"];
      var assertThisInitialized = require_assertThisInitialized();
      function _possibleConstructorReturn2(t, e) {
        if (e && ("object" == _typeof2(e) || "function" == typeof e)) return e;
        if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
        return assertThisInitialized(t);
      }
      module2.exports = _possibleConstructorReturn2, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/getPrototypeOf.js
  var require_getPrototypeOf = __commonJS({
    "node_modules/@babel/runtime/helpers/getPrototypeOf.js"(exports, module2) {
      function _getPrototypeOf2(t) {
        return module2.exports = _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
          return t2.__proto__ || Object.getPrototypeOf(t2);
        }, module2.exports.__esModule = true, module2.exports["default"] = module2.exports, _getPrototypeOf2(t);
      }
      module2.exports = _getPrototypeOf2, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/setPrototypeOf.js
  var require_setPrototypeOf = __commonJS({
    "node_modules/@babel/runtime/helpers/setPrototypeOf.js"(exports, module2) {
      function _setPrototypeOf2(t, e) {
        return module2.exports = _setPrototypeOf2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
          return t2.__proto__ = e2, t2;
        }, module2.exports.__esModule = true, module2.exports["default"] = module2.exports, _setPrototypeOf2(t, e);
      }
      module2.exports = _setPrototypeOf2, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/inherits.js
  var require_inherits = __commonJS({
    "node_modules/@babel/runtime/helpers/inherits.js"(exports, module2) {
      var setPrototypeOf2 = require_setPrototypeOf();
      function _inherits2(t, e) {
        if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
        t.prototype = Object.create(e && e.prototype, {
          constructor: {
            value: t,
            writable: true,
            configurable: true
          }
        }), Object.defineProperty(t, "prototype", {
          writable: false
        }), e && setPrototypeOf2(t, e);
      }
      module2.exports = _inherits2, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/isNativeFunction.js
  var require_isNativeFunction = __commonJS({
    "node_modules/@babel/runtime/helpers/isNativeFunction.js"(exports, module2) {
      function _isNativeFunction(t) {
        try {
          return -1 !== Function.toString.call(t).indexOf("[native code]");
        } catch (n) {
          return "function" == typeof t;
        }
      }
      module2.exports = _isNativeFunction, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js
  var require_isNativeReflectConstruct = __commonJS({
    "node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js"(exports, module2) {
      function _isNativeReflectConstruct4() {
        try {
          var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
        } catch (t2) {
        }
        return (module2.exports = _isNativeReflectConstruct4 = function _isNativeReflectConstruct5() {
          return !!t;
        }, module2.exports.__esModule = true, module2.exports["default"] = module2.exports)();
      }
      module2.exports = _isNativeReflectConstruct4, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/construct.js
  var require_construct = __commonJS({
    "node_modules/@babel/runtime/helpers/construct.js"(exports, module2) {
      var isNativeReflectConstruct = require_isNativeReflectConstruct();
      var setPrototypeOf2 = require_setPrototypeOf();
      function _construct(t, e, r) {
        if (isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments);
        var o = [null];
        o.push.apply(o, e);
        var p = new (t.bind.apply(t, o))();
        return r && setPrototypeOf2(p, r.prototype), p;
      }
      module2.exports = _construct, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/wrapNativeSuper.js
  var require_wrapNativeSuper = __commonJS({
    "node_modules/@babel/runtime/helpers/wrapNativeSuper.js"(exports, module2) {
      var getPrototypeOf = require_getPrototypeOf();
      var setPrototypeOf2 = require_setPrototypeOf();
      var isNativeFunction = require_isNativeFunction();
      var construct = require_construct();
      function _wrapNativeSuper(t) {
        var r = "function" == typeof Map ? /* @__PURE__ */ new Map() : void 0;
        return module2.exports = _wrapNativeSuper = function _wrapNativeSuper2(t2) {
          if (null === t2 || !isNativeFunction(t2)) return t2;
          if ("function" != typeof t2) throw new TypeError("Super expression must either be null or a function");
          if (void 0 !== r) {
            if (r.has(t2)) return r.get(t2);
            r.set(t2, Wrapper);
          }
          function Wrapper() {
            return construct(t2, arguments, getPrototypeOf(this).constructor);
          }
          return Wrapper.prototype = Object.create(t2.prototype, {
            constructor: {
              value: Wrapper,
              enumerable: false,
              writable: true,
              configurable: true
            }
          }), setPrototypeOf2(Wrapper, t2);
        }, module2.exports.__esModule = true, module2.exports["default"] = module2.exports, _wrapNativeSuper(t);
      }
      module2.exports = _wrapNativeSuper, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
    }
  });

  // node_modules/@atlaskit/feature-gate-js-client/dist/cjs/client/fetcher/errors.js
  var require_errors = __commonJS({
    "node_modules/@atlaskit/feature-gate-js-client/dist/cjs/client/fetcher/errors.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.ResponseError = void 0;
      var _createClass22 = _interopRequireDefault(require_createClass());
      var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
      var _possibleConstructorReturn2 = _interopRequireDefault(require_possibleConstructorReturn());
      var _getPrototypeOf2 = _interopRequireDefault(require_getPrototypeOf());
      var _inherits2 = _interopRequireDefault(require_inherits());
      var _wrapNativeSuper2 = _interopRequireDefault(require_wrapNativeSuper());
      function _callSuper4(t, o, e) {
        return o = (0, _getPrototypeOf2.default)(o), (0, _possibleConstructorReturn2.default)(t, _isNativeReflectConstruct4() ? Reflect.construct(o, e || [], (0, _getPrototypeOf2.default)(t).constructor) : o.apply(t, e));
      }
      function _isNativeReflectConstruct4() {
        try {
          var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
        } catch (t2) {
        }
        return (_isNativeReflectConstruct4 = function _isNativeReflectConstruct5() {
          return !!t;
        })();
      }
      var ResponseError = exports.ResponseError = /* @__PURE__ */ (function(_Error) {
        function ResponseError2(message2) {
          (0, _classCallCheck2.default)(this, ResponseError2);
          return _callSuper4(this, ResponseError2, [message2]);
        }
        (0, _inherits2.default)(ResponseError2, _Error);
        return (0, _createClass22.default)(ResponseError2);
      })(/* @__PURE__ */ (0, _wrapNativeSuper2.default)(Error));
    }
  });

  // node_modules/@atlaskit/feature-gate-js-client/dist/cjs/client/fetcher/Fetcher.js
  var require_Fetcher = __commonJS({
    "node_modules/@atlaskit/feature-gate-js-client/dist/cjs/client/fetcher/Fetcher.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = exports.STAGING_BASE_URL = exports.PROD_BASE_URL = exports.IC_STAGING_BASE_DOMAIN_URL = exports.IC_PROD_BASE_DOMAIN_URL = exports.IC_FFS_BASE_URL = exports.GATEWAY_BASE_URL = exports.FEDM_STAGING_BASE_URL = exports.FEDM_PROD_BASE_URL = exports.DEV_BASE_URL = void 0;
      var _regenerator = _interopRequireDefault(require_regenerator2());
      var _defineProperty2 = _interopRequireDefault(require_defineProperty());
      var _asyncToGenerator2 = _interopRequireDefault(require_asyncToGenerator());
      var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
      var _createClass22 = _interopRequireDefault(require_createClass());
      var _types = require_types3();
      var _version = require_version();
      var _errors = require_errors();
      function ownKeys25(e, r) {
        var t = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
          var o = Object.getOwnPropertySymbols(e);
          r && (o = o.filter(function(r2) {
            return Object.getOwnPropertyDescriptor(e, r2).enumerable;
          })), t.push.apply(t, o);
        }
        return t;
      }
      function _objectSpread25(e) {
        for (var r = 1; r < arguments.length; r++) {
          var t = null != arguments[r] ? arguments[r] : {};
          r % 2 ? ownKeys25(Object(t), true).forEach(function(r2) {
            (0, _defineProperty2.default)(e, r2, t[r2]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys25(Object(t)).forEach(function(r2) {
            Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
          });
        }
        return e;
      }
      var DEFAULT_REQUEST_TIMEOUT_MS = 5e3;
      var PROD_BASE_URL = exports.PROD_BASE_URL = "https://api.atlassian.com/flags";
      var STAGING_BASE_URL = exports.STAGING_BASE_URL = "https://api.stg.atlassian.com/flags";
      var DEV_BASE_URL = exports.DEV_BASE_URL = "https://api.dev.atlassian.com/flags";
      var FEDM_STAGING_BASE_URL = exports.FEDM_STAGING_BASE_URL = "https://api.stg.atlassian-us-gov-mod.com/flags";
      var FEDM_PROD_BASE_URL = exports.FEDM_PROD_BASE_URL = "https://api.atlassian-us-gov-mod.com/flags";
      var IC_FFS_BASE_URL = exports.IC_FFS_BASE_URL = "https://atlassian-statsig-proxy-archetype.atl-paas.%s.atl-ic.net";
      var IC_STAGING_BASE_DOMAIN_URL = exports.IC_STAGING_BASE_DOMAIN_URL = "oasis-stg.com/flags";
      var IC_PROD_BASE_DOMAIN_URL = exports.IC_PROD_BASE_DOMAIN_URL = "atlassian-isolated.net/flags";
      var GATEWAY_BASE_URL = exports.GATEWAY_BASE_URL = "/gateway/api/flags";
      var Fetcher = exports.default = /* @__PURE__ */ (function() {
        function Fetcher2() {
          (0, _classCallCheck2.default)(this, Fetcher2);
        }
        return (0, _createClass22.default)(Fetcher2, null, [{
          key: "fetchClientSdk",
          value: (function() {
            var _fetchClientSdk = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(fetcherOptions) {
              var targetApp, url;
              return _regenerator.default.wrap(function _callee$(_context) {
                while (1) switch (_context.prev = _context.next) {
                  case 0:
                    targetApp = fetcherOptions.targetApp;
                    url = "/api/v2/frontend/clientSdkKey/".concat(targetApp);
                    _context.prev = 2;
                    _context.next = 5;
                    return this.fetchRequest(url, "GET", fetcherOptions);
                  case 5:
                    return _context.abrupt("return", _context.sent);
                  case 8:
                    _context.prev = 8;
                    _context.t0 = _context["catch"](2);
                    if (!(_context.t0 instanceof Error)) {
                      _context.next = 12;
                      break;
                    }
                    throw _context.t0;
                  case 12:
                    throw Error("Failed to retrieve client sdk key");
                  case 13:
                  case "end":
                    return _context.stop();
                }
              }, _callee, this, [[2, 8]]);
            }));
            function fetchClientSdk(_x) {
              return _fetchClientSdk.apply(this, arguments);
            }
            return fetchClientSdk;
          })()
        }, {
          key: "fetchExperimentValues",
          value: (function() {
            var _fetchExperimentValues = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee2(fetcherOptions, identifiers, customAttributes) {
              var requestBody;
              return _regenerator.default.wrap(function _callee2$(_context2) {
                while (1) switch (_context2.prev = _context2.next) {
                  case 0:
                    requestBody = {
                      identifiers,
                      customAttributes,
                      targetApp: fetcherOptions.targetApp
                    };
                    _context2.prev = 1;
                    _context2.next = 4;
                    return this.fetchRequest("/api/v2/frontend/experimentValues", "POST", fetcherOptions, requestBody);
                  case 4:
                    return _context2.abrupt("return", _context2.sent);
                  case 7:
                    _context2.prev = 7;
                    _context2.t0 = _context2["catch"](1);
                    if (!(_context2.t0 instanceof Error)) {
                      _context2.next = 11;
                      break;
                    }
                    throw _context2.t0;
                  case 11:
                    throw Error("Failed to retrieve experiment values");
                  case 12:
                  case "end":
                    return _context2.stop();
                }
              }, _callee2, this, [[1, 7]]);
            }));
            function fetchExperimentValues(_x2, _x3, _x4) {
              return _fetchExperimentValues.apply(this, arguments);
            }
            return fetchExperimentValues;
          })()
        }, {
          key: "handleResponseError",
          value: (function() {
            var _handleResponseError = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee3(response) {
              var body;
              return _regenerator.default.wrap(function _callee3$(_context3) {
                while (1) switch (_context3.prev = _context3.next) {
                  case 0:
                    if (response.ok) {
                      _context3.next = 5;
                      break;
                    }
                    _context3.next = 3;
                    return response.text();
                  case 3:
                    body = _context3.sent;
                    throw new _errors.ResponseError("Non 2xx response status received, status: ".concat(response.status, ", body: ").concat(JSON.stringify(body)));
                  case 5:
                    if (!(response.status === 204)) {
                      _context3.next = 7;
                      break;
                    }
                    throw new _errors.ResponseError("Unexpected 204 response");
                  case 7:
                  case "end":
                    return _context3.stop();
                }
              }, _callee3);
            }));
            function handleResponseError(_x5) {
              return _handleResponseError.apply(this, arguments);
            }
            return handleResponseError;
          })()
        }, {
          key: "extractResponseBody",
          value: (function() {
            var _extractResponseBody = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee4(response) {
              var value;
              return _regenerator.default.wrap(function _callee4$(_context4) {
                while (1) switch (_context4.prev = _context4.next) {
                  case 0:
                    _context4.next = 2;
                    return response.text();
                  case 2:
                    value = _context4.sent;
                    return _context4.abrupt("return", JSON.parse(value));
                  case 4:
                  case "end":
                    return _context4.stop();
                }
              }, _callee4);
            }));
            function extractResponseBody(_x6) {
              return _extractResponseBody.apply(this, arguments);
            }
            return extractResponseBody;
          })()
        }, {
          key: "getBaseUrl",
          value: function getBaseUrl(serviceEnv) {
            var useGatewayUrl = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
            var perimeter = arguments.length > 2 ? arguments[2] : void 0;
            var isolationContextId = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
            if (useGatewayUrl) {
              return GATEWAY_BASE_URL;
            }
            if (perimeter === _types.PerimeterType.FEDRAMP_MODERATE) {
              switch (serviceEnv) {
                case _types.FeatureGateEnvironment.Production:
                  return FEDM_PROD_BASE_URL;
                case _types.FeatureGateEnvironment.Staging:
                  return FEDM_STAGING_BASE_URL;
                default:
                  throw new Error('Invalid environment "'.concat(serviceEnv, '" for "').concat(perimeter, '" perimeter'));
              }
            } else if (perimeter === _types.PerimeterType.COMMERCIAL) {
              switch (serviceEnv) {
                case _types.FeatureGateEnvironment.Development:
                  return DEV_BASE_URL;
                case _types.FeatureGateEnvironment.Staging:
                  var apiUrl = this.getApiUrl(isolationContextId);
                  if (apiUrl !== null) {
                    return apiUrl;
                  }
                  return STAGING_BASE_URL;
                default:
                  var prodApiUrl = this.getApiUrl(isolationContextId);
                  if (prodApiUrl !== null) {
                    return prodApiUrl;
                  }
                  return PROD_BASE_URL;
              }
            } else {
              throw new Error('Invalid perimeter "'.concat(perimeter, '"'));
            }
          }
        }, {
          key: "fetchRequest",
          value: (function() {
            var _fetchRequest = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee5(path, method, fetcherOptions, body) {
              var baseUrl, fetchTimeout, abortSignal, abortController, response;
              return _regenerator.default.wrap(function _callee5$(_context5) {
                while (1) switch (_context5.prev = _context5.next) {
                  case 0:
                    baseUrl = Fetcher2.getBaseUrl(fetcherOptions.environment, fetcherOptions.useGatewayURL, fetcherOptions.perimeter, fetcherOptions.isolationContextId);
                    fetchTimeout = fetcherOptions.fetchTimeoutMs || DEFAULT_REQUEST_TIMEOUT_MS;
                    if (AbortSignal.timeout) {
                      abortSignal = AbortSignal.timeout(fetchTimeout);
                    } else if (AbortController) {
                      abortController = new AbortController();
                      abortSignal = abortController.signal;
                      setTimeout(function() {
                        return abortController.abort();
                      }, fetchTimeout);
                    }
                    _context5.next = 5;
                    return fetch("".concat(baseUrl).concat(path), _objectSpread25({
                      method,
                      headers: {
                        "Content-Type": "application/json",
                        "X-Client-Name": "feature-gate-js-client",
                        "X-Client-Version": _version.CLIENT_VERSION,
                        "X-API-KEY": fetcherOptions.apiKey
                      },
                      signal: abortSignal
                    }, body && {
                      body: JSON.stringify(body)
                    }));
                  case 5:
                    response = _context5.sent;
                    _context5.next = 8;
                    return this.handleResponseError(response);
                  case 8:
                    _context5.next = 10;
                    return this.extractResponseBody(response);
                  case 10:
                    return _context5.abrupt("return", _context5.sent);
                  case 11:
                  case "end":
                    return _context5.stop();
                }
              }, _callee5, this);
            }));
            function fetchRequest(_x7, _x8, _x9, _x0) {
              return _fetchRequest.apply(this, arguments);
            }
            return fetchRequest;
          })()
        }, {
          key: "getApiUrl",
          value: function getApiUrl(isolationContextId) {
            var window2 = this.getWindowLocation();
            if (window2 === void 0) {
              if (!isolationContextId) {
                return null;
              }
              return IC_FFS_BASE_URL.replace("%s", isolationContextId);
            }
            var protocol = window2.protocol, hostname = window2.hostname;
            var oasisMatch = hostname.match(/([^.]+)\.oasis-stg\.com$/);
            if (oasisMatch) {
              return "".concat(protocol, "//api.").concat(oasisMatch[1], ".").concat(IC_STAGING_BASE_DOMAIN_URL);
            }
            var isolatedMatch = hostname.match(/([^.]+)\.atlassian-isolated\.net$/);
            if (isolatedMatch) {
              return "".concat(protocol, "//api.").concat(isolatedMatch[1], ".").concat(IC_PROD_BASE_DOMAIN_URL);
            }
            return null;
          }
        }, {
          key: "getWindowLocation",
          value: function getWindowLocation() {
            if (typeof window !== "undefined" && window.location) {
              return window.location;
            }
            return void 0;
          }
        }]);
      })();
    }
  });

  // node_modules/@atlaskit/feature-gate-js-client/dist/cjs/client/fetcher/index.js
  var require_fetcher = __commonJS({
    "node_modules/@atlaskit/feature-gate-js-client/dist/cjs/client/fetcher/index.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "default", {
        enumerable: true,
        get: function get() {
          return _Fetcher.default;
        }
      });
      var _Fetcher = _interopRequireDefault(require_Fetcher());
    }
  });

  // node_modules/@babel/runtime/helpers/superPropBase.js
  var require_superPropBase = __commonJS({
    "node_modules/@babel/runtime/helpers/superPropBase.js"(exports, module2) {
      var getPrototypeOf = require_getPrototypeOf();
      function _superPropBase2(t, o) {
        for (; !{}.hasOwnProperty.call(t, o) && null !== (t = getPrototypeOf(t)); ) ;
        return t;
      }
      module2.exports = _superPropBase2, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/get.js
  var require_get = __commonJS({
    "node_modules/@babel/runtime/helpers/get.js"(exports, module2) {
      var superPropBase = require_superPropBase();
      function _get2() {
        return module2.exports = _get2 = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(e, t, r) {
          var p = superPropBase(e, t);
          if (p) {
            var n = Object.getOwnPropertyDescriptor(p, t);
            return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value;
          }
        }, module2.exports.__esModule = true, module2.exports["default"] = module2.exports, _get2.apply(null, arguments);
      }
      module2.exports = _get2, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
    }
  });

  // node_modules/@atlaskit/feature-gate-js-client/dist/cjs/client/NoFetchDataAdapter.js
  var require_NoFetchDataAdapter = __commonJS({
    "node_modules/@atlaskit/feature-gate-js-client/dist/cjs/client/NoFetchDataAdapter.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.NoFetchDataAdapter = void 0;
      var _regenerator = _interopRequireDefault(require_regenerator2());
      var _asyncToGenerator2 = _interopRequireDefault(require_asyncToGenerator());
      var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
      var _createClass22 = _interopRequireDefault(require_createClass());
      var _possibleConstructorReturn2 = _interopRequireDefault(require_possibleConstructorReturn());
      var _getPrototypeOf2 = _interopRequireDefault(require_getPrototypeOf());
      var _get2 = _interopRequireDefault(require_get());
      var _inherits2 = _interopRequireDefault(require_inherits());
      var _defineProperty2 = _interopRequireDefault(require_defineProperty());
      var _jsClient = require_src2();
      function ownKeys25(e, r) {
        var t = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
          var o = Object.getOwnPropertySymbols(e);
          r && (o = o.filter(function(r2) {
            return Object.getOwnPropertyDescriptor(e, r2).enumerable;
          })), t.push.apply(t, o);
        }
        return t;
      }
      function _objectSpread25(e) {
        for (var r = 1; r < arguments.length; r++) {
          var t = null != arguments[r] ? arguments[r] : {};
          r % 2 ? ownKeys25(Object(t), true).forEach(function(r2) {
            (0, _defineProperty2.default)(e, r2, t[r2]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys25(Object(t)).forEach(function(r2) {
            Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
          });
        }
        return e;
      }
      function _callSuper4(t, o, e) {
        return o = (0, _getPrototypeOf2.default)(o), (0, _possibleConstructorReturn2.default)(t, _isNativeReflectConstruct4() ? Reflect.construct(o, e || [], (0, _getPrototypeOf2.default)(t).constructor) : o.apply(t, e));
      }
      function _isNativeReflectConstruct4() {
        try {
          var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
        } catch (t2) {
        }
        return (_isNativeReflectConstruct4 = function _isNativeReflectConstruct5() {
          return !!t;
        })();
      }
      function _superPropGet2(t, o, e, r) {
        var p = (0, _get2.default)((0, _getPrototypeOf2.default)(1 & r ? t.prototype : t), o, e);
        return 2 & r && "function" == typeof p ? function(t2) {
          return p.apply(e, t2);
        } : p;
      }
      var NoFetchDataAdapter = exports.NoFetchDataAdapter = /* @__PURE__ */ (function(_DataAdapterCore) {
        function NoFetchDataAdapter2() {
          var _this;
          (0, _classCallCheck2.default)(this, NoFetchDataAdapter2);
          _this = _callSuper4(this, NoFetchDataAdapter2, ["NoFetchDataAdapter", "nofetch"]);
          (0, _defineProperty2.default)(_this, "bootstrapResult", null);
          return _this;
        }
        (0, _inherits2.default)(NoFetchDataAdapter2, _DataAdapterCore);
        return (0, _createClass22.default)(NoFetchDataAdapter2, [{
          key: "setBootstrapData",
          value: function setBootstrapData(data) {
            this.bootstrapResult = data ? {
              source: "Bootstrap",
              data: JSON.stringify(data),
              receivedAt: Date.now(),
              stableID: _jsClient.StableID.get(this._getSdkKey()),
              fullUserHash: null
            } : null;
          }
        }, {
          key: "prefetchData",
          value: (function() {
            var _prefetchData = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(_user, _options) {
              return _regenerator.default.wrap(function _callee$(_context) {
                while (1) switch (_context.prev = _context.next) {
                  case 0:
                  case "end":
                    return _context.stop();
                }
              }, _callee);
            }));
            function prefetchData(_x, _x2) {
              return _prefetchData.apply(this, arguments);
            }
            return prefetchData;
          })()
        }, {
          key: "getDataAsync",
          value: (function() {
            var _getDataAsync = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee2(_current, user, _options) {
              return _regenerator.default.wrap(function _callee2$(_context2) {
                while (1) switch (_context2.prev = _context2.next) {
                  case 0:
                    return _context2.abrupt("return", this.bootstrapResult && _objectSpread25(_objectSpread25({}, this.bootstrapResult), {}, {
                      fullUserHash: (0, _jsClient._getFullUserHash)(user)
                    }));
                  case 1:
                  case "end":
                    return _context2.stop();
                }
              }, _callee2, this);
            }));
            function getDataAsync(_x3, _x4, _x5) {
              return _getDataAsync.apply(this, arguments);
            }
            return getDataAsync;
          })()
        }, {
          key: "getDataSync",
          value: function getDataSync(user) {
            return this.bootstrapResult && _objectSpread25(_objectSpread25({}, this.bootstrapResult), {}, {
              fullUserHash: (0, _jsClient._getFullUserHash)(user)
            });
          }
        }, {
          key: "_fetchFromNetwork",
          value: (function() {
            var _fetchFromNetwork2 = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee3(_current, _user, _options) {
              return _regenerator.default.wrap(function _callee3$(_context3) {
                while (1) switch (_context3.prev = _context3.next) {
                  case 0:
                    return _context3.abrupt("return", null);
                  case 1:
                  case "end":
                    return _context3.stop();
                }
              }, _callee3);
            }));
            function _fetchFromNetwork(_x6, _x7, _x8) {
              return _fetchFromNetwork2.apply(this, arguments);
            }
            return _fetchFromNetwork;
          })()
        }, {
          key: "_getCacheKey",
          value: function _getCacheKey(user) {
            var key = (0, _jsClient._getStorageKey)(this._getSdkKey(), user);
            return "".concat(_jsClient.DataAdapterCachePrefix, ".").concat(this._cacheSuffix, ".").concat(key);
          }
        }, {
          key: "_isCachedResultValidFor204",
          value: function _isCachedResultValidFor204(_result, _user) {
            return false;
          }
        }, {
          key: "setDataLegacy",
          value: function setDataLegacy(data, user) {
            _superPropGet2(NoFetchDataAdapter2, "setData", this, 3)([data, user]);
          }
          // Do not stringify options property since that includes this adapter and will
          // cause a circular reference when Statsig sends diagnostic events and including
          // values is not necessary and makes the result huge
        }, {
          key: "toJSON",
          value: function toJSON() {
            var result2 = _objectSpread25({}, this);
            delete result2._options;
            delete result2._inMemoryCache;
            delete result2.bootstrapResult;
            return result2;
          }
        }]);
      })(_jsClient.DataAdapterCore);
    }
  });

  // node_modules/@atlaskit/feature-gate-js-client/dist/cjs/client/PersistentOverrideAdapter.js
  var require_PersistentOverrideAdapter = __commonJS({
    "node_modules/@atlaskit/feature-gate-js-client/dist/cjs/client/PersistentOverrideAdapter.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.PersistentOverrideAdapter = exports.LOCAL_STORAGE_KEY = void 0;
      var _defineProperty2 = _interopRequireDefault(require_defineProperty());
      var _slicedToArray2 = _interopRequireDefault(require_slicedToArray());
      var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
      var _createClass22 = _interopRequireDefault(require_createClass());
      var _clientCore = require_src();
      function ownKeys25(e, r) {
        var t = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
          var o = Object.getOwnPropertySymbols(e);
          r && (o = o.filter(function(r2) {
            return Object.getOwnPropertyDescriptor(e, r2).enumerable;
          })), t.push.apply(t, o);
        }
        return t;
      }
      function _objectSpread25(e) {
        for (var r = 1; r < arguments.length; r++) {
          var t = null != arguments[r] ? arguments[r] : {};
          r % 2 ? ownKeys25(Object(t), true).forEach(function(r2) {
            (0, _defineProperty2.default)(e, r2, t[r2]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys25(Object(t)).forEach(function(r2) {
            Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
          });
        }
        return e;
      }
      function _createForOfIteratorHelper4(r, e) {
        var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
        if (!t) {
          if (Array.isArray(r) || (t = _unsupportedIterableToArray6(r)) || e && r && "number" == typeof r.length) {
            t && (r = t);
            var _n = 0, F = function F2() {
            };
            return { s: F, n: function n() {
              return _n >= r.length ? { done: true } : { done: false, value: r[_n++] };
            }, e: function e2(r2) {
              throw r2;
            }, f: F };
          }
          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var o, a = true, u = false;
        return { s: function s() {
          t = t.call(r);
        }, n: function n() {
          var r2 = t.next();
          return a = r2.done, r2;
        }, e: function e2(r2) {
          u = true, o = r2;
        }, f: function f() {
          try {
            a || null == t.return || t.return();
          } finally {
            if (u) throw o;
          }
        } };
      }
      function _unsupportedIterableToArray6(r, a) {
        if (r) {
          if ("string" == typeof r) return _arrayLikeToArray6(r, a);
          var t = {}.toString.call(r).slice(8, -1);
          return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray6(r, a) : void 0;
        }
      }
      function _arrayLikeToArray6(r, a) {
        (null == a || a > r.length) && (a = r.length);
        for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
        return n;
      }
      var LOCAL_OVERRIDE_REASON = "LocalOverride:Recognized";
      var LOCAL_STORAGE_KEY = exports.LOCAL_STORAGE_KEY = "STATSIG_OVERRIDES";
      var LEGACY_LOCAL_STORAGE_KEY = "STATSIG_JS_LITE_LOCAL_OVERRIDES";
      var makeEmptyStore = function makeEmptyStore2() {
        return {
          gates: {},
          configs: {},
          layers: {}
        };
      };
      var djb2MapKey = function djb2MapKey2(hash4, kind) {
        return kind + ":" + hash4;
      };
      var PersistentOverrideAdapter = exports.PersistentOverrideAdapter = /* @__PURE__ */ (function() {
        function PersistentOverrideAdapter2(localStorageKey) {
          (0, _classCallCheck2.default)(this, PersistentOverrideAdapter2);
          this._overrides = makeEmptyStore();
          this._djb2Map = /* @__PURE__ */ new Map();
          this._localStorageKey = localStorageKey;
        }
        return (0, _createClass22.default)(PersistentOverrideAdapter2, [{
          key: "parseStoredOverrides",
          value: function parseStoredOverrides(localStorageKey) {
            try {
              var json = window.localStorage.getItem(localStorageKey);
              if (!json) {
                return makeEmptyStore();
              }
              return JSON.parse(json);
            } catch (_unused) {
              return makeEmptyStore();
            }
          }
        }, {
          key: "mergeOverrides",
          value: function mergeOverrides() {
            var merged = makeEmptyStore();
            for (var _len = arguments.length, allOverrides = new Array(_len), _key = 0; _key < _len; _key++) {
              allOverrides[_key] = arguments[_key];
            }
            for (var _i = 0, _allOverrides = allOverrides; _i < _allOverrides.length; _i++) {
              var overrides = _allOverrides[_i];
              for (var _i2 = 0, _Object$entries = Object.entries((_overrides$gates = overrides.gates) !== null && _overrides$gates !== void 0 ? _overrides$gates : {}); _i2 < _Object$entries.length; _i2++) {
                var _overrides$gates;
                var _Object$entries$_i = (0, _slicedToArray2.default)(_Object$entries[_i2], 2), name = _Object$entries$_i[0], value = _Object$entries$_i[1];
                merged.gates[name] = value;
              }
              for (var _i3 = 0, _Object$entries2 = Object.entries((_overrides$configs = overrides.configs) !== null && _overrides$configs !== void 0 ? _overrides$configs : {}); _i3 < _Object$entries2.length; _i3++) {
                var _overrides$configs;
                var _Object$entries2$_i = (0, _slicedToArray2.default)(_Object$entries2[_i3], 2), _name = _Object$entries2$_i[0], _value = _Object$entries2$_i[1];
                merged.configs[_name] = _value;
              }
              for (var _i4 = 0, _Object$entries3 = Object.entries((_overrides$layers = overrides.layers) !== null && _overrides$layers !== void 0 ? _overrides$layers : {}); _i4 < _Object$entries3.length; _i4++) {
                var _overrides$layers;
                var _Object$entries3$_i = (0, _slicedToArray2.default)(_Object$entries3[_i4], 2), _name2 = _Object$entries3$_i[0], _value2 = _Object$entries3$_i[1];
                merged.layers[_name2] = _value2;
              }
            }
            return merged;
          }
        }, {
          key: "initFromStoredOverrides",
          value: function initFromStoredOverrides() {
            var storedOverrides = this.mergeOverrides(this._overrides, this.parseStoredOverrides(LEGACY_LOCAL_STORAGE_KEY), this.parseStoredOverrides(this._localStorageKey));
            try {
              window.localStorage.removeItem(LEGACY_LOCAL_STORAGE_KEY);
            } catch (_unused2) {
            }
            for (var _i5 = 0, _Object$values = Object.values(storedOverrides); _i5 < _Object$values.length; _i5++) {
              var container = _Object$values[_i5];
              var allKeys = new Set(Object.keys(container));
              var _iterator = _createForOfIteratorHelper4(allKeys), _step;
              try {
                for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                  var name = _step.value;
                  var hash4 = (0, _clientCore._DJB2)(name);
                  if (allKeys.has(hash4)) {
                    delete container[hash4];
                  }
                }
              } catch (err) {
                _iterator.e(err);
              } finally {
                _iterator.f();
              }
            }
            this.applyOverrides(storedOverrides);
          }
        }, {
          key: "saveOverrides",
          value: function saveOverrides() {
            try {
              window.localStorage.setItem(this._localStorageKey, JSON.stringify(this._overrides));
            } catch (_unused3) {
            }
          }
        }, {
          key: "getOverrides",
          value: function getOverrides() {
            return this.mergeOverrides(this._overrides);
          }
        }, {
          key: "applyOverrides",
          value: function applyOverrides(overrides) {
            var newOverrides = _objectSpread25(_objectSpread25({}, makeEmptyStore()), overrides);
            this._djb2Map.clear();
            for (var _i6 = 0, _Object$entries4 = Object.entries(newOverrides); _i6 < _Object$entries4.length; _i6++) {
              var _Object$entries4$_i = (0, _slicedToArray2.default)(_Object$entries4[_i6], 2), containerName = _Object$entries4$_i[0], container = _Object$entries4$_i[1];
              for (var _i7 = 0, _Object$entries5 = Object.entries(container); _i7 < _Object$entries5.length; _i7++) {
                var _Object$entries5$_i = (0, _slicedToArray2.default)(_Object$entries5[_i7], 2), name = _Object$entries5$_i[0], value = _Object$entries5$_i[1];
                this._djb2Map.set(djb2MapKey((0, _clientCore._DJB2)(name), containerName), value);
              }
            }
            this._overrides = newOverrides;
          }
        }, {
          key: "setOverrides",
          value: function setOverrides(overrides) {
            this.applyOverrides(overrides);
            this.saveOverrides();
          }
        }, {
          key: "overrideGate",
          value: function overrideGate(name, value) {
            this._overrides.gates[name] = value;
            this._djb2Map.set(djb2MapKey((0, _clientCore._DJB2)(name), "gates"), value);
            this.saveOverrides();
          }
        }, {
          key: "removeGateOverride",
          value: function removeGateOverride(name) {
            delete this._overrides.gates[name];
            this._djb2Map.delete(djb2MapKey((0, _clientCore._DJB2)(name), "gates"));
            this.saveOverrides();
          }
        }, {
          key: "getGateOverride",
          value: function getGateOverride(current, _user) {
            var _this$_overrides$gate;
            var overridden = (_this$_overrides$gate = this._overrides.gates[current.name]) !== null && _this$_overrides$gate !== void 0 ? _this$_overrides$gate : this._djb2Map.get(djb2MapKey(current.name, "gates"));
            if (overridden == null) {
              return null;
            }
            return _objectSpread25(_objectSpread25({}, current), {}, {
              value: overridden,
              details: _objectSpread25(_objectSpread25({}, current.details), {}, {
                reason: LOCAL_OVERRIDE_REASON
              })
            });
          }
        }, {
          key: "overrideDynamicConfig",
          value: function overrideDynamicConfig(name, value) {
            this._overrides.configs[name] = value;
            this._djb2Map.set(djb2MapKey((0, _clientCore._DJB2)(name), "configs"), value);
            this.saveOverrides();
          }
        }, {
          key: "removeDynamicConfigOverride",
          value: function removeDynamicConfigOverride(name) {
            delete this._overrides.configs[name];
            this._djb2Map.delete(djb2MapKey((0, _clientCore._DJB2)(name), "configs"));
            this.saveOverrides();
          }
        }, {
          key: "getDynamicConfigOverride",
          value: function getDynamicConfigOverride(current, _user) {
            return this._getConfigOverride(current, this._overrides.configs);
          }
        }, {
          key: "overrideExperiment",
          value: function overrideExperiment(name, value) {
            this._overrides.configs[name] = value;
            this._djb2Map.set(djb2MapKey((0, _clientCore._DJB2)(name), "configs"), value);
            this.saveOverrides();
          }
        }, {
          key: "removeExperimentOverride",
          value: function removeExperimentOverride(name) {
            delete this._overrides.configs[name];
            this._djb2Map.delete(djb2MapKey((0, _clientCore._DJB2)(name), "configs"));
            this.saveOverrides();
          }
        }, {
          key: "getExperimentOverride",
          value: function getExperimentOverride(current, _user) {
            return this._getConfigOverride(current, this._overrides.configs);
          }
        }, {
          key: "overrideLayer",
          value: function overrideLayer(name, value) {
            this._overrides.layers[name] = value;
            this._djb2Map.set(djb2MapKey((0, _clientCore._DJB2)(name), "layers"), value);
            this.saveOverrides();
          }
        }, {
          key: "removeLayerOverride",
          value: function removeLayerOverride(name) {
            delete this._overrides.layers[name];
            this._djb2Map.delete(djb2MapKey((0, _clientCore._DJB2)(name), "layers"));
            this.saveOverrides();
          }
        }, {
          key: "removeAllOverrides",
          value: function removeAllOverrides() {
            this._overrides = makeEmptyStore();
            try {
              window.localStorage.removeItem(this._localStorageKey);
            } catch (_unused4) {
            }
          }
        }, {
          key: "getLayerOverride",
          value: function getLayerOverride(current, _user) {
            var _this$_overrides$laye;
            var overridden = (_this$_overrides$laye = this._overrides.layers[current.name]) !== null && _this$_overrides$laye !== void 0 ? _this$_overrides$laye : this._djb2Map.get(djb2MapKey(current.name, "layers"));
            if (overridden == null) {
              return null;
            }
            return _objectSpread25(_objectSpread25({}, current), {}, {
              __value: overridden,
              get: (0, _clientCore._makeTypedGet)(current.name, overridden),
              details: _objectSpread25(_objectSpread25({}, current.details), {}, {
                reason: LOCAL_OVERRIDE_REASON
              })
            });
          }
        }, {
          key: "_getConfigOverride",
          value: function _getConfigOverride(current, lookup) {
            var _lookup$current$name;
            var overridden = (_lookup$current$name = lookup[current.name]) !== null && _lookup$current$name !== void 0 ? _lookup$current$name : this._djb2Map.get(djb2MapKey(current.name, "configs"));
            if (overridden == null) {
              return null;
            }
            return _objectSpread25(_objectSpread25({}, current), {}, {
              value: overridden,
              get: (0, _clientCore._makeTypedGet)(current.name, overridden),
              details: _objectSpread25(_objectSpread25({}, current.details), {}, {
                reason: LOCAL_OVERRIDE_REASON
              })
            });
          }
        }]);
      })();
    }
  });

  // node_modules/@atlaskit/feature-gate-js-client/dist/cjs/client/Client.js
  var require_Client = __commonJS({
    "node_modules/@atlaskit/feature-gate-js-client/dist/cjs/client/Client.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.Client = void 0;
      var _objectWithoutProperties2 = _interopRequireDefault(require_objectWithoutProperties());
      var _regenerator = _interopRequireDefault(require_regenerator2());
      var _slicedToArray2 = _interopRequireDefault(require_slicedToArray());
      var _asyncToGenerator2 = _interopRequireDefault(require_asyncToGenerator());
      var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
      var _createClass22 = _interopRequireDefault(require_createClass());
      var _defineProperty2 = _interopRequireDefault(require_defineProperty());
      var _jsClient = require_src2();
      var _subscriptions = _interopRequireDefault(require_subscriptions());
      var _DynamicConfig = require_DynamicConfig();
      var _Layer = require_Layer();
      var _types = require_types2();
      var _fetcher = _interopRequireDefault(require_fetcher());
      var _NoFetchDataAdapter = require_NoFetchDataAdapter();
      var _PersistentOverrideAdapter = require_PersistentOverrideAdapter();
      var _types2 = require_types3();
      var _utils = require_utils();
      var _version = require_version();
      var _excluded30 = ["sdkKey", "environment", "updateUserCompletionCallback", "perimeter"];
      function ownKeys25(e, r) {
        var t = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
          var o = Object.getOwnPropertySymbols(e);
          r && (o = o.filter(function(r2) {
            return Object.getOwnPropertyDescriptor(e, r2).enumerable;
          })), t.push.apply(t, o);
        }
        return t;
      }
      function _objectSpread25(e) {
        for (var r = 1; r < arguments.length; r++) {
          var t = null != arguments[r] ? arguments[r] : {};
          r % 2 ? ownKeys25(Object(t), true).forEach(function(r2) {
            (0, _defineProperty2.default)(e, r2, t[r2]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys25(Object(t)).forEach(function(r2) {
            Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
          });
        }
        return e;
      }
      var DEFAULT_CLIENT_KEY = "client-default-key";
      var DEFAULT_EVENT_LOGGING_API = "https://xp.atlassian.com/v1/rgstr";
      var Client = exports.Client = /* @__PURE__ */ (function() {
        function Client2() {
          var _this = this;
          var _ref2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref$localStorageKey = _ref2.localStorageKey, localStorageKey = _ref$localStorageKey === void 0 ? _PersistentOverrideAdapter.LOCAL_STORAGE_KEY : _ref$localStorageKey, overrideAdapter = _ref2.overrideAdapter;
          (0, _classCallCheck2.default)(this, Client2);
          (0, _defineProperty2.default)(this, "initPromise", null);
          (0, _defineProperty2.default)(this, "initCompleted", false);
          (0, _defineProperty2.default)(this, "initWithDefaults", false);
          (0, _defineProperty2.default)(this, "hasCheckGateErrorOccurred", false);
          (0, _defineProperty2.default)(this, "hasGetExperimentErrorOccurred", false);
          (0, _defineProperty2.default)(this, "hasGetExperimentValueErrorOccurred", false);
          (0, _defineProperty2.default)(this, "hasGetLayerErrorOccurred", false);
          (0, _defineProperty2.default)(this, "hasGetLayerValueErrorOccurred", false);
          (0, _defineProperty2.default)(this, "subscriptions", new _subscriptions.default());
          (0, _defineProperty2.default)(this, "dataAdapter", new _NoFetchDataAdapter.NoFetchDataAdapter());
          (0, _defineProperty2.default)(this, "statsigValuesUpdated", function() {
            if (_this.user) {
              _this.statsigClient.updateUserSync(_this.user, {
                disableBackgroundCacheRefresh: true
              });
            }
            _this.subscriptions.anyUpdated();
          });
          this.overrideAdapter = overrideAdapter || new _PersistentOverrideAdapter.PersistentOverrideAdapter(localStorageKey);
        }
        return (0, _createClass22.default)(Client2, [{
          key: "initialize",
          value: (function() {
            var _initialize = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(clientOptions, identifiers, customAttributes) {
              var _this2 = this;
              var clientOptionsWithDefaults, startTime;
              return _regenerator.default.wrap(function _callee$(_context) {
                while (1) switch (_context.prev = _context.next) {
                  case 0:
                    clientOptionsWithDefaults = (0, _utils.getOptionsWithDefaults)(clientOptions);
                    if (!this.initPromise) {
                      _context.next = 4;
                      break;
                    }
                    if (!(0, _utils.shallowEquals)(clientOptionsWithDefaults, this.initOptions)) {
                      console.warn("Feature Gates client already initialized with different options. New options were not applied.");
                    }
                    return _context.abrupt("return", this.initPromise);
                  case 4:
                    startTime = performance.now();
                    this.initOptions = clientOptionsWithDefaults;
                    this.initPromise = this.init(clientOptionsWithDefaults, identifiers, customAttributes).then(function() {
                      _this2.initCompleted = true;
                      _this2.initWithDefaults = true;
                    }).finally(function() {
                      var endTime = performance.now();
                      var totalTime = endTime - startTime;
                      _this2.fireClientEvent(startTime, totalTime, "initialize", _this2.initCompleted, clientOptionsWithDefaults.apiKey);
                    });
                    return _context.abrupt("return", this.initPromise);
                  case 8:
                  case "end":
                    return _context.stop();
                }
              }, _callee, this);
            }));
            function initialize(_x, _x2, _x3) {
              return _initialize.apply(this, arguments);
            }
            return initialize;
          })()
        }, {
          key: "initializeWithProvider",
          value: (function() {
            var _initializeWithProvider = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee2(clientOptions, provider, identifiers, customAttributes) {
              var _this3 = this;
              var clientOptionsWithDefaults, startTime;
              return _regenerator.default.wrap(function _callee2$(_context2) {
                while (1) switch (_context2.prev = _context2.next) {
                  case 0:
                    clientOptionsWithDefaults = (0, _utils.getOptionsWithDefaults)(clientOptions);
                    if (!this.initPromise) {
                      _context2.next = 4;
                      break;
                    }
                    if (!(0, _utils.shallowEquals)(clientOptionsWithDefaults, this.initOptions)) {
                      console.warn("Feature Gates client already initialized with different options. New options were not applied.");
                    }
                    return _context2.abrupt("return", this.initPromise);
                  case 4:
                    startTime = performance.now();
                    this.initOptions = clientOptionsWithDefaults;
                    this.provider = provider;
                    this.provider.setClientVersion(_version.CLIENT_VERSION);
                    if (this.provider.setApplyUpdateCallback) {
                      this.provider.setApplyUpdateCallback(this.applyUpdateCallback.bind(this));
                    }
                    this.initPromise = this.initWithProvider(clientOptionsWithDefaults, provider, identifiers, customAttributes).then(function() {
                      _this3.initCompleted = true;
                      _this3.initWithDefaults = true;
                    }).finally(function() {
                      var endTime = performance.now();
                      var totalTime = endTime - startTime;
                      _this3.fireClientEvent(startTime, totalTime, "initializeWithProvider", _this3.initCompleted, provider.getApiKey ? provider.getApiKey() : void 0);
                    });
                    return _context2.abrupt("return", this.initPromise);
                  case 11:
                  case "end":
                    return _context2.stop();
                }
              }, _callee2, this);
            }));
            function initializeWithProvider(_x4, _x5, _x6, _x7) {
              return _initializeWithProvider.apply(this, arguments);
            }
            return initializeWithProvider;
          })()
        }, {
          key: "applyUpdateCallback",
          value: function applyUpdateCallback(experimentsResult) {
            try {
              if (this.initCompleted || this.initWithDefaults) {
                this.assertInitialized(this.statsigClient);
                this.dataAdapter.setBootstrapData(experimentsResult.experimentValues);
                this.dataAdapter.setData(JSON.stringify(experimentsResult.experimentValues));
                this.statsigValuesUpdated();
              }
            } catch (error) {
              console.warn("Error when attempting to apply update", error);
            }
          }
        }, {
          key: "fireClientEvent",
          value: function fireClientEvent(startTime, totalTime, action, success) {
            var _analyticsWebClient, _this4 = this;
            var apiKey = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : void 0;
            (_analyticsWebClient = this.initOptions.analyticsWebClient) === null || _analyticsWebClient === void 0 || _analyticsWebClient.then(function(analyticsWebClient) {
              var attributes = _objectSpread25({
                targetApp: _this4.initOptions.targetApp,
                clientVersion: _version.CLIENT_VERSION,
                success,
                startTime,
                totalTime
              }, apiKey && {
                apiKey
              });
              analyticsWebClient.sendOperationalEvent({
                action,
                actionSubject: "featureGatesClient",
                attributes,
                tags: ["measurement"],
                source: "@atlaskit/feature-gate-js-client"
              });
            }).catch(function(err) {
              if (_this4.initOptions.environment !== _types2.FeatureGateEnvironment.Production) {
                console.error("Analytics web client promise did not resolve", err);
              }
            });
          }
        }, {
          key: "initializeFromValues",
          value: (function() {
            var _initializeFromValues = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee3(clientOptions, identifiers, customAttributes) {
              var _this5 = this;
              var initializeValues, clientOptionsWithDefaults, startTime, _args3 = arguments;
              return _regenerator.default.wrap(function _callee3$(_context3) {
                while (1) switch (_context3.prev = _context3.next) {
                  case 0:
                    initializeValues = _args3.length > 3 && _args3[3] !== void 0 ? _args3[3] : {};
                    clientOptionsWithDefaults = (0, _utils.getOptionsWithDefaults)(clientOptions);
                    if (!this.initPromise) {
                      _context3.next = 5;
                      break;
                    }
                    if (!(0, _utils.shallowEquals)(clientOptionsWithDefaults, this.initOptions)) {
                      console.warn("Feature Gates client already initialized with different options. New options were not applied.");
                    }
                    return _context3.abrupt("return", this.initPromise);
                  case 5:
                    if (!Object.prototype.hasOwnProperty.call(initializeValues, "has_updates")) {
                      initializeValues["has_updates"] = true;
                    }
                    startTime = performance.now();
                    this.initOptions = clientOptionsWithDefaults;
                    this.initPromise = this.initFromValues(clientOptionsWithDefaults, identifiers, customAttributes, initializeValues).then(function() {
                      _this5.initCompleted = true;
                      _this5.initWithDefaults = true;
                    }).finally(function() {
                      var endTime = performance.now();
                      var totalTime = endTime - startTime;
                      _this5.fireClientEvent(startTime, totalTime, "initializeFromValues", _this5.initCompleted);
                    });
                    return _context3.abrupt("return", this.initPromise);
                  case 10:
                  case "end":
                    return _context3.stop();
                }
              }, _callee3, this);
            }));
            function initializeFromValues(_x8, _x9, _x0) {
              return _initializeFromValues.apply(this, arguments);
            }
            return initializeFromValues;
          })()
        }, {
          key: "assertInitialized",
          value: function assertInitialized(statsigClient) {
            if (!statsigClient) {
              throw new Error("Client must be initialized before using this method");
            }
          }
          /**
           * This method updates the user using a network call to fetch the new set of values.
           * @param fetchOptions {FetcherOptions}
           * @param identifiers {Identifiers}
           * @param customAttributes {CustomAttributes}
           */
        }, {
          key: "updateUser",
          value: (function() {
            var _updateUser = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee4(fetchOptions, identifiers, customAttributes) {
              var fetchOptionsWithDefaults, initializeValuesProducer;
              return _regenerator.default.wrap(function _callee4$(_context4) {
                while (1) switch (_context4.prev = _context4.next) {
                  case 0:
                    this.assertInitialized(this.statsigClient);
                    fetchOptionsWithDefaults = (0, _utils.getOptionsWithDefaults)(fetchOptions);
                    initializeValuesProducer = function initializeValuesProducer2() {
                      return _fetcher.default.fetchExperimentValues(fetchOptionsWithDefaults, identifiers, customAttributes).then(function(_ref2) {
                        var experimentValues = _ref2.experimentValues, customAttributes2 = _ref2.customAttributes;
                        return {
                          experimentValues,
                          customAttributesFromFetch: customAttributes2
                        };
                      });
                    };
                    _context4.next = 5;
                    return this.updateUserUsingInitializeValuesProducer(initializeValuesProducer, identifiers, customAttributes);
                  case 5:
                  case "end":
                    return _context4.stop();
                }
              }, _callee4, this);
            }));
            function updateUser(_x1, _x10, _x11) {
              return _updateUser.apply(this, arguments);
            }
            return updateUser;
          })()
        }, {
          key: "updateUserWithProvider",
          value: (function() {
            var _updateUserWithProvider = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee5(identifiers, customAttributes) {
              var _this6 = this;
              return _regenerator.default.wrap(function _callee5$(_context5) {
                while (1) switch (_context5.prev = _context5.next) {
                  case 0:
                    this.assertInitialized(this.statsigClient);
                    if (this.provider) {
                      _context5.next = 3;
                      break;
                    }
                    throw new Error("Cannot update user using provider as the client was not initialised with a provider");
                  case 3:
                    _context5.next = 5;
                    return this.provider.setProfile(this.initOptions, identifiers, customAttributes);
                  case 5:
                    _context5.next = 7;
                    return this.updateUserUsingInitializeValuesProducer(function() {
                      return _this6.provider.getExperimentValues();
                    }, identifiers, customAttributes);
                  case 7:
                  case "end":
                    return _context5.stop();
                }
              }, _callee5, this);
            }));
            function updateUserWithProvider(_x12, _x13) {
              return _updateUserWithProvider.apply(this, arguments);
            }
            return updateUserWithProvider;
          })()
        }, {
          key: "updateUserWithValues",
          value: (function() {
            var _updateUserWithValues = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee6(identifiers, customAttributes) {
              var initializeValues, initializeValuesProducer, _args6 = arguments;
              return _regenerator.default.wrap(function _callee6$(_context6) {
                while (1) switch (_context6.prev = _context6.next) {
                  case 0:
                    initializeValues = _args6.length > 2 && _args6[2] !== void 0 ? _args6[2] : {};
                    this.assertInitialized(this.statsigClient);
                    initializeValuesProducer = function initializeValuesProducer2() {
                      return Promise.resolve({
                        experimentValues: initializeValues,
                        customAttributesFromFetch: customAttributes
                      });
                    };
                    _context6.next = 5;
                    return this.updateUserUsingInitializeValuesProducer(initializeValuesProducer, identifiers, customAttributes);
                  case 5:
                  case "end":
                    return _context6.stop();
                }
              }, _callee6, this);
            }));
            function updateUserWithValues(_x14, _x15) {
              return _updateUserWithValues.apply(this, arguments);
            }
            return updateUserWithValues;
          })()
        }, {
          key: "initializeCalled",
          value: function initializeCalled() {
            return this.initPromise != null;
          }
        }, {
          key: "initializeCompleted",
          value: function initializeCompleted() {
            return this.initCompleted;
          }
          /**
           * Returns the value for a feature gate. Returns false if there are errors.
           * @param {string} gateName - The name of the feature gate.
           * @param {Object} options
           * @param {boolean} options.fireGateExposure
           *        Whether or not to fire the exposure event for the gate. Defaults to true.
           *        To log an exposure event manually at a later time, use {@link Client.manuallyLogGateExposure}
           *        (see [Statsig docs about manually logging exposures](https://docs.statsig.com/client/jsClientSDK#manual-exposures-)).
           */
        }, {
          key: "checkGate",
          value: function checkGate(gateName) {
            var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            try {
              this.assertInitialized(this.statsigClient);
              var _options$fireGateExpo = options2.fireGateExposure, fireGateExposure = _options$fireGateExpo === void 0 ? true : _options$fireGateExpo;
              return this.statsigClient.checkGate(gateName, {
                disableExposureLog: !fireGateExposure
              });
            } catch (error) {
              if (!this.hasCheckGateErrorOccurred) {
                console.warn({
                  msg: "An error has occurred checking the feature gate. Only the first occurrence of this error is logged.",
                  gateName,
                  error
                });
                this.hasCheckGateErrorOccurred = true;
              }
              return false;
            }
          }
        }, {
          key: "isGateExist",
          value: function isGateExist(gateName) {
            try {
              this.assertInitialized(this.statsigClient);
              var gate = this.statsigClient.getFeatureGate(gateName, {
                disableExposureLog: true
              });
              return !gate.details.reason.includes("Unrecognized");
            } catch (error) {
              console.error("Error occurred when trying to check FeatureGate: ".concat(error));
              return true;
            }
          }
        }, {
          key: "isExperimentExist",
          value: function isExperimentExist(experimentName) {
            try {
              this.assertInitialized(this.statsigClient);
              var config = this.statsigClient.getExperiment(experimentName, {
                disableExposureLog: true
              });
              return !config.details.reason.includes("Unrecognized");
            } catch (error) {
              console.error("Error occurred when trying to check Experiment: ".concat(error));
              return true;
            }
          }
          /**
           * Manually log a gate exposure (see [Statsig docs about manually logging exposures](https://docs.statsig.com/client/jsClientSDK#manual-exposures-)).
           * This is useful if you have evaluated a gate earlier via {@link Client.checkGate} where
           * <code>options.fireGateExposure</code> is false.
           * @param gateName
           */
        }, {
          key: "manuallyLogGateExposure",
          value: function manuallyLogGateExposure(gateName) {
            this.assertInitialized(this.statsigClient);
            this.statsigClient.checkGate(gateName);
          }
          /**
           * Returns the entire config for a given experiment.
           *
           * @param {string} experimentName - The name of the experiment
           * @param {Object} options
           * @param {boolean} options.fireExperimentExposure - Whether or not to fire the exposure event
           * for the experiment. Defaults to true. To log an exposure event manually at a later time, use
           * {@link Client.manuallyLogExperimentExposure} (see [Statsig docs about manually logging exposures](https://docs.statsig.com/client/jsClientSDK#manual-exposures-)).
           * @returns The config for an experiment
           * @example
           * ```ts
           * const experimentConfig = client.getExperiment('example-experiment-name');
           * const backgroundColor: string = experimentConfig.get('backgroundColor', 'yellow');
           * ```
           */
        }, {
          key: "getExperiment",
          value: function getExperiment(experimentName) {
            var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            try {
              this.assertInitialized(this.statsigClient);
              var _options$fireExperime = options2.fireExperimentExposure, fireExperimentExposure = _options$fireExperime === void 0 ? true : _options$fireExperime;
              return _DynamicConfig.DynamicConfig.fromExperiment(this.statsigClient.getExperiment(experimentName, {
                disableExposureLog: !fireExperimentExposure
              }));
            } catch (error) {
              if (!this.hasGetExperimentErrorOccurred) {
                console.warn({
                  msg: "An error has occurred getting the experiment. Only the first occurrence of this error is logged.",
                  experimentName,
                  error
                });
                this.hasGetExperimentErrorOccurred = true;
              }
              return new _DynamicConfig.DynamicConfig(experimentName, {}, "", {
                time: Date.now(),
                reason: _types.EvaluationReason.Error
              });
            }
          }
          /**
           * Returns the value of a given parameter in an experiment config.
           *
           * @template T
           * @param {string} experimentName - The name of the experiment
           * @param {string} parameterName - The name of the parameter to fetch from the experiment config
           * @param {T} defaultValue - The value to serve if the experiment or parameter do not exist, or
           * if the returned value does not match the expected type.
           * @param {Object} options
           * @param {boolean} options.fireExperimentExposure - Whether or not to fire the exposure event
           * for the experiment. Defaults to true. To log an exposure event manually at a later time, use
           * {@link Client.manuallyLogExperimentExposure} (see [Statsig docs about manually logging exposures](https://docs.statsig.com/client/jsClientSDK#manual-exposures-))
           * @param {function} options.typeGuard - A function that asserts that the return value has the
           * expected type. If this function returns false, then the default value will be returned
           * instead. This can be set to protect your code from unexpected values being set remotely. By
           * default, this will be done by asserting that the default value and value are the same primitive
           * type.
           * @returns The value of the parameter if the experiment and parameter both exist, otherwise the
           * default value.
           * @example
           ``` ts
           type ValidColor = 'blue' | 'red' | 'yellow';
           type ValidColorTypeCheck = (value: unknown) => value is ValidColor;
          	 const isValidColor: ValidColorTypeCheck =
          		(value: unknown) => typeof value === 'string' && ['blue', 'red', 'yellow'].includes(value);
          	 const buttonColor: ValidColor = client.getExperimentValue(
          		'example-experiment-name',
          		'backgroundColor',
          		'yellow',
          		{
          				typeGuard: isValidColor
          		}
           );
           ```
          */
        }, {
          key: "getExperimentValue",
          value: function getExperimentValue(experimentName, parameterName, defaultValue) {
            var options2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
            var experiment = this.getExperiment(experimentName, options2);
            try {
              var typeGuard = options2.typeGuard;
              return experiment.get(parameterName, defaultValue, typeGuard);
            } catch (error) {
              if (!this.hasGetExperimentValueErrorOccurred) {
                console.warn({
                  msg: "An error has occurred getting the experiment value. Only the first occurrence of this error is logged.",
                  experimentName,
                  defaultValue,
                  options: options2,
                  error
                });
                this.hasGetExperimentValueErrorOccurred = true;
              }
              return defaultValue;
            }
          }
          /**
           * Manually log an experiment exposure (see [Statsig docs about manually logging exposures](https://docs.statsig.com/client/jsClientSDK#manual-exposures-)).
           * This is useful if you have evaluated an experiment earlier via {@link Client.getExperimentValue} or
           * {@link Client.getExperiment} where <code>options.fireExperimentExposure</code> is false.
           * @param experimentName
           */
        }, {
          key: "manuallyLogExperimentExposure",
          value: function manuallyLogExperimentExposure(experimentName) {
            this.assertInitialized(this.statsigClient);
            this.statsigClient.getExperiment(experimentName);
          }
          /**
           * Manually log a layer exposure (see [Statsig docs about manually logging exposures](https://docs.statsig.com/client/jsClientSDK#manual-exposures-)).
           * This is useful if you have evaluated a layer earlier via {@link Client.getLayerValue} where <code>options.fireExperimentExposure</code> is false.
           * @param layerName
           * @param parameterName
           */
        }, {
          key: "manuallyLogLayerExposure",
          value: function manuallyLogLayerExposure(layerName, parameterName) {
            var _this$statsigClient$g;
            this.assertInitialized(this.statsigClient);
            (_this$statsigClient$g = this.statsigClient.getLayer(layerName)) === null || _this$statsigClient$g === void 0 || _this$statsigClient$g.get(parameterName);
          }
        }, {
          key: "shutdownStatsig",
          value: function shutdownStatsig() {
            this.assertInitialized(this.statsigClient);
            this.statsigClient.shutdown();
          }
          /**
           * Adds a new override for the given gate.
           *
           * This method is additive, meaning you can call it multiple times with different gate names to
           * build your full set of overrides.
           *
           * Overrides are persisted to the `STATSIG_OVERRIDES` key in localStorage, so they
           * will continue to affect every client that is initialized on the same domain after this method
           * is called. If you are using this API for testing purposes, you should call
           * {@link Client.clearGateOverride} after your tests are completed to remove this
           * localStorage entry.
           *
           * @param {string} gateName
           * @param {boolean} value
           */
        }, {
          key: "overrideGate",
          value: function overrideGate(gateName, value) {
            this.overrideAdapter.overrideGate(gateName, value);
            if (this.user) {
              var _this$statsigClient;
              (_this$statsigClient = this.statsigClient) === null || _this$statsigClient === void 0 || _this$statsigClient.updateUserSync(this.user, {
                disableBackgroundCacheRefresh: true
              });
            }
            this.statsigValuesUpdated();
          }
          /**
           * Removes any overrides that have been set for the given gate.
           */
        }, {
          key: "clearGateOverride",
          value: function clearGateOverride(gateName) {
            this.overrideAdapter.removeGateOverride(gateName);
            this.statsigValuesUpdated();
          }
          /**
           * Adds a new override for the given config (or experiment).
           *
           * This method is additive, meaning you can call it multiple times with different experiment
           * names to build your full set of overrides.
           *
           * Overrides are persisted to the `STATSIG_OVERRIDES` key in localStorage, so they
           * will continue to affect every client that is initialized on the same domain after this method
           * is called. If you are using this API for testing purposes, you should call
           * {@link Client.clearConfigOverride} after your tests are completed to remove this
           * localStorage entry.
           *
           * @param {string} experimentName
           * @param {object} values
           */
        }, {
          key: "overrideConfig",
          value: function overrideConfig(experimentName, values) {
            this.overrideAdapter.overrideDynamicConfig(experimentName, values);
            this.statsigValuesUpdated();
          }
          /**
           * Removes any overrides that have been set for the given experiment.
           * @param {string} experimentName
           */
        }, {
          key: "clearConfigOverride",
          value: function clearConfigOverride(experimentName) {
            this.overrideAdapter.removeDynamicConfigOverride(experimentName);
            this.statsigValuesUpdated();
          }
          /**
           * Set overrides for gates, experiments and layers in batch.
           *
           * Note that these overrides are **not** additive and will completely replace any that have been
           * added via prior calls to {@link Client.overrideConfig} or
           * {@link Client.overrideGate}.
           *
           * Overrides are persisted to the `STATSIG_OVERRIDES` key in localStorage, so they
           * will continue to affect every client that is initialized on the same domain after this method
           * is called. If you are using this API for testing purposes, you should call
           * {@link Client.clearAllOverrides} after your tests are completed to remove this
           * localStorage entry.
           */
        }, {
          key: "setOverrides",
          value: function setOverrides(overrides) {
            this.overrideAdapter.setOverrides(overrides);
            this.statsigValuesUpdated();
          }
          /**
           * @returns The current overrides for gates, configs (including experiments) and layers.
           */
        }, {
          key: "getOverrides",
          value: function getOverrides() {
            return this.overrideAdapter.getOverrides();
          }
          /**
           * Clears overrides for all gates, configs (including experiments) and layers.
           */
        }, {
          key: "clearAllOverrides",
          value: function clearAllOverrides() {
            this.overrideAdapter.removeAllOverrides();
            this.statsigValuesUpdated();
          }
          /**
           * Returns whether the given identifiers and customAttributes align with the current
           * set that is being used by the client.
           *
           * If this method returns false, then the {@link Client.updateUser},
           * {@link Client.updateUserWithValues} or {@link Client.updateUserWithProvider}
           * methods can be used to re-align these values.
           *
           * @param identifiers
           * @param customAttributes
           * @returns a flag indicating whether the clients current configuration aligns with the given values
           */
        }, {
          key: "isCurrentUser",
          value: function isCurrentUser(identifiers, customAttributes) {
            return (0, _utils.shallowEquals)(this.currentIdentifiers, identifiers) && (0, _utils.shallowEquals)(this.currentAttributes, customAttributes);
          }
          /**
           * Subscribe to updates where the given callback will be called with the current checkGate value
           * @param gateName
           * @param callback
           * @param options
           * @returns off function to unsubscribe from updates
           */
        }, {
          key: "onGateUpdated",
          value: function onGateUpdated(gateName, callback) {
            var _this7 = this;
            var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            var wrapCallback = function wrapCallback2(value) {
              var _options$fireGateExpo2 = options2.fireGateExposure, fireGateExposure = _options$fireGateExpo2 === void 0 ? true : _options$fireGateExpo2;
              if (fireGateExposure) {
                _this7.manuallyLogGateExposure(gateName);
              }
              try {
                callback(value);
              } catch (error) {
                console.warn("Error calling callback for gate ".concat(gateName, " with value ").concat(value), error);
              }
            };
            return this.subscriptions.onGateUpdated(gateName, wrapCallback, this.checkGate.bind(this), options2);
          }
          /**
           * Subscribe to updates where the given callback will be called with the current experiment value
           * @param experimentName
           * @param parameterName
           * @param defaultValue
           * @param callback
           * @param options
           * @returns off function to unsubscribe from updates
           */
        }, {
          key: "onExperimentValueUpdated",
          value: function onExperimentValueUpdated(experimentName, parameterName, defaultValue, callback) {
            var _this8 = this;
            var options2 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
            var wrapCallback = function wrapCallback2(value) {
              var _options$fireExperime2 = options2.fireExperimentExposure, fireExperimentExposure = _options$fireExperime2 === void 0 ? true : _options$fireExperime2;
              if (fireExperimentExposure) {
                _this8.manuallyLogExperimentExposure(experimentName);
              }
              try {
                callback(value);
              } catch (error) {
                console.warn("Error calling callback for experiment ".concat(experimentName, " with value ").concat(value), error);
              }
            };
            return this.subscriptions.onExperimentValueUpdated(experimentName, parameterName, defaultValue, wrapCallback, this.getExperimentValue.bind(this), options2);
          }
          /**
           * Subscribe so on any update the callback will be called.
           * NOTE: The callback will be called whenever the values are updated even if the values have not
           * changed.
           * @param callback
           * @returns off function to unsubscribe from updates
           */
        }, {
          key: "onAnyUpdated",
          value: function onAnyUpdated(callback) {
            return this.subscriptions.onAnyUpdated(callback);
          }
          /**
           * This method initializes the client using a network call to fetch the bootstrap values for the
           * given user.
           *
           * @param clientOptions
           * @param identifiers
           * @param customAttributes
           * @private
           */
        }, {
          key: "init",
          value: (function() {
            var _init = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee7(clientOptions, identifiers, customAttributes) {
              var fromValuesClientOptions, experimentValues, customAttributesFromResult, clientSdkKeyPromise, experimentValuesPromise, _yield$Promise$all, _yield$Promise$all2, experimentValuesResult;
              return _regenerator.default.wrap(function _callee7$(_context7) {
                while (1) switch (_context7.prev = _context7.next) {
                  case 0:
                    fromValuesClientOptions = _objectSpread25({}, clientOptions);
                    _context7.prev = 1;
                    clientSdkKeyPromise = _fetcher.default.fetchClientSdk(clientOptions).then(function(value) {
                      return fromValuesClientOptions.sdkKey = value.clientSdkKey;
                    });
                    experimentValuesPromise = _fetcher.default.fetchExperimentValues(clientOptions, identifiers, customAttributes);
                    _context7.next = 6;
                    return Promise.all([clientSdkKeyPromise, experimentValuesPromise]);
                  case 6:
                    _yield$Promise$all = _context7.sent;
                    _yield$Promise$all2 = (0, _slicedToArray2.default)(_yield$Promise$all, 2);
                    experimentValuesResult = _yield$Promise$all2[1];
                    experimentValues = experimentValuesResult.experimentValues;
                    customAttributesFromResult = experimentValuesResult.customAttributes;
                    _context7.next = 20;
                    break;
                  case 13:
                    _context7.prev = 13;
                    _context7.t0 = _context7["catch"](1);
                    if (_context7.t0 instanceof Error) {
                      console.error("Error occurred when trying to fetch the Feature Gates client values, error: ".concat(_context7.t0 === null || _context7.t0 === void 0 ? void 0 : _context7.t0.message));
                    }
                    console.warn("Initialising Statsig client without values");
                    _context7.next = 19;
                    return this.initFromValues(fromValuesClientOptions, identifiers, customAttributes);
                  case 19:
                    throw _context7.t0;
                  case 20:
                    return _context7.abrupt("return", this.initFromValues(fromValuesClientOptions, identifiers, customAttributesFromResult, experimentValues));
                  case 21:
                  case "end":
                    return _context7.stop();
                }
              }, _callee7, this, [[1, 13]]);
            }));
            function init(_x16, _x17, _x18) {
              return _init.apply(this, arguments);
            }
            return init;
          })()
        }, {
          key: "initWithProvider",
          value: (function() {
            var _initWithProvider = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee8(baseClientOptions, provider, identifiers, customAttributes) {
              var fromValuesClientOptions, experimentValues, customAttributesFromResult, clientSdkKeyPromise, experimentValuesPromise, _yield$Promise$all3, _yield$Promise$all4, experimentValuesResult;
              return _regenerator.default.wrap(function _callee8$(_context8) {
                while (1) switch (_context8.prev = _context8.next) {
                  case 0:
                    fromValuesClientOptions = _objectSpread25(_objectSpread25({}, baseClientOptions), {}, {
                      disableCurrentPageLogging: true
                    });
                    _context8.prev = 1;
                    _context8.next = 4;
                    return provider.setProfile(baseClientOptions, identifiers, customAttributes);
                  case 4:
                    clientSdkKeyPromise = provider.getClientSdkKey().then(function(value) {
                      return fromValuesClientOptions.sdkKey = value;
                    });
                    experimentValuesPromise = provider.getExperimentValues();
                    _context8.next = 8;
                    return Promise.all([clientSdkKeyPromise, experimentValuesPromise]);
                  case 8:
                    _yield$Promise$all3 = _context8.sent;
                    _yield$Promise$all4 = (0, _slicedToArray2.default)(_yield$Promise$all3, 2);
                    experimentValuesResult = _yield$Promise$all4[1];
                    experimentValues = experimentValuesResult.experimentValues;
                    customAttributesFromResult = experimentValuesResult.customAttributesFromFetch;
                    _context8.next = 22;
                    break;
                  case 15:
                    _context8.prev = 15;
                    _context8.t0 = _context8["catch"](1);
                    if (_context8.t0 instanceof Error) {
                      console.error("Error occurred when trying to fetch the Feature Gates client values, error: ".concat(_context8.t0 === null || _context8.t0 === void 0 ? void 0 : _context8.t0.message));
                    }
                    console.warn("Initialising Statsig client without values");
                    _context8.next = 21;
                    return this.initFromValues(fromValuesClientOptions, identifiers, customAttributes);
                  case 21:
                    throw _context8.t0;
                  case 22:
                    return _context8.abrupt("return", this.initFromValues(fromValuesClientOptions, identifiers, customAttributesFromResult, experimentValues));
                  case 23:
                  case "end":
                    return _context8.stop();
                }
              }, _callee8, this, [[1, 15]]);
            }));
            function initWithProvider(_x19, _x20, _x21, _x22) {
              return _initWithProvider.apply(this, arguments);
            }
            return initWithProvider;
          })()
          /**
           * This method initializes the client using a set of boostrap values obtained from one of the
           * server-side SDKs.
           *
           * @param clientOptions
           * @param identifiers
           * @param customAttributes
           * @param initializeValues
           * @private
           */
        }, {
          key: "initFromValues",
          value: (function() {
            var _initFromValues = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee9(clientOptions, identifiers, customAttributes) {
              var _newClientOptions$net;
              var initializeValues, newClientOptions, sdkKey, environment, _updateUserCompletionCallback, _perimeter, restClientOptions, statsigOptions, _args9 = arguments;
              return _regenerator.default.wrap(function _callee9$(_context9) {
                while (1) switch (_context9.prev = _context9.next) {
                  case 0:
                    initializeValues = _args9.length > 3 && _args9[3] !== void 0 ? _args9[3] : {};
                    this.overrideAdapter.initFromStoredOverrides();
                    this.currentIdentifiers = identifiers;
                    this.currentAttributes = customAttributes;
                    newClientOptions = (0, _utils.migrateInitializationOptions)(clientOptions);
                    if (!newClientOptions.sdkKey) {
                      newClientOptions.sdkKey = DEFAULT_CLIENT_KEY;
                    }
                    if (!((_newClientOptions$net = newClientOptions.networkConfig) !== null && _newClientOptions$net !== void 0 && _newClientOptions$net.logEventUrl)) {
                      newClientOptions.networkConfig = _objectSpread25(_objectSpread25({}, newClientOptions.networkConfig), {}, {
                        logEventUrl: DEFAULT_EVENT_LOGGING_API
                      });
                    }
                    if (newClientOptions.perimeter === _types2.PerimeterType.FEDRAMP_MODERATE) {
                      newClientOptions.disableLogging = true;
                    }
                    sdkKey = newClientOptions.sdkKey, environment = newClientOptions.environment, _updateUserCompletionCallback = newClientOptions.updateUserCompletionCallback, _perimeter = newClientOptions.perimeter, restClientOptions = (0, _objectWithoutProperties2.default)(newClientOptions, _excluded30);
                    this.user = (0, _utils.toStatsigUser)(identifiers, customAttributes);
                    statsigOptions = _objectSpread25(_objectSpread25({}, restClientOptions), {}, {
                      environment: {
                        tier: environment
                      },
                      includeCurrentPageUrlWithEvents: false,
                      dataAdapter: this.dataAdapter,
                      overrideAdapter: this.overrideAdapter,
                      logEventCompressionMode: _jsClient.LogEventCompressionMode.Forced
                    });
                    if (identifiers.stableId) {
                      _jsClient.StableID.setOverride(identifiers.stableId, sdkKey);
                    } else {
                      statsigOptions.disableStableID = true;
                    }
                    _context9.prev = 12;
                    this.statsigClient = new _jsClient.StatsigClient(sdkKey, this.user, statsigOptions);
                    this.dataAdapter.setBootstrapData(initializeValues);
                    _context9.next = 17;
                    return this.statsigClient.initializeAsync();
                  case 17:
                    _context9.next = 29;
                    break;
                  case 19:
                    _context9.prev = 19;
                    _context9.t0 = _context9["catch"](12);
                    if (_context9.t0 instanceof Error) {
                      console.error("Error occurred when trying to initialise the Statsig client, error: ".concat(_context9.t0 === null || _context9.t0 === void 0 ? void 0 : _context9.t0.message));
                    }
                    console.warn("Initialising Statsig client with default sdk key and without values");
                    this.statsigClient = new _jsClient.StatsigClient(DEFAULT_CLIENT_KEY, this.user, statsigOptions);
                    this.dataAdapter.setBootstrapData();
                    _context9.next = 27;
                    return this.statsigClient.initializeAsync();
                  case 27:
                    this.initWithDefaults = true;
                    throw _context9.t0;
                  case 29:
                  case "end":
                    return _context9.stop();
                }
              }, _callee9, this, [[12, 19]]);
            }));
            function initFromValues(_x23, _x24, _x25) {
              return _initFromValues.apply(this, arguments);
            }
            return initFromValues;
          })()
        }, {
          key: "updateUserUsingInitializeValuesProducer",
          value: (function() {
            var _updateUserUsingInitializeValuesProducer = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee1(getInitializeValues, identifiers, customAttributes) {
              var _this9 = this;
              var originalInitPromise, initializeValuesPromise, updateUserPromise;
              return _regenerator.default.wrap(function _callee1$(_context1) {
                while (1) switch (_context1.prev = _context1.next) {
                  case 0:
                    this.assertInitialized(this.statsigClient);
                    if (this.initPromise) {
                      _context1.next = 3;
                      break;
                    }
                    throw new Error("The client must be initialized before you can update the user.");
                  case 3:
                    if (!this.isCurrentUser(identifiers, customAttributes)) {
                      _context1.next = 5;
                      break;
                    }
                    return _context1.abrupt("return", this.initPromise);
                  case 5:
                    originalInitPromise = this.initPromise;
                    _context1.prev = 6;
                    _context1.next = 9;
                    return this.initPromise;
                  case 9:
                    _context1.next = 13;
                    break;
                  case 11:
                    _context1.prev = 11;
                    _context1.t0 = _context1["catch"](6);
                  case 13:
                    initializeValuesPromise = getInitializeValues();
                    updateUserPromise = this.updateStatsigClientUser(initializeValuesPromise, identifiers, customAttributes);
                    this.initPromise = updateUserPromise.catch(/* @__PURE__ */ (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee0() {
                      return _regenerator.default.wrap(function _callee0$(_context0) {
                        while (1) switch (_context0.prev = _context0.next) {
                          case 0:
                            _this9.initPromise = originalInitPromise;
                            if (!_this9.provider) {
                              _context0.next = 4;
                              break;
                            }
                            _context0.next = 4;
                            return _this9.provider.setProfile(_this9.initOptions, _this9.currentIdentifiers, _this9.currentAttributes);
                          case 4:
                          case "end":
                            return _context0.stop();
                        }
                      }, _callee0);
                    })));
                    return _context1.abrupt("return", updateUserPromise);
                  case 17:
                  case "end":
                    return _context1.stop();
                }
              }, _callee1, this, [[6, 11]]);
            }));
            function updateUserUsingInitializeValuesProducer(_x26, _x27, _x28) {
              return _updateUserUsingInitializeValuesProducer.apply(this, arguments);
            }
            return updateUserUsingInitializeValuesProducer;
          })()
        }, {
          key: "updateStatsigClientUser",
          value: (function() {
            var _updateStatsigClientUser = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee10(initializeValuesPromise, identifiers, customAttributes) {
              var _this$initOptions, _this$initOptions$upd;
              var initializeValues, user, _updateUserCompletion, _ref4, errMsg, success, errorMessage;
              return _regenerator.default.wrap(function _callee10$(_context10) {
                while (1) switch (_context10.prev = _context10.next) {
                  case 0:
                    this.assertInitialized(this.statsigClient);
                    _context10.prev = 1;
                    _context10.next = 4;
                    return initializeValuesPromise;
                  case 4:
                    initializeValues = _context10.sent;
                    user = (0, _utils.toStatsigUser)(identifiers, initializeValues.customAttributesFromFetch);
                    _context10.next = 13;
                    break;
                  case 8:
                    _context10.prev = 8;
                    _context10.t0 = _context10["catch"](1);
                    errMsg = _context10.t0 instanceof Error ? _context10.t0.message : JSON.stringify(_context10.t0);
                    (_updateUserCompletion = (_ref4 = this.initOptions).updateUserCompletionCallback) === null || _updateUserCompletion === void 0 || _updateUserCompletion.call(_ref4, false, errMsg);
                    throw _context10.t0;
                  case 13:
                    success = true;
                    errorMessage = null;
                    _context10.prev = 15;
                    this.dataAdapter.setBootstrapData(initializeValues.experimentValues);
                    this.user = user;
                    if (!this.user) {
                      _context10.next = 21;
                      break;
                    }
                    _context10.next = 21;
                    return this.statsigClient.updateUserAsync(this.user);
                  case 21:
                    _context10.next = 27;
                    break;
                  case 23:
                    _context10.prev = 23;
                    _context10.t1 = _context10["catch"](15);
                    success = false;
                    errorMessage = String(_context10.t1);
                  case 27:
                    (_this$initOptions = this.initOptions) === null || _this$initOptions === void 0 || (_this$initOptions$upd = _this$initOptions.updateUserCompletionCallback) === null || _this$initOptions$upd === void 0 || _this$initOptions$upd.call(_this$initOptions, success, errorMessage);
                    if (!success) {
                      _context10.next = 34;
                      break;
                    }
                    this.currentIdentifiers = identifiers;
                    this.currentAttributes = customAttributes;
                    this.subscriptions.anyUpdated();
                    _context10.next = 35;
                    break;
                  case 34:
                    throw new Error("Failed to update user. An unexpected error occured.");
                  case 35:
                  case "end":
                    return _context10.stop();
                }
              }, _callee10, this, [[1, 8], [15, 23]]);
            }));
            function updateStatsigClientUser(_x29, _x30, _x31) {
              return _updateStatsigClientUser.apply(this, arguments);
            }
            return updateStatsigClientUser;
          })()
        }, {
          key: "getPackageVersion",
          value: (
            /**
             * @returns string version of the current package in semver style.
             */
            function getPackageVersion() {
              return _version.CLIENT_VERSION;
            }
          )
          /**
           * Returns a specified layer otherwise returns an empty layer as a default value if the layer doesn't exist.
           *
           * @param {string} layerName - The name of the layer
           * @param {Object} options
           * @param {boolean} options.fireLayerExposure - Whether or not to fire the exposure event for the
           * layer. Defaults to true. To log an exposure event manually at a later time, use
           * {@link Client.manuallyLogLayerExposure} (see [Statsig docs about manually logging exposures](https://docs.statsig.com/client/jsClientSDK#manual-exposures-)).
           * @returns A layer
           * @example
           * ```ts
           * const layer = client.getLayer('example-layer-name');
           * const exampletitle: string = layer.get("title", "Welcome to Statsig!");
           * ```
           */
        }, {
          key: "getLayer",
          value: function getLayer(layerName) {
            var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            try {
              this.assertInitialized(this.statsigClient);
              var _options$fireLayerExp = options2.fireLayerExposure, fireLayerExposure = _options$fireLayerExp === void 0 ? true : _options$fireLayerExp;
              return _Layer.Layer.fromLayer(this.statsigClient.getLayer(layerName, {
                disableExposureLog: !fireLayerExposure
              }));
            } catch (error) {
              if (!this.hasGetLayerErrorOccurred) {
                console.warn({
                  msg: "An error has occurred getting the layer. Only the first occurrence of this error is logged.",
                  layerName,
                  error
                });
                this.hasGetLayerErrorOccurred = true;
              }
              return _Layer.Layer.fromLayer((0, _jsClient._makeLayer)(layerName, {
                reason: "Error"
              }, null));
            }
          }
          /**
           * Returns the value of a given parameter in a layer config.
           *
           * @template T
           * @param {string} layerName - The name of the layer
           * @param {string} parameterName - The name of the parameter to fetch from the layer config
           * @param {T} defaultValue - The value to serve if the layer or parameter do not exist, or if the
           * returned value does not match the expected type.
           * @param {Object} options
           * @param {boolean} options.fireLayerExposure - Whether or not to fire the exposure event for the
           * layer. Defaults to true. To log an exposure event manually at a later time, use
           * {@link Client.manuallyLogLayerExposure} (see [Statsig docs about manually logging exposures](https://docs.statsig.com/client/jsClientSDK#manual-exposures-))
           * @param {function} options.typeGuard - A function that asserts that the return value has the expected type. If this function returns false, then the default value will be returned instead. This can be set to protect your code from unexpected values being set remotely. By default, this will be done by asserting that the default value and value are the same primitive type.
           * @returns The value of the parameter if the layer and parameter both exist, otherwise the default value.
           * @example
           * ``` ts
           * type ValidColor = 'blue' | 'red' | 'yellow';
           * type ValidColorTypeCheck = (value: unknown) => value is ValidColor;
           *
           * const isValidColor: ValidColorTypeCheck =
           *    (value: unknown) => typeof value === 'string' && ['blue', 'red', 'yellow'].includes(value);
           *
           * const buttonColor: ValidColor = client.getLayerValue(
           *    'example-layer-name',
           *    'backgroundColor',
           *    'yellow',
           *    {
           *        typeGuard: isValidColor
           *    }
           * );
           * ```
           */
        }, {
          key: "getLayerValue",
          value: function getLayerValue(layerName, parameterName, defaultValue) {
            var options2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
            var layer2 = this.getLayer(layerName, options2);
            try {
              var typeGuard = options2.typeGuard;
              return layer2.get(parameterName, defaultValue, typeGuard);
            } catch (error) {
              if (!this.hasGetLayerValueErrorOccurred) {
                console.warn({
                  msg: "An error has occurred getting the layer value. Only the first occurrence of this error is logged.",
                  layerName,
                  defaultValue,
                  options: options2,
                  error
                });
                this.hasGetLayerValueErrorOccurred = true;
              }
              return defaultValue;
            }
          }
        }]);
      })();
    }
  });

  // node_modules/@atlaskit/feature-gate-js-client/dist/cjs/client/FeatureGates.js
  var require_FeatureGates = __commonJS({
    "node_modules/@atlaskit/feature-gate-js-client/dist/cjs/client/FeatureGates.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "CLIENT_VERSION", {
        enumerable: true,
        get: function get() {
          return _version.CLIENT_VERSION;
        }
      });
      Object.defineProperty(exports, "DynamicConfig", {
        enumerable: true,
        get: function get() {
          return _DynamicConfig.DynamicConfig;
        }
      });
      Object.defineProperty(exports, "EvaluationReason", {
        enumerable: true,
        get: function get() {
          return _types.EvaluationReason;
        }
      });
      Object.defineProperty(exports, "FeatureGateEnvironment", {
        enumerable: true,
        get: function get() {
          return _types2.FeatureGateEnvironment;
        }
      });
      Object.defineProperty(exports, "PerimeterType", {
        enumerable: true,
        get: function get() {
          return _types2.PerimeterType;
        }
      });
      exports.default = void 0;
      var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
      var _createClass22 = _interopRequireDefault(require_createClass());
      var _defineProperty2 = _interopRequireDefault(require_defineProperty());
      var _Client = require_Client();
      var _version = require_version();
      var _types = require_types2();
      var _DynamicConfig = require_DynamicConfig();
      var _types2 = require_types3();
      var _FeatureGates;
      var FeatureGates = /* @__PURE__ */ (function() {
        function FeatureGates2() {
          (0, _classCallCheck2.default)(this, FeatureGates2);
        }
        return (0, _createClass22.default)(FeatureGates2, null, [{
          key: "isGateExists",
          value: function isGateExists(gateName) {
            return this.client.isGateExist(gateName);
          }
        }, {
          key: "isExperimentExists",
          value: function isExperimentExists(experimentName) {
            return this.client.isExperimentExist(experimentName);
          }
        }]);
      })();
      _FeatureGates = FeatureGates;
      (0, _defineProperty2.default)(FeatureGates, "client", new _Client.Client());
      (0, _defineProperty2.default)(FeatureGates, "hasCheckGateErrorOccurred", false);
      (0, _defineProperty2.default)(FeatureGates, "hasGetExperimentValueErrorOccurred", false);
      (0, _defineProperty2.default)(FeatureGates, "checkGate", function(gateName, options2) {
        try {
          if (typeof window !== "undefined" && window.__CRITERION__ && typeof window.__CRITERION__.getFeatureFlagOverride === "function") {
            var overrideValue = window.__CRITERION__.getFeatureFlagOverride(gateName);
            if (overrideValue !== void 0) {
              return overrideValue;
            }
          }
        } catch (error) {
          if (!_FeatureGates.hasCheckGateErrorOccurred) {
            console.warn({
              msg: "An error has occurred checking the feature gate from criterion override. Only the first occurrence of this error is logged.",
              gateName,
              error
            });
            _FeatureGates.hasCheckGateErrorOccurred = true;
          }
        }
        return _FeatureGates.client.checkGate(gateName, options2);
      });
      (0, _defineProperty2.default)(FeatureGates, "getExperimentValue", function(experimentName, parameterName, defaultValue, options2) {
        try {
          if (typeof window !== "undefined" && window.__CRITERION__ && typeof window.__CRITERION__.getExperimentValueOverride === "function") {
            var overrideValue = window.__CRITERION__.getExperimentValueOverride(experimentName, parameterName);
            if (overrideValue !== void 0 && overrideValue !== null) {
              return overrideValue;
            }
          }
        } catch (error) {
          if (!_FeatureGates.hasGetExperimentValueErrorOccurred) {
            console.warn({
              msg: "An error has occurred getting the experiment value from criterion override. Only the first occurrence of this error is logged.",
              experimentName,
              defaultValue,
              options: options2,
              error
            });
            _FeatureGates.hasGetExperimentValueErrorOccurred = true;
          }
          return defaultValue;
        }
        return _FeatureGates.client.getExperimentValue(experimentName, parameterName, defaultValue, options2);
      });
      (0, _defineProperty2.default)(FeatureGates, "initializeCalled", _FeatureGates.client.initializeCalled.bind(_FeatureGates.client));
      (0, _defineProperty2.default)(FeatureGates, "initializeCompleted", _FeatureGates.client.initializeCompleted.bind(_FeatureGates.client));
      (0, _defineProperty2.default)(FeatureGates, "initialize", _FeatureGates.client.initialize.bind(_FeatureGates.client));
      (0, _defineProperty2.default)(FeatureGates, "initializeWithProvider", _FeatureGates.client.initializeWithProvider.bind(_FeatureGates.client));
      (0, _defineProperty2.default)(FeatureGates, "initializeFromValues", _FeatureGates.client.initializeFromValues.bind(_FeatureGates.client));
      (0, _defineProperty2.default)(FeatureGates, "manuallyLogGateExposure", _FeatureGates.client.manuallyLogGateExposure.bind(_FeatureGates.client));
      (0, _defineProperty2.default)(FeatureGates, "getExperiment", _FeatureGates.client.getExperiment.bind(_FeatureGates.client));
      (0, _defineProperty2.default)(FeatureGates, "manuallyLogExperimentExposure", _FeatureGates.client.manuallyLogExperimentExposure.bind(_FeatureGates.client));
      (0, _defineProperty2.default)(FeatureGates, "manuallyLogLayerExposure", _FeatureGates.client.manuallyLogLayerExposure.bind(_FeatureGates.client));
      (0, _defineProperty2.default)(FeatureGates, "shutdownStatsig", _FeatureGates.client.shutdownStatsig.bind(_FeatureGates.client));
      (0, _defineProperty2.default)(FeatureGates, "overrideGate", _FeatureGates.client.overrideGate.bind(_FeatureGates.client));
      (0, _defineProperty2.default)(FeatureGates, "clearGateOverride", _FeatureGates.client.clearGateOverride.bind(_FeatureGates.client));
      (0, _defineProperty2.default)(FeatureGates, "overrideConfig", _FeatureGates.client.overrideConfig.bind(_FeatureGates.client));
      (0, _defineProperty2.default)(FeatureGates, "clearConfigOverride", _FeatureGates.client.clearConfigOverride.bind(_FeatureGates.client));
      (0, _defineProperty2.default)(FeatureGates, "setOverrides", _FeatureGates.client.setOverrides.bind(_FeatureGates.client));
      (0, _defineProperty2.default)(FeatureGates, "getOverrides", _FeatureGates.client.getOverrides.bind(_FeatureGates.client));
      (0, _defineProperty2.default)(FeatureGates, "clearAllOverrides", _FeatureGates.client.clearAllOverrides.bind(_FeatureGates.client));
      (0, _defineProperty2.default)(FeatureGates, "isCurrentUser", _FeatureGates.client.isCurrentUser.bind(_FeatureGates.client));
      (0, _defineProperty2.default)(FeatureGates, "onGateUpdated", _FeatureGates.client.onGateUpdated.bind(_FeatureGates.client));
      (0, _defineProperty2.default)(FeatureGates, "onExperimentValueUpdated", _FeatureGates.client.onExperimentValueUpdated.bind(_FeatureGates.client));
      (0, _defineProperty2.default)(FeatureGates, "onAnyUpdated", _FeatureGates.client.onAnyUpdated.bind(_FeatureGates.client));
      (0, _defineProperty2.default)(FeatureGates, "updateUser", _FeatureGates.client.updateUser.bind(_FeatureGates.client));
      (0, _defineProperty2.default)(FeatureGates, "updateUserWithProvider", _FeatureGates.client.updateUserWithProvider.bind(_FeatureGates.client));
      (0, _defineProperty2.default)(FeatureGates, "updateUserWithValues", _FeatureGates.client.updateUserWithValues.bind(_FeatureGates.client));
      (0, _defineProperty2.default)(FeatureGates, "getPackageVersion", _FeatureGates.client.getPackageVersion.bind(_FeatureGates.client));
      (0, _defineProperty2.default)(FeatureGates, "getLayer", _FeatureGates.client.getLayer.bind(_FeatureGates.client));
      (0, _defineProperty2.default)(FeatureGates, "getLayerValue", _FeatureGates.client.getLayerValue.bind(_FeatureGates.client));
      var boundFGJS = FeatureGates;
      if (typeof window !== "undefined") {
        if (window.__FEATUREGATES_JS__ === void 0) {
          window.__FEATUREGATES_JS__ = FeatureGates;
        } else {
          boundFGJS = window.__FEATUREGATES_JS__;
          boundVersion = ((_boundFGJS = boundFGJS) === null || _boundFGJS === void 0 || (_boundFGJS$getPackage = _boundFGJS.getPackageVersion) === null || _boundFGJS$getPackage === void 0 ? void 0 : _boundFGJS$getPackage.call(_boundFGJS)) || "4.10.0 or earlier";
          if (boundVersion !== _version.CLIENT_VERSION) {
            message2 = "Multiple versions of FeatureGateClients found on the current page.\n      The currently bound version is ".concat(boundVersion, " when module version ").concat(_version.CLIENT_VERSION, " was loading.");
            console.warn(message2);
          }
        }
      }
      var _boundFGJS;
      var _boundFGJS$getPackage;
      var boundVersion;
      var message2;
      var _default = exports.default = boundFGJS;
    }
  });

  // node_modules/@atlaskit/feature-gate-js-client/dist/cjs/index.js
  var require_cjs2 = __commonJS({
    "node_modules/@atlaskit/feature-gate-js-client/dist/cjs/index.js"(exports) {
      "use strict";
      var _typeof2 = require_typeof();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "CLIENT_VERSION", {
        enumerable: true,
        get: function get() {
          return _FeatureGates.CLIENT_VERSION;
        }
      });
      Object.defineProperty(exports, "DynamicConfig", {
        enumerable: true,
        get: function get() {
          return _DynamicConfig.DynamicConfig;
        }
      });
      Object.defineProperty(exports, "EvaluationReason", {
        enumerable: true,
        get: function get() {
          return _types.EvaluationReason;
        }
      });
      Object.defineProperty(exports, "FeatureGateEnvironment", {
        enumerable: true,
        get: function get() {
          return _FeatureGates.FeatureGateEnvironment;
        }
      });
      Object.defineProperty(exports, "Layer", {
        enumerable: true,
        get: function get() {
          return _Layer.Layer;
        }
      });
      Object.defineProperty(exports, "PerimeterType", {
        enumerable: true,
        get: function get() {
          return _FeatureGates.PerimeterType;
        }
      });
      Object.defineProperty(exports, "default", {
        enumerable: true,
        get: function get() {
          return _FeatureGates.default;
        }
      });
      var _FeatureGates = _interopRequireWildcard(require_FeatureGates());
      var _DynamicConfig = require_DynamicConfig();
      var _Layer = require_Layer();
      var _types = require_types2();
      function _interopRequireWildcard(e, t) {
        if ("function" == typeof WeakMap) var r = /* @__PURE__ */ new WeakMap(), n = /* @__PURE__ */ new WeakMap();
        return (_interopRequireWildcard = function _interopRequireWildcard2(e2, t2) {
          if (!t2 && e2 && e2.__esModule) return e2;
          var o, i, f = { __proto__: null, default: e2 };
          if (null === e2 || "object" != _typeof2(e2) && "function" != typeof e2) return f;
          if (o = t2 ? n : r) {
            if (o.has(e2)) return o.get(e2);
            o.set(e2, f);
          }
          for (var _t in e2) "default" !== _t && {}.hasOwnProperty.call(e2, _t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e2, _t)) && (i.get || i.set) ? o(f, _t, i) : f[_t] = e2[_t]);
          return f;
        })(e, t);
      }
    }
  });

  // node_modules/@atlaskit/platform-feature-flags/dist/cjs/debug.js
  var require_debug = __commonJS({
    "node_modules/@atlaskit/platform-feature-flags/dist/cjs/debug.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.debug = void 0;
      var _process;
      var _process2;
      var TESTS_MODE = (globalThis === null || globalThis === void 0 || (_process = globalThis.process) === null || _process === void 0 || (_process = _process.env) === null || _process === void 0 ? void 0 : _process.JEST_WORKER_ID) !== void 0;
      var DEBUG_MODE = !TESTS_MODE && (globalThis === null || globalThis === void 0 || (_process2 = globalThis.process) === null || _process2 === void 0 || (_process2 = _process2.env) === null || _process2 === void 0 ? void 0 : _process2.NODE_ENV) !== "production";
      var debug = exports.debug = function debug2() {
        var _console;
        if (!DEBUG_MODE) {
          return;
        }
        (_console = console).debug.apply(_console, arguments);
      };
    }
  });

  // node_modules/@atlaskit/platform-feature-flags/dist/cjs/resolvers.js
  var require_resolvers = __commonJS({
    "node_modules/@atlaskit/platform-feature-flags/dist/cjs/resolvers.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.PFF_GLOBAL_KEY = void 0;
      exports.resolveBooleanFlag = resolveBooleanFlag;
      exports.setBooleanResolver = setBooleanResolver;
      var _featureGateJsClient = _interopRequireDefault(require_cjs2());
      var _debug = require_debug();
      var pkgName = "@atlaskit/platform-feature-flags";
      var PFF_GLOBAL_KEY = exports.PFF_GLOBAL_KEY = "__PLATFORM_FEATURE_FLAGS__";
      var hasProcessEnv = typeof process !== "undefined" && typeof process.env !== "undefined";
      var ENV_ENABLE_PLATFORM_FF = hasProcessEnv ? (
        // Use global "process" variable and process.env['FLAG_NAME'] syntax, so it can be replaced by webpack DefinePlugin
        process.env["ENABLE_PLATFORM_FF"] === "true"
      ) : false;
      var ENV_STORYBOOK_ENABLE_PLATFORM_FF = hasProcessEnv ? (
        // Use global "process" variable and process.env['FLAG_NAME'] syntax, so it can be replaced by webpack DefinePlugin
        process.env["STORYBOOK_ENABLE_PLATFORM_FF"] === "true"
      ) : false;
      var ENABLE_GLOBAL_PLATFORM_FF_OVERRIDE = ENV_ENABLE_PLATFORM_FF || ENV_STORYBOOK_ENABLE_PLATFORM_FF;
      var DEFAULT_PFF_GLOBAL = {
        booleanResolver: void 0
      };
      var globalVar = typeof window !== "undefined" ? window : globalThis;
      globalVar[PFF_GLOBAL_KEY] = globalVar[PFF_GLOBAL_KEY] || DEFAULT_PFF_GLOBAL;
      function setBooleanResolver(resolver) {
        globalVar[PFF_GLOBAL_KEY].booleanResolver = resolver;
      }
      function resolveBooleanFlag(flagKey) {
        if (ENABLE_GLOBAL_PLATFORM_FF_OVERRIDE) {
          (0, _debug.debug)('[%s]: The feature flags were enabled while running tests. The flag "%s" will be always enabled.', pkgName, flagKey);
          return true;
        }
        try {
          var _globalVar$PFF_GLOBAL, _globalVar$PFF_GLOBAL2, _globalVar$PFF_GLOBAL3;
          if (((_globalVar$PFF_GLOBAL = globalVar[PFF_GLOBAL_KEY]) === null || _globalVar$PFF_GLOBAL === void 0 ? void 0 : _globalVar$PFF_GLOBAL.booleanResolver) === void 0 || ((_globalVar$PFF_GLOBAL2 = globalVar[PFF_GLOBAL_KEY]) === null || _globalVar$PFF_GLOBAL2 === void 0 ? void 0 : _globalVar$PFF_GLOBAL2.booleanResolver) === null) {
            return _featureGateJsClient.default.checkGate(flagKey);
          }
          var result2 = (_globalVar$PFF_GLOBAL3 = globalVar[PFF_GLOBAL_KEY]) === null || _globalVar$PFF_GLOBAL3 === void 0 ? void 0 : _globalVar$PFF_GLOBAL3.booleanResolver(flagKey);
          if (typeof result2 !== "boolean") {
            console.warn("".concat(flagKey, " resolved to a non-boolean value, returning false for safety"));
            return false;
          }
          return result2;
        } catch (e) {
          return false;
        }
      }
    }
  });

  // node_modules/@atlaskit/platform-feature-flags/dist/cjs/index.js
  var require_cjs3 = __commonJS({
    "node_modules/@atlaskit/platform-feature-flags/dist/cjs/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.fg = fg21;
      exports.getBooleanFF = getBooleanFF;
      exports.setBooleanFeatureFlagResolver = setBooleanFeatureFlagResolver;
      var _resolvers = require_resolvers();
      function setBooleanFeatureFlagResolver(flagResolver) {
        (0, _resolvers.setBooleanResolver)(flagResolver);
      }
      function getBooleanFF(name) {
        return (0, _resolvers.resolveBooleanFlag)(name);
      }
      function fg21(name) {
        return (0, _resolvers.resolveBooleanFlag)(name);
      }
    }
  });

  // node_modules/prop-types/lib/ReactPropTypesSecret.js
  var require_ReactPropTypesSecret = __commonJS({
    "node_modules/prop-types/lib/ReactPropTypesSecret.js"(exports, module2) {
      "use strict";
      var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
      module2.exports = ReactPropTypesSecret;
    }
  });

  // node_modules/prop-types/factoryWithThrowingShims.js
  var require_factoryWithThrowingShims = __commonJS({
    "node_modules/prop-types/factoryWithThrowingShims.js"(exports, module2) {
      "use strict";
      var ReactPropTypesSecret = require_ReactPropTypesSecret();
      function emptyFunction() {
      }
      function emptyFunctionWithReset() {
      }
      emptyFunctionWithReset.resetWarningCache = emptyFunction;
      module2.exports = function() {
        function shim(props, propName, componentName, location2, propFullName, secret) {
          if (secret === ReactPropTypesSecret) {
            return;
          }
          var err = new Error(
            "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
          );
          err.name = "Invariant Violation";
          throw err;
        }
        ;
        shim.isRequired = shim;
        function getShim() {
          return shim;
        }
        ;
        var ReactPropTypes = {
          array: shim,
          bigint: shim,
          bool: shim,
          func: shim,
          number: shim,
          object: shim,
          string: shim,
          symbol: shim,
          any: shim,
          arrayOf: getShim,
          element: shim,
          elementType: shim,
          instanceOf: getShim,
          node: shim,
          objectOf: getShim,
          oneOf: getShim,
          oneOfType: getShim,
          shape: getShim,
          exact: getShim,
          checkPropTypes: emptyFunctionWithReset,
          resetWarningCache: emptyFunction
        };
        ReactPropTypes.PropTypes = ReactPropTypes;
        return ReactPropTypes;
      };
    }
  });

  // node_modules/prop-types/index.js
  var require_prop_types = __commonJS({
    "node_modules/prop-types/index.js"(exports, module2) {
      if (false) {
        ReactIs = null;
        throwOnDirectAccess = true;
        module2.exports = null(ReactIs.isElement, throwOnDirectAccess);
      } else {
        module2.exports = require_factoryWithThrowingShims()();
      }
      var ReactIs;
      var throwOnDirectAccess;
    }
  });

  // node_modules/scheduler/cjs/scheduler.production.min.js
  var require_scheduler_production_min = __commonJS({
    "node_modules/scheduler/cjs/scheduler.production.min.js"(exports) {
      "use strict";
      function f(a, b) {
        var c = a.length;
        a.push(b);
        a: for (; 0 < c; ) {
          var d = c - 1 >>> 1, e = a[d];
          if (0 < g(e, b)) a[d] = b, a[c] = e, c = d;
          else break a;
        }
      }
      function h(a) {
        return 0 === a.length ? null : a[0];
      }
      function k(a) {
        if (0 === a.length) return null;
        var b = a[0], c = a.pop();
        if (c !== b) {
          a[0] = c;
          a: for (var d = 0, e = a.length, w2 = e >>> 1; d < w2; ) {
            var m = 2 * (d + 1) - 1, C = a[m], n = m + 1, x = a[n];
            if (0 > g(C, c)) n < e && 0 > g(x, C) ? (a[d] = x, a[n] = c, d = n) : (a[d] = C, a[m] = c, d = m);
            else if (n < e && 0 > g(x, c)) a[d] = x, a[n] = c, d = n;
            else break a;
          }
        }
        return b;
      }
      function g(a, b) {
        var c = a.sortIndex - b.sortIndex;
        return 0 !== c ? c : a.id - b.id;
      }
      if ("object" === typeof performance && "function" === typeof performance.now) {
        l = performance;
        exports.unstable_now = function() {
          return l.now();
        };
      } else {
        p = Date, q = p.now();
        exports.unstable_now = function() {
          return p.now() - q;
        };
      }
      var l;
      var p;
      var q;
      var r = [];
      var t = [];
      var u = 1;
      var v = null;
      var y = 3;
      var z = false;
      var A = false;
      var B = false;
      var D = "function" === typeof setTimeout ? setTimeout : null;
      var E = "function" === typeof clearTimeout ? clearTimeout : null;
      var F = "undefined" !== typeof setImmediate ? setImmediate : null;
      "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
      function G(a) {
        for (var b = h(t); null !== b; ) {
          if (null === b.callback) k(t);
          else if (b.startTime <= a) k(t), b.sortIndex = b.expirationTime, f(r, b);
          else break;
          b = h(t);
        }
      }
      function H(a) {
        B = false;
        G(a);
        if (!A) if (null !== h(r)) A = true, I(J);
        else {
          var b = h(t);
          null !== b && K(H, b.startTime - a);
        }
      }
      function J(a, b) {
        A = false;
        B && (B = false, E(L), L = -1);
        z = true;
        var c = y;
        try {
          G(b);
          for (v = h(r); null !== v && (!(v.expirationTime > b) || a && !M()); ) {
            var d = v.callback;
            if ("function" === typeof d) {
              v.callback = null;
              y = v.priorityLevel;
              var e = d(v.expirationTime <= b);
              b = exports.unstable_now();
              "function" === typeof e ? v.callback = e : v === h(r) && k(r);
              G(b);
            } else k(r);
            v = h(r);
          }
          if (null !== v) var w2 = true;
          else {
            var m = h(t);
            null !== m && K(H, m.startTime - b);
            w2 = false;
          }
          return w2;
        } finally {
          v = null, y = c, z = false;
        }
      }
      var N = false;
      var O = null;
      var L = -1;
      var P = 5;
      var Q = -1;
      function M() {
        return exports.unstable_now() - Q < P ? false : true;
      }
      function R() {
        if (null !== O) {
          var a = exports.unstable_now();
          Q = a;
          var b = true;
          try {
            b = O(true, a);
          } finally {
            b ? S() : (N = false, O = null);
          }
        } else N = false;
      }
      var S;
      if ("function" === typeof F) S = function() {
        F(R);
      };
      else if ("undefined" !== typeof MessageChannel) {
        T = new MessageChannel(), U = T.port2;
        T.port1.onmessage = R;
        S = function() {
          U.postMessage(null);
        };
      } else S = function() {
        D(R, 0);
      };
      var T;
      var U;
      function I(a) {
        O = a;
        N || (N = true, S());
      }
      function K(a, b) {
        L = D(function() {
          a(exports.unstable_now());
        }, b);
      }
      exports.unstable_IdlePriority = 5;
      exports.unstable_ImmediatePriority = 1;
      exports.unstable_LowPriority = 4;
      exports.unstable_NormalPriority = 3;
      exports.unstable_Profiling = null;
      exports.unstable_UserBlockingPriority = 2;
      exports.unstable_cancelCallback = function(a) {
        a.callback = null;
      };
      exports.unstable_continueExecution = function() {
        A || z || (A = true, I(J));
      };
      exports.unstable_forceFrameRate = function(a) {
        0 > a || 125 < a ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P = 0 < a ? Math.floor(1e3 / a) : 5;
      };
      exports.unstable_getCurrentPriorityLevel = function() {
        return y;
      };
      exports.unstable_getFirstCallbackNode = function() {
        return h(r);
      };
      exports.unstable_next = function(a) {
        switch (y) {
          case 1:
          case 2:
          case 3:
            var b = 3;
            break;
          default:
            b = y;
        }
        var c = y;
        y = b;
        try {
          return a();
        } finally {
          y = c;
        }
      };
      exports.unstable_pauseExecution = function() {
      };
      exports.unstable_requestPaint = function() {
      };
      exports.unstable_runWithPriority = function(a, b) {
        switch (a) {
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
            break;
          default:
            a = 3;
        }
        var c = y;
        y = a;
        try {
          return b();
        } finally {
          y = c;
        }
      };
      exports.unstable_scheduleCallback = function(a, b, c) {
        var d = exports.unstable_now();
        "object" === typeof c && null !== c ? (c = c.delay, c = "number" === typeof c && 0 < c ? d + c : d) : c = d;
        switch (a) {
          case 1:
            var e = -1;
            break;
          case 2:
            e = 250;
            break;
          case 5:
            e = 1073741823;
            break;
          case 4:
            e = 1e4;
            break;
          default:
            e = 5e3;
        }
        e = c + e;
        a = { id: u++, callback: b, priorityLevel: a, startTime: c, expirationTime: e, sortIndex: -1 };
        c > d ? (a.sortIndex = c, f(t, a), null === h(r) && a === h(t) && (B ? (E(L), L = -1) : B = true, K(H, c - d))) : (a.sortIndex = e, f(r, a), A || z || (A = true, I(J)));
        return a;
      };
      exports.unstable_shouldYield = M;
      exports.unstable_wrapCallback = function(a) {
        var b = y;
        return function() {
          var c = y;
          y = b;
          try {
            return a.apply(this, arguments);
          } finally {
            y = c;
          }
        };
      };
    }
  });

  // node_modules/scheduler/index.js
  var require_scheduler = __commonJS({
    "node_modules/scheduler/index.js"(exports, module2) {
      "use strict";
      if (true) {
        module2.exports = require_scheduler_production_min();
      } else {
        module2.exports = null;
      }
    }
  });

  // node_modules/react-dom/cjs/react-dom.production.min.js
  var require_react_dom_production_min = __commonJS({
    "node_modules/react-dom/cjs/react-dom.production.min.js"(exports) {
      "use strict";
      var aa = require_react();
      var ca = require_scheduler();
      function p(a) {
        for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++) b += "&args[]=" + encodeURIComponent(arguments[c]);
        return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
      }
      var da = /* @__PURE__ */ new Set();
      var ea = {};
      function fa(a, b) {
        ha(a, b);
        ha(a + "Capture", b);
      }
      function ha(a, b) {
        ea[a] = b;
        for (a = 0; a < b.length; a++) da.add(b[a]);
      }
      var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement);
      var ja = Object.prototype.hasOwnProperty;
      var ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/;
      var la = {};
      var ma = {};
      function oa(a) {
        if (ja.call(ma, a)) return true;
        if (ja.call(la, a)) return false;
        if (ka.test(a)) return ma[a] = true;
        la[a] = true;
        return false;
      }
      function pa(a, b, c, d) {
        if (null !== c && 0 === c.type) return false;
        switch (typeof b) {
          case "function":
          case "symbol":
            return true;
          case "boolean":
            if (d) return false;
            if (null !== c) return !c.acceptsBooleans;
            a = a.toLowerCase().slice(0, 5);
            return "data-" !== a && "aria-" !== a;
          default:
            return false;
        }
      }
      function qa(a, b, c, d) {
        if (null === b || "undefined" === typeof b || pa(a, b, c, d)) return true;
        if (d) return false;
        if (null !== c) switch (c.type) {
          case 3:
            return !b;
          case 4:
            return false === b;
          case 5:
            return isNaN(b);
          case 6:
            return isNaN(b) || 1 > b;
        }
        return false;
      }
      function v(a, b, c, d, e, f, g) {
        this.acceptsBooleans = 2 === b || 3 === b || 4 === b;
        this.attributeName = d;
        this.attributeNamespace = e;
        this.mustUseProperty = c;
        this.propertyName = a;
        this.type = b;
        this.sanitizeURL = f;
        this.removeEmptyString = g;
      }
      var z = {};
      "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a) {
        z[a] = new v(a, 0, false, a, null, false, false);
      });
      [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a) {
        var b = a[0];
        z[b] = new v(b, 1, false, a[1], null, false, false);
      });
      ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a) {
        z[a] = new v(a, 2, false, a.toLowerCase(), null, false, false);
      });
      ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a) {
        z[a] = new v(a, 2, false, a, null, false, false);
      });
      "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a) {
        z[a] = new v(a, 3, false, a.toLowerCase(), null, false, false);
      });
      ["checked", "multiple", "muted", "selected"].forEach(function(a) {
        z[a] = new v(a, 3, true, a, null, false, false);
      });
      ["capture", "download"].forEach(function(a) {
        z[a] = new v(a, 4, false, a, null, false, false);
      });
      ["cols", "rows", "size", "span"].forEach(function(a) {
        z[a] = new v(a, 6, false, a, null, false, false);
      });
      ["rowSpan", "start"].forEach(function(a) {
        z[a] = new v(a, 5, false, a.toLowerCase(), null, false, false);
      });
      var ra = /[\-:]([a-z])/g;
      function sa(a) {
        return a[1].toUpperCase();
      }
      "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a) {
        var b = a.replace(
          ra,
          sa
        );
        z[b] = new v(b, 1, false, a, null, false, false);
      });
      "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a) {
        var b = a.replace(ra, sa);
        z[b] = new v(b, 1, false, a, "http://www.w3.org/1999/xlink", false, false);
      });
      ["xml:base", "xml:lang", "xml:space"].forEach(function(a) {
        var b = a.replace(ra, sa);
        z[b] = new v(b, 1, false, a, "http://www.w3.org/XML/1998/namespace", false, false);
      });
      ["tabIndex", "crossOrigin"].forEach(function(a) {
        z[a] = new v(a, 1, false, a.toLowerCase(), null, false, false);
      });
      z.xlinkHref = new v("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
      ["src", "href", "action", "formAction"].forEach(function(a) {
        z[a] = new v(a, 1, false, a.toLowerCase(), null, true, true);
      });
      function ta(a, b, c, d) {
        var e = z.hasOwnProperty(b) ? z[b] : null;
        if (null !== e ? 0 !== e.type : d || !(2 < b.length) || "o" !== b[0] && "O" !== b[0] || "n" !== b[1] && "N" !== b[1]) qa(b, c, e, d) && (c = null), d || null === e ? oa(b) && (null === c ? a.removeAttribute(b) : a.setAttribute(b, "" + c)) : e.mustUseProperty ? a[e.propertyName] = null === c ? 3 === e.type ? false : "" : c : (b = e.attributeName, d = e.attributeNamespace, null === c ? a.removeAttribute(b) : (e = e.type, c = 3 === e || 4 === e && true === c ? "" : "" + c, d ? a.setAttributeNS(d, b, c) : a.setAttribute(b, c)));
      }
      var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      var va = Symbol.for("react.element");
      var wa = Symbol.for("react.portal");
      var ya = Symbol.for("react.fragment");
      var za = Symbol.for("react.strict_mode");
      var Aa = Symbol.for("react.profiler");
      var Ba = Symbol.for("react.provider");
      var Ca = Symbol.for("react.context");
      var Da = Symbol.for("react.forward_ref");
      var Ea = Symbol.for("react.suspense");
      var Fa = Symbol.for("react.suspense_list");
      var Ga = Symbol.for("react.memo");
      var Ha = Symbol.for("react.lazy");
      Symbol.for("react.scope");
      Symbol.for("react.debug_trace_mode");
      var Ia = Symbol.for("react.offscreen");
      Symbol.for("react.legacy_hidden");
      Symbol.for("react.cache");
      Symbol.for("react.tracing_marker");
      var Ja = Symbol.iterator;
      function Ka(a) {
        if (null === a || "object" !== typeof a) return null;
        a = Ja && a[Ja] || a["@@iterator"];
        return "function" === typeof a ? a : null;
      }
      var A = Object.assign;
      var La;
      function Ma(a) {
        if (void 0 === La) try {
          throw Error();
        } catch (c) {
          var b = c.stack.trim().match(/\n( *(at )?)/);
          La = b && b[1] || "";
        }
        return "\n" + La + a;
      }
      var Na = false;
      function Oa(a, b) {
        if (!a || Na) return "";
        Na = true;
        var c = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        try {
          if (b) if (b = function() {
            throw Error();
          }, Object.defineProperty(b.prototype, "props", { set: function() {
            throw Error();
          } }), "object" === typeof Reflect && Reflect.construct) {
            try {
              Reflect.construct(b, []);
            } catch (l) {
              var d = l;
            }
            Reflect.construct(a, [], b);
          } else {
            try {
              b.call();
            } catch (l) {
              d = l;
            }
            a.call(b.prototype);
          }
          else {
            try {
              throw Error();
            } catch (l) {
              d = l;
            }
            a();
          }
        } catch (l) {
          if (l && d && "string" === typeof l.stack) {
            for (var e = l.stack.split("\n"), f = d.stack.split("\n"), g = e.length - 1, h = f.length - 1; 1 <= g && 0 <= h && e[g] !== f[h]; ) h--;
            for (; 1 <= g && 0 <= h; g--, h--) if (e[g] !== f[h]) {
              if (1 !== g || 1 !== h) {
                do
                  if (g--, h--, 0 > h || e[g] !== f[h]) {
                    var k = "\n" + e[g].replace(" at new ", " at ");
                    a.displayName && k.includes("<anonymous>") && (k = k.replace("<anonymous>", a.displayName));
                    return k;
                  }
                while (1 <= g && 0 <= h);
              }
              break;
            }
          }
        } finally {
          Na = false, Error.prepareStackTrace = c;
        }
        return (a = a ? a.displayName || a.name : "") ? Ma(a) : "";
      }
      function Pa(a) {
        switch (a.tag) {
          case 5:
            return Ma(a.type);
          case 16:
            return Ma("Lazy");
          case 13:
            return Ma("Suspense");
          case 19:
            return Ma("SuspenseList");
          case 0:
          case 2:
          case 15:
            return a = Oa(a.type, false), a;
          case 11:
            return a = Oa(a.type.render, false), a;
          case 1:
            return a = Oa(a.type, true), a;
          default:
            return "";
        }
      }
      function Qa(a) {
        if (null == a) return null;
        if ("function" === typeof a) return a.displayName || a.name || null;
        if ("string" === typeof a) return a;
        switch (a) {
          case ya:
            return "Fragment";
          case wa:
            return "Portal";
          case Aa:
            return "Profiler";
          case za:
            return "StrictMode";
          case Ea:
            return "Suspense";
          case Fa:
            return "SuspenseList";
        }
        if ("object" === typeof a) switch (a.$$typeof) {
          case Ca:
            return (a.displayName || "Context") + ".Consumer";
          case Ba:
            return (a._context.displayName || "Context") + ".Provider";
          case Da:
            var b = a.render;
            a = a.displayName;
            a || (a = b.displayName || b.name || "", a = "" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
            return a;
          case Ga:
            return b = a.displayName || null, null !== b ? b : Qa(a.type) || "Memo";
          case Ha:
            b = a._payload;
            a = a._init;
            try {
              return Qa(a(b));
            } catch (c) {
            }
        }
        return null;
      }
      function Ra(a) {
        var b = a.type;
        switch (a.tag) {
          case 24:
            return "Cache";
          case 9:
            return (b.displayName || "Context") + ".Consumer";
          case 10:
            return (b._context.displayName || "Context") + ".Provider";
          case 18:
            return "DehydratedFragment";
          case 11:
            return a = b.render, a = a.displayName || a.name || "", b.displayName || ("" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
          case 7:
            return "Fragment";
          case 5:
            return b;
          case 4:
            return "Portal";
          case 3:
            return "Root";
          case 6:
            return "Text";
          case 16:
            return Qa(b);
          case 8:
            return b === za ? "StrictMode" : "Mode";
          case 22:
            return "Offscreen";
          case 12:
            return "Profiler";
          case 21:
            return "Scope";
          case 13:
            return "Suspense";
          case 19:
            return "SuspenseList";
          case 25:
            return "TracingMarker";
          case 1:
          case 0:
          case 17:
          case 2:
          case 14:
          case 15:
            if ("function" === typeof b) return b.displayName || b.name || null;
            if ("string" === typeof b) return b;
        }
        return null;
      }
      function Sa(a) {
        switch (typeof a) {
          case "boolean":
          case "number":
          case "string":
          case "undefined":
            return a;
          case "object":
            return a;
          default:
            return "";
        }
      }
      function Ta(a) {
        var b = a.type;
        return (a = a.nodeName) && "input" === a.toLowerCase() && ("checkbox" === b || "radio" === b);
      }
      function Ua(a) {
        var b = Ta(a) ? "checked" : "value", c = Object.getOwnPropertyDescriptor(a.constructor.prototype, b), d = "" + a[b];
        if (!a.hasOwnProperty(b) && "undefined" !== typeof c && "function" === typeof c.get && "function" === typeof c.set) {
          var e = c.get, f = c.set;
          Object.defineProperty(a, b, { configurable: true, get: function() {
            return e.call(this);
          }, set: function(a2) {
            d = "" + a2;
            f.call(this, a2);
          } });
          Object.defineProperty(a, b, { enumerable: c.enumerable });
          return { getValue: function() {
            return d;
          }, setValue: function(a2) {
            d = "" + a2;
          }, stopTracking: function() {
            a._valueTracker = null;
            delete a[b];
          } };
        }
      }
      function Va(a) {
        a._valueTracker || (a._valueTracker = Ua(a));
      }
      function Wa(a) {
        if (!a) return false;
        var b = a._valueTracker;
        if (!b) return true;
        var c = b.getValue();
        var d = "";
        a && (d = Ta(a) ? a.checked ? "true" : "false" : a.value);
        a = d;
        return a !== c ? (b.setValue(a), true) : false;
      }
      function Xa(a) {
        a = a || ("undefined" !== typeof document ? document : void 0);
        if ("undefined" === typeof a) return null;
        try {
          return a.activeElement || a.body;
        } catch (b) {
          return a.body;
        }
      }
      function Ya(a, b) {
        var c = b.checked;
        return A({}, b, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c ? c : a._wrapperState.initialChecked });
      }
      function Za(a, b) {
        var c = null == b.defaultValue ? "" : b.defaultValue, d = null != b.checked ? b.checked : b.defaultChecked;
        c = Sa(null != b.value ? b.value : c);
        a._wrapperState = { initialChecked: d, initialValue: c, controlled: "checkbox" === b.type || "radio" === b.type ? null != b.checked : null != b.value };
      }
      function ab(a, b) {
        b = b.checked;
        null != b && ta(a, "checked", b, false);
      }
      function bb(a, b) {
        ab(a, b);
        var c = Sa(b.value), d = b.type;
        if (null != c) if ("number" === d) {
          if (0 === c && "" === a.value || a.value != c) a.value = "" + c;
        } else a.value !== "" + c && (a.value = "" + c);
        else if ("submit" === d || "reset" === d) {
          a.removeAttribute("value");
          return;
        }
        b.hasOwnProperty("value") ? cb(a, b.type, c) : b.hasOwnProperty("defaultValue") && cb(a, b.type, Sa(b.defaultValue));
        null == b.checked && null != b.defaultChecked && (a.defaultChecked = !!b.defaultChecked);
      }
      function db2(a, b, c) {
        if (b.hasOwnProperty("value") || b.hasOwnProperty("defaultValue")) {
          var d = b.type;
          if (!("submit" !== d && "reset" !== d || void 0 !== b.value && null !== b.value)) return;
          b = "" + a._wrapperState.initialValue;
          c || b === a.value || (a.value = b);
          a.defaultValue = b;
        }
        c = a.name;
        "" !== c && (a.name = "");
        a.defaultChecked = !!a._wrapperState.initialChecked;
        "" !== c && (a.name = c);
      }
      function cb(a, b, c) {
        if ("number" !== b || Xa(a.ownerDocument) !== a) null == c ? a.defaultValue = "" + a._wrapperState.initialValue : a.defaultValue !== "" + c && (a.defaultValue = "" + c);
      }
      var eb = Array.isArray;
      function fb(a, b, c, d) {
        a = a.options;
        if (b) {
          b = {};
          for (var e = 0; e < c.length; e++) b["$" + c[e]] = true;
          for (c = 0; c < a.length; c++) e = b.hasOwnProperty("$" + a[c].value), a[c].selected !== e && (a[c].selected = e), e && d && (a[c].defaultSelected = true);
        } else {
          c = "" + Sa(c);
          b = null;
          for (e = 0; e < a.length; e++) {
            if (a[e].value === c) {
              a[e].selected = true;
              d && (a[e].defaultSelected = true);
              return;
            }
            null !== b || a[e].disabled || (b = a[e]);
          }
          null !== b && (b.selected = true);
        }
      }
      function gb(a, b) {
        if (null != b.dangerouslySetInnerHTML) throw Error(p(91));
        return A({}, b, { value: void 0, defaultValue: void 0, children: "" + a._wrapperState.initialValue });
      }
      function hb(a, b) {
        var c = b.value;
        if (null == c) {
          c = b.children;
          b = b.defaultValue;
          if (null != c) {
            if (null != b) throw Error(p(92));
            if (eb(c)) {
              if (1 < c.length) throw Error(p(93));
              c = c[0];
            }
            b = c;
          }
          null == b && (b = "");
          c = b;
        }
        a._wrapperState = { initialValue: Sa(c) };
      }
      function ib(a, b) {
        var c = Sa(b.value), d = Sa(b.defaultValue);
        null != c && (c = "" + c, c !== a.value && (a.value = c), null == b.defaultValue && a.defaultValue !== c && (a.defaultValue = c));
        null != d && (a.defaultValue = "" + d);
      }
      function jb(a) {
        var b = a.textContent;
        b === a._wrapperState.initialValue && "" !== b && null !== b && (a.value = b);
      }
      function kb(a) {
        switch (a) {
          case "svg":
            return "http://www.w3.org/2000/svg";
          case "math":
            return "http://www.w3.org/1998/Math/MathML";
          default:
            return "http://www.w3.org/1999/xhtml";
        }
      }
      function lb(a, b) {
        return null == a || "http://www.w3.org/1999/xhtml" === a ? kb(b) : "http://www.w3.org/2000/svg" === a && "foreignObject" === b ? "http://www.w3.org/1999/xhtml" : a;
      }
      var mb;
      var nb = (function(a) {
        return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b, c, d, e) {
          MSApp.execUnsafeLocalFunction(function() {
            return a(b, c, d, e);
          });
        } : a;
      })(function(a, b) {
        if ("http://www.w3.org/2000/svg" !== a.namespaceURI || "innerHTML" in a) a.innerHTML = b;
        else {
          mb = mb || document.createElement("div");
          mb.innerHTML = "<svg>" + b.valueOf().toString() + "</svg>";
          for (b = mb.firstChild; a.firstChild; ) a.removeChild(a.firstChild);
          for (; b.firstChild; ) a.appendChild(b.firstChild);
        }
      });
      function ob(a, b) {
        if (b) {
          var c = a.firstChild;
          if (c && c === a.lastChild && 3 === c.nodeType) {
            c.nodeValue = b;
            return;
          }
        }
        a.textContent = b;
      }
      var pb = {
        animationIterationCount: true,
        aspectRatio: true,
        borderImageOutset: true,
        borderImageSlice: true,
        borderImageWidth: true,
        boxFlex: true,
        boxFlexGroup: true,
        boxOrdinalGroup: true,
        columnCount: true,
        columns: true,
        flex: true,
        flexGrow: true,
        flexPositive: true,
        flexShrink: true,
        flexNegative: true,
        flexOrder: true,
        gridArea: true,
        gridRow: true,
        gridRowEnd: true,
        gridRowSpan: true,
        gridRowStart: true,
        gridColumn: true,
        gridColumnEnd: true,
        gridColumnSpan: true,
        gridColumnStart: true,
        fontWeight: true,
        lineClamp: true,
        lineHeight: true,
        opacity: true,
        order: true,
        orphans: true,
        tabSize: true,
        widows: true,
        zIndex: true,
        zoom: true,
        fillOpacity: true,
        floodOpacity: true,
        stopOpacity: true,
        strokeDasharray: true,
        strokeDashoffset: true,
        strokeMiterlimit: true,
        strokeOpacity: true,
        strokeWidth: true
      };
      var qb = ["Webkit", "ms", "Moz", "O"];
      Object.keys(pb).forEach(function(a) {
        qb.forEach(function(b) {
          b = b + a.charAt(0).toUpperCase() + a.substring(1);
          pb[b] = pb[a];
        });
      });
      function rb(a, b, c) {
        return null == b || "boolean" === typeof b || "" === b ? "" : c || "number" !== typeof b || 0 === b || pb.hasOwnProperty(a) && pb[a] ? ("" + b).trim() : b + "px";
      }
      function sb(a, b) {
        a = a.style;
        for (var c in b) if (b.hasOwnProperty(c)) {
          var d = 0 === c.indexOf("--"), e = rb(c, b[c], d);
          "float" === c && (c = "cssFloat");
          d ? a.setProperty(c, e) : a[c] = e;
        }
      }
      var tb = A({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
      function ub(a, b) {
        if (b) {
          if (tb[a] && (null != b.children || null != b.dangerouslySetInnerHTML)) throw Error(p(137, a));
          if (null != b.dangerouslySetInnerHTML) {
            if (null != b.children) throw Error(p(60));
            if ("object" !== typeof b.dangerouslySetInnerHTML || !("__html" in b.dangerouslySetInnerHTML)) throw Error(p(61));
          }
          if (null != b.style && "object" !== typeof b.style) throw Error(p(62));
        }
      }
      function vb(a, b) {
        if (-1 === a.indexOf("-")) return "string" === typeof b.is;
        switch (a) {
          case "annotation-xml":
          case "color-profile":
          case "font-face":
          case "font-face-src":
          case "font-face-uri":
          case "font-face-format":
          case "font-face-name":
          case "missing-glyph":
            return false;
          default:
            return true;
        }
      }
      var wb = null;
      function xb(a) {
        a = a.target || a.srcElement || window;
        a.correspondingUseElement && (a = a.correspondingUseElement);
        return 3 === a.nodeType ? a.parentNode : a;
      }
      var yb = null;
      var zb = null;
      var Ab = null;
      function Bb(a) {
        if (a = Cb(a)) {
          if ("function" !== typeof yb) throw Error(p(280));
          var b = a.stateNode;
          b && (b = Db(b), yb(a.stateNode, a.type, b));
        }
      }
      function Eb(a) {
        zb ? Ab ? Ab.push(a) : Ab = [a] : zb = a;
      }
      function Fb() {
        if (zb) {
          var a = zb, b = Ab;
          Ab = zb = null;
          Bb(a);
          if (b) for (a = 0; a < b.length; a++) Bb(b[a]);
        }
      }
      function Gb(a, b) {
        return a(b);
      }
      function Hb() {
      }
      var Ib = false;
      function Jb(a, b, c) {
        if (Ib) return a(b, c);
        Ib = true;
        try {
          return Gb(a, b, c);
        } finally {
          if (Ib = false, null !== zb || null !== Ab) Hb(), Fb();
        }
      }
      function Kb(a, b) {
        var c = a.stateNode;
        if (null === c) return null;
        var d = Db(c);
        if (null === d) return null;
        c = d[b];
        a: switch (b) {
          case "onClick":
          case "onClickCapture":
          case "onDoubleClick":
          case "onDoubleClickCapture":
          case "onMouseDown":
          case "onMouseDownCapture":
          case "onMouseMove":
          case "onMouseMoveCapture":
          case "onMouseUp":
          case "onMouseUpCapture":
          case "onMouseEnter":
            (d = !d.disabled) || (a = a.type, d = !("button" === a || "input" === a || "select" === a || "textarea" === a));
            a = !d;
            break a;
          default:
            a = false;
        }
        if (a) return null;
        if (c && "function" !== typeof c) throw Error(p(231, b, typeof c));
        return c;
      }
      var Lb = false;
      if (ia) try {
        Mb = {};
        Object.defineProperty(Mb, "passive", { get: function() {
          Lb = true;
        } });
        window.addEventListener("test", Mb, Mb);
        window.removeEventListener("test", Mb, Mb);
      } catch (a) {
        Lb = false;
      }
      var Mb;
      function Nb(a, b, c, d, e, f, g, h, k) {
        var l = Array.prototype.slice.call(arguments, 3);
        try {
          b.apply(c, l);
        } catch (m) {
          this.onError(m);
        }
      }
      var Ob = false;
      var Pb = null;
      var Qb = false;
      var Rb = null;
      var Sb = { onError: function(a) {
        Ob = true;
        Pb = a;
      } };
      function Tb(a, b, c, d, e, f, g, h, k) {
        Ob = false;
        Pb = null;
        Nb.apply(Sb, arguments);
      }
      function Ub(a, b, c, d, e, f, g, h, k) {
        Tb.apply(this, arguments);
        if (Ob) {
          if (Ob) {
            var l = Pb;
            Ob = false;
            Pb = null;
          } else throw Error(p(198));
          Qb || (Qb = true, Rb = l);
        }
      }
      function Vb(a) {
        var b = a, c = a;
        if (a.alternate) for (; b.return; ) b = b.return;
        else {
          a = b;
          do
            b = a, 0 !== (b.flags & 4098) && (c = b.return), a = b.return;
          while (a);
        }
        return 3 === b.tag ? c : null;
      }
      function Wb(a) {
        if (13 === a.tag) {
          var b = a.memoizedState;
          null === b && (a = a.alternate, null !== a && (b = a.memoizedState));
          if (null !== b) return b.dehydrated;
        }
        return null;
      }
      function Xb(a) {
        if (Vb(a) !== a) throw Error(p(188));
      }
      function Yb(a) {
        var b = a.alternate;
        if (!b) {
          b = Vb(a);
          if (null === b) throw Error(p(188));
          return b !== a ? null : a;
        }
        for (var c = a, d = b; ; ) {
          var e = c.return;
          if (null === e) break;
          var f = e.alternate;
          if (null === f) {
            d = e.return;
            if (null !== d) {
              c = d;
              continue;
            }
            break;
          }
          if (e.child === f.child) {
            for (f = e.child; f; ) {
              if (f === c) return Xb(e), a;
              if (f === d) return Xb(e), b;
              f = f.sibling;
            }
            throw Error(p(188));
          }
          if (c.return !== d.return) c = e, d = f;
          else {
            for (var g = false, h = e.child; h; ) {
              if (h === c) {
                g = true;
                c = e;
                d = f;
                break;
              }
              if (h === d) {
                g = true;
                d = e;
                c = f;
                break;
              }
              h = h.sibling;
            }
            if (!g) {
              for (h = f.child; h; ) {
                if (h === c) {
                  g = true;
                  c = f;
                  d = e;
                  break;
                }
                if (h === d) {
                  g = true;
                  d = f;
                  c = e;
                  break;
                }
                h = h.sibling;
              }
              if (!g) throw Error(p(189));
            }
          }
          if (c.alternate !== d) throw Error(p(190));
        }
        if (3 !== c.tag) throw Error(p(188));
        return c.stateNode.current === c ? a : b;
      }
      function Zb(a) {
        a = Yb(a);
        return null !== a ? $b(a) : null;
      }
      function $b(a) {
        if (5 === a.tag || 6 === a.tag) return a;
        for (a = a.child; null !== a; ) {
          var b = $b(a);
          if (null !== b) return b;
          a = a.sibling;
        }
        return null;
      }
      var ac = ca.unstable_scheduleCallback;
      var bc = ca.unstable_cancelCallback;
      var cc = ca.unstable_shouldYield;
      var dc = ca.unstable_requestPaint;
      var B = ca.unstable_now;
      var ec = ca.unstable_getCurrentPriorityLevel;
      var fc = ca.unstable_ImmediatePriority;
      var gc = ca.unstable_UserBlockingPriority;
      var hc = ca.unstable_NormalPriority;
      var ic = ca.unstable_LowPriority;
      var jc = ca.unstable_IdlePriority;
      var kc = null;
      var lc = null;
      function mc(a) {
        if (lc && "function" === typeof lc.onCommitFiberRoot) try {
          lc.onCommitFiberRoot(kc, a, void 0, 128 === (a.current.flags & 128));
        } catch (b) {
        }
      }
      var oc = Math.clz32 ? Math.clz32 : nc;
      var pc = Math.log;
      var qc = Math.LN2;
      function nc(a) {
        a >>>= 0;
        return 0 === a ? 32 : 31 - (pc(a) / qc | 0) | 0;
      }
      var rc = 64;
      var sc = 4194304;
      function tc(a) {
        switch (a & -a) {
          case 1:
            return 1;
          case 2:
            return 2;
          case 4:
            return 4;
          case 8:
            return 8;
          case 16:
            return 16;
          case 32:
            return 32;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
            return a & 4194240;
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            return a & 130023424;
          case 134217728:
            return 134217728;
          case 268435456:
            return 268435456;
          case 536870912:
            return 536870912;
          case 1073741824:
            return 1073741824;
          default:
            return a;
        }
      }
      function uc(a, b) {
        var c = a.pendingLanes;
        if (0 === c) return 0;
        var d = 0, e = a.suspendedLanes, f = a.pingedLanes, g = c & 268435455;
        if (0 !== g) {
          var h = g & ~e;
          0 !== h ? d = tc(h) : (f &= g, 0 !== f && (d = tc(f)));
        } else g = c & ~e, 0 !== g ? d = tc(g) : 0 !== f && (d = tc(f));
        if (0 === d) return 0;
        if (0 !== b && b !== d && 0 === (b & e) && (e = d & -d, f = b & -b, e >= f || 16 === e && 0 !== (f & 4194240))) return b;
        0 !== (d & 4) && (d |= c & 16);
        b = a.entangledLanes;
        if (0 !== b) for (a = a.entanglements, b &= d; 0 < b; ) c = 31 - oc(b), e = 1 << c, d |= a[c], b &= ~e;
        return d;
      }
      function vc(a, b) {
        switch (a) {
          case 1:
          case 2:
          case 4:
            return b + 250;
          case 8:
          case 16:
          case 32:
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
            return b + 5e3;
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            return -1;
          case 134217728:
          case 268435456:
          case 536870912:
          case 1073741824:
            return -1;
          default:
            return -1;
        }
      }
      function wc(a, b) {
        for (var c = a.suspendedLanes, d = a.pingedLanes, e = a.expirationTimes, f = a.pendingLanes; 0 < f; ) {
          var g = 31 - oc(f), h = 1 << g, k = e[g];
          if (-1 === k) {
            if (0 === (h & c) || 0 !== (h & d)) e[g] = vc(h, b);
          } else k <= b && (a.expiredLanes |= h);
          f &= ~h;
        }
      }
      function xc(a) {
        a = a.pendingLanes & -1073741825;
        return 0 !== a ? a : a & 1073741824 ? 1073741824 : 0;
      }
      function yc() {
        var a = rc;
        rc <<= 1;
        0 === (rc & 4194240) && (rc = 64);
        return a;
      }
      function zc(a) {
        for (var b = [], c = 0; 31 > c; c++) b.push(a);
        return b;
      }
      function Ac(a, b, c) {
        a.pendingLanes |= b;
        536870912 !== b && (a.suspendedLanes = 0, a.pingedLanes = 0);
        a = a.eventTimes;
        b = 31 - oc(b);
        a[b] = c;
      }
      function Bc(a, b) {
        var c = a.pendingLanes & ~b;
        a.pendingLanes = b;
        a.suspendedLanes = 0;
        a.pingedLanes = 0;
        a.expiredLanes &= b;
        a.mutableReadLanes &= b;
        a.entangledLanes &= b;
        b = a.entanglements;
        var d = a.eventTimes;
        for (a = a.expirationTimes; 0 < c; ) {
          var e = 31 - oc(c), f = 1 << e;
          b[e] = 0;
          d[e] = -1;
          a[e] = -1;
          c &= ~f;
        }
      }
      function Cc(a, b) {
        var c = a.entangledLanes |= b;
        for (a = a.entanglements; c; ) {
          var d = 31 - oc(c), e = 1 << d;
          e & b | a[d] & b && (a[d] |= b);
          c &= ~e;
        }
      }
      var C = 0;
      function Dc(a) {
        a &= -a;
        return 1 < a ? 4 < a ? 0 !== (a & 268435455) ? 16 : 536870912 : 4 : 1;
      }
      var Ec;
      var Fc;
      var Gc;
      var Hc;
      var Ic;
      var Jc = false;
      var Kc = [];
      var Lc = null;
      var Mc = null;
      var Nc = null;
      var Oc = /* @__PURE__ */ new Map();
      var Pc = /* @__PURE__ */ new Map();
      var Qc = [];
      var Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
      function Sc(a, b) {
        switch (a) {
          case "focusin":
          case "focusout":
            Lc = null;
            break;
          case "dragenter":
          case "dragleave":
            Mc = null;
            break;
          case "mouseover":
          case "mouseout":
            Nc = null;
            break;
          case "pointerover":
          case "pointerout":
            Oc.delete(b.pointerId);
            break;
          case "gotpointercapture":
          case "lostpointercapture":
            Pc.delete(b.pointerId);
        }
      }
      function Tc(a, b, c, d, e, f) {
        if (null === a || a.nativeEvent !== f) return a = { blockedOn: b, domEventName: c, eventSystemFlags: d, nativeEvent: f, targetContainers: [e] }, null !== b && (b = Cb(b), null !== b && Fc(b)), a;
        a.eventSystemFlags |= d;
        b = a.targetContainers;
        null !== e && -1 === b.indexOf(e) && b.push(e);
        return a;
      }
      function Uc(a, b, c, d, e) {
        switch (b) {
          case "focusin":
            return Lc = Tc(Lc, a, b, c, d, e), true;
          case "dragenter":
            return Mc = Tc(Mc, a, b, c, d, e), true;
          case "mouseover":
            return Nc = Tc(Nc, a, b, c, d, e), true;
          case "pointerover":
            var f = e.pointerId;
            Oc.set(f, Tc(Oc.get(f) || null, a, b, c, d, e));
            return true;
          case "gotpointercapture":
            return f = e.pointerId, Pc.set(f, Tc(Pc.get(f) || null, a, b, c, d, e)), true;
        }
        return false;
      }
      function Vc(a) {
        var b = Wc(a.target);
        if (null !== b) {
          var c = Vb(b);
          if (null !== c) {
            if (b = c.tag, 13 === b) {
              if (b = Wb(c), null !== b) {
                a.blockedOn = b;
                Ic(a.priority, function() {
                  Gc(c);
                });
                return;
              }
            } else if (3 === b && c.stateNode.current.memoizedState.isDehydrated) {
              a.blockedOn = 3 === c.tag ? c.stateNode.containerInfo : null;
              return;
            }
          }
        }
        a.blockedOn = null;
      }
      function Xc(a) {
        if (null !== a.blockedOn) return false;
        for (var b = a.targetContainers; 0 < b.length; ) {
          var c = Yc(a.domEventName, a.eventSystemFlags, b[0], a.nativeEvent);
          if (null === c) {
            c = a.nativeEvent;
            var d = new c.constructor(c.type, c);
            wb = d;
            c.target.dispatchEvent(d);
            wb = null;
          } else return b = Cb(c), null !== b && Fc(b), a.blockedOn = c, false;
          b.shift();
        }
        return true;
      }
      function Zc(a, b, c) {
        Xc(a) && c.delete(b);
      }
      function $c() {
        Jc = false;
        null !== Lc && Xc(Lc) && (Lc = null);
        null !== Mc && Xc(Mc) && (Mc = null);
        null !== Nc && Xc(Nc) && (Nc = null);
        Oc.forEach(Zc);
        Pc.forEach(Zc);
      }
      function ad(a, b) {
        a.blockedOn === b && (a.blockedOn = null, Jc || (Jc = true, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
      }
      function bd(a) {
        function b(b2) {
          return ad(b2, a);
        }
        if (0 < Kc.length) {
          ad(Kc[0], a);
          for (var c = 1; c < Kc.length; c++) {
            var d = Kc[c];
            d.blockedOn === a && (d.blockedOn = null);
          }
        }
        null !== Lc && ad(Lc, a);
        null !== Mc && ad(Mc, a);
        null !== Nc && ad(Nc, a);
        Oc.forEach(b);
        Pc.forEach(b);
        for (c = 0; c < Qc.length; c++) d = Qc[c], d.blockedOn === a && (d.blockedOn = null);
        for (; 0 < Qc.length && (c = Qc[0], null === c.blockedOn); ) Vc(c), null === c.blockedOn && Qc.shift();
      }
      var cd = ua.ReactCurrentBatchConfig;
      var dd = true;
      function ed(a, b, c, d) {
        var e = C, f = cd.transition;
        cd.transition = null;
        try {
          C = 1, fd(a, b, c, d);
        } finally {
          C = e, cd.transition = f;
        }
      }
      function gd(a, b, c, d) {
        var e = C, f = cd.transition;
        cd.transition = null;
        try {
          C = 4, fd(a, b, c, d);
        } finally {
          C = e, cd.transition = f;
        }
      }
      function fd(a, b, c, d) {
        if (dd) {
          var e = Yc(a, b, c, d);
          if (null === e) hd(a, b, d, id, c), Sc(a, d);
          else if (Uc(e, a, b, c, d)) d.stopPropagation();
          else if (Sc(a, d), b & 4 && -1 < Rc.indexOf(a)) {
            for (; null !== e; ) {
              var f = Cb(e);
              null !== f && Ec(f);
              f = Yc(a, b, c, d);
              null === f && hd(a, b, d, id, c);
              if (f === e) break;
              e = f;
            }
            null !== e && d.stopPropagation();
          } else hd(a, b, d, null, c);
        }
      }
      var id = null;
      function Yc(a, b, c, d) {
        id = null;
        a = xb(d);
        a = Wc(a);
        if (null !== a) if (b = Vb(a), null === b) a = null;
        else if (c = b.tag, 13 === c) {
          a = Wb(b);
          if (null !== a) return a;
          a = null;
        } else if (3 === c) {
          if (b.stateNode.current.memoizedState.isDehydrated) return 3 === b.tag ? b.stateNode.containerInfo : null;
          a = null;
        } else b !== a && (a = null);
        id = a;
        return null;
      }
      function jd(a) {
        switch (a) {
          case "cancel":
          case "click":
          case "close":
          case "contextmenu":
          case "copy":
          case "cut":
          case "auxclick":
          case "dblclick":
          case "dragend":
          case "dragstart":
          case "drop":
          case "focusin":
          case "focusout":
          case "input":
          case "invalid":
          case "keydown":
          case "keypress":
          case "keyup":
          case "mousedown":
          case "mouseup":
          case "paste":
          case "pause":
          case "play":
          case "pointercancel":
          case "pointerdown":
          case "pointerup":
          case "ratechange":
          case "reset":
          case "resize":
          case "seeked":
          case "submit":
          case "touchcancel":
          case "touchend":
          case "touchstart":
          case "volumechange":
          case "change":
          case "selectionchange":
          case "textInput":
          case "compositionstart":
          case "compositionend":
          case "compositionupdate":
          case "beforeblur":
          case "afterblur":
          case "beforeinput":
          case "blur":
          case "fullscreenchange":
          case "focus":
          case "hashchange":
          case "popstate":
          case "select":
          case "selectstart":
            return 1;
          case "drag":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "mousemove":
          case "mouseout":
          case "mouseover":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "scroll":
          case "toggle":
          case "touchmove":
          case "wheel":
          case "mouseenter":
          case "mouseleave":
          case "pointerenter":
          case "pointerleave":
            return 4;
          case "message":
            switch (ec()) {
              case fc:
                return 1;
              case gc:
                return 4;
              case hc:
              case ic:
                return 16;
              case jc:
                return 536870912;
              default:
                return 16;
            }
          default:
            return 16;
        }
      }
      var kd = null;
      var ld = null;
      var md = null;
      function nd() {
        if (md) return md;
        var a, b = ld, c = b.length, d, e = "value" in kd ? kd.value : kd.textContent, f = e.length;
        for (a = 0; a < c && b[a] === e[a]; a++) ;
        var g = c - a;
        for (d = 1; d <= g && b[c - d] === e[f - d]; d++) ;
        return md = e.slice(a, 1 < d ? 1 - d : void 0);
      }
      function od(a) {
        var b = a.keyCode;
        "charCode" in a ? (a = a.charCode, 0 === a && 13 === b && (a = 13)) : a = b;
        10 === a && (a = 13);
        return 32 <= a || 13 === a ? a : 0;
      }
      function pd() {
        return true;
      }
      function qd() {
        return false;
      }
      function rd(a) {
        function b(b2, d, e, f, g) {
          this._reactName = b2;
          this._targetInst = e;
          this.type = d;
          this.nativeEvent = f;
          this.target = g;
          this.currentTarget = null;
          for (var c in a) a.hasOwnProperty(c) && (b2 = a[c], this[c] = b2 ? b2(f) : f[c]);
          this.isDefaultPrevented = (null != f.defaultPrevented ? f.defaultPrevented : false === f.returnValue) ? pd : qd;
          this.isPropagationStopped = qd;
          return this;
        }
        A(b.prototype, { preventDefault: function() {
          this.defaultPrevented = true;
          var a2 = this.nativeEvent;
          a2 && (a2.preventDefault ? a2.preventDefault() : "unknown" !== typeof a2.returnValue && (a2.returnValue = false), this.isDefaultPrevented = pd);
        }, stopPropagation: function() {
          var a2 = this.nativeEvent;
          a2 && (a2.stopPropagation ? a2.stopPropagation() : "unknown" !== typeof a2.cancelBubble && (a2.cancelBubble = true), this.isPropagationStopped = pd);
        }, persist: function() {
        }, isPersistent: pd });
        return b;
      }
      var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a) {
        return a.timeStamp || Date.now();
      }, defaultPrevented: 0, isTrusted: 0 };
      var td = rd(sd);
      var ud = A({}, sd, { view: 0, detail: 0 });
      var vd = rd(ud);
      var wd;
      var xd;
      var yd;
      var Ad = A({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a) {
        return void 0 === a.relatedTarget ? a.fromElement === a.srcElement ? a.toElement : a.fromElement : a.relatedTarget;
      }, movementX: function(a) {
        if ("movementX" in a) return a.movementX;
        a !== yd && (yd && "mousemove" === a.type ? (wd = a.screenX - yd.screenX, xd = a.screenY - yd.screenY) : xd = wd = 0, yd = a);
        return wd;
      }, movementY: function(a) {
        return "movementY" in a ? a.movementY : xd;
      } });
      var Bd = rd(Ad);
      var Cd = A({}, Ad, { dataTransfer: 0 });
      var Dd = rd(Cd);
      var Ed = A({}, ud, { relatedTarget: 0 });
      var Fd = rd(Ed);
      var Gd = A({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 });
      var Hd = rd(Gd);
      var Id = A({}, sd, { clipboardData: function(a) {
        return "clipboardData" in a ? a.clipboardData : window.clipboardData;
      } });
      var Jd = rd(Id);
      var Kd = A({}, sd, { data: 0 });
      var Ld = rd(Kd);
      var Md = {
        Esc: "Escape",
        Spacebar: " ",
        Left: "ArrowLeft",
        Up: "ArrowUp",
        Right: "ArrowRight",
        Down: "ArrowDown",
        Del: "Delete",
        Win: "OS",
        Menu: "ContextMenu",
        Apps: "ContextMenu",
        Scroll: "ScrollLock",
        MozPrintableKey: "Unidentified"
      };
      var Nd = {
        8: "Backspace",
        9: "Tab",
        12: "Clear",
        13: "Enter",
        16: "Shift",
        17: "Control",
        18: "Alt",
        19: "Pause",
        20: "CapsLock",
        27: "Escape",
        32: " ",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "ArrowLeft",
        38: "ArrowUp",
        39: "ArrowRight",
        40: "ArrowDown",
        45: "Insert",
        46: "Delete",
        112: "F1",
        113: "F2",
        114: "F3",
        115: "F4",
        116: "F5",
        117: "F6",
        118: "F7",
        119: "F8",
        120: "F9",
        121: "F10",
        122: "F11",
        123: "F12",
        144: "NumLock",
        145: "ScrollLock",
        224: "Meta"
      };
      var Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
      function Pd(a) {
        var b = this.nativeEvent;
        return b.getModifierState ? b.getModifierState(a) : (a = Od[a]) ? !!b[a] : false;
      }
      function zd() {
        return Pd;
      }
      var Qd = A({}, ud, { key: function(a) {
        if (a.key) {
          var b = Md[a.key] || a.key;
          if ("Unidentified" !== b) return b;
        }
        return "keypress" === a.type ? (a = od(a), 13 === a ? "Enter" : String.fromCharCode(a)) : "keydown" === a.type || "keyup" === a.type ? Nd[a.keyCode] || "Unidentified" : "";
      }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a) {
        return "keypress" === a.type ? od(a) : 0;
      }, keyCode: function(a) {
        return "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
      }, which: function(a) {
        return "keypress" === a.type ? od(a) : "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
      } });
      var Rd = rd(Qd);
      var Sd = A({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 });
      var Td = rd(Sd);
      var Ud = A({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd });
      var Vd = rd(Ud);
      var Wd = A({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 });
      var Xd = rd(Wd);
      var Yd = A({}, Ad, {
        deltaX: function(a) {
          return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
        },
        deltaY: function(a) {
          return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
        },
        deltaZ: 0,
        deltaMode: 0
      });
      var Zd = rd(Yd);
      var $d = [9, 13, 27, 32];
      var ae = ia && "CompositionEvent" in window;
      var be = null;
      ia && "documentMode" in document && (be = document.documentMode);
      var ce = ia && "TextEvent" in window && !be;
      var de = ia && (!ae || be && 8 < be && 11 >= be);
      var ee = String.fromCharCode(32);
      var fe = false;
      function ge(a, b) {
        switch (a) {
          case "keyup":
            return -1 !== $d.indexOf(b.keyCode);
          case "keydown":
            return 229 !== b.keyCode;
          case "keypress":
          case "mousedown":
          case "focusout":
            return true;
          default:
            return false;
        }
      }
      function he(a) {
        a = a.detail;
        return "object" === typeof a && "data" in a ? a.data : null;
      }
      var ie = false;
      function je(a, b) {
        switch (a) {
          case "compositionend":
            return he(b);
          case "keypress":
            if (32 !== b.which) return null;
            fe = true;
            return ee;
          case "textInput":
            return a = b.data, a === ee && fe ? null : a;
          default:
            return null;
        }
      }
      function ke(a, b) {
        if (ie) return "compositionend" === a || !ae && ge(a, b) ? (a = nd(), md = ld = kd = null, ie = false, a) : null;
        switch (a) {
          case "paste":
            return null;
          case "keypress":
            if (!(b.ctrlKey || b.altKey || b.metaKey) || b.ctrlKey && b.altKey) {
              if (b.char && 1 < b.char.length) return b.char;
              if (b.which) return String.fromCharCode(b.which);
            }
            return null;
          case "compositionend":
            return de && "ko" !== b.locale ? null : b.data;
          default:
            return null;
        }
      }
      var le = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
      function me(a) {
        var b = a && a.nodeName && a.nodeName.toLowerCase();
        return "input" === b ? !!le[a.type] : "textarea" === b ? true : false;
      }
      function ne(a, b, c, d) {
        Eb(d);
        b = oe(b, "onChange");
        0 < b.length && (c = new td("onChange", "change", null, c, d), a.push({ event: c, listeners: b }));
      }
      var pe = null;
      var qe = null;
      function re(a) {
        se(a, 0);
      }
      function te(a) {
        var b = ue(a);
        if (Wa(b)) return a;
      }
      function ve(a, b) {
        if ("change" === a) return b;
      }
      var we = false;
      if (ia) {
        if (ia) {
          ye = "oninput" in document;
          if (!ye) {
            ze = document.createElement("div");
            ze.setAttribute("oninput", "return;");
            ye = "function" === typeof ze.oninput;
          }
          xe = ye;
        } else xe = false;
        we = xe && (!document.documentMode || 9 < document.documentMode);
      }
      var xe;
      var ye;
      var ze;
      function Ae() {
        pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
      }
      function Be(a) {
        if ("value" === a.propertyName && te(qe)) {
          var b = [];
          ne(b, qe, a, xb(a));
          Jb(re, b);
        }
      }
      function Ce(a, b, c) {
        "focusin" === a ? (Ae(), pe = b, qe = c, pe.attachEvent("onpropertychange", Be)) : "focusout" === a && Ae();
      }
      function De(a) {
        if ("selectionchange" === a || "keyup" === a || "keydown" === a) return te(qe);
      }
      function Ee(a, b) {
        if ("click" === a) return te(b);
      }
      function Fe(a, b) {
        if ("input" === a || "change" === a) return te(b);
      }
      function Ge(a, b) {
        return a === b && (0 !== a || 1 / a === 1 / b) || a !== a && b !== b;
      }
      var He = "function" === typeof Object.is ? Object.is : Ge;
      function Ie(a, b) {
        if (He(a, b)) return true;
        if ("object" !== typeof a || null === a || "object" !== typeof b || null === b) return false;
        var c = Object.keys(a), d = Object.keys(b);
        if (c.length !== d.length) return false;
        for (d = 0; d < c.length; d++) {
          var e = c[d];
          if (!ja.call(b, e) || !He(a[e], b[e])) return false;
        }
        return true;
      }
      function Je(a) {
        for (; a && a.firstChild; ) a = a.firstChild;
        return a;
      }
      function Ke(a, b) {
        var c = Je(a);
        a = 0;
        for (var d; c; ) {
          if (3 === c.nodeType) {
            d = a + c.textContent.length;
            if (a <= b && d >= b) return { node: c, offset: b - a };
            a = d;
          }
          a: {
            for (; c; ) {
              if (c.nextSibling) {
                c = c.nextSibling;
                break a;
              }
              c = c.parentNode;
            }
            c = void 0;
          }
          c = Je(c);
        }
      }
      function Le(a, b) {
        return a && b ? a === b ? true : a && 3 === a.nodeType ? false : b && 3 === b.nodeType ? Le(a, b.parentNode) : "contains" in a ? a.contains(b) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(b) & 16) : false : false;
      }
      function Me() {
        for (var a = window, b = Xa(); b instanceof a.HTMLIFrameElement; ) {
          try {
            var c = "string" === typeof b.contentWindow.location.href;
          } catch (d) {
            c = false;
          }
          if (c) a = b.contentWindow;
          else break;
          b = Xa(a.document);
        }
        return b;
      }
      function Ne(a) {
        var b = a && a.nodeName && a.nodeName.toLowerCase();
        return b && ("input" === b && ("text" === a.type || "search" === a.type || "tel" === a.type || "url" === a.type || "password" === a.type) || "textarea" === b || "true" === a.contentEditable);
      }
      function Oe(a) {
        var b = Me(), c = a.focusedElem, d = a.selectionRange;
        if (b !== c && c && c.ownerDocument && Le(c.ownerDocument.documentElement, c)) {
          if (null !== d && Ne(c)) {
            if (b = d.start, a = d.end, void 0 === a && (a = b), "selectionStart" in c) c.selectionStart = b, c.selectionEnd = Math.min(a, c.value.length);
            else if (a = (b = c.ownerDocument || document) && b.defaultView || window, a.getSelection) {
              a = a.getSelection();
              var e = c.textContent.length, f = Math.min(d.start, e);
              d = void 0 === d.end ? f : Math.min(d.end, e);
              !a.extend && f > d && (e = d, d = f, f = e);
              e = Ke(c, f);
              var g = Ke(
                c,
                d
              );
              e && g && (1 !== a.rangeCount || a.anchorNode !== e.node || a.anchorOffset !== e.offset || a.focusNode !== g.node || a.focusOffset !== g.offset) && (b = b.createRange(), b.setStart(e.node, e.offset), a.removeAllRanges(), f > d ? (a.addRange(b), a.extend(g.node, g.offset)) : (b.setEnd(g.node, g.offset), a.addRange(b)));
            }
          }
          b = [];
          for (a = c; a = a.parentNode; ) 1 === a.nodeType && b.push({ element: a, left: a.scrollLeft, top: a.scrollTop });
          "function" === typeof c.focus && c.focus();
          for (c = 0; c < b.length; c++) a = b[c], a.element.scrollLeft = a.left, a.element.scrollTop = a.top;
        }
      }
      var Pe = ia && "documentMode" in document && 11 >= document.documentMode;
      var Qe = null;
      var Re = null;
      var Se = null;
      var Te = false;
      function Ue(a, b, c) {
        var d = c.window === c ? c.document : 9 === c.nodeType ? c : c.ownerDocument;
        Te || null == Qe || Qe !== Xa(d) || (d = Qe, "selectionStart" in d && Ne(d) ? d = { start: d.selectionStart, end: d.selectionEnd } : (d = (d.ownerDocument && d.ownerDocument.defaultView || window).getSelection(), d = { anchorNode: d.anchorNode, anchorOffset: d.anchorOffset, focusNode: d.focusNode, focusOffset: d.focusOffset }), Se && Ie(Se, d) || (Se = d, d = oe(Re, "onSelect"), 0 < d.length && (b = new td("onSelect", "select", null, b, c), a.push({ event: b, listeners: d }), b.target = Qe)));
      }
      function Ve(a, b) {
        var c = {};
        c[a.toLowerCase()] = b.toLowerCase();
        c["Webkit" + a] = "webkit" + b;
        c["Moz" + a] = "moz" + b;
        return c;
      }
      var We = { animationend: Ve("Animation", "AnimationEnd"), animationiteration: Ve("Animation", "AnimationIteration"), animationstart: Ve("Animation", "AnimationStart"), transitionend: Ve("Transition", "TransitionEnd") };
      var Xe = {};
      var Ye = {};
      ia && (Ye = document.createElement("div").style, "AnimationEvent" in window || (delete We.animationend.animation, delete We.animationiteration.animation, delete We.animationstart.animation), "TransitionEvent" in window || delete We.transitionend.transition);
      function Ze(a) {
        if (Xe[a]) return Xe[a];
        if (!We[a]) return a;
        var b = We[a], c;
        for (c in b) if (b.hasOwnProperty(c) && c in Ye) return Xe[a] = b[c];
        return a;
      }
      var $e = Ze("animationend");
      var af = Ze("animationiteration");
      var bf = Ze("animationstart");
      var cf = Ze("transitionend");
      var df = /* @__PURE__ */ new Map();
      var ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
      function ff(a, b) {
        df.set(a, b);
        fa(b, [a]);
      }
      for (gf = 0; gf < ef.length; gf++) {
        hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
        ff(jf, "on" + kf);
      }
      var hf;
      var jf;
      var kf;
      var gf;
      ff($e, "onAnimationEnd");
      ff(af, "onAnimationIteration");
      ff(bf, "onAnimationStart");
      ff("dblclick", "onDoubleClick");
      ff("focusin", "onFocus");
      ff("focusout", "onBlur");
      ff(cf, "onTransitionEnd");
      ha("onMouseEnter", ["mouseout", "mouseover"]);
      ha("onMouseLeave", ["mouseout", "mouseover"]);
      ha("onPointerEnter", ["pointerout", "pointerover"]);
      ha("onPointerLeave", ["pointerout", "pointerover"]);
      fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
      fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
      fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
      fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
      fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
      fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
      var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" ");
      var mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
      function nf(a, b, c) {
        var d = a.type || "unknown-event";
        a.currentTarget = c;
        Ub(d, b, void 0, a);
        a.currentTarget = null;
      }
      function se(a, b) {
        b = 0 !== (b & 4);
        for (var c = 0; c < a.length; c++) {
          var d = a[c], e = d.event;
          d = d.listeners;
          a: {
            var f = void 0;
            if (b) for (var g = d.length - 1; 0 <= g; g--) {
              var h = d[g], k = h.instance, l = h.currentTarget;
              h = h.listener;
              if (k !== f && e.isPropagationStopped()) break a;
              nf(e, h, l);
              f = k;
            }
            else for (g = 0; g < d.length; g++) {
              h = d[g];
              k = h.instance;
              l = h.currentTarget;
              h = h.listener;
              if (k !== f && e.isPropagationStopped()) break a;
              nf(e, h, l);
              f = k;
            }
          }
        }
        if (Qb) throw a = Rb, Qb = false, Rb = null, a;
      }
      function D(a, b) {
        var c = b[of];
        void 0 === c && (c = b[of] = /* @__PURE__ */ new Set());
        var d = a + "__bubble";
        c.has(d) || (pf(b, a, 2, false), c.add(d));
      }
      function qf(a, b, c) {
        var d = 0;
        b && (d |= 4);
        pf(c, a, d, b);
      }
      var rf = "_reactListening" + Math.random().toString(36).slice(2);
      function sf(a) {
        if (!a[rf]) {
          a[rf] = true;
          da.forEach(function(b2) {
            "selectionchange" !== b2 && (mf.has(b2) || qf(b2, false, a), qf(b2, true, a));
          });
          var b = 9 === a.nodeType ? a : a.ownerDocument;
          null === b || b[rf] || (b[rf] = true, qf("selectionchange", false, b));
        }
      }
      function pf(a, b, c, d) {
        switch (jd(b)) {
          case 1:
            var e = ed;
            break;
          case 4:
            e = gd;
            break;
          default:
            e = fd;
        }
        c = e.bind(null, b, c, a);
        e = void 0;
        !Lb || "touchstart" !== b && "touchmove" !== b && "wheel" !== b || (e = true);
        d ? void 0 !== e ? a.addEventListener(b, c, { capture: true, passive: e }) : a.addEventListener(b, c, true) : void 0 !== e ? a.addEventListener(b, c, { passive: e }) : a.addEventListener(b, c, false);
      }
      function hd(a, b, c, d, e) {
        var f = d;
        if (0 === (b & 1) && 0 === (b & 2) && null !== d) a: for (; ; ) {
          if (null === d) return;
          var g = d.tag;
          if (3 === g || 4 === g) {
            var h = d.stateNode.containerInfo;
            if (h === e || 8 === h.nodeType && h.parentNode === e) break;
            if (4 === g) for (g = d.return; null !== g; ) {
              var k = g.tag;
              if (3 === k || 4 === k) {
                if (k = g.stateNode.containerInfo, k === e || 8 === k.nodeType && k.parentNode === e) return;
              }
              g = g.return;
            }
            for (; null !== h; ) {
              g = Wc(h);
              if (null === g) return;
              k = g.tag;
              if (5 === k || 6 === k) {
                d = f = g;
                continue a;
              }
              h = h.parentNode;
            }
          }
          d = d.return;
        }
        Jb(function() {
          var d2 = f, e2 = xb(c), g2 = [];
          a: {
            var h2 = df.get(a);
            if (void 0 !== h2) {
              var k2 = td, n = a;
              switch (a) {
                case "keypress":
                  if (0 === od(c)) break a;
                case "keydown":
                case "keyup":
                  k2 = Rd;
                  break;
                case "focusin":
                  n = "focus";
                  k2 = Fd;
                  break;
                case "focusout":
                  n = "blur";
                  k2 = Fd;
                  break;
                case "beforeblur":
                case "afterblur":
                  k2 = Fd;
                  break;
                case "click":
                  if (2 === c.button) break a;
                case "auxclick":
                case "dblclick":
                case "mousedown":
                case "mousemove":
                case "mouseup":
                case "mouseout":
                case "mouseover":
                case "contextmenu":
                  k2 = Bd;
                  break;
                case "drag":
                case "dragend":
                case "dragenter":
                case "dragexit":
                case "dragleave":
                case "dragover":
                case "dragstart":
                case "drop":
                  k2 = Dd;
                  break;
                case "touchcancel":
                case "touchend":
                case "touchmove":
                case "touchstart":
                  k2 = Vd;
                  break;
                case $e:
                case af:
                case bf:
                  k2 = Hd;
                  break;
                case cf:
                  k2 = Xd;
                  break;
                case "scroll":
                  k2 = vd;
                  break;
                case "wheel":
                  k2 = Zd;
                  break;
                case "copy":
                case "cut":
                case "paste":
                  k2 = Jd;
                  break;
                case "gotpointercapture":
                case "lostpointercapture":
                case "pointercancel":
                case "pointerdown":
                case "pointermove":
                case "pointerout":
                case "pointerover":
                case "pointerup":
                  k2 = Td;
              }
              var t = 0 !== (b & 4), J = !t && "scroll" === a, x = t ? null !== h2 ? h2 + "Capture" : null : h2;
              t = [];
              for (var w2 = d2, u; null !== w2; ) {
                u = w2;
                var F = u.stateNode;
                5 === u.tag && null !== F && (u = F, null !== x && (F = Kb(w2, x), null != F && t.push(tf(w2, F, u))));
                if (J) break;
                w2 = w2.return;
              }
              0 < t.length && (h2 = new k2(h2, n, null, c, e2), g2.push({ event: h2, listeners: t }));
            }
          }
          if (0 === (b & 7)) {
            a: {
              h2 = "mouseover" === a || "pointerover" === a;
              k2 = "mouseout" === a || "pointerout" === a;
              if (h2 && c !== wb && (n = c.relatedTarget || c.fromElement) && (Wc(n) || n[uf])) break a;
              if (k2 || h2) {
                h2 = e2.window === e2 ? e2 : (h2 = e2.ownerDocument) ? h2.defaultView || h2.parentWindow : window;
                if (k2) {
                  if (n = c.relatedTarget || c.toElement, k2 = d2, n = n ? Wc(n) : null, null !== n && (J = Vb(n), n !== J || 5 !== n.tag && 6 !== n.tag)) n = null;
                } else k2 = null, n = d2;
                if (k2 !== n) {
                  t = Bd;
                  F = "onMouseLeave";
                  x = "onMouseEnter";
                  w2 = "mouse";
                  if ("pointerout" === a || "pointerover" === a) t = Td, F = "onPointerLeave", x = "onPointerEnter", w2 = "pointer";
                  J = null == k2 ? h2 : ue(k2);
                  u = null == n ? h2 : ue(n);
                  h2 = new t(F, w2 + "leave", k2, c, e2);
                  h2.target = J;
                  h2.relatedTarget = u;
                  F = null;
                  Wc(e2) === d2 && (t = new t(x, w2 + "enter", n, c, e2), t.target = u, t.relatedTarget = J, F = t);
                  J = F;
                  if (k2 && n) b: {
                    t = k2;
                    x = n;
                    w2 = 0;
                    for (u = t; u; u = vf(u)) w2++;
                    u = 0;
                    for (F = x; F; F = vf(F)) u++;
                    for (; 0 < w2 - u; ) t = vf(t), w2--;
                    for (; 0 < u - w2; ) x = vf(x), u--;
                    for (; w2--; ) {
                      if (t === x || null !== x && t === x.alternate) break b;
                      t = vf(t);
                      x = vf(x);
                    }
                    t = null;
                  }
                  else t = null;
                  null !== k2 && wf(g2, h2, k2, t, false);
                  null !== n && null !== J && wf(g2, J, n, t, true);
                }
              }
            }
            a: {
              h2 = d2 ? ue(d2) : window;
              k2 = h2.nodeName && h2.nodeName.toLowerCase();
              if ("select" === k2 || "input" === k2 && "file" === h2.type) var na = ve;
              else if (me(h2)) if (we) na = Fe;
              else {
                na = De;
                var xa = Ce;
              }
              else (k2 = h2.nodeName) && "input" === k2.toLowerCase() && ("checkbox" === h2.type || "radio" === h2.type) && (na = Ee);
              if (na && (na = na(a, d2))) {
                ne(g2, na, c, e2);
                break a;
              }
              xa && xa(a, h2, d2);
              "focusout" === a && (xa = h2._wrapperState) && xa.controlled && "number" === h2.type && cb(h2, "number", h2.value);
            }
            xa = d2 ? ue(d2) : window;
            switch (a) {
              case "focusin":
                if (me(xa) || "true" === xa.contentEditable) Qe = xa, Re = d2, Se = null;
                break;
              case "focusout":
                Se = Re = Qe = null;
                break;
              case "mousedown":
                Te = true;
                break;
              case "contextmenu":
              case "mouseup":
              case "dragend":
                Te = false;
                Ue(g2, c, e2);
                break;
              case "selectionchange":
                if (Pe) break;
              case "keydown":
              case "keyup":
                Ue(g2, c, e2);
            }
            var $a;
            if (ae) b: {
              switch (a) {
                case "compositionstart":
                  var ba = "onCompositionStart";
                  break b;
                case "compositionend":
                  ba = "onCompositionEnd";
                  break b;
                case "compositionupdate":
                  ba = "onCompositionUpdate";
                  break b;
              }
              ba = void 0;
            }
            else ie ? ge(a, c) && (ba = "onCompositionEnd") : "keydown" === a && 229 === c.keyCode && (ba = "onCompositionStart");
            ba && (de && "ko" !== c.locale && (ie || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie && ($a = nd()) : (kd = e2, ld = "value" in kd ? kd.value : kd.textContent, ie = true)), xa = oe(d2, ba), 0 < xa.length && (ba = new Ld(ba, a, null, c, e2), g2.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he(c), null !== $a && (ba.data = $a))));
            if ($a = ce ? je(a, c) : ke(a, c)) d2 = oe(d2, "onBeforeInput"), 0 < d2.length && (e2 = new Ld("onBeforeInput", "beforeinput", null, c, e2), g2.push({ event: e2, listeners: d2 }), e2.data = $a);
          }
          se(g2, b);
        });
      }
      function tf(a, b, c) {
        return { instance: a, listener: b, currentTarget: c };
      }
      function oe(a, b) {
        for (var c = b + "Capture", d = []; null !== a; ) {
          var e = a, f = e.stateNode;
          5 === e.tag && null !== f && (e = f, f = Kb(a, c), null != f && d.unshift(tf(a, f, e)), f = Kb(a, b), null != f && d.push(tf(a, f, e)));
          a = a.return;
        }
        return d;
      }
      function vf(a) {
        if (null === a) return null;
        do
          a = a.return;
        while (a && 5 !== a.tag);
        return a ? a : null;
      }
      function wf(a, b, c, d, e) {
        for (var f = b._reactName, g = []; null !== c && c !== d; ) {
          var h = c, k = h.alternate, l = h.stateNode;
          if (null !== k && k === d) break;
          5 === h.tag && null !== l && (h = l, e ? (k = Kb(c, f), null != k && g.unshift(tf(c, k, h))) : e || (k = Kb(c, f), null != k && g.push(tf(c, k, h))));
          c = c.return;
        }
        0 !== g.length && a.push({ event: b, listeners: g });
      }
      var xf = /\r\n?/g;
      var yf = /\u0000|\uFFFD/g;
      function zf(a) {
        return ("string" === typeof a ? a : "" + a).replace(xf, "\n").replace(yf, "");
      }
      function Af(a, b, c) {
        b = zf(b);
        if (zf(a) !== b && c) throw Error(p(425));
      }
      function Bf() {
      }
      var Cf = null;
      var Df = null;
      function Ef(a, b) {
        return "textarea" === a || "noscript" === a || "string" === typeof b.children || "number" === typeof b.children || "object" === typeof b.dangerouslySetInnerHTML && null !== b.dangerouslySetInnerHTML && null != b.dangerouslySetInnerHTML.__html;
      }
      var Ff = "function" === typeof setTimeout ? setTimeout : void 0;
      var Gf = "function" === typeof clearTimeout ? clearTimeout : void 0;
      var Hf = "function" === typeof Promise ? Promise : void 0;
      var Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a) {
        return Hf.resolve(null).then(a).catch(If);
      } : Ff;
      function If(a) {
        setTimeout(function() {
          throw a;
        });
      }
      function Kf(a, b) {
        var c = b, d = 0;
        do {
          var e = c.nextSibling;
          a.removeChild(c);
          if (e && 8 === e.nodeType) if (c = e.data, "/$" === c) {
            if (0 === d) {
              a.removeChild(e);
              bd(b);
              return;
            }
            d--;
          } else "$" !== c && "$?" !== c && "$!" !== c || d++;
          c = e;
        } while (c);
        bd(b);
      }
      function Lf(a) {
        for (; null != a; a = a.nextSibling) {
          var b = a.nodeType;
          if (1 === b || 3 === b) break;
          if (8 === b) {
            b = a.data;
            if ("$" === b || "$!" === b || "$?" === b) break;
            if ("/$" === b) return null;
          }
        }
        return a;
      }
      function Mf(a) {
        a = a.previousSibling;
        for (var b = 0; a; ) {
          if (8 === a.nodeType) {
            var c = a.data;
            if ("$" === c || "$!" === c || "$?" === c) {
              if (0 === b) return a;
              b--;
            } else "/$" === c && b++;
          }
          a = a.previousSibling;
        }
        return null;
      }
      var Nf = Math.random().toString(36).slice(2);
      var Of = "__reactFiber$" + Nf;
      var Pf = "__reactProps$" + Nf;
      var uf = "__reactContainer$" + Nf;
      var of = "__reactEvents$" + Nf;
      var Qf = "__reactListeners$" + Nf;
      var Rf = "__reactHandles$" + Nf;
      function Wc(a) {
        var b = a[Of];
        if (b) return b;
        for (var c = a.parentNode; c; ) {
          if (b = c[uf] || c[Of]) {
            c = b.alternate;
            if (null !== b.child || null !== c && null !== c.child) for (a = Mf(a); null !== a; ) {
              if (c = a[Of]) return c;
              a = Mf(a);
            }
            return b;
          }
          a = c;
          c = a.parentNode;
        }
        return null;
      }
      function Cb(a) {
        a = a[Of] || a[uf];
        return !a || 5 !== a.tag && 6 !== a.tag && 13 !== a.tag && 3 !== a.tag ? null : a;
      }
      function ue(a) {
        if (5 === a.tag || 6 === a.tag) return a.stateNode;
        throw Error(p(33));
      }
      function Db(a) {
        return a[Pf] || null;
      }
      var Sf = [];
      var Tf = -1;
      function Uf(a) {
        return { current: a };
      }
      function E(a) {
        0 > Tf || (a.current = Sf[Tf], Sf[Tf] = null, Tf--);
      }
      function G(a, b) {
        Tf++;
        Sf[Tf] = a.current;
        a.current = b;
      }
      var Vf = {};
      var H = Uf(Vf);
      var Wf = Uf(false);
      var Xf = Vf;
      function Yf(a, b) {
        var c = a.type.contextTypes;
        if (!c) return Vf;
        var d = a.stateNode;
        if (d && d.__reactInternalMemoizedUnmaskedChildContext === b) return d.__reactInternalMemoizedMaskedChildContext;
        var e = {}, f;
        for (f in c) e[f] = b[f];
        d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b, a.__reactInternalMemoizedMaskedChildContext = e);
        return e;
      }
      function Zf(a) {
        a = a.childContextTypes;
        return null !== a && void 0 !== a;
      }
      function $f() {
        E(Wf);
        E(H);
      }
      function ag(a, b, c) {
        if (H.current !== Vf) throw Error(p(168));
        G(H, b);
        G(Wf, c);
      }
      function bg(a, b, c) {
        var d = a.stateNode;
        b = b.childContextTypes;
        if ("function" !== typeof d.getChildContext) return c;
        d = d.getChildContext();
        for (var e in d) if (!(e in b)) throw Error(p(108, Ra(a) || "Unknown", e));
        return A({}, c, d);
      }
      function cg(a) {
        a = (a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext || Vf;
        Xf = H.current;
        G(H, a);
        G(Wf, Wf.current);
        return true;
      }
      function dg(a, b, c) {
        var d = a.stateNode;
        if (!d) throw Error(p(169));
        c ? (a = bg(a, b, Xf), d.__reactInternalMemoizedMergedChildContext = a, E(Wf), E(H), G(H, a)) : E(Wf);
        G(Wf, c);
      }
      var eg = null;
      var fg21 = false;
      var gg = false;
      function hg(a) {
        null === eg ? eg = [a] : eg.push(a);
      }
      function ig(a) {
        fg21 = true;
        hg(a);
      }
      function jg() {
        if (!gg && null !== eg) {
          gg = true;
          var a = 0, b = C;
          try {
            var c = eg;
            for (C = 1; a < c.length; a++) {
              var d = c[a];
              do
                d = d(true);
              while (null !== d);
            }
            eg = null;
            fg21 = false;
          } catch (e) {
            throw null !== eg && (eg = eg.slice(a + 1)), ac(fc, jg), e;
          } finally {
            C = b, gg = false;
          }
        }
        return null;
      }
      var kg = [];
      var lg = 0;
      var mg = null;
      var ng = 0;
      var og = [];
      var pg = 0;
      var qg = null;
      var rg = 1;
      var sg = "";
      function tg(a, b) {
        kg[lg++] = ng;
        kg[lg++] = mg;
        mg = a;
        ng = b;
      }
      function ug(a, b, c) {
        og[pg++] = rg;
        og[pg++] = sg;
        og[pg++] = qg;
        qg = a;
        var d = rg;
        a = sg;
        var e = 32 - oc(d) - 1;
        d &= ~(1 << e);
        c += 1;
        var f = 32 - oc(b) + e;
        if (30 < f) {
          var g = e - e % 5;
          f = (d & (1 << g) - 1).toString(32);
          d >>= g;
          e -= g;
          rg = 1 << 32 - oc(b) + e | c << e | d;
          sg = f + a;
        } else rg = 1 << f | c << e | d, sg = a;
      }
      function vg(a) {
        null !== a.return && (tg(a, 1), ug(a, 1, 0));
      }
      function wg(a) {
        for (; a === mg; ) mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
        for (; a === qg; ) qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
      }
      var xg = null;
      var yg = null;
      var I = false;
      var zg = null;
      function Ag(a, b) {
        var c = Bg(5, null, null, 0);
        c.elementType = "DELETED";
        c.stateNode = b;
        c.return = a;
        b = a.deletions;
        null === b ? (a.deletions = [c], a.flags |= 16) : b.push(c);
      }
      function Cg(a, b) {
        switch (a.tag) {
          case 5:
            var c = a.type;
            b = 1 !== b.nodeType || c.toLowerCase() !== b.nodeName.toLowerCase() ? null : b;
            return null !== b ? (a.stateNode = b, xg = a, yg = Lf(b.firstChild), true) : false;
          case 6:
            return b = "" === a.pendingProps || 3 !== b.nodeType ? null : b, null !== b ? (a.stateNode = b, xg = a, yg = null, true) : false;
          case 13:
            return b = 8 !== b.nodeType ? null : b, null !== b ? (c = null !== qg ? { id: rg, overflow: sg } : null, a.memoizedState = { dehydrated: b, treeContext: c, retryLane: 1073741824 }, c = Bg(18, null, null, 0), c.stateNode = b, c.return = a, a.child = c, xg = a, yg = null, true) : false;
          default:
            return false;
        }
      }
      function Dg(a) {
        return 0 !== (a.mode & 1) && 0 === (a.flags & 128);
      }
      function Eg(a) {
        if (I) {
          var b = yg;
          if (b) {
            var c = b;
            if (!Cg(a, b)) {
              if (Dg(a)) throw Error(p(418));
              b = Lf(c.nextSibling);
              var d = xg;
              b && Cg(a, b) ? Ag(d, c) : (a.flags = a.flags & -4097 | 2, I = false, xg = a);
            }
          } else {
            if (Dg(a)) throw Error(p(418));
            a.flags = a.flags & -4097 | 2;
            I = false;
            xg = a;
          }
        }
      }
      function Fg(a) {
        for (a = a.return; null !== a && 5 !== a.tag && 3 !== a.tag && 13 !== a.tag; ) a = a.return;
        xg = a;
      }
      function Gg(a) {
        if (a !== xg) return false;
        if (!I) return Fg(a), I = true, false;
        var b;
        (b = 3 !== a.tag) && !(b = 5 !== a.tag) && (b = a.type, b = "head" !== b && "body" !== b && !Ef(a.type, a.memoizedProps));
        if (b && (b = yg)) {
          if (Dg(a)) throw Hg(), Error(p(418));
          for (; b; ) Ag(a, b), b = Lf(b.nextSibling);
        }
        Fg(a);
        if (13 === a.tag) {
          a = a.memoizedState;
          a = null !== a ? a.dehydrated : null;
          if (!a) throw Error(p(317));
          a: {
            a = a.nextSibling;
            for (b = 0; a; ) {
              if (8 === a.nodeType) {
                var c = a.data;
                if ("/$" === c) {
                  if (0 === b) {
                    yg = Lf(a.nextSibling);
                    break a;
                  }
                  b--;
                } else "$" !== c && "$!" !== c && "$?" !== c || b++;
              }
              a = a.nextSibling;
            }
            yg = null;
          }
        } else yg = xg ? Lf(a.stateNode.nextSibling) : null;
        return true;
      }
      function Hg() {
        for (var a = yg; a; ) a = Lf(a.nextSibling);
      }
      function Ig() {
        yg = xg = null;
        I = false;
      }
      function Jg(a) {
        null === zg ? zg = [a] : zg.push(a);
      }
      var Kg = ua.ReactCurrentBatchConfig;
      function Lg(a, b, c) {
        a = c.ref;
        if (null !== a && "function" !== typeof a && "object" !== typeof a) {
          if (c._owner) {
            c = c._owner;
            if (c) {
              if (1 !== c.tag) throw Error(p(309));
              var d = c.stateNode;
            }
            if (!d) throw Error(p(147, a));
            var e = d, f = "" + a;
            if (null !== b && null !== b.ref && "function" === typeof b.ref && b.ref._stringRef === f) return b.ref;
            b = function(a2) {
              var b2 = e.refs;
              null === a2 ? delete b2[f] : b2[f] = a2;
            };
            b._stringRef = f;
            return b;
          }
          if ("string" !== typeof a) throw Error(p(284));
          if (!c._owner) throw Error(p(290, a));
        }
        return a;
      }
      function Mg(a, b) {
        a = Object.prototype.toString.call(b);
        throw Error(p(31, "[object Object]" === a ? "object with keys {" + Object.keys(b).join(", ") + "}" : a));
      }
      function Ng(a) {
        var b = a._init;
        return b(a._payload);
      }
      function Og(a) {
        function b(b2, c2) {
          if (a) {
            var d2 = b2.deletions;
            null === d2 ? (b2.deletions = [c2], b2.flags |= 16) : d2.push(c2);
          }
        }
        function c(c2, d2) {
          if (!a) return null;
          for (; null !== d2; ) b(c2, d2), d2 = d2.sibling;
          return null;
        }
        function d(a2, b2) {
          for (a2 = /* @__PURE__ */ new Map(); null !== b2; ) null !== b2.key ? a2.set(b2.key, b2) : a2.set(b2.index, b2), b2 = b2.sibling;
          return a2;
        }
        function e(a2, b2) {
          a2 = Pg(a2, b2);
          a2.index = 0;
          a2.sibling = null;
          return a2;
        }
        function f(b2, c2, d2) {
          b2.index = d2;
          if (!a) return b2.flags |= 1048576, c2;
          d2 = b2.alternate;
          if (null !== d2) return d2 = d2.index, d2 < c2 ? (b2.flags |= 2, c2) : d2;
          b2.flags |= 2;
          return c2;
        }
        function g(b2) {
          a && null === b2.alternate && (b2.flags |= 2);
          return b2;
        }
        function h(a2, b2, c2, d2) {
          if (null === b2 || 6 !== b2.tag) return b2 = Qg(c2, a2.mode, d2), b2.return = a2, b2;
          b2 = e(b2, c2);
          b2.return = a2;
          return b2;
        }
        function k(a2, b2, c2, d2) {
          var f2 = c2.type;
          if (f2 === ya) return m(a2, b2, c2.props.children, d2, c2.key);
          if (null !== b2 && (b2.elementType === f2 || "object" === typeof f2 && null !== f2 && f2.$$typeof === Ha && Ng(f2) === b2.type)) return d2 = e(b2, c2.props), d2.ref = Lg(a2, b2, c2), d2.return = a2, d2;
          d2 = Rg(c2.type, c2.key, c2.props, null, a2.mode, d2);
          d2.ref = Lg(a2, b2, c2);
          d2.return = a2;
          return d2;
        }
        function l(a2, b2, c2, d2) {
          if (null === b2 || 4 !== b2.tag || b2.stateNode.containerInfo !== c2.containerInfo || b2.stateNode.implementation !== c2.implementation) return b2 = Sg(c2, a2.mode, d2), b2.return = a2, b2;
          b2 = e(b2, c2.children || []);
          b2.return = a2;
          return b2;
        }
        function m(a2, b2, c2, d2, f2) {
          if (null === b2 || 7 !== b2.tag) return b2 = Tg(c2, a2.mode, d2, f2), b2.return = a2, b2;
          b2 = e(b2, c2);
          b2.return = a2;
          return b2;
        }
        function q(a2, b2, c2) {
          if ("string" === typeof b2 && "" !== b2 || "number" === typeof b2) return b2 = Qg("" + b2, a2.mode, c2), b2.return = a2, b2;
          if ("object" === typeof b2 && null !== b2) {
            switch (b2.$$typeof) {
              case va:
                return c2 = Rg(b2.type, b2.key, b2.props, null, a2.mode, c2), c2.ref = Lg(a2, null, b2), c2.return = a2, c2;
              case wa:
                return b2 = Sg(b2, a2.mode, c2), b2.return = a2, b2;
              case Ha:
                var d2 = b2._init;
                return q(a2, d2(b2._payload), c2);
            }
            if (eb(b2) || Ka(b2)) return b2 = Tg(b2, a2.mode, c2, null), b2.return = a2, b2;
            Mg(a2, b2);
          }
          return null;
        }
        function r(a2, b2, c2, d2) {
          var e2 = null !== b2 ? b2.key : null;
          if ("string" === typeof c2 && "" !== c2 || "number" === typeof c2) return null !== e2 ? null : h(a2, b2, "" + c2, d2);
          if ("object" === typeof c2 && null !== c2) {
            switch (c2.$$typeof) {
              case va:
                return c2.key === e2 ? k(a2, b2, c2, d2) : null;
              case wa:
                return c2.key === e2 ? l(a2, b2, c2, d2) : null;
              case Ha:
                return e2 = c2._init, r(
                  a2,
                  b2,
                  e2(c2._payload),
                  d2
                );
            }
            if (eb(c2) || Ka(c2)) return null !== e2 ? null : m(a2, b2, c2, d2, null);
            Mg(a2, c2);
          }
          return null;
        }
        function y(a2, b2, c2, d2, e2) {
          if ("string" === typeof d2 && "" !== d2 || "number" === typeof d2) return a2 = a2.get(c2) || null, h(b2, a2, "" + d2, e2);
          if ("object" === typeof d2 && null !== d2) {
            switch (d2.$$typeof) {
              case va:
                return a2 = a2.get(null === d2.key ? c2 : d2.key) || null, k(b2, a2, d2, e2);
              case wa:
                return a2 = a2.get(null === d2.key ? c2 : d2.key) || null, l(b2, a2, d2, e2);
              case Ha:
                var f2 = d2._init;
                return y(a2, b2, c2, f2(d2._payload), e2);
            }
            if (eb(d2) || Ka(d2)) return a2 = a2.get(c2) || null, m(b2, a2, d2, e2, null);
            Mg(b2, d2);
          }
          return null;
        }
        function n(e2, g2, h2, k2) {
          for (var l2 = null, m2 = null, u = g2, w2 = g2 = 0, x = null; null !== u && w2 < h2.length; w2++) {
            u.index > w2 ? (x = u, u = null) : x = u.sibling;
            var n2 = r(e2, u, h2[w2], k2);
            if (null === n2) {
              null === u && (u = x);
              break;
            }
            a && u && null === n2.alternate && b(e2, u);
            g2 = f(n2, g2, w2);
            null === m2 ? l2 = n2 : m2.sibling = n2;
            m2 = n2;
            u = x;
          }
          if (w2 === h2.length) return c(e2, u), I && tg(e2, w2), l2;
          if (null === u) {
            for (; w2 < h2.length; w2++) u = q(e2, h2[w2], k2), null !== u && (g2 = f(u, g2, w2), null === m2 ? l2 = u : m2.sibling = u, m2 = u);
            I && tg(e2, w2);
            return l2;
          }
          for (u = d(e2, u); w2 < h2.length; w2++) x = y(u, e2, w2, h2[w2], k2), null !== x && (a && null !== x.alternate && u.delete(null === x.key ? w2 : x.key), g2 = f(x, g2, w2), null === m2 ? l2 = x : m2.sibling = x, m2 = x);
          a && u.forEach(function(a2) {
            return b(e2, a2);
          });
          I && tg(e2, w2);
          return l2;
        }
        function t(e2, g2, h2, k2) {
          var l2 = Ka(h2);
          if ("function" !== typeof l2) throw Error(p(150));
          h2 = l2.call(h2);
          if (null == h2) throw Error(p(151));
          for (var u = l2 = null, m2 = g2, w2 = g2 = 0, x = null, n2 = h2.next(); null !== m2 && !n2.done; w2++, n2 = h2.next()) {
            m2.index > w2 ? (x = m2, m2 = null) : x = m2.sibling;
            var t2 = r(e2, m2, n2.value, k2);
            if (null === t2) {
              null === m2 && (m2 = x);
              break;
            }
            a && m2 && null === t2.alternate && b(e2, m2);
            g2 = f(t2, g2, w2);
            null === u ? l2 = t2 : u.sibling = t2;
            u = t2;
            m2 = x;
          }
          if (n2.done) return c(
            e2,
            m2
          ), I && tg(e2, w2), l2;
          if (null === m2) {
            for (; !n2.done; w2++, n2 = h2.next()) n2 = q(e2, n2.value, k2), null !== n2 && (g2 = f(n2, g2, w2), null === u ? l2 = n2 : u.sibling = n2, u = n2);
            I && tg(e2, w2);
            return l2;
          }
          for (m2 = d(e2, m2); !n2.done; w2++, n2 = h2.next()) n2 = y(m2, e2, w2, n2.value, k2), null !== n2 && (a && null !== n2.alternate && m2.delete(null === n2.key ? w2 : n2.key), g2 = f(n2, g2, w2), null === u ? l2 = n2 : u.sibling = n2, u = n2);
          a && m2.forEach(function(a2) {
            return b(e2, a2);
          });
          I && tg(e2, w2);
          return l2;
        }
        function J(a2, d2, f2, h2) {
          "object" === typeof f2 && null !== f2 && f2.type === ya && null === f2.key && (f2 = f2.props.children);
          if ("object" === typeof f2 && null !== f2) {
            switch (f2.$$typeof) {
              case va:
                a: {
                  for (var k2 = f2.key, l2 = d2; null !== l2; ) {
                    if (l2.key === k2) {
                      k2 = f2.type;
                      if (k2 === ya) {
                        if (7 === l2.tag) {
                          c(a2, l2.sibling);
                          d2 = e(l2, f2.props.children);
                          d2.return = a2;
                          a2 = d2;
                          break a;
                        }
                      } else if (l2.elementType === k2 || "object" === typeof k2 && null !== k2 && k2.$$typeof === Ha && Ng(k2) === l2.type) {
                        c(a2, l2.sibling);
                        d2 = e(l2, f2.props);
                        d2.ref = Lg(a2, l2, f2);
                        d2.return = a2;
                        a2 = d2;
                        break a;
                      }
                      c(a2, l2);
                      break;
                    } else b(a2, l2);
                    l2 = l2.sibling;
                  }
                  f2.type === ya ? (d2 = Tg(f2.props.children, a2.mode, h2, f2.key), d2.return = a2, a2 = d2) : (h2 = Rg(f2.type, f2.key, f2.props, null, a2.mode, h2), h2.ref = Lg(a2, d2, f2), h2.return = a2, a2 = h2);
                }
                return g(a2);
              case wa:
                a: {
                  for (l2 = f2.key; null !== d2; ) {
                    if (d2.key === l2) if (4 === d2.tag && d2.stateNode.containerInfo === f2.containerInfo && d2.stateNode.implementation === f2.implementation) {
                      c(a2, d2.sibling);
                      d2 = e(d2, f2.children || []);
                      d2.return = a2;
                      a2 = d2;
                      break a;
                    } else {
                      c(a2, d2);
                      break;
                    }
                    else b(a2, d2);
                    d2 = d2.sibling;
                  }
                  d2 = Sg(f2, a2.mode, h2);
                  d2.return = a2;
                  a2 = d2;
                }
                return g(a2);
              case Ha:
                return l2 = f2._init, J(a2, d2, l2(f2._payload), h2);
            }
            if (eb(f2)) return n(a2, d2, f2, h2);
            if (Ka(f2)) return t(a2, d2, f2, h2);
            Mg(a2, f2);
          }
          return "string" === typeof f2 && "" !== f2 || "number" === typeof f2 ? (f2 = "" + f2, null !== d2 && 6 === d2.tag ? (c(a2, d2.sibling), d2 = e(d2, f2), d2.return = a2, a2 = d2) : (c(a2, d2), d2 = Qg(f2, a2.mode, h2), d2.return = a2, a2 = d2), g(a2)) : c(a2, d2);
        }
        return J;
      }
      var Ug = Og(true);
      var Vg = Og(false);
      var Wg = Uf(null);
      var Xg = null;
      var Yg = null;
      var Zg = null;
      function $g() {
        Zg = Yg = Xg = null;
      }
      function ah(a) {
        var b = Wg.current;
        E(Wg);
        a._currentValue = b;
      }
      function bh(a, b, c) {
        for (; null !== a; ) {
          var d = a.alternate;
          (a.childLanes & b) !== b ? (a.childLanes |= b, null !== d && (d.childLanes |= b)) : null !== d && (d.childLanes & b) !== b && (d.childLanes |= b);
          if (a === c) break;
          a = a.return;
        }
      }
      function ch(a, b) {
        Xg = a;
        Zg = Yg = null;
        a = a.dependencies;
        null !== a && null !== a.firstContext && (0 !== (a.lanes & b) && (dh = true), a.firstContext = null);
      }
      function eh(a) {
        var b = a._currentValue;
        if (Zg !== a) if (a = { context: a, memoizedValue: b, next: null }, null === Yg) {
          if (null === Xg) throw Error(p(308));
          Yg = a;
          Xg.dependencies = { lanes: 0, firstContext: a };
        } else Yg = Yg.next = a;
        return b;
      }
      var fh = null;
      function gh(a) {
        null === fh ? fh = [a] : fh.push(a);
      }
      function hh(a, b, c, d) {
        var e = b.interleaved;
        null === e ? (c.next = c, gh(b)) : (c.next = e.next, e.next = c);
        b.interleaved = c;
        return ih(a, d);
      }
      function ih(a, b) {
        a.lanes |= b;
        var c = a.alternate;
        null !== c && (c.lanes |= b);
        c = a;
        for (a = a.return; null !== a; ) a.childLanes |= b, c = a.alternate, null !== c && (c.childLanes |= b), c = a, a = a.return;
        return 3 === c.tag ? c.stateNode : null;
      }
      var jh = false;
      function kh(a) {
        a.updateQueue = { baseState: a.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
      }
      function lh(a, b) {
        a = a.updateQueue;
        b.updateQueue === a && (b.updateQueue = { baseState: a.baseState, firstBaseUpdate: a.firstBaseUpdate, lastBaseUpdate: a.lastBaseUpdate, shared: a.shared, effects: a.effects });
      }
      function mh(a, b) {
        return { eventTime: a, lane: b, tag: 0, payload: null, callback: null, next: null };
      }
      function nh(a, b, c) {
        var d = a.updateQueue;
        if (null === d) return null;
        d = d.shared;
        if (0 !== (K & 2)) {
          var e = d.pending;
          null === e ? b.next = b : (b.next = e.next, e.next = b);
          d.pending = b;
          return ih(a, c);
        }
        e = d.interleaved;
        null === e ? (b.next = b, gh(d)) : (b.next = e.next, e.next = b);
        d.interleaved = b;
        return ih(a, c);
      }
      function oh(a, b, c) {
        b = b.updateQueue;
        if (null !== b && (b = b.shared, 0 !== (c & 4194240))) {
          var d = b.lanes;
          d &= a.pendingLanes;
          c |= d;
          b.lanes = c;
          Cc(a, c);
        }
      }
      function ph(a, b) {
        var c = a.updateQueue, d = a.alternate;
        if (null !== d && (d = d.updateQueue, c === d)) {
          var e = null, f = null;
          c = c.firstBaseUpdate;
          if (null !== c) {
            do {
              var g = { eventTime: c.eventTime, lane: c.lane, tag: c.tag, payload: c.payload, callback: c.callback, next: null };
              null === f ? e = f = g : f = f.next = g;
              c = c.next;
            } while (null !== c);
            null === f ? e = f = b : f = f.next = b;
          } else e = f = b;
          c = { baseState: d.baseState, firstBaseUpdate: e, lastBaseUpdate: f, shared: d.shared, effects: d.effects };
          a.updateQueue = c;
          return;
        }
        a = c.lastBaseUpdate;
        null === a ? c.firstBaseUpdate = b : a.next = b;
        c.lastBaseUpdate = b;
      }
      function qh(a, b, c, d) {
        var e = a.updateQueue;
        jh = false;
        var f = e.firstBaseUpdate, g = e.lastBaseUpdate, h = e.shared.pending;
        if (null !== h) {
          e.shared.pending = null;
          var k = h, l = k.next;
          k.next = null;
          null === g ? f = l : g.next = l;
          g = k;
          var m = a.alternate;
          null !== m && (m = m.updateQueue, h = m.lastBaseUpdate, h !== g && (null === h ? m.firstBaseUpdate = l : h.next = l, m.lastBaseUpdate = k));
        }
        if (null !== f) {
          var q = e.baseState;
          g = 0;
          m = l = k = null;
          h = f;
          do {
            var r = h.lane, y = h.eventTime;
            if ((d & r) === r) {
              null !== m && (m = m.next = {
                eventTime: y,
                lane: 0,
                tag: h.tag,
                payload: h.payload,
                callback: h.callback,
                next: null
              });
              a: {
                var n = a, t = h;
                r = b;
                y = c;
                switch (t.tag) {
                  case 1:
                    n = t.payload;
                    if ("function" === typeof n) {
                      q = n.call(y, q, r);
                      break a;
                    }
                    q = n;
                    break a;
                  case 3:
                    n.flags = n.flags & -65537 | 128;
                  case 0:
                    n = t.payload;
                    r = "function" === typeof n ? n.call(y, q, r) : n;
                    if (null === r || void 0 === r) break a;
                    q = A({}, q, r);
                    break a;
                  case 2:
                    jh = true;
                }
              }
              null !== h.callback && 0 !== h.lane && (a.flags |= 64, r = e.effects, null === r ? e.effects = [h] : r.push(h));
            } else y = { eventTime: y, lane: r, tag: h.tag, payload: h.payload, callback: h.callback, next: null }, null === m ? (l = m = y, k = q) : m = m.next = y, g |= r;
            h = h.next;
            if (null === h) if (h = e.shared.pending, null === h) break;
            else r = h, h = r.next, r.next = null, e.lastBaseUpdate = r, e.shared.pending = null;
          } while (1);
          null === m && (k = q);
          e.baseState = k;
          e.firstBaseUpdate = l;
          e.lastBaseUpdate = m;
          b = e.shared.interleaved;
          if (null !== b) {
            e = b;
            do
              g |= e.lane, e = e.next;
            while (e !== b);
          } else null === f && (e.shared.lanes = 0);
          rh |= g;
          a.lanes = g;
          a.memoizedState = q;
        }
      }
      function sh(a, b, c) {
        a = b.effects;
        b.effects = null;
        if (null !== a) for (b = 0; b < a.length; b++) {
          var d = a[b], e = d.callback;
          if (null !== e) {
            d.callback = null;
            d = c;
            if ("function" !== typeof e) throw Error(p(191, e));
            e.call(d);
          }
        }
      }
      var th = {};
      var uh = Uf(th);
      var vh = Uf(th);
      var wh = Uf(th);
      function xh(a) {
        if (a === th) throw Error(p(174));
        return a;
      }
      function yh(a, b) {
        G(wh, b);
        G(vh, a);
        G(uh, th);
        a = b.nodeType;
        switch (a) {
          case 9:
          case 11:
            b = (b = b.documentElement) ? b.namespaceURI : lb(null, "");
            break;
          default:
            a = 8 === a ? b.parentNode : b, b = a.namespaceURI || null, a = a.tagName, b = lb(b, a);
        }
        E(uh);
        G(uh, b);
      }
      function zh() {
        E(uh);
        E(vh);
        E(wh);
      }
      function Ah(a) {
        xh(wh.current);
        var b = xh(uh.current);
        var c = lb(b, a.type);
        b !== c && (G(vh, a), G(uh, c));
      }
      function Bh(a) {
        vh.current === a && (E(uh), E(vh));
      }
      var L = Uf(0);
      function Ch(a) {
        for (var b = a; null !== b; ) {
          if (13 === b.tag) {
            var c = b.memoizedState;
            if (null !== c && (c = c.dehydrated, null === c || "$?" === c.data || "$!" === c.data)) return b;
          } else if (19 === b.tag && void 0 !== b.memoizedProps.revealOrder) {
            if (0 !== (b.flags & 128)) return b;
          } else if (null !== b.child) {
            b.child.return = b;
            b = b.child;
            continue;
          }
          if (b === a) break;
          for (; null === b.sibling; ) {
            if (null === b.return || b.return === a) return null;
            b = b.return;
          }
          b.sibling.return = b.return;
          b = b.sibling;
        }
        return null;
      }
      var Dh = [];
      function Eh() {
        for (var a = 0; a < Dh.length; a++) Dh[a]._workInProgressVersionPrimary = null;
        Dh.length = 0;
      }
      var Fh = ua.ReactCurrentDispatcher;
      var Gh = ua.ReactCurrentBatchConfig;
      var Hh = 0;
      var M = null;
      var N = null;
      var O = null;
      var Ih = false;
      var Jh = false;
      var Kh = 0;
      var Lh = 0;
      function P() {
        throw Error(p(321));
      }
      function Mh(a, b) {
        if (null === b) return false;
        for (var c = 0; c < b.length && c < a.length; c++) if (!He(a[c], b[c])) return false;
        return true;
      }
      function Nh(a, b, c, d, e, f) {
        Hh = f;
        M = b;
        b.memoizedState = null;
        b.updateQueue = null;
        b.lanes = 0;
        Fh.current = null === a || null === a.memoizedState ? Oh : Ph;
        a = c(d, e);
        if (Jh) {
          f = 0;
          do {
            Jh = false;
            Kh = 0;
            if (25 <= f) throw Error(p(301));
            f += 1;
            O = N = null;
            b.updateQueue = null;
            Fh.current = Qh;
            a = c(d, e);
          } while (Jh);
        }
        Fh.current = Rh;
        b = null !== N && null !== N.next;
        Hh = 0;
        O = N = M = null;
        Ih = false;
        if (b) throw Error(p(300));
        return a;
      }
      function Sh() {
        var a = 0 !== Kh;
        Kh = 0;
        return a;
      }
      function Th() {
        var a = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
        null === O ? M.memoizedState = O = a : O = O.next = a;
        return O;
      }
      function Uh() {
        if (null === N) {
          var a = M.alternate;
          a = null !== a ? a.memoizedState : null;
        } else a = N.next;
        var b = null === O ? M.memoizedState : O.next;
        if (null !== b) O = b, N = a;
        else {
          if (null === a) throw Error(p(310));
          N = a;
          a = { memoizedState: N.memoizedState, baseState: N.baseState, baseQueue: N.baseQueue, queue: N.queue, next: null };
          null === O ? M.memoizedState = O = a : O = O.next = a;
        }
        return O;
      }
      function Vh(a, b) {
        return "function" === typeof b ? b(a) : b;
      }
      function Wh(a) {
        var b = Uh(), c = b.queue;
        if (null === c) throw Error(p(311));
        c.lastRenderedReducer = a;
        var d = N, e = d.baseQueue, f = c.pending;
        if (null !== f) {
          if (null !== e) {
            var g = e.next;
            e.next = f.next;
            f.next = g;
          }
          d.baseQueue = e = f;
          c.pending = null;
        }
        if (null !== e) {
          f = e.next;
          d = d.baseState;
          var h = g = null, k = null, l = f;
          do {
            var m = l.lane;
            if ((Hh & m) === m) null !== k && (k = k.next = { lane: 0, action: l.action, hasEagerState: l.hasEagerState, eagerState: l.eagerState, next: null }), d = l.hasEagerState ? l.eagerState : a(d, l.action);
            else {
              var q = {
                lane: m,
                action: l.action,
                hasEagerState: l.hasEagerState,
                eagerState: l.eagerState,
                next: null
              };
              null === k ? (h = k = q, g = d) : k = k.next = q;
              M.lanes |= m;
              rh |= m;
            }
            l = l.next;
          } while (null !== l && l !== f);
          null === k ? g = d : k.next = h;
          He(d, b.memoizedState) || (dh = true);
          b.memoizedState = d;
          b.baseState = g;
          b.baseQueue = k;
          c.lastRenderedState = d;
        }
        a = c.interleaved;
        if (null !== a) {
          e = a;
          do
            f = e.lane, M.lanes |= f, rh |= f, e = e.next;
          while (e !== a);
        } else null === e && (c.lanes = 0);
        return [b.memoizedState, c.dispatch];
      }
      function Xh(a) {
        var b = Uh(), c = b.queue;
        if (null === c) throw Error(p(311));
        c.lastRenderedReducer = a;
        var d = c.dispatch, e = c.pending, f = b.memoizedState;
        if (null !== e) {
          c.pending = null;
          var g = e = e.next;
          do
            f = a(f, g.action), g = g.next;
          while (g !== e);
          He(f, b.memoizedState) || (dh = true);
          b.memoizedState = f;
          null === b.baseQueue && (b.baseState = f);
          c.lastRenderedState = f;
        }
        return [f, d];
      }
      function Yh() {
      }
      function Zh(a, b) {
        var c = M, d = Uh(), e = b(), f = !He(d.memoizedState, e);
        f && (d.memoizedState = e, dh = true);
        d = d.queue;
        $h(ai.bind(null, c, d, a), [a]);
        if (d.getSnapshot !== b || f || null !== O && O.memoizedState.tag & 1) {
          c.flags |= 2048;
          bi(9, ci.bind(null, c, d, e, b), void 0, null);
          if (null === Q) throw Error(p(349));
          0 !== (Hh & 30) || di(c, b, e);
        }
        return e;
      }
      function di(a, b, c) {
        a.flags |= 16384;
        a = { getSnapshot: b, value: c };
        b = M.updateQueue;
        null === b ? (b = { lastEffect: null, stores: null }, M.updateQueue = b, b.stores = [a]) : (c = b.stores, null === c ? b.stores = [a] : c.push(a));
      }
      function ci(a, b, c, d) {
        b.value = c;
        b.getSnapshot = d;
        ei(b) && fi(a);
      }
      function ai(a, b, c) {
        return c(function() {
          ei(b) && fi(a);
        });
      }
      function ei(a) {
        var b = a.getSnapshot;
        a = a.value;
        try {
          var c = b();
          return !He(a, c);
        } catch (d) {
          return true;
        }
      }
      function fi(a) {
        var b = ih(a, 1);
        null !== b && gi(b, a, 1, -1);
      }
      function hi(a) {
        var b = Th();
        "function" === typeof a && (a = a());
        b.memoizedState = b.baseState = a;
        a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Vh, lastRenderedState: a };
        b.queue = a;
        a = a.dispatch = ii.bind(null, M, a);
        return [b.memoizedState, a];
      }
      function bi(a, b, c, d) {
        a = { tag: a, create: b, destroy: c, deps: d, next: null };
        b = M.updateQueue;
        null === b ? (b = { lastEffect: null, stores: null }, M.updateQueue = b, b.lastEffect = a.next = a) : (c = b.lastEffect, null === c ? b.lastEffect = a.next = a : (d = c.next, c.next = a, a.next = d, b.lastEffect = a));
        return a;
      }
      function ji() {
        return Uh().memoizedState;
      }
      function ki(a, b, c, d) {
        var e = Th();
        M.flags |= a;
        e.memoizedState = bi(1 | b, c, void 0, void 0 === d ? null : d);
      }
      function li(a, b, c, d) {
        var e = Uh();
        d = void 0 === d ? null : d;
        var f = void 0;
        if (null !== N) {
          var g = N.memoizedState;
          f = g.destroy;
          if (null !== d && Mh(d, g.deps)) {
            e.memoizedState = bi(b, c, f, d);
            return;
          }
        }
        M.flags |= a;
        e.memoizedState = bi(1 | b, c, f, d);
      }
      function mi(a, b) {
        return ki(8390656, 8, a, b);
      }
      function $h(a, b) {
        return li(2048, 8, a, b);
      }
      function ni(a, b) {
        return li(4, 2, a, b);
      }
      function oi(a, b) {
        return li(4, 4, a, b);
      }
      function pi(a, b) {
        if ("function" === typeof b) return a = a(), b(a), function() {
          b(null);
        };
        if (null !== b && void 0 !== b) return a = a(), b.current = a, function() {
          b.current = null;
        };
      }
      function qi(a, b, c) {
        c = null !== c && void 0 !== c ? c.concat([a]) : null;
        return li(4, 4, pi.bind(null, b, a), c);
      }
      function ri() {
      }
      function si(a, b) {
        var c = Uh();
        b = void 0 === b ? null : b;
        var d = c.memoizedState;
        if (null !== d && null !== b && Mh(b, d[1])) return d[0];
        c.memoizedState = [a, b];
        return a;
      }
      function ti(a, b) {
        var c = Uh();
        b = void 0 === b ? null : b;
        var d = c.memoizedState;
        if (null !== d && null !== b && Mh(b, d[1])) return d[0];
        a = a();
        c.memoizedState = [a, b];
        return a;
      }
      function ui(a, b, c) {
        if (0 === (Hh & 21)) return a.baseState && (a.baseState = false, dh = true), a.memoizedState = c;
        He(c, b) || (c = yc(), M.lanes |= c, rh |= c, a.baseState = true);
        return b;
      }
      function vi(a, b) {
        var c = C;
        C = 0 !== c && 4 > c ? c : 4;
        a(true);
        var d = Gh.transition;
        Gh.transition = {};
        try {
          a(false), b();
        } finally {
          C = c, Gh.transition = d;
        }
      }
      function wi() {
        return Uh().memoizedState;
      }
      function xi(a, b, c) {
        var d = yi(a);
        c = { lane: d, action: c, hasEagerState: false, eagerState: null, next: null };
        if (zi(a)) Ai(b, c);
        else if (c = hh(a, b, c, d), null !== c) {
          var e = R();
          gi(c, a, d, e);
          Bi(c, b, d);
        }
      }
      function ii(a, b, c) {
        var d = yi(a), e = { lane: d, action: c, hasEagerState: false, eagerState: null, next: null };
        if (zi(a)) Ai(b, e);
        else {
          var f = a.alternate;
          if (0 === a.lanes && (null === f || 0 === f.lanes) && (f = b.lastRenderedReducer, null !== f)) try {
            var g = b.lastRenderedState, h = f(g, c);
            e.hasEagerState = true;
            e.eagerState = h;
            if (He(h, g)) {
              var k = b.interleaved;
              null === k ? (e.next = e, gh(b)) : (e.next = k.next, k.next = e);
              b.interleaved = e;
              return;
            }
          } catch (l) {
          } finally {
          }
          c = hh(a, b, e, d);
          null !== c && (e = R(), gi(c, a, d, e), Bi(c, b, d));
        }
      }
      function zi(a) {
        var b = a.alternate;
        return a === M || null !== b && b === M;
      }
      function Ai(a, b) {
        Jh = Ih = true;
        var c = a.pending;
        null === c ? b.next = b : (b.next = c.next, c.next = b);
        a.pending = b;
      }
      function Bi(a, b, c) {
        if (0 !== (c & 4194240)) {
          var d = b.lanes;
          d &= a.pendingLanes;
          c |= d;
          b.lanes = c;
          Cc(a, c);
        }
      }
      var Rh = { readContext: eh, useCallback: P, useContext: P, useEffect: P, useImperativeHandle: P, useInsertionEffect: P, useLayoutEffect: P, useMemo: P, useReducer: P, useRef: P, useState: P, useDebugValue: P, useDeferredValue: P, useTransition: P, useMutableSource: P, useSyncExternalStore: P, useId: P, unstable_isNewReconciler: false };
      var Oh = { readContext: eh, useCallback: function(a, b) {
        Th().memoizedState = [a, void 0 === b ? null : b];
        return a;
      }, useContext: eh, useEffect: mi, useImperativeHandle: function(a, b, c) {
        c = null !== c && void 0 !== c ? c.concat([a]) : null;
        return ki(
          4194308,
          4,
          pi.bind(null, b, a),
          c
        );
      }, useLayoutEffect: function(a, b) {
        return ki(4194308, 4, a, b);
      }, useInsertionEffect: function(a, b) {
        return ki(4, 2, a, b);
      }, useMemo: function(a, b) {
        var c = Th();
        b = void 0 === b ? null : b;
        a = a();
        c.memoizedState = [a, b];
        return a;
      }, useReducer: function(a, b, c) {
        var d = Th();
        b = void 0 !== c ? c(b) : b;
        d.memoizedState = d.baseState = b;
        a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a, lastRenderedState: b };
        d.queue = a;
        a = a.dispatch = xi.bind(null, M, a);
        return [d.memoizedState, a];
      }, useRef: function(a) {
        var b = Th();
        a = { current: a };
        return b.memoizedState = a;
      }, useState: hi, useDebugValue: ri, useDeferredValue: function(a) {
        return Th().memoizedState = a;
      }, useTransition: function() {
        var a = hi(false), b = a[0];
        a = vi.bind(null, a[1]);
        Th().memoizedState = a;
        return [b, a];
      }, useMutableSource: function() {
      }, useSyncExternalStore: function(a, b, c) {
        var d = M, e = Th();
        if (I) {
          if (void 0 === c) throw Error(p(407));
          c = c();
        } else {
          c = b();
          if (null === Q) throw Error(p(349));
          0 !== (Hh & 30) || di(d, b, c);
        }
        e.memoizedState = c;
        var f = { value: c, getSnapshot: b };
        e.queue = f;
        mi(ai.bind(
          null,
          d,
          f,
          a
        ), [a]);
        d.flags |= 2048;
        bi(9, ci.bind(null, d, f, c, b), void 0, null);
        return c;
      }, useId: function() {
        var a = Th(), b = Q.identifierPrefix;
        if (I) {
          var c = sg;
          var d = rg;
          c = (d & ~(1 << 32 - oc(d) - 1)).toString(32) + c;
          b = ":" + b + "R" + c;
          c = Kh++;
          0 < c && (b += "H" + c.toString(32));
          b += ":";
        } else c = Lh++, b = ":" + b + "r" + c.toString(32) + ":";
        return a.memoizedState = b;
      }, unstable_isNewReconciler: false };
      var Ph = {
        readContext: eh,
        useCallback: si,
        useContext: eh,
        useEffect: $h,
        useImperativeHandle: qi,
        useInsertionEffect: ni,
        useLayoutEffect: oi,
        useMemo: ti,
        useReducer: Wh,
        useRef: ji,
        useState: function() {
          return Wh(Vh);
        },
        useDebugValue: ri,
        useDeferredValue: function(a) {
          var b = Uh();
          return ui(b, N.memoizedState, a);
        },
        useTransition: function() {
          var a = Wh(Vh)[0], b = Uh().memoizedState;
          return [a, b];
        },
        useMutableSource: Yh,
        useSyncExternalStore: Zh,
        useId: wi,
        unstable_isNewReconciler: false
      };
      var Qh = { readContext: eh, useCallback: si, useContext: eh, useEffect: $h, useImperativeHandle: qi, useInsertionEffect: ni, useLayoutEffect: oi, useMemo: ti, useReducer: Xh, useRef: ji, useState: function() {
        return Xh(Vh);
      }, useDebugValue: ri, useDeferredValue: function(a) {
        var b = Uh();
        return null === N ? b.memoizedState = a : ui(b, N.memoizedState, a);
      }, useTransition: function() {
        var a = Xh(Vh)[0], b = Uh().memoizedState;
        return [a, b];
      }, useMutableSource: Yh, useSyncExternalStore: Zh, useId: wi, unstable_isNewReconciler: false };
      function Ci(a, b) {
        if (a && a.defaultProps) {
          b = A({}, b);
          a = a.defaultProps;
          for (var c in a) void 0 === b[c] && (b[c] = a[c]);
          return b;
        }
        return b;
      }
      function Di(a, b, c, d) {
        b = a.memoizedState;
        c = c(d, b);
        c = null === c || void 0 === c ? b : A({}, b, c);
        a.memoizedState = c;
        0 === a.lanes && (a.updateQueue.baseState = c);
      }
      var Ei = { isMounted: function(a) {
        return (a = a._reactInternals) ? Vb(a) === a : false;
      }, enqueueSetState: function(a, b, c) {
        a = a._reactInternals;
        var d = R(), e = yi(a), f = mh(d, e);
        f.payload = b;
        void 0 !== c && null !== c && (f.callback = c);
        b = nh(a, f, e);
        null !== b && (gi(b, a, e, d), oh(b, a, e));
      }, enqueueReplaceState: function(a, b, c) {
        a = a._reactInternals;
        var d = R(), e = yi(a), f = mh(d, e);
        f.tag = 1;
        f.payload = b;
        void 0 !== c && null !== c && (f.callback = c);
        b = nh(a, f, e);
        null !== b && (gi(b, a, e, d), oh(b, a, e));
      }, enqueueForceUpdate: function(a, b) {
        a = a._reactInternals;
        var c = R(), d = yi(a), e = mh(c, d);
        e.tag = 2;
        void 0 !== b && null !== b && (e.callback = b);
        b = nh(a, e, d);
        null !== b && (gi(b, a, d, c), oh(b, a, d));
      } };
      function Fi(a, b, c, d, e, f, g) {
        a = a.stateNode;
        return "function" === typeof a.shouldComponentUpdate ? a.shouldComponentUpdate(d, f, g) : b.prototype && b.prototype.isPureReactComponent ? !Ie(c, d) || !Ie(e, f) : true;
      }
      function Gi(a, b, c) {
        var d = false, e = Vf;
        var f = b.contextType;
        "object" === typeof f && null !== f ? f = eh(f) : (e = Zf(b) ? Xf : H.current, d = b.contextTypes, f = (d = null !== d && void 0 !== d) ? Yf(a, e) : Vf);
        b = new b(c, f);
        a.memoizedState = null !== b.state && void 0 !== b.state ? b.state : null;
        b.updater = Ei;
        a.stateNode = b;
        b._reactInternals = a;
        d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = e, a.__reactInternalMemoizedMaskedChildContext = f);
        return b;
      }
      function Hi(a, b, c, d) {
        a = b.state;
        "function" === typeof b.componentWillReceiveProps && b.componentWillReceiveProps(c, d);
        "function" === typeof b.UNSAFE_componentWillReceiveProps && b.UNSAFE_componentWillReceiveProps(c, d);
        b.state !== a && Ei.enqueueReplaceState(b, b.state, null);
      }
      function Ii(a, b, c, d) {
        var e = a.stateNode;
        e.props = c;
        e.state = a.memoizedState;
        e.refs = {};
        kh(a);
        var f = b.contextType;
        "object" === typeof f && null !== f ? e.context = eh(f) : (f = Zf(b) ? Xf : H.current, e.context = Yf(a, f));
        e.state = a.memoizedState;
        f = b.getDerivedStateFromProps;
        "function" === typeof f && (Di(a, b, f, c), e.state = a.memoizedState);
        "function" === typeof b.getDerivedStateFromProps || "function" === typeof e.getSnapshotBeforeUpdate || "function" !== typeof e.UNSAFE_componentWillMount && "function" !== typeof e.componentWillMount || (b = e.state, "function" === typeof e.componentWillMount && e.componentWillMount(), "function" === typeof e.UNSAFE_componentWillMount && e.UNSAFE_componentWillMount(), b !== e.state && Ei.enqueueReplaceState(e, e.state, null), qh(a, c, e, d), e.state = a.memoizedState);
        "function" === typeof e.componentDidMount && (a.flags |= 4194308);
      }
      function Ji(a, b) {
        try {
          var c = "", d = b;
          do
            c += Pa(d), d = d.return;
          while (d);
          var e = c;
        } catch (f) {
          e = "\nError generating stack: " + f.message + "\n" + f.stack;
        }
        return { value: a, source: b, stack: e, digest: null };
      }
      function Ki(a, b, c) {
        return { value: a, source: null, stack: null != c ? c : null, digest: null != b ? b : null };
      }
      function Li(a, b) {
        try {
          console.error(b.value);
        } catch (c) {
          setTimeout(function() {
            throw c;
          });
        }
      }
      var Mi = "function" === typeof WeakMap ? WeakMap : Map;
      function Ni(a, b, c) {
        c = mh(-1, c);
        c.tag = 3;
        c.payload = { element: null };
        var d = b.value;
        c.callback = function() {
          Oi || (Oi = true, Pi = d);
          Li(a, b);
        };
        return c;
      }
      function Qi(a, b, c) {
        c = mh(-1, c);
        c.tag = 3;
        var d = a.type.getDerivedStateFromError;
        if ("function" === typeof d) {
          var e = b.value;
          c.payload = function() {
            return d(e);
          };
          c.callback = function() {
            Li(a, b);
          };
        }
        var f = a.stateNode;
        null !== f && "function" === typeof f.componentDidCatch && (c.callback = function() {
          Li(a, b);
          "function" !== typeof d && (null === Ri ? Ri = /* @__PURE__ */ new Set([this]) : Ri.add(this));
          var c2 = b.stack;
          this.componentDidCatch(b.value, { componentStack: null !== c2 ? c2 : "" });
        });
        return c;
      }
      function Si(a, b, c) {
        var d = a.pingCache;
        if (null === d) {
          d = a.pingCache = new Mi();
          var e = /* @__PURE__ */ new Set();
          d.set(b, e);
        } else e = d.get(b), void 0 === e && (e = /* @__PURE__ */ new Set(), d.set(b, e));
        e.has(c) || (e.add(c), a = Ti.bind(null, a, b, c), b.then(a, a));
      }
      function Ui(a) {
        do {
          var b;
          if (b = 13 === a.tag) b = a.memoizedState, b = null !== b ? null !== b.dehydrated ? true : false : true;
          if (b) return a;
          a = a.return;
        } while (null !== a);
        return null;
      }
      function Vi(a, b, c, d, e) {
        if (0 === (a.mode & 1)) return a === b ? a.flags |= 65536 : (a.flags |= 128, c.flags |= 131072, c.flags &= -52805, 1 === c.tag && (null === c.alternate ? c.tag = 17 : (b = mh(-1, 1), b.tag = 2, nh(c, b, 1))), c.lanes |= 1), a;
        a.flags |= 65536;
        a.lanes = e;
        return a;
      }
      var Wi = ua.ReactCurrentOwner;
      var dh = false;
      function Xi(a, b, c, d) {
        b.child = null === a ? Vg(b, null, c, d) : Ug(b, a.child, c, d);
      }
      function Yi(a, b, c, d, e) {
        c = c.render;
        var f = b.ref;
        ch(b, e);
        d = Nh(a, b, c, d, f, e);
        c = Sh();
        if (null !== a && !dh) return b.updateQueue = a.updateQueue, b.flags &= -2053, a.lanes &= ~e, Zi(a, b, e);
        I && c && vg(b);
        b.flags |= 1;
        Xi(a, b, d, e);
        return b.child;
      }
      function $i(a, b, c, d, e) {
        if (null === a) {
          var f = c.type;
          if ("function" === typeof f && !aj(f) && void 0 === f.defaultProps && null === c.compare && void 0 === c.defaultProps) return b.tag = 15, b.type = f, bj(a, b, f, d, e);
          a = Rg(c.type, null, d, b, b.mode, e);
          a.ref = b.ref;
          a.return = b;
          return b.child = a;
        }
        f = a.child;
        if (0 === (a.lanes & e)) {
          var g = f.memoizedProps;
          c = c.compare;
          c = null !== c ? c : Ie;
          if (c(g, d) && a.ref === b.ref) return Zi(a, b, e);
        }
        b.flags |= 1;
        a = Pg(f, d);
        a.ref = b.ref;
        a.return = b;
        return b.child = a;
      }
      function bj(a, b, c, d, e) {
        if (null !== a) {
          var f = a.memoizedProps;
          if (Ie(f, d) && a.ref === b.ref) if (dh = false, b.pendingProps = d = f, 0 !== (a.lanes & e)) 0 !== (a.flags & 131072) && (dh = true);
          else return b.lanes = a.lanes, Zi(a, b, e);
        }
        return cj(a, b, c, d, e);
      }
      function dj(a, b, c) {
        var d = b.pendingProps, e = d.children, f = null !== a ? a.memoizedState : null;
        if ("hidden" === d.mode) if (0 === (b.mode & 1)) b.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G(ej, fj), fj |= c;
        else {
          if (0 === (c & 1073741824)) return a = null !== f ? f.baseLanes | c : c, b.lanes = b.childLanes = 1073741824, b.memoizedState = { baseLanes: a, cachePool: null, transitions: null }, b.updateQueue = null, G(ej, fj), fj |= a, null;
          b.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
          d = null !== f ? f.baseLanes : c;
          G(ej, fj);
          fj |= d;
        }
        else null !== f ? (d = f.baseLanes | c, b.memoizedState = null) : d = c, G(ej, fj), fj |= d;
        Xi(a, b, e, c);
        return b.child;
      }
      function gj(a, b) {
        var c = b.ref;
        if (null === a && null !== c || null !== a && a.ref !== c) b.flags |= 512, b.flags |= 2097152;
      }
      function cj(a, b, c, d, e) {
        var f = Zf(c) ? Xf : H.current;
        f = Yf(b, f);
        ch(b, e);
        c = Nh(a, b, c, d, f, e);
        d = Sh();
        if (null !== a && !dh) return b.updateQueue = a.updateQueue, b.flags &= -2053, a.lanes &= ~e, Zi(a, b, e);
        I && d && vg(b);
        b.flags |= 1;
        Xi(a, b, c, e);
        return b.child;
      }
      function hj(a, b, c, d, e) {
        if (Zf(c)) {
          var f = true;
          cg(b);
        } else f = false;
        ch(b, e);
        if (null === b.stateNode) ij(a, b), Gi(b, c, d), Ii(b, c, d, e), d = true;
        else if (null === a) {
          var g = b.stateNode, h = b.memoizedProps;
          g.props = h;
          var k = g.context, l = c.contextType;
          "object" === typeof l && null !== l ? l = eh(l) : (l = Zf(c) ? Xf : H.current, l = Yf(b, l));
          var m = c.getDerivedStateFromProps, q = "function" === typeof m || "function" === typeof g.getSnapshotBeforeUpdate;
          q || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h !== d || k !== l) && Hi(b, g, d, l);
          jh = false;
          var r = b.memoizedState;
          g.state = r;
          qh(b, d, g, e);
          k = b.memoizedState;
          h !== d || r !== k || Wf.current || jh ? ("function" === typeof m && (Di(b, c, m, d), k = b.memoizedState), (h = jh || Fi(b, c, h, d, r, k, l)) ? (q || "function" !== typeof g.UNSAFE_componentWillMount && "function" !== typeof g.componentWillMount || ("function" === typeof g.componentWillMount && g.componentWillMount(), "function" === typeof g.UNSAFE_componentWillMount && g.UNSAFE_componentWillMount()), "function" === typeof g.componentDidMount && (b.flags |= 4194308)) : ("function" === typeof g.componentDidMount && (b.flags |= 4194308), b.memoizedProps = d, b.memoizedState = k), g.props = d, g.state = k, g.context = l, d = h) : ("function" === typeof g.componentDidMount && (b.flags |= 4194308), d = false);
        } else {
          g = b.stateNode;
          lh(a, b);
          h = b.memoizedProps;
          l = b.type === b.elementType ? h : Ci(b.type, h);
          g.props = l;
          q = b.pendingProps;
          r = g.context;
          k = c.contextType;
          "object" === typeof k && null !== k ? k = eh(k) : (k = Zf(c) ? Xf : H.current, k = Yf(b, k));
          var y = c.getDerivedStateFromProps;
          (m = "function" === typeof y || "function" === typeof g.getSnapshotBeforeUpdate) || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h !== q || r !== k) && Hi(b, g, d, k);
          jh = false;
          r = b.memoizedState;
          g.state = r;
          qh(b, d, g, e);
          var n = b.memoizedState;
          h !== q || r !== n || Wf.current || jh ? ("function" === typeof y && (Di(b, c, y, d), n = b.memoizedState), (l = jh || Fi(b, c, l, d, r, n, k) || false) ? (m || "function" !== typeof g.UNSAFE_componentWillUpdate && "function" !== typeof g.componentWillUpdate || ("function" === typeof g.componentWillUpdate && g.componentWillUpdate(d, n, k), "function" === typeof g.UNSAFE_componentWillUpdate && g.UNSAFE_componentWillUpdate(d, n, k)), "function" === typeof g.componentDidUpdate && (b.flags |= 4), "function" === typeof g.getSnapshotBeforeUpdate && (b.flags |= 1024)) : ("function" !== typeof g.componentDidUpdate || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 1024), b.memoizedProps = d, b.memoizedState = n), g.props = d, g.state = n, g.context = k, d = l) : ("function" !== typeof g.componentDidUpdate || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 1024), d = false);
        }
        return jj(a, b, c, d, f, e);
      }
      function jj(a, b, c, d, e, f) {
        gj(a, b);
        var g = 0 !== (b.flags & 128);
        if (!d && !g) return e && dg(b, c, false), Zi(a, b, f);
        d = b.stateNode;
        Wi.current = b;
        var h = g && "function" !== typeof c.getDerivedStateFromError ? null : d.render();
        b.flags |= 1;
        null !== a && g ? (b.child = Ug(b, a.child, null, f), b.child = Ug(b, null, h, f)) : Xi(a, b, h, f);
        b.memoizedState = d.state;
        e && dg(b, c, true);
        return b.child;
      }
      function kj(a) {
        var b = a.stateNode;
        b.pendingContext ? ag(a, b.pendingContext, b.pendingContext !== b.context) : b.context && ag(a, b.context, false);
        yh(a, b.containerInfo);
      }
      function lj(a, b, c, d, e) {
        Ig();
        Jg(e);
        b.flags |= 256;
        Xi(a, b, c, d);
        return b.child;
      }
      var mj = { dehydrated: null, treeContext: null, retryLane: 0 };
      function nj(a) {
        return { baseLanes: a, cachePool: null, transitions: null };
      }
      function oj(a, b, c) {
        var d = b.pendingProps, e = L.current, f = false, g = 0 !== (b.flags & 128), h;
        (h = g) || (h = null !== a && null === a.memoizedState ? false : 0 !== (e & 2));
        if (h) f = true, b.flags &= -129;
        else if (null === a || null !== a.memoizedState) e |= 1;
        G(L, e & 1);
        if (null === a) {
          Eg(b);
          a = b.memoizedState;
          if (null !== a && (a = a.dehydrated, null !== a)) return 0 === (b.mode & 1) ? b.lanes = 1 : "$!" === a.data ? b.lanes = 8 : b.lanes = 1073741824, null;
          g = d.children;
          a = d.fallback;
          return f ? (d = b.mode, f = b.child, g = { mode: "hidden", children: g }, 0 === (d & 1) && null !== f ? (f.childLanes = 0, f.pendingProps = g) : f = pj(g, d, 0, null), a = Tg(a, d, c, null), f.return = b, a.return = b, f.sibling = a, b.child = f, b.child.memoizedState = nj(c), b.memoizedState = mj, a) : qj(b, g);
        }
        e = a.memoizedState;
        if (null !== e && (h = e.dehydrated, null !== h)) return rj(a, b, g, d, h, e, c);
        if (f) {
          f = d.fallback;
          g = b.mode;
          e = a.child;
          h = e.sibling;
          var k = { mode: "hidden", children: d.children };
          0 === (g & 1) && b.child !== e ? (d = b.child, d.childLanes = 0, d.pendingProps = k, b.deletions = null) : (d = Pg(e, k), d.subtreeFlags = e.subtreeFlags & 14680064);
          null !== h ? f = Pg(h, f) : (f = Tg(f, g, c, null), f.flags |= 2);
          f.return = b;
          d.return = b;
          d.sibling = f;
          b.child = d;
          d = f;
          f = b.child;
          g = a.child.memoizedState;
          g = null === g ? nj(c) : { baseLanes: g.baseLanes | c, cachePool: null, transitions: g.transitions };
          f.memoizedState = g;
          f.childLanes = a.childLanes & ~c;
          b.memoizedState = mj;
          return d;
        }
        f = a.child;
        a = f.sibling;
        d = Pg(f, { mode: "visible", children: d.children });
        0 === (b.mode & 1) && (d.lanes = c);
        d.return = b;
        d.sibling = null;
        null !== a && (c = b.deletions, null === c ? (b.deletions = [a], b.flags |= 16) : c.push(a));
        b.child = d;
        b.memoizedState = null;
        return d;
      }
      function qj(a, b) {
        b = pj({ mode: "visible", children: b }, a.mode, 0, null);
        b.return = a;
        return a.child = b;
      }
      function sj(a, b, c, d) {
        null !== d && Jg(d);
        Ug(b, a.child, null, c);
        a = qj(b, b.pendingProps.children);
        a.flags |= 2;
        b.memoizedState = null;
        return a;
      }
      function rj(a, b, c, d, e, f, g) {
        if (c) {
          if (b.flags & 256) return b.flags &= -257, d = Ki(Error(p(422))), sj(a, b, g, d);
          if (null !== b.memoizedState) return b.child = a.child, b.flags |= 128, null;
          f = d.fallback;
          e = b.mode;
          d = pj({ mode: "visible", children: d.children }, e, 0, null);
          f = Tg(f, e, g, null);
          f.flags |= 2;
          d.return = b;
          f.return = b;
          d.sibling = f;
          b.child = d;
          0 !== (b.mode & 1) && Ug(b, a.child, null, g);
          b.child.memoizedState = nj(g);
          b.memoizedState = mj;
          return f;
        }
        if (0 === (b.mode & 1)) return sj(a, b, g, null);
        if ("$!" === e.data) {
          d = e.nextSibling && e.nextSibling.dataset;
          if (d) var h = d.dgst;
          d = h;
          f = Error(p(419));
          d = Ki(f, d, void 0);
          return sj(a, b, g, d);
        }
        h = 0 !== (g & a.childLanes);
        if (dh || h) {
          d = Q;
          if (null !== d) {
            switch (g & -g) {
              case 4:
                e = 2;
                break;
              case 16:
                e = 8;
                break;
              case 64:
              case 128:
              case 256:
              case 512:
              case 1024:
              case 2048:
              case 4096:
              case 8192:
              case 16384:
              case 32768:
              case 65536:
              case 131072:
              case 262144:
              case 524288:
              case 1048576:
              case 2097152:
              case 4194304:
              case 8388608:
              case 16777216:
              case 33554432:
              case 67108864:
                e = 32;
                break;
              case 536870912:
                e = 268435456;
                break;
              default:
                e = 0;
            }
            e = 0 !== (e & (d.suspendedLanes | g)) ? 0 : e;
            0 !== e && e !== f.retryLane && (f.retryLane = e, ih(a, e), gi(d, a, e, -1));
          }
          tj();
          d = Ki(Error(p(421)));
          return sj(a, b, g, d);
        }
        if ("$?" === e.data) return b.flags |= 128, b.child = a.child, b = uj.bind(null, a), e._reactRetry = b, null;
        a = f.treeContext;
        yg = Lf(e.nextSibling);
        xg = b;
        I = true;
        zg = null;
        null !== a && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a.id, sg = a.overflow, qg = b);
        b = qj(b, d.children);
        b.flags |= 4096;
        return b;
      }
      function vj(a, b, c) {
        a.lanes |= b;
        var d = a.alternate;
        null !== d && (d.lanes |= b);
        bh(a.return, b, c);
      }
      function wj(a, b, c, d, e) {
        var f = a.memoizedState;
        null === f ? a.memoizedState = { isBackwards: b, rendering: null, renderingStartTime: 0, last: d, tail: c, tailMode: e } : (f.isBackwards = b, f.rendering = null, f.renderingStartTime = 0, f.last = d, f.tail = c, f.tailMode = e);
      }
      function xj(a, b, c) {
        var d = b.pendingProps, e = d.revealOrder, f = d.tail;
        Xi(a, b, d.children, c);
        d = L.current;
        if (0 !== (d & 2)) d = d & 1 | 2, b.flags |= 128;
        else {
          if (null !== a && 0 !== (a.flags & 128)) a: for (a = b.child; null !== a; ) {
            if (13 === a.tag) null !== a.memoizedState && vj(a, c, b);
            else if (19 === a.tag) vj(a, c, b);
            else if (null !== a.child) {
              a.child.return = a;
              a = a.child;
              continue;
            }
            if (a === b) break a;
            for (; null === a.sibling; ) {
              if (null === a.return || a.return === b) break a;
              a = a.return;
            }
            a.sibling.return = a.return;
            a = a.sibling;
          }
          d &= 1;
        }
        G(L, d);
        if (0 === (b.mode & 1)) b.memoizedState = null;
        else switch (e) {
          case "forwards":
            c = b.child;
            for (e = null; null !== c; ) a = c.alternate, null !== a && null === Ch(a) && (e = c), c = c.sibling;
            c = e;
            null === c ? (e = b.child, b.child = null) : (e = c.sibling, c.sibling = null);
            wj(b, false, e, c, f);
            break;
          case "backwards":
            c = null;
            e = b.child;
            for (b.child = null; null !== e; ) {
              a = e.alternate;
              if (null !== a && null === Ch(a)) {
                b.child = e;
                break;
              }
              a = e.sibling;
              e.sibling = c;
              c = e;
              e = a;
            }
            wj(b, true, c, null, f);
            break;
          case "together":
            wj(b, false, null, null, void 0);
            break;
          default:
            b.memoizedState = null;
        }
        return b.child;
      }
      function ij(a, b) {
        0 === (b.mode & 1) && null !== a && (a.alternate = null, b.alternate = null, b.flags |= 2);
      }
      function Zi(a, b, c) {
        null !== a && (b.dependencies = a.dependencies);
        rh |= b.lanes;
        if (0 === (c & b.childLanes)) return null;
        if (null !== a && b.child !== a.child) throw Error(p(153));
        if (null !== b.child) {
          a = b.child;
          c = Pg(a, a.pendingProps);
          b.child = c;
          for (c.return = b; null !== a.sibling; ) a = a.sibling, c = c.sibling = Pg(a, a.pendingProps), c.return = b;
          c.sibling = null;
        }
        return b.child;
      }
      function yj(a, b, c) {
        switch (b.tag) {
          case 3:
            kj(b);
            Ig();
            break;
          case 5:
            Ah(b);
            break;
          case 1:
            Zf(b.type) && cg(b);
            break;
          case 4:
            yh(b, b.stateNode.containerInfo);
            break;
          case 10:
            var d = b.type._context, e = b.memoizedProps.value;
            G(Wg, d._currentValue);
            d._currentValue = e;
            break;
          case 13:
            d = b.memoizedState;
            if (null !== d) {
              if (null !== d.dehydrated) return G(L, L.current & 1), b.flags |= 128, null;
              if (0 !== (c & b.child.childLanes)) return oj(a, b, c);
              G(L, L.current & 1);
              a = Zi(a, b, c);
              return null !== a ? a.sibling : null;
            }
            G(L, L.current & 1);
            break;
          case 19:
            d = 0 !== (c & b.childLanes);
            if (0 !== (a.flags & 128)) {
              if (d) return xj(a, b, c);
              b.flags |= 128;
            }
            e = b.memoizedState;
            null !== e && (e.rendering = null, e.tail = null, e.lastEffect = null);
            G(L, L.current);
            if (d) break;
            else return null;
          case 22:
          case 23:
            return b.lanes = 0, dj(a, b, c);
        }
        return Zi(a, b, c);
      }
      var zj;
      var Aj;
      var Bj;
      var Cj;
      zj = function(a, b) {
        for (var c = b.child; null !== c; ) {
          if (5 === c.tag || 6 === c.tag) a.appendChild(c.stateNode);
          else if (4 !== c.tag && null !== c.child) {
            c.child.return = c;
            c = c.child;
            continue;
          }
          if (c === b) break;
          for (; null === c.sibling; ) {
            if (null === c.return || c.return === b) return;
            c = c.return;
          }
          c.sibling.return = c.return;
          c = c.sibling;
        }
      };
      Aj = function() {
      };
      Bj = function(a, b, c, d) {
        var e = a.memoizedProps;
        if (e !== d) {
          a = b.stateNode;
          xh(uh.current);
          var f = null;
          switch (c) {
            case "input":
              e = Ya(a, e);
              d = Ya(a, d);
              f = [];
              break;
            case "select":
              e = A({}, e, { value: void 0 });
              d = A({}, d, { value: void 0 });
              f = [];
              break;
            case "textarea":
              e = gb(a, e);
              d = gb(a, d);
              f = [];
              break;
            default:
              "function" !== typeof e.onClick && "function" === typeof d.onClick && (a.onclick = Bf);
          }
          ub(c, d);
          var g;
          c = null;
          for (l in e) if (!d.hasOwnProperty(l) && e.hasOwnProperty(l) && null != e[l]) if ("style" === l) {
            var h = e[l];
            for (g in h) h.hasOwnProperty(g) && (c || (c = {}), c[g] = "");
          } else "dangerouslySetInnerHTML" !== l && "children" !== l && "suppressContentEditableWarning" !== l && "suppressHydrationWarning" !== l && "autoFocus" !== l && (ea.hasOwnProperty(l) ? f || (f = []) : (f = f || []).push(l, null));
          for (l in d) {
            var k = d[l];
            h = null != e ? e[l] : void 0;
            if (d.hasOwnProperty(l) && k !== h && (null != k || null != h)) if ("style" === l) if (h) {
              for (g in h) !h.hasOwnProperty(g) || k && k.hasOwnProperty(g) || (c || (c = {}), c[g] = "");
              for (g in k) k.hasOwnProperty(g) && h[g] !== k[g] && (c || (c = {}), c[g] = k[g]);
            } else c || (f || (f = []), f.push(
              l,
              c
            )), c = k;
            else "dangerouslySetInnerHTML" === l ? (k = k ? k.__html : void 0, h = h ? h.__html : void 0, null != k && h !== k && (f = f || []).push(l, k)) : "children" === l ? "string" !== typeof k && "number" !== typeof k || (f = f || []).push(l, "" + k) : "suppressContentEditableWarning" !== l && "suppressHydrationWarning" !== l && (ea.hasOwnProperty(l) ? (null != k && "onScroll" === l && D("scroll", a), f || h === k || (f = [])) : (f = f || []).push(l, k));
          }
          c && (f = f || []).push("style", c);
          var l = f;
          if (b.updateQueue = l) b.flags |= 4;
        }
      };
      Cj = function(a, b, c, d) {
        c !== d && (b.flags |= 4);
      };
      function Dj(a, b) {
        if (!I) switch (a.tailMode) {
          case "hidden":
            b = a.tail;
            for (var c = null; null !== b; ) null !== b.alternate && (c = b), b = b.sibling;
            null === c ? a.tail = null : c.sibling = null;
            break;
          case "collapsed":
            c = a.tail;
            for (var d = null; null !== c; ) null !== c.alternate && (d = c), c = c.sibling;
            null === d ? b || null === a.tail ? a.tail = null : a.tail.sibling = null : d.sibling = null;
        }
      }
      function S(a) {
        var b = null !== a.alternate && a.alternate.child === a.child, c = 0, d = 0;
        if (b) for (var e = a.child; null !== e; ) c |= e.lanes | e.childLanes, d |= e.subtreeFlags & 14680064, d |= e.flags & 14680064, e.return = a, e = e.sibling;
        else for (e = a.child; null !== e; ) c |= e.lanes | e.childLanes, d |= e.subtreeFlags, d |= e.flags, e.return = a, e = e.sibling;
        a.subtreeFlags |= d;
        a.childLanes = c;
        return b;
      }
      function Ej(a, b, c) {
        var d = b.pendingProps;
        wg(b);
        switch (b.tag) {
          case 2:
          case 16:
          case 15:
          case 0:
          case 11:
          case 7:
          case 8:
          case 12:
          case 9:
          case 14:
            return S(b), null;
          case 1:
            return Zf(b.type) && $f(), S(b), null;
          case 3:
            d = b.stateNode;
            zh();
            E(Wf);
            E(H);
            Eh();
            d.pendingContext && (d.context = d.pendingContext, d.pendingContext = null);
            if (null === a || null === a.child) Gg(b) ? b.flags |= 4 : null === a || a.memoizedState.isDehydrated && 0 === (b.flags & 256) || (b.flags |= 1024, null !== zg && (Fj(zg), zg = null));
            Aj(a, b);
            S(b);
            return null;
          case 5:
            Bh(b);
            var e = xh(wh.current);
            c = b.type;
            if (null !== a && null != b.stateNode) Bj(a, b, c, d, e), a.ref !== b.ref && (b.flags |= 512, b.flags |= 2097152);
            else {
              if (!d) {
                if (null === b.stateNode) throw Error(p(166));
                S(b);
                return null;
              }
              a = xh(uh.current);
              if (Gg(b)) {
                d = b.stateNode;
                c = b.type;
                var f = b.memoizedProps;
                d[Of] = b;
                d[Pf] = f;
                a = 0 !== (b.mode & 1);
                switch (c) {
                  case "dialog":
                    D("cancel", d);
                    D("close", d);
                    break;
                  case "iframe":
                  case "object":
                  case "embed":
                    D("load", d);
                    break;
                  case "video":
                  case "audio":
                    for (e = 0; e < lf.length; e++) D(lf[e], d);
                    break;
                  case "source":
                    D("error", d);
                    break;
                  case "img":
                  case "image":
                  case "link":
                    D(
                      "error",
                      d
                    );
                    D("load", d);
                    break;
                  case "details":
                    D("toggle", d);
                    break;
                  case "input":
                    Za(d, f);
                    D("invalid", d);
                    break;
                  case "select":
                    d._wrapperState = { wasMultiple: !!f.multiple };
                    D("invalid", d);
                    break;
                  case "textarea":
                    hb(d, f), D("invalid", d);
                }
                ub(c, f);
                e = null;
                for (var g in f) if (f.hasOwnProperty(g)) {
                  var h = f[g];
                  "children" === g ? "string" === typeof h ? d.textContent !== h && (true !== f.suppressHydrationWarning && Af(d.textContent, h, a), e = ["children", h]) : "number" === typeof h && d.textContent !== "" + h && (true !== f.suppressHydrationWarning && Af(
                    d.textContent,
                    h,
                    a
                  ), e = ["children", "" + h]) : ea.hasOwnProperty(g) && null != h && "onScroll" === g && D("scroll", d);
                }
                switch (c) {
                  case "input":
                    Va(d);
                    db2(d, f, true);
                    break;
                  case "textarea":
                    Va(d);
                    jb(d);
                    break;
                  case "select":
                  case "option":
                    break;
                  default:
                    "function" === typeof f.onClick && (d.onclick = Bf);
                }
                d = e;
                b.updateQueue = d;
                null !== d && (b.flags |= 4);
              } else {
                g = 9 === e.nodeType ? e : e.ownerDocument;
                "http://www.w3.org/1999/xhtml" === a && (a = kb(c));
                "http://www.w3.org/1999/xhtml" === a ? "script" === c ? (a = g.createElement("div"), a.innerHTML = "<script><\/script>", a = a.removeChild(a.firstChild)) : "string" === typeof d.is ? a = g.createElement(c, { is: d.is }) : (a = g.createElement(c), "select" === c && (g = a, d.multiple ? g.multiple = true : d.size && (g.size = d.size))) : a = g.createElementNS(a, c);
                a[Of] = b;
                a[Pf] = d;
                zj(a, b, false, false);
                b.stateNode = a;
                a: {
                  g = vb(c, d);
                  switch (c) {
                    case "dialog":
                      D("cancel", a);
                      D("close", a);
                      e = d;
                      break;
                    case "iframe":
                    case "object":
                    case "embed":
                      D("load", a);
                      e = d;
                      break;
                    case "video":
                    case "audio":
                      for (e = 0; e < lf.length; e++) D(lf[e], a);
                      e = d;
                      break;
                    case "source":
                      D("error", a);
                      e = d;
                      break;
                    case "img":
                    case "image":
                    case "link":
                      D(
                        "error",
                        a
                      );
                      D("load", a);
                      e = d;
                      break;
                    case "details":
                      D("toggle", a);
                      e = d;
                      break;
                    case "input":
                      Za(a, d);
                      e = Ya(a, d);
                      D("invalid", a);
                      break;
                    case "option":
                      e = d;
                      break;
                    case "select":
                      a._wrapperState = { wasMultiple: !!d.multiple };
                      e = A({}, d, { value: void 0 });
                      D("invalid", a);
                      break;
                    case "textarea":
                      hb(a, d);
                      e = gb(a, d);
                      D("invalid", a);
                      break;
                    default:
                      e = d;
                  }
                  ub(c, e);
                  h = e;
                  for (f in h) if (h.hasOwnProperty(f)) {
                    var k = h[f];
                    "style" === f ? sb(a, k) : "dangerouslySetInnerHTML" === f ? (k = k ? k.__html : void 0, null != k && nb(a, k)) : "children" === f ? "string" === typeof k ? ("textarea" !== c || "" !== k) && ob(a, k) : "number" === typeof k && ob(a, "" + k) : "suppressContentEditableWarning" !== f && "suppressHydrationWarning" !== f && "autoFocus" !== f && (ea.hasOwnProperty(f) ? null != k && "onScroll" === f && D("scroll", a) : null != k && ta(a, f, k, g));
                  }
                  switch (c) {
                    case "input":
                      Va(a);
                      db2(a, d, false);
                      break;
                    case "textarea":
                      Va(a);
                      jb(a);
                      break;
                    case "option":
                      null != d.value && a.setAttribute("value", "" + Sa(d.value));
                      break;
                    case "select":
                      a.multiple = !!d.multiple;
                      f = d.value;
                      null != f ? fb(a, !!d.multiple, f, false) : null != d.defaultValue && fb(
                        a,
                        !!d.multiple,
                        d.defaultValue,
                        true
                      );
                      break;
                    default:
                      "function" === typeof e.onClick && (a.onclick = Bf);
                  }
                  switch (c) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                      d = !!d.autoFocus;
                      break a;
                    case "img":
                      d = true;
                      break a;
                    default:
                      d = false;
                  }
                }
                d && (b.flags |= 4);
              }
              null !== b.ref && (b.flags |= 512, b.flags |= 2097152);
            }
            S(b);
            return null;
          case 6:
            if (a && null != b.stateNode) Cj(a, b, a.memoizedProps, d);
            else {
              if ("string" !== typeof d && null === b.stateNode) throw Error(p(166));
              c = xh(wh.current);
              xh(uh.current);
              if (Gg(b)) {
                d = b.stateNode;
                c = b.memoizedProps;
                d[Of] = b;
                if (f = d.nodeValue !== c) {
                  if (a = xg, null !== a) switch (a.tag) {
                    case 3:
                      Af(d.nodeValue, c, 0 !== (a.mode & 1));
                      break;
                    case 5:
                      true !== a.memoizedProps.suppressHydrationWarning && Af(d.nodeValue, c, 0 !== (a.mode & 1));
                  }
                }
                f && (b.flags |= 4);
              } else d = (9 === c.nodeType ? c : c.ownerDocument).createTextNode(d), d[Of] = b, b.stateNode = d;
            }
            S(b);
            return null;
          case 13:
            E(L);
            d = b.memoizedState;
            if (null === a || null !== a.memoizedState && null !== a.memoizedState.dehydrated) {
              if (I && null !== yg && 0 !== (b.mode & 1) && 0 === (b.flags & 128)) Hg(), Ig(), b.flags |= 98560, f = false;
              else if (f = Gg(b), null !== d && null !== d.dehydrated) {
                if (null === a) {
                  if (!f) throw Error(p(318));
                  f = b.memoizedState;
                  f = null !== f ? f.dehydrated : null;
                  if (!f) throw Error(p(317));
                  f[Of] = b;
                } else Ig(), 0 === (b.flags & 128) && (b.memoizedState = null), b.flags |= 4;
                S(b);
                f = false;
              } else null !== zg && (Fj(zg), zg = null), f = true;
              if (!f) return b.flags & 65536 ? b : null;
            }
            if (0 !== (b.flags & 128)) return b.lanes = c, b;
            d = null !== d;
            d !== (null !== a && null !== a.memoizedState) && d && (b.child.flags |= 8192, 0 !== (b.mode & 1) && (null === a || 0 !== (L.current & 1) ? 0 === T && (T = 3) : tj()));
            null !== b.updateQueue && (b.flags |= 4);
            S(b);
            return null;
          case 4:
            return zh(), Aj(a, b), null === a && sf(b.stateNode.containerInfo), S(b), null;
          case 10:
            return ah(b.type._context), S(b), null;
          case 17:
            return Zf(b.type) && $f(), S(b), null;
          case 19:
            E(L);
            f = b.memoizedState;
            if (null === f) return S(b), null;
            d = 0 !== (b.flags & 128);
            g = f.rendering;
            if (null === g) if (d) Dj(f, false);
            else {
              if (0 !== T || null !== a && 0 !== (a.flags & 128)) for (a = b.child; null !== a; ) {
                g = Ch(a);
                if (null !== g) {
                  b.flags |= 128;
                  Dj(f, false);
                  d = g.updateQueue;
                  null !== d && (b.updateQueue = d, b.flags |= 4);
                  b.subtreeFlags = 0;
                  d = c;
                  for (c = b.child; null !== c; ) f = c, a = d, f.flags &= 14680066, g = f.alternate, null === g ? (f.childLanes = 0, f.lanes = a, f.child = null, f.subtreeFlags = 0, f.memoizedProps = null, f.memoizedState = null, f.updateQueue = null, f.dependencies = null, f.stateNode = null) : (f.childLanes = g.childLanes, f.lanes = g.lanes, f.child = g.child, f.subtreeFlags = 0, f.deletions = null, f.memoizedProps = g.memoizedProps, f.memoizedState = g.memoizedState, f.updateQueue = g.updateQueue, f.type = g.type, a = g.dependencies, f.dependencies = null === a ? null : { lanes: a.lanes, firstContext: a.firstContext }), c = c.sibling;
                  G(L, L.current & 1 | 2);
                  return b.child;
                }
                a = a.sibling;
              }
              null !== f.tail && B() > Gj && (b.flags |= 128, d = true, Dj(f, false), b.lanes = 4194304);
            }
            else {
              if (!d) if (a = Ch(g), null !== a) {
                if (b.flags |= 128, d = true, c = a.updateQueue, null !== c && (b.updateQueue = c, b.flags |= 4), Dj(f, true), null === f.tail && "hidden" === f.tailMode && !g.alternate && !I) return S(b), null;
              } else 2 * B() - f.renderingStartTime > Gj && 1073741824 !== c && (b.flags |= 128, d = true, Dj(f, false), b.lanes = 4194304);
              f.isBackwards ? (g.sibling = b.child, b.child = g) : (c = f.last, null !== c ? c.sibling = g : b.child = g, f.last = g);
            }
            if (null !== f.tail) return b = f.tail, f.rendering = b, f.tail = b.sibling, f.renderingStartTime = B(), b.sibling = null, c = L.current, G(L, d ? c & 1 | 2 : c & 1), b;
            S(b);
            return null;
          case 22:
          case 23:
            return Hj(), d = null !== b.memoizedState, null !== a && null !== a.memoizedState !== d && (b.flags |= 8192), d && 0 !== (b.mode & 1) ? 0 !== (fj & 1073741824) && (S(b), b.subtreeFlags & 6 && (b.flags |= 8192)) : S(b), null;
          case 24:
            return null;
          case 25:
            return null;
        }
        throw Error(p(156, b.tag));
      }
      function Ij(a, b) {
        wg(b);
        switch (b.tag) {
          case 1:
            return Zf(b.type) && $f(), a = b.flags, a & 65536 ? (b.flags = a & -65537 | 128, b) : null;
          case 3:
            return zh(), E(Wf), E(H), Eh(), a = b.flags, 0 !== (a & 65536) && 0 === (a & 128) ? (b.flags = a & -65537 | 128, b) : null;
          case 5:
            return Bh(b), null;
          case 13:
            E(L);
            a = b.memoizedState;
            if (null !== a && null !== a.dehydrated) {
              if (null === b.alternate) throw Error(p(340));
              Ig();
            }
            a = b.flags;
            return a & 65536 ? (b.flags = a & -65537 | 128, b) : null;
          case 19:
            return E(L), null;
          case 4:
            return zh(), null;
          case 10:
            return ah(b.type._context), null;
          case 22:
          case 23:
            return Hj(), null;
          case 24:
            return null;
          default:
            return null;
        }
      }
      var Jj = false;
      var U = false;
      var Kj = "function" === typeof WeakSet ? WeakSet : Set;
      var V = null;
      function Lj(a, b) {
        var c = a.ref;
        if (null !== c) if ("function" === typeof c) try {
          c(null);
        } catch (d) {
          W(a, b, d);
        }
        else c.current = null;
      }
      function Mj(a, b, c) {
        try {
          c();
        } catch (d) {
          W(a, b, d);
        }
      }
      var Nj = false;
      function Oj(a, b) {
        Cf = dd;
        a = Me();
        if (Ne(a)) {
          if ("selectionStart" in a) var c = { start: a.selectionStart, end: a.selectionEnd };
          else a: {
            c = (c = a.ownerDocument) && c.defaultView || window;
            var d = c.getSelection && c.getSelection();
            if (d && 0 !== d.rangeCount) {
              c = d.anchorNode;
              var e = d.anchorOffset, f = d.focusNode;
              d = d.focusOffset;
              try {
                c.nodeType, f.nodeType;
              } catch (F) {
                c = null;
                break a;
              }
              var g = 0, h = -1, k = -1, l = 0, m = 0, q = a, r = null;
              b: for (; ; ) {
                for (var y; ; ) {
                  q !== c || 0 !== e && 3 !== q.nodeType || (h = g + e);
                  q !== f || 0 !== d && 3 !== q.nodeType || (k = g + d);
                  3 === q.nodeType && (g += q.nodeValue.length);
                  if (null === (y = q.firstChild)) break;
                  r = q;
                  q = y;
                }
                for (; ; ) {
                  if (q === a) break b;
                  r === c && ++l === e && (h = g);
                  r === f && ++m === d && (k = g);
                  if (null !== (y = q.nextSibling)) break;
                  q = r;
                  r = q.parentNode;
                }
                q = y;
              }
              c = -1 === h || -1 === k ? null : { start: h, end: k };
            } else c = null;
          }
          c = c || { start: 0, end: 0 };
        } else c = null;
        Df = { focusedElem: a, selectionRange: c };
        dd = false;
        for (V = b; null !== V; ) if (b = V, a = b.child, 0 !== (b.subtreeFlags & 1028) && null !== a) a.return = b, V = a;
        else for (; null !== V; ) {
          b = V;
          try {
            var n = b.alternate;
            if (0 !== (b.flags & 1024)) switch (b.tag) {
              case 0:
              case 11:
              case 15:
                break;
              case 1:
                if (null !== n) {
                  var t = n.memoizedProps, J = n.memoizedState, x = b.stateNode, w2 = x.getSnapshotBeforeUpdate(b.elementType === b.type ? t : Ci(b.type, t), J);
                  x.__reactInternalSnapshotBeforeUpdate = w2;
                }
                break;
              case 3:
                var u = b.stateNode.containerInfo;
                1 === u.nodeType ? u.textContent = "" : 9 === u.nodeType && u.documentElement && u.removeChild(u.documentElement);
                break;
              case 5:
              case 6:
              case 4:
              case 17:
                break;
              default:
                throw Error(p(163));
            }
          } catch (F) {
            W(b, b.return, F);
          }
          a = b.sibling;
          if (null !== a) {
            a.return = b.return;
            V = a;
            break;
          }
          V = b.return;
        }
        n = Nj;
        Nj = false;
        return n;
      }
      function Pj(a, b, c) {
        var d = b.updateQueue;
        d = null !== d ? d.lastEffect : null;
        if (null !== d) {
          var e = d = d.next;
          do {
            if ((e.tag & a) === a) {
              var f = e.destroy;
              e.destroy = void 0;
              void 0 !== f && Mj(b, c, f);
            }
            e = e.next;
          } while (e !== d);
        }
      }
      function Qj(a, b) {
        b = b.updateQueue;
        b = null !== b ? b.lastEffect : null;
        if (null !== b) {
          var c = b = b.next;
          do {
            if ((c.tag & a) === a) {
              var d = c.create;
              c.destroy = d();
            }
            c = c.next;
          } while (c !== b);
        }
      }
      function Rj(a) {
        var b = a.ref;
        if (null !== b) {
          var c = a.stateNode;
          switch (a.tag) {
            case 5:
              a = c;
              break;
            default:
              a = c;
          }
          "function" === typeof b ? b(a) : b.current = a;
        }
      }
      function Sj(a) {
        var b = a.alternate;
        null !== b && (a.alternate = null, Sj(b));
        a.child = null;
        a.deletions = null;
        a.sibling = null;
        5 === a.tag && (b = a.stateNode, null !== b && (delete b[Of], delete b[Pf], delete b[of], delete b[Qf], delete b[Rf]));
        a.stateNode = null;
        a.return = null;
        a.dependencies = null;
        a.memoizedProps = null;
        a.memoizedState = null;
        a.pendingProps = null;
        a.stateNode = null;
        a.updateQueue = null;
      }
      function Tj(a) {
        return 5 === a.tag || 3 === a.tag || 4 === a.tag;
      }
      function Uj(a) {
        a: for (; ; ) {
          for (; null === a.sibling; ) {
            if (null === a.return || Tj(a.return)) return null;
            a = a.return;
          }
          a.sibling.return = a.return;
          for (a = a.sibling; 5 !== a.tag && 6 !== a.tag && 18 !== a.tag; ) {
            if (a.flags & 2) continue a;
            if (null === a.child || 4 === a.tag) continue a;
            else a.child.return = a, a = a.child;
          }
          if (!(a.flags & 2)) return a.stateNode;
        }
      }
      function Vj(a, b, c) {
        var d = a.tag;
        if (5 === d || 6 === d) a = a.stateNode, b ? 8 === c.nodeType ? c.parentNode.insertBefore(a, b) : c.insertBefore(a, b) : (8 === c.nodeType ? (b = c.parentNode, b.insertBefore(a, c)) : (b = c, b.appendChild(a)), c = c._reactRootContainer, null !== c && void 0 !== c || null !== b.onclick || (b.onclick = Bf));
        else if (4 !== d && (a = a.child, null !== a)) for (Vj(a, b, c), a = a.sibling; null !== a; ) Vj(a, b, c), a = a.sibling;
      }
      function Wj(a, b, c) {
        var d = a.tag;
        if (5 === d || 6 === d) a = a.stateNode, b ? c.insertBefore(a, b) : c.appendChild(a);
        else if (4 !== d && (a = a.child, null !== a)) for (Wj(a, b, c), a = a.sibling; null !== a; ) Wj(a, b, c), a = a.sibling;
      }
      var X = null;
      var Xj = false;
      function Yj(a, b, c) {
        for (c = c.child; null !== c; ) Zj(a, b, c), c = c.sibling;
      }
      function Zj(a, b, c) {
        if (lc && "function" === typeof lc.onCommitFiberUnmount) try {
          lc.onCommitFiberUnmount(kc, c);
        } catch (h) {
        }
        switch (c.tag) {
          case 5:
            U || Lj(c, b);
          case 6:
            var d = X, e = Xj;
            X = null;
            Yj(a, b, c);
            X = d;
            Xj = e;
            null !== X && (Xj ? (a = X, c = c.stateNode, 8 === a.nodeType ? a.parentNode.removeChild(c) : a.removeChild(c)) : X.removeChild(c.stateNode));
            break;
          case 18:
            null !== X && (Xj ? (a = X, c = c.stateNode, 8 === a.nodeType ? Kf(a.parentNode, c) : 1 === a.nodeType && Kf(a, c), bd(a)) : Kf(X, c.stateNode));
            break;
          case 4:
            d = X;
            e = Xj;
            X = c.stateNode.containerInfo;
            Xj = true;
            Yj(a, b, c);
            X = d;
            Xj = e;
            break;
          case 0:
          case 11:
          case 14:
          case 15:
            if (!U && (d = c.updateQueue, null !== d && (d = d.lastEffect, null !== d))) {
              e = d = d.next;
              do {
                var f = e, g = f.destroy;
                f = f.tag;
                void 0 !== g && (0 !== (f & 2) ? Mj(c, b, g) : 0 !== (f & 4) && Mj(c, b, g));
                e = e.next;
              } while (e !== d);
            }
            Yj(a, b, c);
            break;
          case 1:
            if (!U && (Lj(c, b), d = c.stateNode, "function" === typeof d.componentWillUnmount)) try {
              d.props = c.memoizedProps, d.state = c.memoizedState, d.componentWillUnmount();
            } catch (h) {
              W(c, b, h);
            }
            Yj(a, b, c);
            break;
          case 21:
            Yj(a, b, c);
            break;
          case 22:
            c.mode & 1 ? (U = (d = U) || null !== c.memoizedState, Yj(a, b, c), U = d) : Yj(a, b, c);
            break;
          default:
            Yj(a, b, c);
        }
      }
      function ak(a) {
        var b = a.updateQueue;
        if (null !== b) {
          a.updateQueue = null;
          var c = a.stateNode;
          null === c && (c = a.stateNode = new Kj());
          b.forEach(function(b2) {
            var d = bk.bind(null, a, b2);
            c.has(b2) || (c.add(b2), b2.then(d, d));
          });
        }
      }
      function ck(a, b) {
        var c = b.deletions;
        if (null !== c) for (var d = 0; d < c.length; d++) {
          var e = c[d];
          try {
            var f = a, g = b, h = g;
            a: for (; null !== h; ) {
              switch (h.tag) {
                case 5:
                  X = h.stateNode;
                  Xj = false;
                  break a;
                case 3:
                  X = h.stateNode.containerInfo;
                  Xj = true;
                  break a;
                case 4:
                  X = h.stateNode.containerInfo;
                  Xj = true;
                  break a;
              }
              h = h.return;
            }
            if (null === X) throw Error(p(160));
            Zj(f, g, e);
            X = null;
            Xj = false;
            var k = e.alternate;
            null !== k && (k.return = null);
            e.return = null;
          } catch (l) {
            W(e, b, l);
          }
        }
        if (b.subtreeFlags & 12854) for (b = b.child; null !== b; ) dk(b, a), b = b.sibling;
      }
      function dk(a, b) {
        var c = a.alternate, d = a.flags;
        switch (a.tag) {
          case 0:
          case 11:
          case 14:
          case 15:
            ck(b, a);
            ek(a);
            if (d & 4) {
              try {
                Pj(3, a, a.return), Qj(3, a);
              } catch (t) {
                W(a, a.return, t);
              }
              try {
                Pj(5, a, a.return);
              } catch (t) {
                W(a, a.return, t);
              }
            }
            break;
          case 1:
            ck(b, a);
            ek(a);
            d & 512 && null !== c && Lj(c, c.return);
            break;
          case 5:
            ck(b, a);
            ek(a);
            d & 512 && null !== c && Lj(c, c.return);
            if (a.flags & 32) {
              var e = a.stateNode;
              try {
                ob(e, "");
              } catch (t) {
                W(a, a.return, t);
              }
            }
            if (d & 4 && (e = a.stateNode, null != e)) {
              var f = a.memoizedProps, g = null !== c ? c.memoizedProps : f, h = a.type, k = a.updateQueue;
              a.updateQueue = null;
              if (null !== k) try {
                "input" === h && "radio" === f.type && null != f.name && ab(e, f);
                vb(h, g);
                var l = vb(h, f);
                for (g = 0; g < k.length; g += 2) {
                  var m = k[g], q = k[g + 1];
                  "style" === m ? sb(e, q) : "dangerouslySetInnerHTML" === m ? nb(e, q) : "children" === m ? ob(e, q) : ta(e, m, q, l);
                }
                switch (h) {
                  case "input":
                    bb(e, f);
                    break;
                  case "textarea":
                    ib(e, f);
                    break;
                  case "select":
                    var r = e._wrapperState.wasMultiple;
                    e._wrapperState.wasMultiple = !!f.multiple;
                    var y = f.value;
                    null != y ? fb(e, !!f.multiple, y, false) : r !== !!f.multiple && (null != f.defaultValue ? fb(
                      e,
                      !!f.multiple,
                      f.defaultValue,
                      true
                    ) : fb(e, !!f.multiple, f.multiple ? [] : "", false));
                }
                e[Pf] = f;
              } catch (t) {
                W(a, a.return, t);
              }
            }
            break;
          case 6:
            ck(b, a);
            ek(a);
            if (d & 4) {
              if (null === a.stateNode) throw Error(p(162));
              e = a.stateNode;
              f = a.memoizedProps;
              try {
                e.nodeValue = f;
              } catch (t) {
                W(a, a.return, t);
              }
            }
            break;
          case 3:
            ck(b, a);
            ek(a);
            if (d & 4 && null !== c && c.memoizedState.isDehydrated) try {
              bd(b.containerInfo);
            } catch (t) {
              W(a, a.return, t);
            }
            break;
          case 4:
            ck(b, a);
            ek(a);
            break;
          case 13:
            ck(b, a);
            ek(a);
            e = a.child;
            e.flags & 8192 && (f = null !== e.memoizedState, e.stateNode.isHidden = f, !f || null !== e.alternate && null !== e.alternate.memoizedState || (fk = B()));
            d & 4 && ak(a);
            break;
          case 22:
            m = null !== c && null !== c.memoizedState;
            a.mode & 1 ? (U = (l = U) || m, ck(b, a), U = l) : ck(b, a);
            ek(a);
            if (d & 8192) {
              l = null !== a.memoizedState;
              if ((a.stateNode.isHidden = l) && !m && 0 !== (a.mode & 1)) for (V = a, m = a.child; null !== m; ) {
                for (q = V = m; null !== V; ) {
                  r = V;
                  y = r.child;
                  switch (r.tag) {
                    case 0:
                    case 11:
                    case 14:
                    case 15:
                      Pj(4, r, r.return);
                      break;
                    case 1:
                      Lj(r, r.return);
                      var n = r.stateNode;
                      if ("function" === typeof n.componentWillUnmount) {
                        d = r;
                        c = r.return;
                        try {
                          b = d, n.props = b.memoizedProps, n.state = b.memoizedState, n.componentWillUnmount();
                        } catch (t) {
                          W(d, c, t);
                        }
                      }
                      break;
                    case 5:
                      Lj(r, r.return);
                      break;
                    case 22:
                      if (null !== r.memoizedState) {
                        gk(q);
                        continue;
                      }
                  }
                  null !== y ? (y.return = r, V = y) : gk(q);
                }
                m = m.sibling;
              }
              a: for (m = null, q = a; ; ) {
                if (5 === q.tag) {
                  if (null === m) {
                    m = q;
                    try {
                      e = q.stateNode, l ? (f = e.style, "function" === typeof f.setProperty ? f.setProperty("display", "none", "important") : f.display = "none") : (h = q.stateNode, k = q.memoizedProps.style, g = void 0 !== k && null !== k && k.hasOwnProperty("display") ? k.display : null, h.style.display = rb("display", g));
                    } catch (t) {
                      W(a, a.return, t);
                    }
                  }
                } else if (6 === q.tag) {
                  if (null === m) try {
                    q.stateNode.nodeValue = l ? "" : q.memoizedProps;
                  } catch (t) {
                    W(a, a.return, t);
                  }
                } else if ((22 !== q.tag && 23 !== q.tag || null === q.memoizedState || q === a) && null !== q.child) {
                  q.child.return = q;
                  q = q.child;
                  continue;
                }
                if (q === a) break a;
                for (; null === q.sibling; ) {
                  if (null === q.return || q.return === a) break a;
                  m === q && (m = null);
                  q = q.return;
                }
                m === q && (m = null);
                q.sibling.return = q.return;
                q = q.sibling;
              }
            }
            break;
          case 19:
            ck(b, a);
            ek(a);
            d & 4 && ak(a);
            break;
          case 21:
            break;
          default:
            ck(
              b,
              a
            ), ek(a);
        }
      }
      function ek(a) {
        var b = a.flags;
        if (b & 2) {
          try {
            a: {
              for (var c = a.return; null !== c; ) {
                if (Tj(c)) {
                  var d = c;
                  break a;
                }
                c = c.return;
              }
              throw Error(p(160));
            }
            switch (d.tag) {
              case 5:
                var e = d.stateNode;
                d.flags & 32 && (ob(e, ""), d.flags &= -33);
                var f = Uj(a);
                Wj(a, f, e);
                break;
              case 3:
              case 4:
                var g = d.stateNode.containerInfo, h = Uj(a);
                Vj(a, h, g);
                break;
              default:
                throw Error(p(161));
            }
          } catch (k) {
            W(a, a.return, k);
          }
          a.flags &= -3;
        }
        b & 4096 && (a.flags &= -4097);
      }
      function hk(a, b, c) {
        V = a;
        ik(a, b, c);
      }
      function ik(a, b, c) {
        for (var d = 0 !== (a.mode & 1); null !== V; ) {
          var e = V, f = e.child;
          if (22 === e.tag && d) {
            var g = null !== e.memoizedState || Jj;
            if (!g) {
              var h = e.alternate, k = null !== h && null !== h.memoizedState || U;
              h = Jj;
              var l = U;
              Jj = g;
              if ((U = k) && !l) for (V = e; null !== V; ) g = V, k = g.child, 22 === g.tag && null !== g.memoizedState ? jk(e) : null !== k ? (k.return = g, V = k) : jk(e);
              for (; null !== f; ) V = f, ik(f, b, c), f = f.sibling;
              V = e;
              Jj = h;
              U = l;
            }
            kk(a, b, c);
          } else 0 !== (e.subtreeFlags & 8772) && null !== f ? (f.return = e, V = f) : kk(a, b, c);
        }
      }
      function kk(a) {
        for (; null !== V; ) {
          var b = V;
          if (0 !== (b.flags & 8772)) {
            var c = b.alternate;
            try {
              if (0 !== (b.flags & 8772)) switch (b.tag) {
                case 0:
                case 11:
                case 15:
                  U || Qj(5, b);
                  break;
                case 1:
                  var d = b.stateNode;
                  if (b.flags & 4 && !U) if (null === c) d.componentDidMount();
                  else {
                    var e = b.elementType === b.type ? c.memoizedProps : Ci(b.type, c.memoizedProps);
                    d.componentDidUpdate(e, c.memoizedState, d.__reactInternalSnapshotBeforeUpdate);
                  }
                  var f = b.updateQueue;
                  null !== f && sh(b, f, d);
                  break;
                case 3:
                  var g = b.updateQueue;
                  if (null !== g) {
                    c = null;
                    if (null !== b.child) switch (b.child.tag) {
                      case 5:
                        c = b.child.stateNode;
                        break;
                      case 1:
                        c = b.child.stateNode;
                    }
                    sh(b, g, c);
                  }
                  break;
                case 5:
                  var h = b.stateNode;
                  if (null === c && b.flags & 4) {
                    c = h;
                    var k = b.memoizedProps;
                    switch (b.type) {
                      case "button":
                      case "input":
                      case "select":
                      case "textarea":
                        k.autoFocus && c.focus();
                        break;
                      case "img":
                        k.src && (c.src = k.src);
                    }
                  }
                  break;
                case 6:
                  break;
                case 4:
                  break;
                case 12:
                  break;
                case 13:
                  if (null === b.memoizedState) {
                    var l = b.alternate;
                    if (null !== l) {
                      var m = l.memoizedState;
                      if (null !== m) {
                        var q = m.dehydrated;
                        null !== q && bd(q);
                      }
                    }
                  }
                  break;
                case 19:
                case 17:
                case 21:
                case 22:
                case 23:
                case 25:
                  break;
                default:
                  throw Error(p(163));
              }
              U || b.flags & 512 && Rj(b);
            } catch (r) {
              W(b, b.return, r);
            }
          }
          if (b === a) {
            V = null;
            break;
          }
          c = b.sibling;
          if (null !== c) {
            c.return = b.return;
            V = c;
            break;
          }
          V = b.return;
        }
      }
      function gk(a) {
        for (; null !== V; ) {
          var b = V;
          if (b === a) {
            V = null;
            break;
          }
          var c = b.sibling;
          if (null !== c) {
            c.return = b.return;
            V = c;
            break;
          }
          V = b.return;
        }
      }
      function jk(a) {
        for (; null !== V; ) {
          var b = V;
          try {
            switch (b.tag) {
              case 0:
              case 11:
              case 15:
                var c = b.return;
                try {
                  Qj(4, b);
                } catch (k) {
                  W(b, c, k);
                }
                break;
              case 1:
                var d = b.stateNode;
                if ("function" === typeof d.componentDidMount) {
                  var e = b.return;
                  try {
                    d.componentDidMount();
                  } catch (k) {
                    W(b, e, k);
                  }
                }
                var f = b.return;
                try {
                  Rj(b);
                } catch (k) {
                  W(b, f, k);
                }
                break;
              case 5:
                var g = b.return;
                try {
                  Rj(b);
                } catch (k) {
                  W(b, g, k);
                }
            }
          } catch (k) {
            W(b, b.return, k);
          }
          if (b === a) {
            V = null;
            break;
          }
          var h = b.sibling;
          if (null !== h) {
            h.return = b.return;
            V = h;
            break;
          }
          V = b.return;
        }
      }
      var lk = Math.ceil;
      var mk = ua.ReactCurrentDispatcher;
      var nk = ua.ReactCurrentOwner;
      var ok = ua.ReactCurrentBatchConfig;
      var K = 0;
      var Q = null;
      var Y = null;
      var Z = 0;
      var fj = 0;
      var ej = Uf(0);
      var T = 0;
      var pk = null;
      var rh = 0;
      var qk = 0;
      var rk = 0;
      var sk = null;
      var tk = null;
      var fk = 0;
      var Gj = Infinity;
      var uk = null;
      var Oi = false;
      var Pi = null;
      var Ri = null;
      var vk = false;
      var wk = null;
      var xk = 0;
      var yk = 0;
      var zk = null;
      var Ak = -1;
      var Bk = 0;
      function R() {
        return 0 !== (K & 6) ? B() : -1 !== Ak ? Ak : Ak = B();
      }
      function yi(a) {
        if (0 === (a.mode & 1)) return 1;
        if (0 !== (K & 2) && 0 !== Z) return Z & -Z;
        if (null !== Kg.transition) return 0 === Bk && (Bk = yc()), Bk;
        a = C;
        if (0 !== a) return a;
        a = window.event;
        a = void 0 === a ? 16 : jd(a.type);
        return a;
      }
      function gi(a, b, c, d) {
        if (50 < yk) throw yk = 0, zk = null, Error(p(185));
        Ac(a, c, d);
        if (0 === (K & 2) || a !== Q) a === Q && (0 === (K & 2) && (qk |= c), 4 === T && Ck(a, Z)), Dk(a, d), 1 === c && 0 === K && 0 === (b.mode & 1) && (Gj = B() + 500, fg21 && jg());
      }
      function Dk(a, b) {
        var c = a.callbackNode;
        wc(a, b);
        var d = uc(a, a === Q ? Z : 0);
        if (0 === d) null !== c && bc(c), a.callbackNode = null, a.callbackPriority = 0;
        else if (b = d & -d, a.callbackPriority !== b) {
          null != c && bc(c);
          if (1 === b) 0 === a.tag ? ig(Ek.bind(null, a)) : hg(Ek.bind(null, a)), Jf(function() {
            0 === (K & 6) && jg();
          }), c = null;
          else {
            switch (Dc(d)) {
              case 1:
                c = fc;
                break;
              case 4:
                c = gc;
                break;
              case 16:
                c = hc;
                break;
              case 536870912:
                c = jc;
                break;
              default:
                c = hc;
            }
            c = Fk(c, Gk.bind(null, a));
          }
          a.callbackPriority = b;
          a.callbackNode = c;
        }
      }
      function Gk(a, b) {
        Ak = -1;
        Bk = 0;
        if (0 !== (K & 6)) throw Error(p(327));
        var c = a.callbackNode;
        if (Hk() && a.callbackNode !== c) return null;
        var d = uc(a, a === Q ? Z : 0);
        if (0 === d) return null;
        if (0 !== (d & 30) || 0 !== (d & a.expiredLanes) || b) b = Ik(a, d);
        else {
          b = d;
          var e = K;
          K |= 2;
          var f = Jk();
          if (Q !== a || Z !== b) uk = null, Gj = B() + 500, Kk(a, b);
          do
            try {
              Lk();
              break;
            } catch (h) {
              Mk(a, h);
            }
          while (1);
          $g();
          mk.current = f;
          K = e;
          null !== Y ? b = 0 : (Q = null, Z = 0, b = T);
        }
        if (0 !== b) {
          2 === b && (e = xc(a), 0 !== e && (d = e, b = Nk(a, e)));
          if (1 === b) throw c = pk, Kk(a, 0), Ck(a, d), Dk(a, B()), c;
          if (6 === b) Ck(a, d);
          else {
            e = a.current.alternate;
            if (0 === (d & 30) && !Ok(e) && (b = Ik(a, d), 2 === b && (f = xc(a), 0 !== f && (d = f, b = Nk(a, f))), 1 === b)) throw c = pk, Kk(a, 0), Ck(a, d), Dk(a, B()), c;
            a.finishedWork = e;
            a.finishedLanes = d;
            switch (b) {
              case 0:
              case 1:
                throw Error(p(345));
              case 2:
                Pk(a, tk, uk);
                break;
              case 3:
                Ck(a, d);
                if ((d & 130023424) === d && (b = fk + 500 - B(), 10 < b)) {
                  if (0 !== uc(a, 0)) break;
                  e = a.suspendedLanes;
                  if ((e & d) !== d) {
                    R();
                    a.pingedLanes |= a.suspendedLanes & e;
                    break;
                  }
                  a.timeoutHandle = Ff(Pk.bind(null, a, tk, uk), b);
                  break;
                }
                Pk(a, tk, uk);
                break;
              case 4:
                Ck(a, d);
                if ((d & 4194240) === d) break;
                b = a.eventTimes;
                for (e = -1; 0 < d; ) {
                  var g = 31 - oc(d);
                  f = 1 << g;
                  g = b[g];
                  g > e && (e = g);
                  d &= ~f;
                }
                d = e;
                d = B() - d;
                d = (120 > d ? 120 : 480 > d ? 480 : 1080 > d ? 1080 : 1920 > d ? 1920 : 3e3 > d ? 3e3 : 4320 > d ? 4320 : 1960 * lk(d / 1960)) - d;
                if (10 < d) {
                  a.timeoutHandle = Ff(Pk.bind(null, a, tk, uk), d);
                  break;
                }
                Pk(a, tk, uk);
                break;
              case 5:
                Pk(a, tk, uk);
                break;
              default:
                throw Error(p(329));
            }
          }
        }
        Dk(a, B());
        return a.callbackNode === c ? Gk.bind(null, a) : null;
      }
      function Nk(a, b) {
        var c = sk;
        a.current.memoizedState.isDehydrated && (Kk(a, b).flags |= 256);
        a = Ik(a, b);
        2 !== a && (b = tk, tk = c, null !== b && Fj(b));
        return a;
      }
      function Fj(a) {
        null === tk ? tk = a : tk.push.apply(tk, a);
      }
      function Ok(a) {
        for (var b = a; ; ) {
          if (b.flags & 16384) {
            var c = b.updateQueue;
            if (null !== c && (c = c.stores, null !== c)) for (var d = 0; d < c.length; d++) {
              var e = c[d], f = e.getSnapshot;
              e = e.value;
              try {
                if (!He(f(), e)) return false;
              } catch (g) {
                return false;
              }
            }
          }
          c = b.child;
          if (b.subtreeFlags & 16384 && null !== c) c.return = b, b = c;
          else {
            if (b === a) break;
            for (; null === b.sibling; ) {
              if (null === b.return || b.return === a) return true;
              b = b.return;
            }
            b.sibling.return = b.return;
            b = b.sibling;
          }
        }
        return true;
      }
      function Ck(a, b) {
        b &= ~rk;
        b &= ~qk;
        a.suspendedLanes |= b;
        a.pingedLanes &= ~b;
        for (a = a.expirationTimes; 0 < b; ) {
          var c = 31 - oc(b), d = 1 << c;
          a[c] = -1;
          b &= ~d;
        }
      }
      function Ek(a) {
        if (0 !== (K & 6)) throw Error(p(327));
        Hk();
        var b = uc(a, 0);
        if (0 === (b & 1)) return Dk(a, B()), null;
        var c = Ik(a, b);
        if (0 !== a.tag && 2 === c) {
          var d = xc(a);
          0 !== d && (b = d, c = Nk(a, d));
        }
        if (1 === c) throw c = pk, Kk(a, 0), Ck(a, b), Dk(a, B()), c;
        if (6 === c) throw Error(p(345));
        a.finishedWork = a.current.alternate;
        a.finishedLanes = b;
        Pk(a, tk, uk);
        Dk(a, B());
        return null;
      }
      function Qk(a, b) {
        var c = K;
        K |= 1;
        try {
          return a(b);
        } finally {
          K = c, 0 === K && (Gj = B() + 500, fg21 && jg());
        }
      }
      function Rk(a) {
        null !== wk && 0 === wk.tag && 0 === (K & 6) && Hk();
        var b = K;
        K |= 1;
        var c = ok.transition, d = C;
        try {
          if (ok.transition = null, C = 1, a) return a();
        } finally {
          C = d, ok.transition = c, K = b, 0 === (K & 6) && jg();
        }
      }
      function Hj() {
        fj = ej.current;
        E(ej);
      }
      function Kk(a, b) {
        a.finishedWork = null;
        a.finishedLanes = 0;
        var c = a.timeoutHandle;
        -1 !== c && (a.timeoutHandle = -1, Gf(c));
        if (null !== Y) for (c = Y.return; null !== c; ) {
          var d = c;
          wg(d);
          switch (d.tag) {
            case 1:
              d = d.type.childContextTypes;
              null !== d && void 0 !== d && $f();
              break;
            case 3:
              zh();
              E(Wf);
              E(H);
              Eh();
              break;
            case 5:
              Bh(d);
              break;
            case 4:
              zh();
              break;
            case 13:
              E(L);
              break;
            case 19:
              E(L);
              break;
            case 10:
              ah(d.type._context);
              break;
            case 22:
            case 23:
              Hj();
          }
          c = c.return;
        }
        Q = a;
        Y = a = Pg(a.current, null);
        Z = fj = b;
        T = 0;
        pk = null;
        rk = qk = rh = 0;
        tk = sk = null;
        if (null !== fh) {
          for (b = 0; b < fh.length; b++) if (c = fh[b], d = c.interleaved, null !== d) {
            c.interleaved = null;
            var e = d.next, f = c.pending;
            if (null !== f) {
              var g = f.next;
              f.next = e;
              d.next = g;
            }
            c.pending = d;
          }
          fh = null;
        }
        return a;
      }
      function Mk(a, b) {
        do {
          var c = Y;
          try {
            $g();
            Fh.current = Rh;
            if (Ih) {
              for (var d = M.memoizedState; null !== d; ) {
                var e = d.queue;
                null !== e && (e.pending = null);
                d = d.next;
              }
              Ih = false;
            }
            Hh = 0;
            O = N = M = null;
            Jh = false;
            Kh = 0;
            nk.current = null;
            if (null === c || null === c.return) {
              T = 1;
              pk = b;
              Y = null;
              break;
            }
            a: {
              var f = a, g = c.return, h = c, k = b;
              b = Z;
              h.flags |= 32768;
              if (null !== k && "object" === typeof k && "function" === typeof k.then) {
                var l = k, m = h, q = m.tag;
                if (0 === (m.mode & 1) && (0 === q || 11 === q || 15 === q)) {
                  var r = m.alternate;
                  r ? (m.updateQueue = r.updateQueue, m.memoizedState = r.memoizedState, m.lanes = r.lanes) : (m.updateQueue = null, m.memoizedState = null);
                }
                var y = Ui(g);
                if (null !== y) {
                  y.flags &= -257;
                  Vi(y, g, h, f, b);
                  y.mode & 1 && Si(f, l, b);
                  b = y;
                  k = l;
                  var n = b.updateQueue;
                  if (null === n) {
                    var t = /* @__PURE__ */ new Set();
                    t.add(k);
                    b.updateQueue = t;
                  } else n.add(k);
                  break a;
                } else {
                  if (0 === (b & 1)) {
                    Si(f, l, b);
                    tj();
                    break a;
                  }
                  k = Error(p(426));
                }
              } else if (I && h.mode & 1) {
                var J = Ui(g);
                if (null !== J) {
                  0 === (J.flags & 65536) && (J.flags |= 256);
                  Vi(J, g, h, f, b);
                  Jg(Ji(k, h));
                  break a;
                }
              }
              f = k = Ji(k, h);
              4 !== T && (T = 2);
              null === sk ? sk = [f] : sk.push(f);
              f = g;
              do {
                switch (f.tag) {
                  case 3:
                    f.flags |= 65536;
                    b &= -b;
                    f.lanes |= b;
                    var x = Ni(f, k, b);
                    ph(f, x);
                    break a;
                  case 1:
                    h = k;
                    var w2 = f.type, u = f.stateNode;
                    if (0 === (f.flags & 128) && ("function" === typeof w2.getDerivedStateFromError || null !== u && "function" === typeof u.componentDidCatch && (null === Ri || !Ri.has(u)))) {
                      f.flags |= 65536;
                      b &= -b;
                      f.lanes |= b;
                      var F = Qi(f, h, b);
                      ph(f, F);
                      break a;
                    }
                }
                f = f.return;
              } while (null !== f);
            }
            Sk(c);
          } catch (na) {
            b = na;
            Y === c && null !== c && (Y = c = c.return);
            continue;
          }
          break;
        } while (1);
      }
      function Jk() {
        var a = mk.current;
        mk.current = Rh;
        return null === a ? Rh : a;
      }
      function tj() {
        if (0 === T || 3 === T || 2 === T) T = 4;
        null === Q || 0 === (rh & 268435455) && 0 === (qk & 268435455) || Ck(Q, Z);
      }
      function Ik(a, b) {
        var c = K;
        K |= 2;
        var d = Jk();
        if (Q !== a || Z !== b) uk = null, Kk(a, b);
        do
          try {
            Tk();
            break;
          } catch (e) {
            Mk(a, e);
          }
        while (1);
        $g();
        K = c;
        mk.current = d;
        if (null !== Y) throw Error(p(261));
        Q = null;
        Z = 0;
        return T;
      }
      function Tk() {
        for (; null !== Y; ) Uk(Y);
      }
      function Lk() {
        for (; null !== Y && !cc(); ) Uk(Y);
      }
      function Uk(a) {
        var b = Vk(a.alternate, a, fj);
        a.memoizedProps = a.pendingProps;
        null === b ? Sk(a) : Y = b;
        nk.current = null;
      }
      function Sk(a) {
        var b = a;
        do {
          var c = b.alternate;
          a = b.return;
          if (0 === (b.flags & 32768)) {
            if (c = Ej(c, b, fj), null !== c) {
              Y = c;
              return;
            }
          } else {
            c = Ij(c, b);
            if (null !== c) {
              c.flags &= 32767;
              Y = c;
              return;
            }
            if (null !== a) a.flags |= 32768, a.subtreeFlags = 0, a.deletions = null;
            else {
              T = 6;
              Y = null;
              return;
            }
          }
          b = b.sibling;
          if (null !== b) {
            Y = b;
            return;
          }
          Y = b = a;
        } while (null !== b);
        0 === T && (T = 5);
      }
      function Pk(a, b, c) {
        var d = C, e = ok.transition;
        try {
          ok.transition = null, C = 1, Wk(a, b, c, d);
        } finally {
          ok.transition = e, C = d;
        }
        return null;
      }
      function Wk(a, b, c, d) {
        do
          Hk();
        while (null !== wk);
        if (0 !== (K & 6)) throw Error(p(327));
        c = a.finishedWork;
        var e = a.finishedLanes;
        if (null === c) return null;
        a.finishedWork = null;
        a.finishedLanes = 0;
        if (c === a.current) throw Error(p(177));
        a.callbackNode = null;
        a.callbackPriority = 0;
        var f = c.lanes | c.childLanes;
        Bc(a, f);
        a === Q && (Y = Q = null, Z = 0);
        0 === (c.subtreeFlags & 2064) && 0 === (c.flags & 2064) || vk || (vk = true, Fk(hc, function() {
          Hk();
          return null;
        }));
        f = 0 !== (c.flags & 15990);
        if (0 !== (c.subtreeFlags & 15990) || f) {
          f = ok.transition;
          ok.transition = null;
          var g = C;
          C = 1;
          var h = K;
          K |= 4;
          nk.current = null;
          Oj(a, c);
          dk(c, a);
          Oe(Df);
          dd = !!Cf;
          Df = Cf = null;
          a.current = c;
          hk(c, a, e);
          dc();
          K = h;
          C = g;
          ok.transition = f;
        } else a.current = c;
        vk && (vk = false, wk = a, xk = e);
        f = a.pendingLanes;
        0 === f && (Ri = null);
        mc(c.stateNode, d);
        Dk(a, B());
        if (null !== b) for (d = a.onRecoverableError, c = 0; c < b.length; c++) e = b[c], d(e.value, { componentStack: e.stack, digest: e.digest });
        if (Oi) throw Oi = false, a = Pi, Pi = null, a;
        0 !== (xk & 1) && 0 !== a.tag && Hk();
        f = a.pendingLanes;
        0 !== (f & 1) ? a === zk ? yk++ : (yk = 0, zk = a) : yk = 0;
        jg();
        return null;
      }
      function Hk() {
        if (null !== wk) {
          var a = Dc(xk), b = ok.transition, c = C;
          try {
            ok.transition = null;
            C = 16 > a ? 16 : a;
            if (null === wk) var d = false;
            else {
              a = wk;
              wk = null;
              xk = 0;
              if (0 !== (K & 6)) throw Error(p(331));
              var e = K;
              K |= 4;
              for (V = a.current; null !== V; ) {
                var f = V, g = f.child;
                if (0 !== (V.flags & 16)) {
                  var h = f.deletions;
                  if (null !== h) {
                    for (var k = 0; k < h.length; k++) {
                      var l = h[k];
                      for (V = l; null !== V; ) {
                        var m = V;
                        switch (m.tag) {
                          case 0:
                          case 11:
                          case 15:
                            Pj(8, m, f);
                        }
                        var q = m.child;
                        if (null !== q) q.return = m, V = q;
                        else for (; null !== V; ) {
                          m = V;
                          var r = m.sibling, y = m.return;
                          Sj(m);
                          if (m === l) {
                            V = null;
                            break;
                          }
                          if (null !== r) {
                            r.return = y;
                            V = r;
                            break;
                          }
                          V = y;
                        }
                      }
                    }
                    var n = f.alternate;
                    if (null !== n) {
                      var t = n.child;
                      if (null !== t) {
                        n.child = null;
                        do {
                          var J = t.sibling;
                          t.sibling = null;
                          t = J;
                        } while (null !== t);
                      }
                    }
                    V = f;
                  }
                }
                if (0 !== (f.subtreeFlags & 2064) && null !== g) g.return = f, V = g;
                else b: for (; null !== V; ) {
                  f = V;
                  if (0 !== (f.flags & 2048)) switch (f.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Pj(9, f, f.return);
                  }
                  var x = f.sibling;
                  if (null !== x) {
                    x.return = f.return;
                    V = x;
                    break b;
                  }
                  V = f.return;
                }
              }
              var w2 = a.current;
              for (V = w2; null !== V; ) {
                g = V;
                var u = g.child;
                if (0 !== (g.subtreeFlags & 2064) && null !== u) u.return = g, V = u;
                else b: for (g = w2; null !== V; ) {
                  h = V;
                  if (0 !== (h.flags & 2048)) try {
                    switch (h.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Qj(9, h);
                    }
                  } catch (na) {
                    W(h, h.return, na);
                  }
                  if (h === g) {
                    V = null;
                    break b;
                  }
                  var F = h.sibling;
                  if (null !== F) {
                    F.return = h.return;
                    V = F;
                    break b;
                  }
                  V = h.return;
                }
              }
              K = e;
              jg();
              if (lc && "function" === typeof lc.onPostCommitFiberRoot) try {
                lc.onPostCommitFiberRoot(kc, a);
              } catch (na) {
              }
              d = true;
            }
            return d;
          } finally {
            C = c, ok.transition = b;
          }
        }
        return false;
      }
      function Xk(a, b, c) {
        b = Ji(c, b);
        b = Ni(a, b, 1);
        a = nh(a, b, 1);
        b = R();
        null !== a && (Ac(a, 1, b), Dk(a, b));
      }
      function W(a, b, c) {
        if (3 === a.tag) Xk(a, a, c);
        else for (; null !== b; ) {
          if (3 === b.tag) {
            Xk(b, a, c);
            break;
          } else if (1 === b.tag) {
            var d = b.stateNode;
            if ("function" === typeof b.type.getDerivedStateFromError || "function" === typeof d.componentDidCatch && (null === Ri || !Ri.has(d))) {
              a = Ji(c, a);
              a = Qi(b, a, 1);
              b = nh(b, a, 1);
              a = R();
              null !== b && (Ac(b, 1, a), Dk(b, a));
              break;
            }
          }
          b = b.return;
        }
      }
      function Ti(a, b, c) {
        var d = a.pingCache;
        null !== d && d.delete(b);
        b = R();
        a.pingedLanes |= a.suspendedLanes & c;
        Q === a && (Z & c) === c && (4 === T || 3 === T && (Z & 130023424) === Z && 500 > B() - fk ? Kk(a, 0) : rk |= c);
        Dk(a, b);
      }
      function Yk(a, b) {
        0 === b && (0 === (a.mode & 1) ? b = 1 : (b = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
        var c = R();
        a = ih(a, b);
        null !== a && (Ac(a, b, c), Dk(a, c));
      }
      function uj(a) {
        var b = a.memoizedState, c = 0;
        null !== b && (c = b.retryLane);
        Yk(a, c);
      }
      function bk(a, b) {
        var c = 0;
        switch (a.tag) {
          case 13:
            var d = a.stateNode;
            var e = a.memoizedState;
            null !== e && (c = e.retryLane);
            break;
          case 19:
            d = a.stateNode;
            break;
          default:
            throw Error(p(314));
        }
        null !== d && d.delete(b);
        Yk(a, c);
      }
      var Vk;
      Vk = function(a, b, c) {
        if (null !== a) if (a.memoizedProps !== b.pendingProps || Wf.current) dh = true;
        else {
          if (0 === (a.lanes & c) && 0 === (b.flags & 128)) return dh = false, yj(a, b, c);
          dh = 0 !== (a.flags & 131072) ? true : false;
        }
        else dh = false, I && 0 !== (b.flags & 1048576) && ug(b, ng, b.index);
        b.lanes = 0;
        switch (b.tag) {
          case 2:
            var d = b.type;
            ij(a, b);
            a = b.pendingProps;
            var e = Yf(b, H.current);
            ch(b, c);
            e = Nh(null, b, d, a, e, c);
            var f = Sh();
            b.flags |= 1;
            "object" === typeof e && null !== e && "function" === typeof e.render && void 0 === e.$$typeof ? (b.tag = 1, b.memoizedState = null, b.updateQueue = null, Zf(d) ? (f = true, cg(b)) : f = false, b.memoizedState = null !== e.state && void 0 !== e.state ? e.state : null, kh(b), e.updater = Ei, b.stateNode = e, e._reactInternals = b, Ii(b, d, a, c), b = jj(null, b, d, true, f, c)) : (b.tag = 0, I && f && vg(b), Xi(null, b, e, c), b = b.child);
            return b;
          case 16:
            d = b.elementType;
            a: {
              ij(a, b);
              a = b.pendingProps;
              e = d._init;
              d = e(d._payload);
              b.type = d;
              e = b.tag = Zk(d);
              a = Ci(d, a);
              switch (e) {
                case 0:
                  b = cj(null, b, d, a, c);
                  break a;
                case 1:
                  b = hj(null, b, d, a, c);
                  break a;
                case 11:
                  b = Yi(null, b, d, a, c);
                  break a;
                case 14:
                  b = $i(null, b, d, Ci(d.type, a), c);
                  break a;
              }
              throw Error(p(
                306,
                d,
                ""
              ));
            }
            return b;
          case 0:
            return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), cj(a, b, d, e, c);
          case 1:
            return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), hj(a, b, d, e, c);
          case 3:
            a: {
              kj(b);
              if (null === a) throw Error(p(387));
              d = b.pendingProps;
              f = b.memoizedState;
              e = f.element;
              lh(a, b);
              qh(b, d, null, c);
              var g = b.memoizedState;
              d = g.element;
              if (f.isDehydrated) if (f = { element: d, isDehydrated: false, cache: g.cache, pendingSuspenseBoundaries: g.pendingSuspenseBoundaries, transitions: g.transitions }, b.updateQueue.baseState = f, b.memoizedState = f, b.flags & 256) {
                e = Ji(Error(p(423)), b);
                b = lj(a, b, d, c, e);
                break a;
              } else if (d !== e) {
                e = Ji(Error(p(424)), b);
                b = lj(a, b, d, c, e);
                break a;
              } else for (yg = Lf(b.stateNode.containerInfo.firstChild), xg = b, I = true, zg = null, c = Vg(b, null, d, c), b.child = c; c; ) c.flags = c.flags & -3 | 4096, c = c.sibling;
              else {
                Ig();
                if (d === e) {
                  b = Zi(a, b, c);
                  break a;
                }
                Xi(a, b, d, c);
              }
              b = b.child;
            }
            return b;
          case 5:
            return Ah(b), null === a && Eg(b), d = b.type, e = b.pendingProps, f = null !== a ? a.memoizedProps : null, g = e.children, Ef(d, e) ? g = null : null !== f && Ef(d, f) && (b.flags |= 32), gj(a, b), Xi(a, b, g, c), b.child;
          case 6:
            return null === a && Eg(b), null;
          case 13:
            return oj(a, b, c);
          case 4:
            return yh(b, b.stateNode.containerInfo), d = b.pendingProps, null === a ? b.child = Ug(b, null, d, c) : Xi(a, b, d, c), b.child;
          case 11:
            return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), Yi(a, b, d, e, c);
          case 7:
            return Xi(a, b, b.pendingProps, c), b.child;
          case 8:
            return Xi(a, b, b.pendingProps.children, c), b.child;
          case 12:
            return Xi(a, b, b.pendingProps.children, c), b.child;
          case 10:
            a: {
              d = b.type._context;
              e = b.pendingProps;
              f = b.memoizedProps;
              g = e.value;
              G(Wg, d._currentValue);
              d._currentValue = g;
              if (null !== f) if (He(f.value, g)) {
                if (f.children === e.children && !Wf.current) {
                  b = Zi(a, b, c);
                  break a;
                }
              } else for (f = b.child, null !== f && (f.return = b); null !== f; ) {
                var h = f.dependencies;
                if (null !== h) {
                  g = f.child;
                  for (var k = h.firstContext; null !== k; ) {
                    if (k.context === d) {
                      if (1 === f.tag) {
                        k = mh(-1, c & -c);
                        k.tag = 2;
                        var l = f.updateQueue;
                        if (null !== l) {
                          l = l.shared;
                          var m = l.pending;
                          null === m ? k.next = k : (k.next = m.next, m.next = k);
                          l.pending = k;
                        }
                      }
                      f.lanes |= c;
                      k = f.alternate;
                      null !== k && (k.lanes |= c);
                      bh(
                        f.return,
                        c,
                        b
                      );
                      h.lanes |= c;
                      break;
                    }
                    k = k.next;
                  }
                } else if (10 === f.tag) g = f.type === b.type ? null : f.child;
                else if (18 === f.tag) {
                  g = f.return;
                  if (null === g) throw Error(p(341));
                  g.lanes |= c;
                  h = g.alternate;
                  null !== h && (h.lanes |= c);
                  bh(g, c, b);
                  g = f.sibling;
                } else g = f.child;
                if (null !== g) g.return = f;
                else for (g = f; null !== g; ) {
                  if (g === b) {
                    g = null;
                    break;
                  }
                  f = g.sibling;
                  if (null !== f) {
                    f.return = g.return;
                    g = f;
                    break;
                  }
                  g = g.return;
                }
                f = g;
              }
              Xi(a, b, e.children, c);
              b = b.child;
            }
            return b;
          case 9:
            return e = b.type, d = b.pendingProps.children, ch(b, c), e = eh(e), d = d(e), b.flags |= 1, Xi(a, b, d, c), b.child;
          case 14:
            return d = b.type, e = Ci(d, b.pendingProps), e = Ci(d.type, e), $i(a, b, d, e, c);
          case 15:
            return bj(a, b, b.type, b.pendingProps, c);
          case 17:
            return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), ij(a, b), b.tag = 1, Zf(d) ? (a = true, cg(b)) : a = false, ch(b, c), Gi(b, d, e), Ii(b, d, e, c), jj(null, b, d, true, a, c);
          case 19:
            return xj(a, b, c);
          case 22:
            return dj(a, b, c);
        }
        throw Error(p(156, b.tag));
      };
      function Fk(a, b) {
        return ac(a, b);
      }
      function $k(a, b, c, d) {
        this.tag = a;
        this.key = c;
        this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
        this.index = 0;
        this.ref = null;
        this.pendingProps = b;
        this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
        this.mode = d;
        this.subtreeFlags = this.flags = 0;
        this.deletions = null;
        this.childLanes = this.lanes = 0;
        this.alternate = null;
      }
      function Bg(a, b, c, d) {
        return new $k(a, b, c, d);
      }
      function aj(a) {
        a = a.prototype;
        return !(!a || !a.isReactComponent);
      }
      function Zk(a) {
        if ("function" === typeof a) return aj(a) ? 1 : 0;
        if (void 0 !== a && null !== a) {
          a = a.$$typeof;
          if (a === Da) return 11;
          if (a === Ga) return 14;
        }
        return 2;
      }
      function Pg(a, b) {
        var c = a.alternate;
        null === c ? (c = Bg(a.tag, b, a.key, a.mode), c.elementType = a.elementType, c.type = a.type, c.stateNode = a.stateNode, c.alternate = a, a.alternate = c) : (c.pendingProps = b, c.type = a.type, c.flags = 0, c.subtreeFlags = 0, c.deletions = null);
        c.flags = a.flags & 14680064;
        c.childLanes = a.childLanes;
        c.lanes = a.lanes;
        c.child = a.child;
        c.memoizedProps = a.memoizedProps;
        c.memoizedState = a.memoizedState;
        c.updateQueue = a.updateQueue;
        b = a.dependencies;
        c.dependencies = null === b ? null : { lanes: b.lanes, firstContext: b.firstContext };
        c.sibling = a.sibling;
        c.index = a.index;
        c.ref = a.ref;
        return c;
      }
      function Rg(a, b, c, d, e, f) {
        var g = 2;
        d = a;
        if ("function" === typeof a) aj(a) && (g = 1);
        else if ("string" === typeof a) g = 5;
        else a: switch (a) {
          case ya:
            return Tg(c.children, e, f, b);
          case za:
            g = 8;
            e |= 8;
            break;
          case Aa:
            return a = Bg(12, c, b, e | 2), a.elementType = Aa, a.lanes = f, a;
          case Ea:
            return a = Bg(13, c, b, e), a.elementType = Ea, a.lanes = f, a;
          case Fa:
            return a = Bg(19, c, b, e), a.elementType = Fa, a.lanes = f, a;
          case Ia:
            return pj(c, e, f, b);
          default:
            if ("object" === typeof a && null !== a) switch (a.$$typeof) {
              case Ba:
                g = 10;
                break a;
              case Ca:
                g = 9;
                break a;
              case Da:
                g = 11;
                break a;
              case Ga:
                g = 14;
                break a;
              case Ha:
                g = 16;
                d = null;
                break a;
            }
            throw Error(p(130, null == a ? a : typeof a, ""));
        }
        b = Bg(g, c, b, e);
        b.elementType = a;
        b.type = d;
        b.lanes = f;
        return b;
      }
      function Tg(a, b, c, d) {
        a = Bg(7, a, d, b);
        a.lanes = c;
        return a;
      }
      function pj(a, b, c, d) {
        a = Bg(22, a, d, b);
        a.elementType = Ia;
        a.lanes = c;
        a.stateNode = { isHidden: false };
        return a;
      }
      function Qg(a, b, c) {
        a = Bg(6, a, null, b);
        a.lanes = c;
        return a;
      }
      function Sg(a, b, c) {
        b = Bg(4, null !== a.children ? a.children : [], a.key, b);
        b.lanes = c;
        b.stateNode = { containerInfo: a.containerInfo, pendingChildren: null, implementation: a.implementation };
        return b;
      }
      function al(a, b, c, d, e) {
        this.tag = b;
        this.containerInfo = a;
        this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
        this.timeoutHandle = -1;
        this.callbackNode = this.pendingContext = this.context = null;
        this.callbackPriority = 0;
        this.eventTimes = zc(0);
        this.expirationTimes = zc(-1);
        this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
        this.entanglements = zc(0);
        this.identifierPrefix = d;
        this.onRecoverableError = e;
        this.mutableSourceEagerHydrationData = null;
      }
      function bl(a, b, c, d, e, f, g, h, k) {
        a = new al(a, b, c, h, k);
        1 === b ? (b = 1, true === f && (b |= 8)) : b = 0;
        f = Bg(3, null, null, b);
        a.current = f;
        f.stateNode = a;
        f.memoizedState = { element: d, isDehydrated: c, cache: null, transitions: null, pendingSuspenseBoundaries: null };
        kh(f);
        return a;
      }
      function cl(a, b, c) {
        var d = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
        return { $$typeof: wa, key: null == d ? null : "" + d, children: a, containerInfo: b, implementation: c };
      }
      function dl(a) {
        if (!a) return Vf;
        a = a._reactInternals;
        a: {
          if (Vb(a) !== a || 1 !== a.tag) throw Error(p(170));
          var b = a;
          do {
            switch (b.tag) {
              case 3:
                b = b.stateNode.context;
                break a;
              case 1:
                if (Zf(b.type)) {
                  b = b.stateNode.__reactInternalMemoizedMergedChildContext;
                  break a;
                }
            }
            b = b.return;
          } while (null !== b);
          throw Error(p(171));
        }
        if (1 === a.tag) {
          var c = a.type;
          if (Zf(c)) return bg(a, c, b);
        }
        return b;
      }
      function el(a, b, c, d, e, f, g, h, k) {
        a = bl(c, d, true, a, e, f, g, h, k);
        a.context = dl(null);
        c = a.current;
        d = R();
        e = yi(c);
        f = mh(d, e);
        f.callback = void 0 !== b && null !== b ? b : null;
        nh(c, f, e);
        a.current.lanes = e;
        Ac(a, e, d);
        Dk(a, d);
        return a;
      }
      function fl(a, b, c, d) {
        var e = b.current, f = R(), g = yi(e);
        c = dl(c);
        null === b.context ? b.context = c : b.pendingContext = c;
        b = mh(f, g);
        b.payload = { element: a };
        d = void 0 === d ? null : d;
        null !== d && (b.callback = d);
        a = nh(e, b, g);
        null !== a && (gi(a, e, g, f), oh(a, e, g));
        return g;
      }
      function gl(a) {
        a = a.current;
        if (!a.child) return null;
        switch (a.child.tag) {
          case 5:
            return a.child.stateNode;
          default:
            return a.child.stateNode;
        }
      }
      function hl(a, b) {
        a = a.memoizedState;
        if (null !== a && null !== a.dehydrated) {
          var c = a.retryLane;
          a.retryLane = 0 !== c && c < b ? c : b;
        }
      }
      function il(a, b) {
        hl(a, b);
        (a = a.alternate) && hl(a, b);
      }
      function jl() {
        return null;
      }
      var kl = "function" === typeof reportError ? reportError : function(a) {
        console.error(a);
      };
      function ll(a) {
        this._internalRoot = a;
      }
      ml.prototype.render = ll.prototype.render = function(a) {
        var b = this._internalRoot;
        if (null === b) throw Error(p(409));
        fl(a, b, null, null);
      };
      ml.prototype.unmount = ll.prototype.unmount = function() {
        var a = this._internalRoot;
        if (null !== a) {
          this._internalRoot = null;
          var b = a.containerInfo;
          Rk(function() {
            fl(null, a, null, null);
          });
          b[uf] = null;
        }
      };
      function ml(a) {
        this._internalRoot = a;
      }
      ml.prototype.unstable_scheduleHydration = function(a) {
        if (a) {
          var b = Hc();
          a = { blockedOn: null, target: a, priority: b };
          for (var c = 0; c < Qc.length && 0 !== b && b < Qc[c].priority; c++) ;
          Qc.splice(c, 0, a);
          0 === c && Vc(a);
        }
      };
      function nl(a) {
        return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType);
      }
      function ol(a) {
        return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType && (8 !== a.nodeType || " react-mount-point-unstable " !== a.nodeValue));
      }
      function pl() {
      }
      function ql(a, b, c, d, e) {
        if (e) {
          if ("function" === typeof d) {
            var f = d;
            d = function() {
              var a2 = gl(g);
              f.call(a2);
            };
          }
          var g = el(b, d, a, 0, null, false, false, "", pl);
          a._reactRootContainer = g;
          a[uf] = g.current;
          sf(8 === a.nodeType ? a.parentNode : a);
          Rk();
          return g;
        }
        for (; e = a.lastChild; ) a.removeChild(e);
        if ("function" === typeof d) {
          var h = d;
          d = function() {
            var a2 = gl(k);
            h.call(a2);
          };
        }
        var k = bl(a, 0, false, null, null, false, false, "", pl);
        a._reactRootContainer = k;
        a[uf] = k.current;
        sf(8 === a.nodeType ? a.parentNode : a);
        Rk(function() {
          fl(b, k, c, d);
        });
        return k;
      }
      function rl(a, b, c, d, e) {
        var f = c._reactRootContainer;
        if (f) {
          var g = f;
          if ("function" === typeof e) {
            var h = e;
            e = function() {
              var a2 = gl(g);
              h.call(a2);
            };
          }
          fl(b, g, a, e);
        } else g = ql(c, b, a, e, d);
        return gl(g);
      }
      Ec = function(a) {
        switch (a.tag) {
          case 3:
            var b = a.stateNode;
            if (b.current.memoizedState.isDehydrated) {
              var c = tc(b.pendingLanes);
              0 !== c && (Cc(b, c | 1), Dk(b, B()), 0 === (K & 6) && (Gj = B() + 500, jg()));
            }
            break;
          case 13:
            Rk(function() {
              var b2 = ih(a, 1);
              if (null !== b2) {
                var c2 = R();
                gi(b2, a, 1, c2);
              }
            }), il(a, 1);
        }
      };
      Fc = function(a) {
        if (13 === a.tag) {
          var b = ih(a, 134217728);
          if (null !== b) {
            var c = R();
            gi(b, a, 134217728, c);
          }
          il(a, 134217728);
        }
      };
      Gc = function(a) {
        if (13 === a.tag) {
          var b = yi(a), c = ih(a, b);
          if (null !== c) {
            var d = R();
            gi(c, a, b, d);
          }
          il(a, b);
        }
      };
      Hc = function() {
        return C;
      };
      Ic = function(a, b) {
        var c = C;
        try {
          return C = a, b();
        } finally {
          C = c;
        }
      };
      yb = function(a, b, c) {
        switch (b) {
          case "input":
            bb(a, c);
            b = c.name;
            if ("radio" === c.type && null != b) {
              for (c = a; c.parentNode; ) c = c.parentNode;
              c = c.querySelectorAll("input[name=" + JSON.stringify("" + b) + '][type="radio"]');
              for (b = 0; b < c.length; b++) {
                var d = c[b];
                if (d !== a && d.form === a.form) {
                  var e = Db(d);
                  if (!e) throw Error(p(90));
                  Wa(d);
                  bb(d, e);
                }
              }
            }
            break;
          case "textarea":
            ib(a, c);
            break;
          case "select":
            b = c.value, null != b && fb(a, !!c.multiple, b, false);
        }
      };
      Gb = Qk;
      Hb = Rk;
      var sl = { usingClientEntryPoint: false, Events: [Cb, ue, Db, Eb, Fb, Qk] };
      var tl = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" };
      var ul = { bundleType: tl.bundleType, version: tl.version, rendererPackageName: tl.rendererPackageName, rendererConfig: tl.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: function(a) {
        a = Zb(a);
        return null === a ? null : a.stateNode;
      }, findFiberByHostInstance: tl.findFiberByHostInstance || jl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" };
      if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
        vl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (!vl.isDisabled && vl.supportsFiber) try {
          kc = vl.inject(ul), lc = vl;
        } catch (a) {
        }
      }
      var vl;
      exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = sl;
      exports.createPortal = function(a, b) {
        var c = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
        if (!nl(b)) throw Error(p(200));
        return cl(a, b, null, c);
      };
      exports.createRoot = function(a, b) {
        if (!nl(a)) throw Error(p(299));
        var c = false, d = "", e = kl;
        null !== b && void 0 !== b && (true === b.unstable_strictMode && (c = true), void 0 !== b.identifierPrefix && (d = b.identifierPrefix), void 0 !== b.onRecoverableError && (e = b.onRecoverableError));
        b = bl(a, 1, false, null, null, c, false, d, e);
        a[uf] = b.current;
        sf(8 === a.nodeType ? a.parentNode : a);
        return new ll(b);
      };
      exports.findDOMNode = function(a) {
        if (null == a) return null;
        if (1 === a.nodeType) return a;
        var b = a._reactInternals;
        if (void 0 === b) {
          if ("function" === typeof a.render) throw Error(p(188));
          a = Object.keys(a).join(",");
          throw Error(p(268, a));
        }
        a = Zb(b);
        a = null === a ? null : a.stateNode;
        return a;
      };
      exports.flushSync = function(a) {
        return Rk(a);
      };
      exports.hydrate = function(a, b, c) {
        if (!ol(b)) throw Error(p(200));
        return rl(null, a, b, true, c);
      };
      exports.hydrateRoot = function(a, b, c) {
        if (!nl(a)) throw Error(p(405));
        var d = null != c && c.hydratedSources || null, e = false, f = "", g = kl;
        null !== c && void 0 !== c && (true === c.unstable_strictMode && (e = true), void 0 !== c.identifierPrefix && (f = c.identifierPrefix), void 0 !== c.onRecoverableError && (g = c.onRecoverableError));
        b = el(b, null, a, 1, null != c ? c : null, e, false, f, g);
        a[uf] = b.current;
        sf(a);
        if (d) for (a = 0; a < d.length; a++) c = d[a], e = c._getVersion, e = e(c._source), null == b.mutableSourceEagerHydrationData ? b.mutableSourceEagerHydrationData = [c, e] : b.mutableSourceEagerHydrationData.push(
          c,
          e
        );
        return new ml(b);
      };
      exports.render = function(a, b, c) {
        if (!ol(b)) throw Error(p(200));
        return rl(null, a, b, false, c);
      };
      exports.unmountComponentAtNode = function(a) {
        if (!ol(a)) throw Error(p(40));
        return a._reactRootContainer ? (Rk(function() {
          rl(null, null, a, false, function() {
            a._reactRootContainer = null;
            a[uf] = null;
          });
        }), true) : false;
      };
      exports.unstable_batchedUpdates = Qk;
      exports.unstable_renderSubtreeIntoContainer = function(a, b, c, d) {
        if (!ol(c)) throw Error(p(200));
        if (null == a || void 0 === a._reactInternals) throw Error(p(38));
        return rl(a, b, c, false, d);
      };
      exports.version = "18.3.1-next-f1338f8080-20240426";
    }
  });

  // node_modules/react-dom/index.js
  var require_react_dom = __commonJS({
    "node_modules/react-dom/index.js"(exports, module2) {
      "use strict";
      function checkDCE() {
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
          return;
        }
        if (false) {
          throw new Error("^_^");
        }
        try {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
        } catch (err) {
          console.error(err);
        }
      }
      if (true) {
        checkDCE();
        module2.exports = require_react_dom_production_min();
      } else {
        module2.exports = null;
      }
    }
  });

  // node_modules/react-fast-compare/index.js
  var require_react_fast_compare = __commonJS({
    "node_modules/react-fast-compare/index.js"(exports, module2) {
      var hasElementType = typeof Element !== "undefined";
      var hasMap = typeof Map === "function";
      var hasSet = typeof Set === "function";
      var hasArrayBuffer = typeof ArrayBuffer === "function" && !!ArrayBuffer.isView;
      function equal2(a, b) {
        if (a === b) return true;
        if (a && b && typeof a == "object" && typeof b == "object") {
          if (a.constructor !== b.constructor) return false;
          var length2, i, keys;
          if (Array.isArray(a)) {
            length2 = a.length;
            if (length2 != b.length) return false;
            for (i = length2; i-- !== 0; )
              if (!equal2(a[i], b[i])) return false;
            return true;
          }
          var it;
          if (hasMap && a instanceof Map && b instanceof Map) {
            if (a.size !== b.size) return false;
            it = a.entries();
            while (!(i = it.next()).done)
              if (!b.has(i.value[0])) return false;
            it = a.entries();
            while (!(i = it.next()).done)
              if (!equal2(i.value[1], b.get(i.value[0]))) return false;
            return true;
          }
          if (hasSet && a instanceof Set && b instanceof Set) {
            if (a.size !== b.size) return false;
            it = a.entries();
            while (!(i = it.next()).done)
              if (!b.has(i.value[0])) return false;
            return true;
          }
          if (hasArrayBuffer && ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {
            length2 = a.length;
            if (length2 != b.length) return false;
            for (i = length2; i-- !== 0; )
              if (a[i] !== b[i]) return false;
            return true;
          }
          if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
          if (a.valueOf !== Object.prototype.valueOf && typeof a.valueOf === "function" && typeof b.valueOf === "function") return a.valueOf() === b.valueOf();
          if (a.toString !== Object.prototype.toString && typeof a.toString === "function" && typeof b.toString === "function") return a.toString() === b.toString();
          keys = Object.keys(a);
          length2 = keys.length;
          if (length2 !== Object.keys(b).length) return false;
          for (i = length2; i-- !== 0; )
            if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
          if (hasElementType && a instanceof Element) return false;
          for (i = length2; i-- !== 0; ) {
            if ((keys[i] === "_owner" || keys[i] === "__v" || keys[i] === "__o") && a.$$typeof) {
              continue;
            }
            if (!equal2(a[keys[i]], b[keys[i]])) return false;
          }
          return true;
        }
        return a !== a && b !== b;
      }
      module2.exports = function isEqual3(a, b) {
        try {
          return equal2(a, b);
        } catch (error) {
          if ((error.message || "").match(/stack|recursion/i)) {
            console.warn("react-fast-compare cannot handle circular refs");
            return false;
          }
          throw error;
        }
      };
    }
  });

  // node_modules/warning/warning.js
  var require_warning = __commonJS({
    "node_modules/warning/warning.js"(exports, module2) {
      "use strict";
      var __DEV__ = false;
      var warning2 = function() {
      };
      if (__DEV__) {
        printWarning = function printWarning2(format2, args) {
          var len = arguments.length;
          args = new Array(len > 1 ? len - 1 : 0);
          for (var key = 1; key < len; key++) {
            args[key - 1] = arguments[key];
          }
          var argIndex = 0;
          var message2 = "Warning: " + format2.replace(/%s/g, function() {
            return args[argIndex++];
          });
          if (typeof console !== "undefined") {
            console.error(message2);
          }
          try {
            throw new Error(message2);
          } catch (x) {
          }
        };
        warning2 = function(condition, format2, args) {
          var len = arguments.length;
          args = new Array(len > 2 ? len - 2 : 0);
          for (var key = 2; key < len; key++) {
            args[key - 2] = arguments[key];
          }
          if (format2 === void 0) {
            throw new Error(
              "`warning(condition, format, ...args)` requires a warning message argument"
            );
          }
          if (!condition) {
            printWarning.apply(null, [format2].concat(args));
          }
        };
      }
      var printWarning;
      module2.exports = warning2;
    }
  });

  // node_modules/@atlaskit/tokens/dist/esm/constants.js
  var CSS_PREFIX, TOKEN_NOT_FOUND_CSS_VAR, CURRENT_SURFACE_CSS_VAR;
  var init_constants = __esm({
    "node_modules/@atlaskit/tokens/dist/esm/constants.js"() {
      CSS_PREFIX = "ds";
      TOKEN_NOT_FOUND_CSS_VAR = "--".concat(CSS_PREFIX, "-token-not-found");
      CURRENT_SURFACE_CSS_VAR = "--".concat(CSS_PREFIX, "-elevation-surface-current");
    }
  });

  // node_modules/tabbable/index.js
  var require_tabbable = __commonJS({
    "node_modules/tabbable/index.js"(exports, module2) {
      module2.exports = function(el, options2) {
        options2 = options2 || {};
        var elementDocument = el.ownerDocument || el;
        var basicTabbables = [];
        var orderedTabbables = [];
        var isUnavailable = createIsUnavailable(elementDocument);
        var candidateSelectors = [
          "input",
          "select",
          "a[href]",
          "textarea",
          "button",
          "[tabindex]"
        ];
        var candidates = el.querySelectorAll(candidateSelectors.join(","));
        if (options2.includeContainer) {
          var matches = Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
          if (candidateSelectors.some(function(candidateSelector) {
            return matches.call(el, candidateSelector);
          })) {
            candidates = Array.prototype.slice.apply(candidates);
            candidates.unshift(el);
          }
        }
        var candidate, candidateIndexAttr, candidateIndex;
        for (var i = 0, l = candidates.length; i < l; i++) {
          candidate = candidates[i];
          candidateIndexAttr = parseInt(candidate.getAttribute("tabindex"), 10);
          candidateIndex = isNaN(candidateIndexAttr) ? candidate.tabIndex : candidateIndexAttr;
          if (candidateIndex < 0 || candidate.tagName === "INPUT" && candidate.type === "hidden" || candidate.disabled || isUnavailable(candidate, elementDocument)) {
            continue;
          }
          if (candidateIndex === 0) {
            basicTabbables.push(candidate);
          } else {
            orderedTabbables.push({
              index: i,
              tabIndex: candidateIndex,
              node: candidate
            });
          }
        }
        var tabbableNodes = orderedTabbables.sort(function(a, b) {
          return a.tabIndex === b.tabIndex ? a.index - b.index : a.tabIndex - b.tabIndex;
        }).map(function(a) {
          return a.node;
        });
        Array.prototype.push.apply(tabbableNodes, basicTabbables);
        return tabbableNodes;
      };
      function createIsUnavailable(elementDocument) {
        var isOffCache = [];
        function isOff(node2, nodeComputedStyle) {
          if (node2 === elementDocument.documentElement) return false;
          for (var i = 0, length2 = isOffCache.length; i < length2; i++) {
            if (isOffCache[i][0] === node2) return isOffCache[i][1];
          }
          nodeComputedStyle = nodeComputedStyle || elementDocument.defaultView.getComputedStyle(node2);
          var result2 = false;
          if (nodeComputedStyle.display === "none") {
            result2 = true;
          } else if (node2.parentNode) {
            result2 = isOff(node2.parentNode);
          }
          isOffCache.push([node2, result2]);
          return result2;
        }
        return function isUnavailable(node2) {
          if (node2 === elementDocument.documentElement) return false;
          var computedStyle = elementDocument.defaultView.getComputedStyle(node2);
          if (isOff(node2, computedStyle)) return true;
          return computedStyle.visibility === "hidden";
        };
      }
    }
  });

  // node_modules/focus-trap/index.js
  var require_focus_trap = __commonJS({
    "node_modules/focus-trap/index.js"(exports, module2) {
      var tabbable = require_tabbable();
      var listeningFocusTrap = null;
      function focusTrap(element, userOptions) {
        var tabbableNodes = [];
        var firstTabbableNode = null;
        var lastTabbableNode = null;
        var nodeFocusedBeforeActivation = null;
        var active2 = false;
        var paused = false;
        var tabEvent = null;
        var container = typeof element === "string" ? document.querySelector(element) : element;
        var config = userOptions || {};
        config.returnFocusOnDeactivate = userOptions && userOptions.returnFocusOnDeactivate !== void 0 ? userOptions.returnFocusOnDeactivate : true;
        config.escapeDeactivates = userOptions && userOptions.escapeDeactivates !== void 0 ? userOptions.escapeDeactivates : true;
        var trap = {
          activate,
          deactivate,
          pause,
          unpause
        };
        return trap;
        function activate(activateOptions) {
          if (active2) return;
          var defaultedActivateOptions = {
            onActivate: activateOptions && activateOptions.onActivate !== void 0 ? activateOptions.onActivate : config.onActivate
          };
          active2 = true;
          paused = false;
          nodeFocusedBeforeActivation = document.activeElement;
          if (defaultedActivateOptions.onActivate) {
            defaultedActivateOptions.onActivate();
          }
          addListeners();
          return trap;
        }
        function deactivate(deactivateOptions) {
          if (!active2) return;
          var defaultedDeactivateOptions = {
            returnFocus: deactivateOptions && deactivateOptions.returnFocus !== void 0 ? deactivateOptions.returnFocus : config.returnFocusOnDeactivate,
            onDeactivate: deactivateOptions && deactivateOptions.onDeactivate !== void 0 ? deactivateOptions.onDeactivate : config.onDeactivate
          };
          removeListeners();
          if (defaultedDeactivateOptions.onDeactivate) {
            defaultedDeactivateOptions.onDeactivate();
          }
          if (defaultedDeactivateOptions.returnFocus) {
            setTimeout(function() {
              tryFocus(nodeFocusedBeforeActivation);
            }, 0);
          }
          active2 = false;
          paused = false;
          return this;
        }
        function pause() {
          if (paused || !active2) return;
          paused = true;
          removeListeners();
        }
        function unpause() {
          if (!paused || !active2) return;
          paused = false;
          addListeners();
        }
        function addListeners() {
          if (!active2) return;
          if (listeningFocusTrap) {
            listeningFocusTrap.pause();
          }
          listeningFocusTrap = trap;
          updateTabbableNodes();
          setTimeout(function() {
            tryFocus(firstFocusNode());
          }, 0);
          document.addEventListener("focus", checkFocus, true);
          document.addEventListener("click", checkClick, true);
          document.addEventListener("mousedown", checkPointerDown, true);
          document.addEventListener("touchstart", checkPointerDown, true);
          document.addEventListener("keydown", checkKey, true);
          return trap;
        }
        function removeListeners() {
          if (!active2 || listeningFocusTrap !== trap) return;
          document.removeEventListener("focus", checkFocus, true);
          document.removeEventListener("click", checkClick, true);
          document.removeEventListener("mousedown", checkPointerDown, true);
          document.removeEventListener("touchstart", checkPointerDown, true);
          document.removeEventListener("keydown", checkKey, true);
          listeningFocusTrap = null;
          return trap;
        }
        function getNodeForOption(optionName) {
          var optionValue = config[optionName];
          var node2 = optionValue;
          if (!optionValue) {
            return null;
          }
          if (typeof optionValue === "string") {
            node2 = document.querySelector(optionValue);
            if (!node2) {
              throw new Error("`" + optionName + "` refers to no known node");
            }
          }
          if (typeof optionValue === "function") {
            node2 = optionValue();
            if (!node2) {
              throw new Error("`" + optionName + "` did not return a node");
            }
          }
          return node2;
        }
        function firstFocusNode() {
          var node2;
          if (getNodeForOption("initialFocus") !== null) {
            node2 = getNodeForOption("initialFocus");
          } else if (container.contains(document.activeElement)) {
            node2 = document.activeElement;
          } else {
            node2 = tabbableNodes[0] || getNodeForOption("fallbackFocus");
          }
          if (!node2) {
            throw new Error("You can't have a focus-trap without at least one focusable element");
          }
          return node2;
        }
        function checkPointerDown(e) {
          if (config.clickOutsideDeactivates && !container.contains(e.target)) {
            deactivate({ returnFocus: false });
          }
        }
        function checkClick(e) {
          if (config.clickOutsideDeactivates) return;
          if (container.contains(e.target)) return;
          e.preventDefault();
          e.stopImmediatePropagation();
        }
        function checkFocus(e) {
          if (container.contains(e.target)) return;
          e.preventDefault();
          e.stopImmediatePropagation();
          if (typeof e.target.blur === "function") e.target.blur();
          if (tabEvent) {
            readjustFocus(tabEvent);
          }
        }
        function checkKey(e) {
          if (e.key === "Tab" || e.keyCode === 9) {
            handleTab(e);
          }
          if (config.escapeDeactivates !== false && isEscapeEvent(e)) {
            deactivate();
          }
        }
        function handleTab(e) {
          updateTabbableNodes();
          if (e.target.hasAttribute("tabindex") && Number(e.target.getAttribute("tabindex")) < 0) {
            return tabEvent = e;
          }
          e.preventDefault();
          var currentFocusIndex = tabbableNodes.indexOf(e.target);
          if (e.shiftKey) {
            if (e.target === firstTabbableNode || tabbableNodes.indexOf(e.target) === -1) {
              return tryFocus(lastTabbableNode);
            }
            return tryFocus(tabbableNodes[currentFocusIndex - 1]);
          }
          if (e.target === lastTabbableNode) return tryFocus(firstTabbableNode);
          tryFocus(tabbableNodes[currentFocusIndex + 1]);
        }
        function updateTabbableNodes() {
          tabbableNodes = tabbable(container);
          firstTabbableNode = tabbableNodes[0];
          lastTabbableNode = tabbableNodes[tabbableNodes.length - 1];
        }
        function readjustFocus(e) {
          if (e.shiftKey) return tryFocus(lastTabbableNode);
          tryFocus(firstTabbableNode);
        }
      }
      function isEscapeEvent(e) {
        return e.key === "Escape" || e.key === "Esc" || e.keyCode === 27;
      }
      function tryFocus(node2) {
        if (!node2 || !node2.focus) return;
        if (node2 === document.activeElement) return;
        node2.focus();
        if (node2.tagName.toLowerCase() === "input") {
          node2.select();
        }
      }
      module2.exports = focusTrap;
    }
  });

  // node_modules/exenv/index.js
  var require_exenv = __commonJS({
    "node_modules/exenv/index.js"(exports, module2) {
      (function() {
        "use strict";
        var canUseDOM3 = !!(typeof window !== "undefined" && window.document && window.document.createElement);
        var ExecutionEnvironment = {
          canUseDOM: canUseDOM3,
          canUseWorkers: typeof Worker !== "undefined",
          canUseEventListeners: canUseDOM3 && !!(window.addEventListener || window.attachEvent),
          canUseViewport: canUseDOM3 && !!window.screen
        };
        if (typeof define === "function" && typeof define.amd === "object" && define.amd) {
          define(function() {
            return ExecutionEnvironment;
          });
        } else if (typeof module2 !== "undefined" && module2.exports) {
          module2.exports = ExecutionEnvironment;
        } else {
          window.ExecutionEnvironment = ExecutionEnvironment;
        }
      })();
    }
  });

  // node_modules/react-scrolllock/dist/utils.js
  var require_utils2 = __commonJS({
    "node_modules/react-scrolllock/dist/utils.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.pipe = exports.listenerOptions = void 0;
      exports.preventTouchMove = preventTouchMove2;
      exports.allowTouchMove = allowTouchMove2;
      exports.preventInertiaScroll = preventInertiaScroll2;
      exports.isTouchDevice = isTouchDevice2;
      exports.camelToKebab = camelToKebab;
      exports.parse = parse5;
      exports.getPadding = getPadding;
      exports.getWindowHeight = getWindowHeight;
      exports.getDocumentHeight = getDocumentHeight;
      exports.makeStyleTag = makeStyleTag;
      exports.injectStyles = injectStyles;
      exports.insertStyleTag = insertStyleTag;
      var _exenv = require_exenv();
      var listenerOptions2 = exports.listenerOptions = {
        capture: false,
        passive: false
      };
      function preventTouchMove2(e) {
        e.preventDefault();
        return false;
      }
      function allowTouchMove2(e) {
        var target = e.currentTarget;
        if (target.scrollHeight > target.clientHeight) {
          e.stopPropagation();
          return true;
        }
        e.preventDefault();
        return false;
      }
      function preventInertiaScroll2() {
        var top2 = this.scrollTop;
        var totalScroll = this.scrollHeight;
        var currentScroll = top2 + this.offsetHeight;
        if (top2 === 0) {
          this.scrollTop = 1;
        } else if (currentScroll === totalScroll) {
          this.scrollTop = top2 - 1;
        }
      }
      function isTouchDevice2() {
        if (!_exenv.canUseDOM) return false;
        return "ontouchstart" in window || navigator.maxTouchPoints;
      }
      function camelToKebab(str) {
        return str.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
      }
      function parse5(val) {
        return isNaN(val) ? val : val + "px";
      }
      var pipeFns = function pipeFns2(a, b) {
        return function() {
          return b(a.apply(void 0, arguments));
        };
      };
      var pipe = exports.pipe = function pipe2() {
        for (var _len = arguments.length, fns = Array(_len), _key = 0; _key < _len; _key++) {
          fns[_key] = arguments[_key];
        }
        return fns.reduce(pipeFns);
      };
      function getPadding() {
        if (!_exenv.canUseDOM) return 0;
        var paddingRight = parseInt(window.getComputedStyle(document.body).paddingRight, 10);
        var scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
        return paddingRight + scrollbarWidth;
      }
      function getWindowHeight() {
        var multiplier = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
        if (_exenv.canUseDOM) {
          return window.innerHeight * multiplier;
        }
      }
      function getDocumentHeight() {
        if (_exenv.canUseDOM) {
          return document.body.clientHeight;
        }
      }
      function makeStyleTag() {
        if (!_exenv.canUseDOM) return;
        var tag = document.createElement("style");
        tag.type = "text/css";
        tag.setAttribute("data-react-scrolllock", "");
        return tag;
      }
      function injectStyles(tag, css7) {
        if (!_exenv.canUseDOM) return;
        if (tag.styleSheet) {
          tag.styleSheet.cssText = css7;
        } else {
          tag.appendChild(document.createTextNode(css7));
        }
      }
      function insertStyleTag(tag) {
        if (!_exenv.canUseDOM) return;
        var head = document.head || document.getElementsByTagName("head")[0];
        head.appendChild(tag);
      }
    }
  });

  // node_modules/react-scrolllock/dist/TouchScrollable.js
  var require_TouchScrollable = __commonJS({
    "node_modules/react-scrolllock/dist/TouchScrollable.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.TouchScrollable = void 0;
      var _extends2 = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source2 = arguments[i];
          for (var key in source2) {
            if (Object.prototype.hasOwnProperty.call(source2, key)) {
              target[key] = source2[key];
            }
          }
        }
        return target;
      };
      var _createClass3 = /* @__PURE__ */ (function() {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function(Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor;
        };
      })();
      var _react = require_react();
      var _exenv = require_exenv();
      var _utils = require_utils2();
      function _objectWithoutProperties2(obj, keys) {
        var target = {};
        for (var i in obj) {
          if (keys.indexOf(i) >= 0) continue;
          if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
          target[i] = obj[i];
        }
        return target;
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _possibleConstructorReturn2(self2, call) {
        if (!self2) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return call && (typeof call === "object" || typeof call === "function") ? call : self2;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
      }
      var TouchScrollable3 = exports.TouchScrollable = (function(_PureComponent) {
        _inherits2(TouchScrollable4, _PureComponent);
        function TouchScrollable4() {
          var _ref2;
          var _temp, _this, _ret;
          _classCallCheck2(this, TouchScrollable4);
          for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          return _ret = (_temp = (_this = _possibleConstructorReturn2(this, (_ref2 = TouchScrollable4.__proto__ || Object.getPrototypeOf(TouchScrollable4)).call.apply(_ref2, [this].concat(args))), _this), _this.getScrollableArea = function(ref) {
            _this.scrollableArea = ref;
          }, _temp), _possibleConstructorReturn2(_this, _ret);
        }
        _createClass3(TouchScrollable4, [{
          key: "componentDidMount",
          value: function componentDidMount() {
            if (!_exenv.canUseEventListeners) return;
            this.scrollableArea.addEventListener("touchstart", _utils.preventInertiaScroll, _utils.listenerOptions);
            this.scrollableArea.addEventListener("touchmove", _utils.allowTouchMove, _utils.listenerOptions);
          }
        }, {
          key: "componentWillUnmount",
          value: function componentWillUnmount() {
            if (!_exenv.canUseEventListeners) return;
            this.scrollableArea.removeEventListener("touchstart", _utils.preventInertiaScroll, _utils.listenerOptions);
            this.scrollableArea.removeEventListener("touchmove", _utils.allowTouchMove, _utils.listenerOptions);
          }
        }, {
          key: "render",
          value: function render() {
            var _props = this.props, children = _props.children, rest = _objectWithoutProperties2(_props, ["children"]);
            return typeof children === "function" ? children(this.getScrollableArea) : (0, _react.cloneElement)(children, _extends2({ ref: this.getScrollableArea }, rest));
          }
        }]);
        return TouchScrollable4;
      })(_react.PureComponent);
    }
  });

  // node_modules/react-scrolllock/dist/withLockSheet.js
  var require_withLockSheet = __commonJS({
    "node_modules/react-scrolllock/dist/withLockSheet.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      var _createClass3 = /* @__PURE__ */ (function() {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function(Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor;
        };
      })();
      exports.default = withLockSheet;
      var _react = require_react();
      var _react2 = _interopRequireDefault(_react);
      var _utils = require_utils2();
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _possibleConstructorReturn2(self2, call) {
        if (!self2) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return call && (typeof call === "object" || typeof call === "function") ? call : self2;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
      }
      function withLockSheet(WrappedComponent) {
        return (function(_PureComponent) {
          _inherits2(SheetProvider, _PureComponent);
          function SheetProvider() {
            var _ref2;
            var _temp, _this, _ret;
            _classCallCheck2(this, SheetProvider);
            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            return _ret = (_temp = (_this = _possibleConstructorReturn2(this, (_ref2 = SheetProvider.__proto__ || Object.getPrototypeOf(SheetProvider)).call.apply(_ref2, [this].concat(args))), _this), _this.addSheet = function() {
              var styles15 = _this.getStyles();
              var sheet = (0, _utils.makeStyleTag)();
              if (!sheet) return;
              (0, _utils.injectStyles)(sheet, styles15);
              (0, _utils.insertStyleTag)(sheet);
              _this.sheet = sheet;
            }, _this.getStyles = function() {
              var accountForScrollbars = _this.props.accountForScrollbars;
              var height = (0, _utils.getDocumentHeight)();
              var paddingRight = accountForScrollbars ? (0, _utils.getPadding)() : null;
              var styles15 = "body {\n        box-sizing: border-box !important;\n        overflow: hidden !important;\n        position: relative !important;\n        " + (height ? "height: " + height + "px !important;" : "") + "\n        " + (paddingRight ? "padding-right: " + paddingRight + "px !important;" : "") + "\n      }";
              return styles15;
            }, _temp), _possibleConstructorReturn2(_this, _ret);
          }
          _createClass3(SheetProvider, [{
            key: "componentDidMount",
            value: function componentDidMount() {
              this.addSheet();
            }
          }, {
            key: "removeSheet",
            value: function removeSheet() {
              if (!this.sheet) return;
              this.sheet.parentNode.removeChild(this.sheet);
              this.sheet = null;
            }
          }, {
            key: "componentWillUnmount",
            value: function componentWillUnmount() {
              this.removeSheet();
            }
          }, {
            key: "render",
            value: function render() {
              return _react2.default.createElement(WrappedComponent, this.props);
            }
          }]);
          return SheetProvider;
        })(_react.PureComponent);
      }
    }
  });

  // node_modules/react-scrolllock/dist/withTouchListeners.js
  var require_withTouchListeners = __commonJS({
    "node_modules/react-scrolllock/dist/withTouchListeners.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      var _createClass3 = /* @__PURE__ */ (function() {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function(Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor;
        };
      })();
      exports.default = withTouchListeners;
      var _react = require_react();
      var _react2 = _interopRequireDefault(_react);
      var _exenv = require_exenv();
      var _utils = require_utils2();
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _possibleConstructorReturn2(self2, call) {
        if (!self2) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return call && (typeof call === "object" || typeof call === "function") ? call : self2;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
      }
      function withTouchListeners(WrappedComponent) {
        return (function(_PureComponent) {
          _inherits2(TouchProvider, _PureComponent);
          function TouchProvider() {
            _classCallCheck2(this, TouchProvider);
            return _possibleConstructorReturn2(this, (TouchProvider.__proto__ || Object.getPrototypeOf(TouchProvider)).apply(this, arguments));
          }
          _createClass3(TouchProvider, [{
            key: "componentDidMount",
            value: function componentDidMount() {
              if (!_exenv.canUseDOM || !(0, _utils.isTouchDevice)()) return;
              document.addEventListener("touchmove", _utils.preventTouchMove, _utils.listenerOptions);
            }
          }, {
            key: "componentWillUnmount",
            value: function componentWillUnmount() {
              if (!_exenv.canUseDOM || !(0, _utils.isTouchDevice)()) return;
              document.removeEventListener("touchmove", _utils.preventTouchMove, _utils.listenerOptions);
            }
          }, {
            key: "render",
            value: function render() {
              return _react2.default.createElement(WrappedComponent, this.props);
            }
          }]);
          return TouchProvider;
        })(_react.PureComponent);
      }
    }
  });

  // node_modules/react-scrolllock/dist/ScrollLock.js
  var require_ScrollLock = __commonJS({
    "node_modules/react-scrolllock/dist/ScrollLock.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      var _createClass3 = /* @__PURE__ */ (function() {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function(Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor;
        };
      })();
      var _react = require_react();
      var _react2 = _interopRequireDefault(_react);
      var _exenv = require_exenv();
      var _TouchScrollable = require_TouchScrollable();
      var _withLockSheet = require_withLockSheet();
      var _withLockSheet2 = _interopRequireDefault(_withLockSheet);
      var _withTouchListeners = require_withTouchListeners();
      var _withTouchListeners2 = _interopRequireDefault(_withTouchListeners);
      var _utils = require_utils2();
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _possibleConstructorReturn2(self2, call) {
        if (!self2) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return call && (typeof call === "object" || typeof call === "function") ? call : self2;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
      }
      var ScrollLock2 = (function(_PureComponent) {
        _inherits2(ScrollLock3, _PureComponent);
        function ScrollLock3() {
          _classCallCheck2(this, ScrollLock3);
          return _possibleConstructorReturn2(this, (ScrollLock3.__proto__ || Object.getPrototypeOf(ScrollLock3)).apply(this, arguments));
        }
        _createClass3(ScrollLock3, [{
          key: "componentDidMount",
          value: function componentDidMount() {
            if (!_exenv.canUseDOM) return;
            this.initialHeight = window.innerHeight;
          }
        }, {
          key: "componentWillUnmount",
          value: function componentWillUnmount() {
            var offset3 = window.innerHeight - this.initialHeight;
            if (offset3) {
              window.scrollTo(0, window.pageYOffset + offset3);
            }
            this.initialHeight = window.innerHeight;
          }
        }, {
          key: "render",
          value: function render() {
            var children = this.props.children;
            return children ? _react2.default.createElement(
              _TouchScrollable.TouchScrollable,
              null,
              children
            ) : null;
          }
        }]);
        return ScrollLock3;
      })(_react.PureComponent);
      var compose = (0, _utils.pipe)(_withTouchListeners2.default, _withLockSheet2.default);
      var SheetLock = compose(ScrollLock2);
      var LockToggle = function LockToggle2(props) {
        return props.isActive ? _react2.default.createElement(SheetLock, props) : props.children;
      };
      LockToggle.defaultProps = {
        accountForScrollbars: true,
        children: null,
        isActive: true
      };
      exports.default = LockToggle;
    }
  });

  // node_modules/react-scrolllock/dist/index.js
  var require_dist2 = __commonJS({
    "node_modules/react-scrolllock/dist/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      var _ScrollLock = require_ScrollLock();
      Object.defineProperty(exports, "default", {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_ScrollLock).default;
        }
      });
      var _TouchScrollable = require_TouchScrollable();
      Object.defineProperty(exports, "TouchScrollable", {
        enumerable: true,
        get: function get() {
          return _TouchScrollable.TouchScrollable;
        }
      });
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
    }
  });

  // node_modules/react-is/cjs/react-is.production.min.js
  var require_react_is_production_min = __commonJS({
    "node_modules/react-is/cjs/react-is.production.min.js"(exports) {
      "use strict";
      var b = "function" === typeof Symbol && Symbol.for;
      var c = b ? Symbol.for("react.element") : 60103;
      var d = b ? Symbol.for("react.portal") : 60106;
      var e = b ? Symbol.for("react.fragment") : 60107;
      var f = b ? Symbol.for("react.strict_mode") : 60108;
      var g = b ? Symbol.for("react.profiler") : 60114;
      var h = b ? Symbol.for("react.provider") : 60109;
      var k = b ? Symbol.for("react.context") : 60110;
      var l = b ? Symbol.for("react.async_mode") : 60111;
      var m = b ? Symbol.for("react.concurrent_mode") : 60111;
      var n = b ? Symbol.for("react.forward_ref") : 60112;
      var p = b ? Symbol.for("react.suspense") : 60113;
      var q = b ? Symbol.for("react.suspense_list") : 60120;
      var r = b ? Symbol.for("react.memo") : 60115;
      var t = b ? Symbol.for("react.lazy") : 60116;
      var v = b ? Symbol.for("react.block") : 60121;
      var w2 = b ? Symbol.for("react.fundamental") : 60117;
      var x = b ? Symbol.for("react.responder") : 60118;
      var y = b ? Symbol.for("react.scope") : 60119;
      function z(a) {
        if ("object" === typeof a && null !== a) {
          var u = a.$$typeof;
          switch (u) {
            case c:
              switch (a = a.type, a) {
                case l:
                case m:
                case e:
                case g:
                case f:
                case p:
                  return a;
                default:
                  switch (a = a && a.$$typeof, a) {
                    case k:
                    case n:
                    case t:
                    case r:
                    case h:
                      return a;
                    default:
                      return u;
                  }
              }
            case d:
              return u;
          }
        }
      }
      function A(a) {
        return z(a) === m;
      }
      exports.AsyncMode = l;
      exports.ConcurrentMode = m;
      exports.ContextConsumer = k;
      exports.ContextProvider = h;
      exports.Element = c;
      exports.ForwardRef = n;
      exports.Fragment = e;
      exports.Lazy = t;
      exports.Memo = r;
      exports.Portal = d;
      exports.Profiler = g;
      exports.StrictMode = f;
      exports.Suspense = p;
      exports.isAsyncMode = function(a) {
        return A(a) || z(a) === l;
      };
      exports.isConcurrentMode = A;
      exports.isContextConsumer = function(a) {
        return z(a) === k;
      };
      exports.isContextProvider = function(a) {
        return z(a) === h;
      };
      exports.isElement = function(a) {
        return "object" === typeof a && null !== a && a.$$typeof === c;
      };
      exports.isForwardRef = function(a) {
        return z(a) === n;
      };
      exports.isFragment = function(a) {
        return z(a) === e;
      };
      exports.isLazy = function(a) {
        return z(a) === t;
      };
      exports.isMemo = function(a) {
        return z(a) === r;
      };
      exports.isPortal = function(a) {
        return z(a) === d;
      };
      exports.isProfiler = function(a) {
        return z(a) === g;
      };
      exports.isStrictMode = function(a) {
        return z(a) === f;
      };
      exports.isSuspense = function(a) {
        return z(a) === p;
      };
      exports.isValidElementType = function(a) {
        return "string" === typeof a || "function" === typeof a || a === e || a === m || a === g || a === f || a === p || a === q || "object" === typeof a && null !== a && (a.$$typeof === t || a.$$typeof === r || a.$$typeof === h || a.$$typeof === k || a.$$typeof === n || a.$$typeof === w2 || a.$$typeof === x || a.$$typeof === y || a.$$typeof === v);
      };
      exports.typeOf = z;
    }
  });

  // node_modules/react-is/index.js
  var require_react_is = __commonJS({
    "node_modules/react-is/index.js"(exports, module2) {
      "use strict";
      if (true) {
        module2.exports = require_react_is_production_min();
      } else {
        module2.exports = null;
      }
    }
  });

  // node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js
  var require_hoist_non_react_statics_cjs = __commonJS({
    "node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js"(exports, module2) {
      "use strict";
      var reactIs = require_react_is();
      var REACT_STATICS = {
        childContextTypes: true,
        contextType: true,
        contextTypes: true,
        defaultProps: true,
        displayName: true,
        getDefaultProps: true,
        getDerivedStateFromError: true,
        getDerivedStateFromProps: true,
        mixins: true,
        propTypes: true,
        type: true
      };
      var KNOWN_STATICS = {
        name: true,
        length: true,
        prototype: true,
        caller: true,
        callee: true,
        arguments: true,
        arity: true
      };
      var FORWARD_REF_STATICS = {
        "$$typeof": true,
        render: true,
        defaultProps: true,
        displayName: true,
        propTypes: true
      };
      var MEMO_STATICS = {
        "$$typeof": true,
        compare: true,
        defaultProps: true,
        displayName: true,
        propTypes: true,
        type: true
      };
      var TYPE_STATICS = {};
      TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
      TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
      function getStatics(component) {
        if (reactIs.isMemo(component)) {
          return MEMO_STATICS;
        }
        return TYPE_STATICS[component["$$typeof"]] || REACT_STATICS;
      }
      var defineProperty = Object.defineProperty;
      var getOwnPropertyNames = Object.getOwnPropertyNames;
      var getOwnPropertySymbols = Object.getOwnPropertySymbols;
      var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
      var getPrototypeOf = Object.getPrototypeOf;
      var objectPrototype = Object.prototype;
      function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
        if (typeof sourceComponent !== "string") {
          if (objectPrototype) {
            var inheritedComponent = getPrototypeOf(sourceComponent);
            if (inheritedComponent && inheritedComponent !== objectPrototype) {
              hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
            }
          }
          var keys = getOwnPropertyNames(sourceComponent);
          if (getOwnPropertySymbols) {
            keys = keys.concat(getOwnPropertySymbols(sourceComponent));
          }
          var targetStatics = getStatics(targetComponent);
          var sourceStatics = getStatics(sourceComponent);
          for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
              var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
              try {
                defineProperty(targetComponent, key, descriptor);
              } catch (e) {
              }
            }
          }
        }
        return targetComponent;
      }
      module2.exports = hoistNonReactStatics;
    }
  });

  // node_modules/@atlaskit/icon/dist/cjs/components/icon-new.compiled.css
  var require_icon_new_compiled = __commonJS({
    "node_modules/@atlaskit/icon/dist/cjs/components/icon-new.compiled.css"(exports, module2) {
      module2.exports = {};
    }
  });

  // node_modules/@compiled/react/dist/cjs/runtime/dev-warnings.js
  var require_dev_warnings = __commonJS({
    "node_modules/@compiled/react/dist/cjs/runtime/dev-warnings.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.analyzeCssInDev = void 0;
      var selectorsToWarn = [":first-child", ":nth-child"];
      var hasWarned = {};
      var warn = (str, ...args) => console.error(`
 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2557   \u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557\u2588\u2588\u2557     \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557
\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255D\u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2551     \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255D\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557
\u2588\u2588\u2551     \u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2554\u2588\u2588\u2588\u2588\u2554\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255D\u2588\u2588\u2551\u2588\u2588\u2551     \u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551  \u2588\u2588\u2551
\u2588\u2588\u2551     \u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2551\u255A\u2588\u2588\u2554\u255D\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u255D \u2588\u2588\u2551\u2588\u2588\u2551     \u2588\u2588\u2554\u2550\u2550\u255D  \u2588\u2588\u2551  \u2588\u2588\u2551
\u255A\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u255A\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255D\u2588\u2588\u2551 \u255A\u2550\u255D \u2588\u2588\u2551\u2588\u2588\u2551     \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255D
 \u255A\u2550\u2550\u2550\u2550\u2550\u255D \u255A\u2550\u2550\u2550\u2550\u2550\u255D \u255A\u2550\u255D     \u255A\u2550\u255D\u255A\u2550\u255D     \u255A\u2550\u255D\u255A\u2550\u2550\u2550\u2550\u2550\u2550\u255D\u255A\u2550\u2550\u2550\u2550\u2550\u2550\u255D\u255A\u2550\u2550\u2550\u2550\u2550\u255D

  @compiled/react/runtime - DEV WARNING

  ${str}
`, ...args);
      var analyzeCssInDev = (sheet) => {
        if (hasWarned[sheet]) {
          return;
        }
        const shouldWarnAboutSelectors = selectorsToWarn.map((selector) => sheet.includes(selector)).filter(Boolean).length > 0;
        if (shouldWarnAboutSelectors) {
          warn(`Selectors "${selectorsToWarn.join(", ")}" are dangerous to use when server side rendering.
  Alternatively try and use ":nth-of-type", or placing data attributes and targetting those instead.
  Read https://compiledcssinjs.com/docs/server-side-rendering for more advice.`);
        }
        hasWarned[sheet] = true;
      };
      exports.analyzeCssInDev = analyzeCssInDev;
    }
  });

  // node_modules/@compiled/react/dist/cjs/runtime/is-server-environment.js
  var require_is_server_environment = __commonJS({
    "node_modules/@compiled/react/dist/cjs/runtime/is-server-environment.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isServerEnvironment = void 0;
      var isJsDomEnvironment = () => window.name === "nodejs" || (navigator === null || navigator === void 0 ? void 0 : navigator.userAgent.includes("Node.js")) || (navigator === null || navigator === void 0 ? void 0 : navigator.userAgent.includes("jsdom"));
      var isServerEnvironment = () => {
        if (typeof window === "undefined" || typeof process !== "undefined" && process.versions != null && process.versions.node != null) {
          return true;
        }
        if (isJsDomEnvironment()) {
          return true;
        }
        return false;
      };
      exports.isServerEnvironment = isServerEnvironment;
    }
  });

  // node_modules/@compiled/react/dist/cjs/runtime/cache.js
  var require_cache = __commonJS({
    "node_modules/@compiled/react/dist/cjs/runtime/cache.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isCacheDisabled = void 0;
      var isCacheDisabled = () => {
        return false;
      };
      exports.isCacheDisabled = isCacheDisabled;
    }
  });

  // node_modules/@compiled/react/dist/cjs/runtime/shorthand.js
  var require_shorthand = __commonJS({
    "node_modules/@compiled/react/dist/cjs/runtime/shorthand.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getShorthandDepth = void 0;
      var shorthandBuckets = {
        all: 0,
        animation: 1,
        "animation-range": 1,
        background: 1,
        border: 1,
        "border-color": 2,
        "border-style": 2,
        "border-width": 2,
        "border-block": 3,
        "border-inline": 3,
        "border-top": 4,
        "border-right": 4,
        "border-bottom": 4,
        "border-left": 4,
        "border-block-start": 5,
        "border-block-end": 5,
        "border-inline-start": 5,
        "border-inline-end": 5,
        "border-image": 1,
        "border-radius": 1,
        "column-rule": 1,
        columns: 1,
        "contain-intrinsic-size": 1,
        container: 1,
        flex: 1,
        "flex-flow": 1,
        font: 1,
        "font-synthesis": 1,
        "font-variant": 2,
        gap: 1,
        grid: 1,
        "grid-area": 1,
        "grid-column": 2,
        "grid-row": 2,
        "grid-template": 2,
        inset: 1,
        "inset-block": 2,
        "inset-inline": 2,
        "list-style": 1,
        margin: 1,
        "margin-block": 2,
        "margin-inline": 2,
        mask: 1,
        "mask-border": 1,
        offset: 1,
        outline: 1,
        overflow: 1,
        "overscroll-behavior": 1,
        padding: 1,
        "padding-block": 2,
        "padding-inline": 2,
        "place-content": 1,
        "place-items": 1,
        "place-self": 1,
        "position-try": 1,
        "scroll-margin": 1,
        "scroll-margin-block": 2,
        "scroll-margin-inline": 2,
        "scroll-padding": 1,
        "scroll-padding-block": 2,
        "scroll-padding-inline": 2,
        "scroll-timeline": 1,
        "text-decoration": 1,
        "text-emphasis": 1,
        "text-wrap": 1,
        transition: 1,
        "view-timeline": 1
      };
      var getShorthandDepth = (shorthand) => {
        var _a2;
        return (_a2 = shorthandBuckets[shorthand]) !== null && _a2 !== void 0 ? _a2 : null;
      };
      exports.getShorthandDepth = getShorthandDepth;
    }
  });

  // node_modules/@compiled/react/dist/cjs/runtime/sheet.js
  var require_sheet = __commonJS({
    "node_modules/@compiled/react/dist/cjs/runtime/sheet.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getStyleBucketName = exports.styleBucketOrdering = void 0;
      var cache_1 = require_cache();
      var shorthand_1 = require_shorthand();
      exports.styleBucketOrdering = [
        // shorthand properties
        "s-0",
        "s-1",
        "s-2",
        "s-3",
        "s-4",
        "s-5",
        // catch-all
        "",
        // link
        "l",
        // visited
        "v",
        // focus-within
        "w",
        // focus
        "f",
        // focus-visible
        "i",
        // hover
        "h",
        // active
        "a",
        // at-rules
        "m"
      ];
      var styleBucketsInHead = {};
      var pseudosMap = {
        // link
        k: "l",
        // visited
        ited: "v",
        // focus-within
        "us-within": "w",
        // focus
        us: "f",
        // focus-visible
        "us-visible": "i",
        // hover
        er: "h",
        // active
        ive: "a"
      };
      function lazyAddStyleBucketToHead(bucketName, opts) {
        if (!styleBucketsInHead[bucketName]) {
          let currentBucketIndex = exports.styleBucketOrdering.indexOf(bucketName) + 1;
          let nextBucketFromCache = null;
          for (; currentBucketIndex < exports.styleBucketOrdering.length; currentBucketIndex++) {
            const nextBucket = styleBucketsInHead[exports.styleBucketOrdering[currentBucketIndex]];
            if (nextBucket) {
              nextBucketFromCache = nextBucket;
              break;
            }
          }
          const tag = document.createElement("style");
          opts.nonce && tag.setAttribute("nonce", opts.nonce);
          tag.appendChild(document.createTextNode(""));
          document.head.insertBefore(tag, nextBucketFromCache);
          if (false) {
            return tag;
          }
          styleBucketsInHead[bucketName] = tag;
        }
        return styleBucketsInHead[bucketName];
      }
      var getStyleBucketName = (sheet) => {
        if (sheet.charCodeAt(0) === 64) {
          return "m";
        }
        const firstBracket = sheet.indexOf("{");
        if (sheet.charCodeAt(10) === 58) {
          const mapped = pseudosMap[sheet.slice(14, firstBracket)];
          if (mapped)
            return mapped;
        }
        const property = sheet.slice(firstBracket + 1, sheet.indexOf(":", firstBracket)).trim();
        const shorthandDepth = (0, shorthand_1.getShorthandDepth)(property);
        if (typeof shorthandDepth === "number") {
          return `s-${shorthandDepth}`;
        }
        return "";
      };
      exports.getStyleBucketName = getStyleBucketName;
      function insertRule(css7, opts) {
        const bucketName = (0, exports.getStyleBucketName)(css7);
        const style = lazyAddStyleBucketToHead(bucketName, opts);
        if (true) {
          const sheet = style.sheet;
          try {
            sheet.insertRule(css7, sheet.cssRules.length);
          } catch (_a2) {
          }
        } else {
          style.appendChild(document.createTextNode(css7));
        }
      }
      exports.default = insertRule;
    }
  });

  // node_modules/@compiled/react/dist/cjs/runtime/style-cache.js
  var require_style_cache = __commonJS({
    "node_modules/@compiled/react/dist/cjs/runtime/style-cache.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      }) : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule) return mod;
        var result2 = {};
        if (mod != null) {
          for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result2, mod, k);
        }
        __setModuleDefault(result2, mod);
        return result2;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.useCache = void 0;
      var React94 = __importStar(require_react());
      var react_1 = require_react();
      var cache_1 = require_cache();
      var is_server_environment_1 = require_is_server_environment();
      var Cache2 = (0, is_server_environment_1.isServerEnvironment)() ? (0, react_1.createContext)(null) : {};
      if (!(0, is_server_environment_1.isServerEnvironment)() && typeof document !== "undefined") {
        const ssrStyles = document.querySelectorAll("style[data-cmpld]");
        for (let i = 0; i < ssrStyles.length; i++) {
          document.head.appendChild(ssrStyles[i]);
        }
      }
      var useCache = () => {
        if (false) {
          return {};
        }
        if ((0, is_server_environment_1.isServerEnvironment)()) {
          return (0, react_1.useContext)(Cache2) || {};
        }
        return Cache2;
      };
      exports.useCache = useCache;
      var StyleCacheProvider = (props) => {
        if ((0, is_server_environment_1.isServerEnvironment)()) {
          const inserted = (0, exports.useCache)();
          return React94.createElement(Cache2.Provider, { value: inserted }, props.children);
        }
        return props.children;
      };
      exports.default = StyleCacheProvider;
    }
  });

  // node_modules/@compiled/react/dist/cjs/runtime/style.js
  var require_style = __commonJS({
    "node_modules/@compiled/react/dist/cjs/runtime/style.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      }) : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule) return mod;
        var result2 = {};
        if (mod != null) {
          for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result2, mod, k);
        }
        __setModuleDefault(result2, mod);
        return result2;
      };
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      var react_1 = __importDefault(require_react());
      var dev_warnings_1 = require_dev_warnings();
      var is_server_environment_1 = require_is_server_environment();
      var sheet_1 = __importStar(require_sheet());
      var style_cache_1 = require_style_cache();
      function Style2(props) {
        const inserted = (0, style_cache_1.useCache)();
        if (false) {
          props.children.forEach(dev_warnings_1.analyzeCssInDev);
        }
        if (props.children.length) {
          if ((0, is_server_environment_1.isServerEnvironment)()) {
            const bucketedSheets = {};
            let hasSheets = false;
            for (let i = 0; i < props.children.length; i++) {
              const sheet = props.children[i];
              if (inserted[sheet]) {
                continue;
              } else {
                inserted[sheet] = true;
                hasSheets = true;
              }
              const bucketName = (0, sheet_1.getStyleBucketName)(sheet);
              bucketedSheets[bucketName] = (bucketedSheets[bucketName] || "") + sheet;
            }
            if (!hasSheets) {
              return null;
            }
            return react_1.default.createElement("style", { "data-cmpld": true, nonce: props.nonce, dangerouslySetInnerHTML: {
              __html: sheet_1.styleBucketOrdering.map((bucket) => bucketedSheets[bucket]).join("")
            } });
          } else {
            for (let i = 0; i < props.children.length; i++) {
              const sheet = props.children[i];
              if (inserted[sheet]) {
                continue;
              }
              inserted[sheet] = true;
              (0, sheet_1.default)(sheet, props);
            }
          }
        }
        return null;
      }
      exports.default = Style2;
    }
  });

  // node_modules/@compiled/react/dist/cjs/runtime/ax.js
  var require_ax = __commonJS({
    "node_modules/@compiled/react/dist/cjs/runtime/ax.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var ATOMIC_GROUP_LENGTH2 = 5;
      function ax2(classNames2) {
        if (!classNames2.length) {
          return;
        }
        if (classNames2.length === 1 && classNames2[0] && // checking to see if `classNames[0]` is a string that contains other classnames
        !classNames2[0].includes(" ")) {
          return classNames2[0];
        }
        const map = {};
        for (const value of classNames2) {
          if (!value) {
            continue;
          }
          const list = value.split(" ");
          for (const className of list) {
            const key = className.startsWith("_") ? className.slice(0, ATOMIC_GROUP_LENGTH2) : className;
            map[key] = className;
          }
        }
        let result2 = "";
        for (const key in map) {
          result2 += map[key] + " ";
        }
        if (!result2) {
          return;
        }
        return result2.trimEnd();
      }
      exports.default = ax2;
    }
  });

  // node_modules/@compiled/react/dist/cjs/runtime/ac.js
  var require_ac = __commonJS({
    "node_modules/@compiled/react/dist/cjs/runtime/ac.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getCache = exports.clearCache = exports.memoizedAc = exports.ac = void 0;
      var is_server_environment_1 = require_is_server_environment();
      var UNDERSCORE_UNICODE = 95;
      var ATOMIC_GROUP_LENGTH2 = 5;
      var cache = /* @__PURE__ */ new Map();
      var AtomicGroups = class {
        constructor(values) {
          this.values = values;
        }
        toString() {
          let str = "";
          for (const [, value] of this.values) {
            str += value + " ";
          }
          return str.slice(0, -1);
        }
      };
      function ac(classNames2) {
        if (classNames2.length <= 1 && !classNames2[0])
          return void 0;
        const atomicGroups = /* @__PURE__ */ new Map();
        for (let i = 0; i < classNames2.length; i++) {
          const cls = classNames2[i];
          if (!cls) {
            continue;
          }
          if (typeof cls === "string") {
            const groups = cls.split(" ");
            for (let x = 0; x < groups.length; x++) {
              const atomic = groups[x];
              const isAtomic = atomic.charCodeAt(0) === UNDERSCORE_UNICODE;
              const isCompressed = isAtomic && atomic.charCodeAt(5) === UNDERSCORE_UNICODE;
              const atomicGroupName = isAtomic ? atomic.slice(0, ATOMIC_GROUP_LENGTH2) : atomic;
              atomicGroups.set(atomicGroupName, isCompressed ? atomic.slice(ATOMIC_GROUP_LENGTH2 + 1) : atomic);
            }
          } else {
            for (const [key, value] of cls.values) {
              atomicGroups.set(key, value);
            }
          }
        }
        return new AtomicGroups(atomicGroups);
      }
      exports.ac = ac;
      function memoizedAc(classNames2) {
        if (classNames2.length <= 1 && !classNames2[0])
          return void 0;
        let cacheKey = "";
        for (let i = 0; i < classNames2.length; i += 1) {
          const current = classNames2[i];
          if (!current)
            continue;
          cacheKey += current + " ";
        }
        cacheKey = cacheKey.slice(0, -1);
        if (cache.has(cacheKey))
          return cache.get(cacheKey);
        const result2 = ac(classNames2);
        cache.set(cacheKey, result2);
        return result2;
      }
      exports.memoizedAc = memoizedAc;
      exports.default = (0, is_server_environment_1.isServerEnvironment)() ? ac : memoizedAc;
      function clearCache2() {
        cache.clear();
      }
      exports.clearCache = clearCache2;
      function getCache() {
        return cache;
      }
      exports.getCache = getCache;
    }
  });

  // node_modules/@compiled/react/dist/cjs/runtime/css-custom-property.js
  var require_css_custom_property = __commonJS({
    "node_modules/@compiled/react/dist/cjs/runtime/css-custom-property.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      function cssCustomPropertyValue2(value, suffix, prefix3) {
        if (value != void 0) {
          if (suffix) {
            if (prefix3) {
              return prefix3 + value + suffix;
            }
            return value + suffix;
          }
          return value;
        }
        return "var(--c-, )";
      }
      exports.default = cssCustomPropertyValue2;
    }
  });

  // node_modules/@compiled/react/dist/cjs/runtime/index.js
  var require_runtime = __commonJS({
    "node_modules/@compiled/react/dist/cjs/runtime/index.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ix = exports.clearAcCache = exports.ac = exports.ax = exports.CC = exports.CS = void 0;
      var style_1 = require_style();
      Object.defineProperty(exports, "CS", { enumerable: true, get: function() {
        return __importDefault(style_1).default;
      } });
      var style_cache_1 = require_style_cache();
      Object.defineProperty(exports, "CC", { enumerable: true, get: function() {
        return __importDefault(style_cache_1).default;
      } });
      var ax_1 = require_ax();
      Object.defineProperty(exports, "ax", { enumerable: true, get: function() {
        return __importDefault(ax_1).default;
      } });
      var ac_1 = require_ac();
      Object.defineProperty(exports, "ac", { enumerable: true, get: function() {
        return __importDefault(ac_1).default;
      } });
      Object.defineProperty(exports, "clearAcCache", { enumerable: true, get: function() {
        return ac_1.clearCache;
      } });
      var css_custom_property_1 = require_css_custom_property();
      Object.defineProperty(exports, "ix", { enumerable: true, get: function() {
        return __importDefault(css_custom_property_1).default;
      } });
    }
  });

  // node_modules/@compiled/react/dist/cjs/runtime.js
  var require_runtime2 = __commonJS({
    "node_modules/@compiled/react/dist/cjs/runtime.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ix = exports.clearAcCache = exports.ac = exports.ax = exports.CS = exports.CC = void 0;
      var index_1 = require_runtime();
      Object.defineProperty(exports, "CC", { enumerable: true, get: function() {
        return index_1.CC;
      } });
      Object.defineProperty(exports, "CS", { enumerable: true, get: function() {
        return index_1.CS;
      } });
      Object.defineProperty(exports, "ax", { enumerable: true, get: function() {
        return index_1.ax;
      } });
      Object.defineProperty(exports, "ac", { enumerable: true, get: function() {
        return index_1.ac;
      } });
      Object.defineProperty(exports, "clearAcCache", { enumerable: true, get: function() {
        return index_1.clearAcCache;
      } });
      Object.defineProperty(exports, "ix", { enumerable: true, get: function() {
        return index_1.ix;
      } });
    }
  });

  // node_modules/@atlaskit/icon/dist/cjs/components/icon-new.js
  var require_icon_new = __commonJS({
    "node_modules/@atlaskit/icon/dist/cjs/components/icon-new.js"(exports) {
      "use strict";
      var _typeof2 = require_typeof();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = exports.Icon = void 0;
      require_icon_new_compiled();
      var _react = _interopRequireWildcard(require_react());
      var React94 = _react;
      var _runtime = require_runtime2();
      var _platformFeatureFlags = require_cjs3();
      function _interopRequireWildcard(e, t) {
        if ("function" == typeof WeakMap) var r = /* @__PURE__ */ new WeakMap(), n = /* @__PURE__ */ new WeakMap();
        return (_interopRequireWildcard = function _interopRequireWildcard2(e2, t2) {
          if (!t2 && e2 && e2.__esModule) return e2;
          var o, i, f = { __proto__: null, default: e2 };
          if (null === e2 || "object" != _typeof2(e2) && "function" != typeof e2) return f;
          if (o = t2 ? n : r) {
            if (o.has(e2)) return o.get(e2);
            o.set(e2, f);
          }
          for (var _t in e2) "default" !== _t && {}.hasOwnProperty.call(e2, _t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e2, _t)) && (i.get || i.set) ? o(f, _t, i) : f[_t] = e2[_t]);
          return f;
        })(e, t);
      }
      var coreSizeMedium = {
        none: "_1bsbpxbi _4t3ipxbi",
        compact: "_1bsb1ejb _4t3i1ejb",
        spacious: "_1bsb1ejb _4t3i1ejb"
      };
      var coreSizeSmall = {
        none: "_1bsbutpp _4t3iutpp",
        compact: "_1bsbpxbi _4t3ipxbi",
        spacious: "_1bsb1ejb _4t3i1ejb"
      };
      var utilSizes = {
        none: "_1bsbutpp _4t3iutpp",
        compact: "_1bsbpxbi _4t3ipxbi",
        spacious: "_1bsb1ejb _4t3i1ejb"
      };
      var baseSizeMap = {
        core: 16,
        utility: 12
      };
      var paddingMap = {
        core: {
          medium: {
            none: 0,
            compact: 4,
            spacious: 4
          },
          small: {
            none: 0,
            compact: 2.66,
            spacious: 8
          }
        },
        utility: {
          medium: {
            none: 0,
            compact: 2,
            spacious: 6
          },
          small: {
            none: 0,
            compact: 2,
            spacious: 6
          }
        }
      };
      var Icon = exports.Icon = /* @__PURE__ */ (0, _react.memo)(function Icon2(props) {
        var _props$type;
        var _ref2 = props, _ref$color = _ref2.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, testId = _ref2.testId, label = _ref2.label, LEGACY_primaryColor = _ref2.LEGACY_primaryColor, LEGACY_secondaryColor = _ref2.LEGACY_secondaryColor, LEGACY_size = _ref2.LEGACY_size, FallbackIcon = _ref2.LEGACY_fallbackIcon, dangerouslySetGlyph = _ref2.dangerouslySetGlyph, shouldScale = _ref2.shouldScale, LEGACY_margin = _ref2.LEGACY_margin, _ref$spacing = _ref2.spacing, spacing = _ref$spacing === void 0 ? "none" : _ref$spacing;
        var dangerouslySetInnerHTML = dangerouslySetGlyph ? {
          __html: dangerouslySetGlyph
        } : void 0;
        if (FallbackIcon && !(0, _platformFeatureFlags.fg)("platform-visual-refresh-icons")) {
          return /* @__PURE__ */ React94.createElement(FallbackIcon, {
            primaryColor: LEGACY_primaryColor !== null && LEGACY_primaryColor !== void 0 ? LEGACY_primaryColor : color,
            secondaryColor: LEGACY_secondaryColor,
            size: LEGACY_size,
            label,
            testId,
            UNSAFE_margin: LEGACY_margin
          });
        }
        var type = (_props$type = props.type) !== null && _props$type !== void 0 ? _props$type : "core";
        var size2 = "size" in props && props.size !== void 0 && // This prevents invalid sizes being passed in, which is required
        // for handling unsupported legacy icon sizes which can
        // cause errors.
        (props.size === "small" || props.size === "medium") ? props.size : "medium";
        var baseSize = baseSizeMap[type];
        var viewBoxPadding = paddingMap[type][size2][spacing];
        var viewBoxSize = baseSize + 2 * viewBoxPadding;
        return /* @__PURE__ */ React94.createElement("span", {
          "data-testid": testId,
          role: label ? "img" : void 0,
          "aria-label": label ? label : void 0,
          "aria-hidden": label ? void 0 : true,
          style: {
            color
          },
          className: (0, _runtime.ax)(["_1e0c1o8l _vchhusvi _1o9zidpf _vwz4kb7n _y4ti1igz _bozg1mb9", "_12va1onz _jcxd1r8n", shouldScale && "_1bsb1kw7 _4t3i1kw7", (type === "utility" || size2 === "small") && "_vwz4utpp"])
        }, /* @__PURE__ */ React94.createElement("svg", {
          fill: "none",
          viewBox: "".concat(0 - viewBoxPadding, " ").concat(0 - viewBoxPadding, " ").concat(viewBoxSize, " ").concat(viewBoxSize),
          role: "presentation",
          dangerouslySetInnerHTML,
          className: (0, _runtime.ax)(["_1reo15vq _18m915vq _syaz1r31 _lcxvglyw _s7n4yfq0 _vc881r31", shouldScale ? "_1bsb1kw7 _4t3i1kw7" : type === "utility" ? utilSizes[spacing] : size2 === "small" ? coreSizeSmall[spacing] : coreSizeMedium[spacing]])
        }));
      });
      var _default = exports.default = Icon;
    }
  });

  // node_modules/@atlaskit/icon/dist/cjs/entry-points/base-new.js
  var require_base_new = __commonJS({
    "node_modules/@atlaskit/icon/dist/cjs/entry-points/base-new.js"(exports) {
      "use strict";
      var _typeof2 = require_typeof();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "Icon", {
        enumerable: true,
        get: function get() {
          return _iconNew.Icon;
        }
      });
      Object.defineProperty(exports, "default", {
        enumerable: true,
        get: function get() {
          return _iconNew.default;
        }
      });
      var _iconNew = _interopRequireWildcard(require_icon_new());
      function _interopRequireWildcard(e, t) {
        if ("function" == typeof WeakMap) var r = /* @__PURE__ */ new WeakMap(), n = /* @__PURE__ */ new WeakMap();
        return (_interopRequireWildcard = function _interopRequireWildcard2(e2, t2) {
          if (!t2 && e2 && e2.__esModule) return e2;
          var o, i, f = { __proto__: null, default: e2 };
          if (null === e2 || "object" != _typeof2(e2) && "function" != typeof e2) return f;
          if (o = t2 ? n : r) {
            if (o.has(e2)) return o.get(e2);
            o.set(e2, f);
          }
          for (var _t in e2) "default" !== _t && {}.hasOwnProperty.call(e2, _t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e2, _t)) && (i.get || i.set) ? o(f, _t, i) : f[_t] = e2[_t]);
          return f;
        })(e, t);
      }
    }
  });

  // node_modules/@atlaskit/icon/core/cross.js
  var require_cross = __commonJS({
    "node_modules/@atlaskit/icon/core/cross.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _react = _interopRequireDefault(require_react());
      var _baseNew = _interopRequireDefault(require_base_new());
      function _interopRequireDefault(e) {
        return e && e.__esModule ? e : { default: e };
      }
      var CrossIcon6 = (props) => /* @__PURE__ */ _react.default.createElement(_baseNew.default, Object.assign({
        dangerouslySetGlyph: `<path fill="currentcolor" d="M14.03 3.03 9.06 8l4.97 4.97-1.06 1.06L8 9.06l-4.97 4.97-1.06-1.06L6.94 8 1.97 3.03l1.06-1.06L8 6.94l4.97-4.97z"/>`
        // eslint-disable-next-line @repo/internal/react/no-unsafe-spread-props
      }, props));
      CrossIcon6.displayName = "CrossIcon";
      var _default = exports.default = CrossIcon6;
    }
  });

  // node_modules/@atlaskit/icon/dist/cjs/components/icon.compiled.css
  var require_icon_compiled = __commonJS({
    "node_modules/@atlaskit/icon/dist/cjs/components/icon.compiled.css"(exports, module2) {
      module2.exports = {};
    }
  });

  // node_modules/@babel/runtime/helpers/extends.js
  var require_extends = __commonJS({
    "node_modules/@babel/runtime/helpers/extends.js"(exports, module2) {
      function _extends2() {
        return module2.exports = _extends2 = Object.assign ? Object.assign.bind() : function(n) {
          for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
          }
          return n;
        }, module2.exports.__esModule = true, module2.exports["default"] = module2.exports, _extends2.apply(null, arguments);
      }
      module2.exports = _extends2, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
    }
  });

  // node_modules/@atlaskit/icon/dist/cjs/components/icon.js
  var require_icon = __commonJS({
    "node_modules/@atlaskit/icon/dist/cjs/components/icon.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      var _typeof2 = require_typeof();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = exports.Icon = void 0;
      require_icon_compiled();
      var _react = _interopRequireWildcard(require_react());
      var React94 = _react;
      var _runtime = require_runtime2();
      var _extends2 = _interopRequireDefault(require_extends());
      var _defineProperty2 = _interopRequireDefault(require_defineProperty());
      function _interopRequireWildcard(e, t) {
        if ("function" == typeof WeakMap) var r = /* @__PURE__ */ new WeakMap(), n = /* @__PURE__ */ new WeakMap();
        return (_interopRequireWildcard = function _interopRequireWildcard2(e2, t2) {
          if (!t2 && e2 && e2.__esModule) return e2;
          var o, i, f = { __proto__: null, default: e2 };
          if (null === e2 || "object" != _typeof2(e2) && "function" != typeof e2) return f;
          if (o = t2 ? n : r) {
            if (o.has(e2)) return o.get(e2);
            o.set(e2, f);
          }
          for (var _t in e2) "default" !== _t && {}.hasOwnProperty.call(e2, _t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e2, _t)) && (i.get || i.set) ? o(f, _t, i) : f[_t] = e2[_t]);
          return f;
        })(e, t);
      }
      function ownKeys25(e, r) {
        var t = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
          var o = Object.getOwnPropertySymbols(e);
          r && (o = o.filter(function(r2) {
            return Object.getOwnPropertyDescriptor(e, r2).enumerable;
          })), t.push.apply(t, o);
        }
        return t;
      }
      function _objectSpread25(e) {
        for (var r = 1; r < arguments.length; r++) {
          var t = null != arguments[r] ? arguments[r] : {};
          r % 2 ? ownKeys25(Object(t), true).forEach(function(r2) {
            (0, _defineProperty2.default)(e, r2, t[r2]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys25(Object(t)).forEach(function(r2) {
            Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
          });
        }
        return e;
      }
      var sizeStyles = {
        small: "_1bsb7vkz _4t3i7vkz _5fdi7vkz _zbji7vkz",
        medium: "_1bsb1tcg _4t3i1tcg _5fdi1tcg _zbji1tcg",
        large: "_1bsbzwfg _4t3izwfg _5fdizwfg _zbjizwfg",
        xlarge: "_1bsbckbl _4t3ickbl _5fdickbl _zbjickbl"
      };
      var Icon = exports.Icon = /* @__PURE__ */ (0, _react.memo)(function Icon2(props) {
        var _ref2 = props, Glyph = _ref2.glyph, dangerouslySetGlyph = _ref2.dangerouslySetGlyph, _ref$primaryColor = _ref2.primaryColor, primaryColor = _ref$primaryColor === void 0 ? "currentColor" : _ref$primaryColor, secondaryColor = _ref2.secondaryColor, size2 = _ref2.size, testId = _ref2.testId, label = _ref2.label, width2 = _ref2.width, height = _ref2.height, UNSAFE_margin = _ref2.UNSAFE_margin;
        var glyphProps = dangerouslySetGlyph ? {
          dangerouslySetInnerHTML: {
            __html: dangerouslySetGlyph
          }
        } : {
          children: Glyph ? /* @__PURE__ */ React94.createElement(Glyph, {
            role: "presentation"
          }) : null
        };
        var customDimensions = width2 && height ? {
          width: width2 + "px",
          height: height + "px"
        } : null;
        return /* @__PURE__ */ React94.createElement("span", (0, _extends2.default)({
          "data-testid": testId,
          "data-vc": "icon-".concat(testId),
          role: label ? "img" : void 0,
          "aria-label": label ? label : void 0,
          "aria-hidden": label ? void 0 : true,
          style: _objectSpread25(_objectSpread25({}, customDimensions), {}, {
            "--icon-primary-color": primaryColor,
            // eslint-disable-next-line @atlaskit/ui-styling-standard/no-imported-style-values -- Ignored via go/DSP-18766
            "--icon-secondary-color": secondaryColor,
            // eslint-disable-next-line @atlaskit/ui-styling-standard/no-imported-style-values -- Ignored via go/DSP-18766
            margin: UNSAFE_margin
          })
        }, glyphProps, {
          className: (0, _runtime.ax)(["_1e0c1o8l _1o9zidpf _vyfuvuon _vwz4kb7n _1szv15vq _1tly15vq _rzyw1osq _17jb1osq _1ksvoz0e _3se1x1jp _re2rglyw _1veoyfq0 _1kg81r31", "_jcxd1r8n _gq0g1onz _1trkwc43", primaryColor === secondaryColor && "_18hbwc43", secondaryColor === "transparent" && "_4fyi1j28", size2 && sizeStyles[size2]])
        }));
      });
      var _default = exports.default = Icon;
    }
  });

  // node_modules/@atlaskit/icon/dist/cjs/components/icon-facade.js
  var require_icon_facade = __commonJS({
    "node_modules/@atlaskit/icon/dist/cjs/components/icon-facade.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      var _typeof2 = require_typeof();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.IconFacade = void 0;
      var _extends2 = _interopRequireDefault(require_extends());
      var _objectWithoutProperties2 = _interopRequireDefault(require_objectWithoutProperties());
      var _react = _interopRequireWildcard(require_react());
      var _platformFeatureFlags = require_cjs3();
      var _icon = require_icon();
      var _excluded30 = ["dangerouslySetGlyph", "size"];
      function _interopRequireWildcard(e, t) {
        if ("function" == typeof WeakMap) var r = /* @__PURE__ */ new WeakMap(), n = /* @__PURE__ */ new WeakMap();
        return (_interopRequireWildcard = function _interopRequireWildcard2(e2, t2) {
          if (!t2 && e2 && e2.__esModule) return e2;
          var o, i, f = { __proto__: null, default: e2 };
          if (null === e2 || "object" != _typeof2(e2) && "function" != typeof e2) return f;
          if (o = t2 ? n : r) {
            if (o.has(e2)) return o.get(e2);
            o.set(e2, f);
          }
          for (var _t in e2) "default" !== _t && {}.hasOwnProperty.call(e2, _t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e2, _t)) && (i.get || i.set) ? o(f, _t, i) : f[_t] = e2[_t]);
          return f;
        })(e, t);
      }
      var sizeSpacingMap = {
        utility: {
          small: "compact",
          medium: "spacious"
        },
        core: {
          small: "none",
          medium: "spacious"
        }
      };
      var IconFacade = exports.IconFacade = /* @__PURE__ */ (0, _react.memo)(function IconFacade2(_ref2) {
        var dangerouslySetGlyph = _ref2.dangerouslySetGlyph, size2 = _ref2.size, props = (0, _objectWithoutProperties2.default)(_ref2, _excluded30);
        var NewIcon = props.newIcon;
        var iconSize = size2 !== null && size2 !== void 0 ? size2 : "medium";
        var useNewIcon = !props.isFacadeDisabled && // eslint-disable-next-line @atlaskit/platform/ensure-feature-flag-prefix
        (0, _platformFeatureFlags.fg)("platform-visual-refresh-icons-legacy-facade");
        if (useNewIcon && NewIcon && (iconSize === "small" || iconSize === "medium") && !(0, _platformFeatureFlags.fg)("platform-visual-refresh-icons-facade-removal")) {
          if (props.iconType === "utility") {
            var Icon = NewIcon;
            return /* @__PURE__ */ _react.default.createElement(Icon, (0, _extends2.default)({}, props, {
              spacing: (0, _platformFeatureFlags.fg)("platform-visual-refresh-icons-facade-button-fix") ? sizeSpacingMap["utility"][iconSize] : "none",
              color: props.primaryColor || "currentColor",
              type: props.iconType
            }));
          } else {
            var _Icon = NewIcon;
            return /* @__PURE__ */ _react.default.createElement(_Icon, (0, _extends2.default)({}, props, {
              size: iconSize,
              spacing: sizeSpacingMap["core"][iconSize],
              color: props.primaryColor || "currentColor",
              type: props.iconType
            }));
          }
        }
        return /* @__PURE__ */ _react.default.createElement(_icon.Icon, (0, _extends2.default)({
          dangerouslySetGlyph,
          size: size2
        }, props));
      });
    }
  });

  // node_modules/@atlaskit/icon/dist/cjs/entry-points/base.js
  var require_base = __commonJS({
    "node_modules/@atlaskit/icon/dist/cjs/entry-points/base.js"(exports) {
      "use strict";
      var _typeof2 = require_typeof();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "Icon", {
        enumerable: true,
        get: function get() {
          return _icon.Icon;
        }
      });
      Object.defineProperty(exports, "IconFacade", {
        enumerable: true,
        get: function get() {
          return _iconFacade.IconFacade;
        }
      });
      Object.defineProperty(exports, "default", {
        enumerable: true,
        get: function get() {
          return _icon.default;
        }
      });
      var _icon = _interopRequireWildcard(require_icon());
      var _iconFacade = require_icon_facade();
      function _interopRequireWildcard(e, t) {
        if ("function" == typeof WeakMap) var r = /* @__PURE__ */ new WeakMap(), n = /* @__PURE__ */ new WeakMap();
        return (_interopRequireWildcard = function _interopRequireWildcard2(e2, t2) {
          if (!t2 && e2 && e2.__esModule) return e2;
          var o, i, f = { __proto__: null, default: e2 };
          if (null === e2 || "object" != _typeof2(e2) && "function" != typeof e2) return f;
          if (o = t2 ? n : r) {
            if (o.has(e2)) return o.get(e2);
            o.set(e2, f);
          }
          for (var _t in e2) "default" !== _t && {}.hasOwnProperty.call(e2, _t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e2, _t)) && (i.get || i.set) ? o(f, _t, i) : f[_t] = e2[_t]);
          return f;
        })(e, t);
      }
    }
  });

  // node_modules/@atlaskit/icon/glyph/cross.js
  var require_cross2 = __commonJS({
    "node_modules/@atlaskit/icon/glyph/cross.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _react = _interopRequireDefault(require_react());
      var _base = require_base();
      var _cross = _interopRequireDefault(require_cross());
      function _interopRequireDefault(e) {
        return e && e.__esModule ? e : { default: e };
      }
      var CrossIcon6 = (props) => /* @__PURE__ */ _react.default.createElement(_base.IconFacade, Object.assign({
        dangerouslySetGlyph: `<svg width="24" height="24" viewBox="0 0 24 24" role="presentation"><path fill="currentcolor" d="M12 10.586 6.707 5.293a1 1 0 0 0-1.414 1.414L10.586 12l-5.293 5.293a1 1 0 0 0 1.414 1.414L12 13.414l5.293 5.293a1 1 0 0 0 1.414-1.414L13.414 12l5.293-5.293a1 1 0 1 0-1.414-1.414z"/></svg>`
      }, props, {
        newIcon: _cross.default
      }));
      CrossIcon6.displayName = "CrossIcon";
      var _default = exports.default = CrossIcon6;
    }
  });

  // node_modules/@atlaskit/icon/core/migration/cross.js
  var require_cross3 = __commonJS({
    "node_modules/@atlaskit/icon/core/migration/cross.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _react = _interopRequireDefault(require_react());
      var _cross = _interopRequireDefault(require_cross());
      var _cross2 = _interopRequireDefault(require_cross2());
      function _interopRequireDefault(e) {
        return e && e.__esModule ? e : { default: e };
      }
      var CrossIcon6 = (props) => /* @__PURE__ */ _react.default.createElement(_cross.default, Object.assign({
        LEGACY_fallbackIcon: _cross2.default
        // eslint-disable-next-line @repo/internal/react/no-unsafe-spread-props
      }, props));
      CrossIcon6.Name = "CrossIconMigration";
      var _default = exports.default = CrossIcon6;
    }
  });

  // node_modules/@atlaskit/icon/core/status-error.js
  var require_status_error = __commonJS({
    "node_modules/@atlaskit/icon/core/status-error.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _react = _interopRequireDefault(require_react());
      var _baseNew = _interopRequireDefault(require_base_new());
      function _interopRequireDefault(e) {
        return e && e.__esModule ? e : { default: e };
      }
      var StatusErrorIcon = (props) => /* @__PURE__ */ _react.default.createElement(_baseNew.default, Object.assign({
        dangerouslySetGlyph: `<path fill="currentcolor" fill-rule="evenodd" d="M6.586.603a2 2 0 0 1 2.828 0l5.983 5.983a2 2 0 0 1 0 2.828l-5.983 5.982a2 2 0 0 1-2.828 0L.604 9.414a2 2 0 0 1 0-2.828zM8 10.25a1 1 0 1 0 0 2 1 1 0 0 0 0-2m-.75-6.5V9h1.5V3.75z" clip-rule="evenodd"/>`
        // eslint-disable-next-line @repo/internal/react/no-unsafe-spread-props
      }, props));
      StatusErrorIcon.displayName = "StatusErrorIcon";
      var _default = exports.default = StatusErrorIcon;
    }
  });

  // node_modules/@atlaskit/icon/glyph/error.js
  var require_error = __commonJS({
    "node_modules/@atlaskit/icon/glyph/error.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _react = _interopRequireDefault(require_react());
      var _base = require_base();
      var _statusError = _interopRequireDefault(require_status_error());
      function _interopRequireDefault(e) {
        return e && e.__esModule ? e : { default: e };
      }
      var ErrorIcon3 = (props) => /* @__PURE__ */ _react.default.createElement(_base.IconFacade, Object.assign({
        dangerouslySetGlyph: `<svg width="24" height="24" viewBox="0 0 24 24" role="presentation"><g fill-rule="evenodd"><path fill="currentcolor" d="M13.416 4.417a2 2 0 0 0-2.832 0l-6.168 6.167a2 2 0 0 0 0 2.833l6.168 6.167a2 2 0 0 0 2.832 0l6.168-6.167a2 2 0 0 0 0-2.833z"/><path fill="inherit" d="M12 14a1 1 0 0 1-1-1V8a1 1 0 0 1 2 0v5a1 1 0 0 1-1 1m0 3a1 1 0 0 1 0-2 1 1 0 0 1 0 2"/></g></svg>`
      }, props, {
        newIcon: _statusError.default
      }));
      ErrorIcon3.displayName = "ErrorIcon";
      var _default = exports.default = ErrorIcon3;
    }
  });

  // node_modules/@atlaskit/icon/core/migration/status-error--error.js
  var require_status_error_error = __commonJS({
    "node_modules/@atlaskit/icon/core/migration/status-error--error.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _react = _interopRequireDefault(require_react());
      var _statusError = _interopRequireDefault(require_status_error());
      var _error = _interopRequireDefault(require_error());
      function _interopRequireDefault(e) {
        return e && e.__esModule ? e : { default: e };
      }
      var StatusErrorIcon = (props) => /* @__PURE__ */ _react.default.createElement(_statusError.default, Object.assign({
        LEGACY_fallbackIcon: _error.default
        // eslint-disable-next-line @repo/internal/react/no-unsafe-spread-props
      }, props));
      StatusErrorIcon.Name = "StatusErrorIconMigration";
      var _default = exports.default = StatusErrorIcon;
    }
  });

  // node_modules/@atlaskit/icon/core/status-warning.js
  var require_status_warning = __commonJS({
    "node_modules/@atlaskit/icon/core/status-warning.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _react = _interopRequireDefault(require_react());
      var _baseNew = _interopRequireDefault(require_base_new());
      function _interopRequireDefault(e) {
        return e && e.__esModule ? e : { default: e };
      }
      var StatusWarningIcon = (props) => /* @__PURE__ */ _react.default.createElement(_baseNew.default, Object.assign({
        dangerouslySetGlyph: `<path fill="currentcolor" fill-rule="evenodd" d="M6.242 1.168c.756-1.395 2.76-1.395 3.516 0l5.9 10.878c.723 1.333-.242 2.953-1.758 2.953H2.1C.584 15-.38 13.38.342 12.046zM8 10.75a1 1 0 1 0 0 2.001 1 1 0 0 0 0-2M7.25 4.5v5h1.5v-5z" clip-rule="evenodd"/>`
        // eslint-disable-next-line @repo/internal/react/no-unsafe-spread-props
      }, props));
      StatusWarningIcon.displayName = "StatusWarningIcon";
      var _default = exports.default = StatusWarningIcon;
    }
  });

  // node_modules/@atlaskit/icon/glyph/warning.js
  var require_warning2 = __commonJS({
    "node_modules/@atlaskit/icon/glyph/warning.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _react = _interopRequireDefault(require_react());
      var _base = require_base();
      var _statusWarning = _interopRequireDefault(require_status_warning());
      function _interopRequireDefault(e) {
        return e && e.__esModule ? e : { default: e };
      }
      var WarningIcon3 = (props) => /* @__PURE__ */ _react.default.createElement(_base.IconFacade, Object.assign({
        dangerouslySetGlyph: `<svg width="24" height="24" viewBox="0 0 24 24" role="presentation"><g fill-rule="evenodd"><path fill="currentcolor" d="M12.938 4.967c-.518-.978-1.36-.974-1.876 0L3.938 18.425c-.518.978-.045 1.771 1.057 1.771h14.01c1.102 0 1.573-.797 1.057-1.771z"/><path fill="inherit" d="M12 15a1 1 0 0 1-1-1V9a1 1 0 0 1 2 0v5a1 1 0 0 1-1 1m0 3a1 1 0 0 1 0-2 1 1 0 0 1 0 2"/></g></svg>`
      }, props, {
        newIcon: _statusWarning.default
      }));
      WarningIcon3.displayName = "WarningIcon";
      var _default = exports.default = WarningIcon3;
    }
  });

  // node_modules/@atlaskit/icon/core/migration/status-warning--warning.js
  var require_status_warning_warning = __commonJS({
    "node_modules/@atlaskit/icon/core/migration/status-warning--warning.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _react = _interopRequireDefault(require_react());
      var _statusWarning = _interopRequireDefault(require_status_warning());
      var _warning = _interopRequireDefault(require_warning2());
      function _interopRequireDefault(e) {
        return e && e.__esModule ? e : { default: e };
      }
      var StatusWarningIcon = (props) => /* @__PURE__ */ _react.default.createElement(_statusWarning.default, Object.assign({
        LEGACY_fallbackIcon: _warning.default
        // eslint-disable-next-line @repo/internal/react/no-unsafe-spread-props
      }, props));
      StatusWarningIcon.Name = "StatusWarningIconMigration";
      var _default = exports.default = StatusWarningIcon;
    }
  });

  // node_modules/@atlaskit/icon/core/discovery.js
  var require_discovery = __commonJS({
    "node_modules/@atlaskit/icon/core/discovery.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _react = _interopRequireDefault(require_react());
      var _baseNew = _interopRequireDefault(require_base_new());
      function _interopRequireDefault(e) {
        return e && e.__esModule ? e : { default: e };
      }
      var DiscoveryIcon2 = (props) => /* @__PURE__ */ _react.default.createElement(_baseNew.default, Object.assign({
        dangerouslySetGlyph: `<path fill="currentcolor" fill-rule="evenodd" d="M13 1H3a2 2 0 0 0-2 2v10a2 2 0 0 0 2 2h6v-4.75C9 9.56 9.56 9 10.25 9H15V3a2 2 0 0 0-2-2M4 5.5h7V4H4zM4 9h3V7.5H4z" clip-rule="evenodd"/><path fill="currentcolor" d="M11.25 10.5a.75.75 0 0 0-.75.75v3.81l4.56-4.56z"/>`
        // eslint-disable-next-line @repo/internal/react/no-unsafe-spread-props
      }, props));
      DiscoveryIcon2.displayName = "DiscoveryIcon";
      var _default = exports.default = DiscoveryIcon2;
    }
  });

  // node_modules/@atlaskit/icon/glyph/editor/note.js
  var require_note = __commonJS({
    "node_modules/@atlaskit/icon/glyph/editor/note.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _react = _interopRequireDefault(require_react());
      var _base = require_base();
      var _discovery = _interopRequireDefault(require_discovery());
      function _interopRequireDefault(e) {
        return e && e.__esModule ? e : { default: e };
      }
      var EditorNoteIcon = (props) => /* @__PURE__ */ _react.default.createElement(_base.IconFacade, Object.assign({
        dangerouslySetGlyph: `<svg width="24" height="24" viewBox="0 0 24 24" role="presentation"><path fill="currentcolor" fill-rule="evenodd" d="M8 4h8a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2m1.5 4a.5.5 0 0 0-.5.5v1a.5.5 0 0 0 .5.5h5a.5.5 0 0 0 .5-.5v-1a.5.5 0 0 0-.5-.5zm0 4a.5.5 0 0 0-.5.5v1a.5.5 0 0 0 .5.5h3a.5.5 0 0 0 .5-.5v-1a.5.5 0 0 0-.5-.5z"/></svg>`
      }, props, {
        newIcon: _discovery.default
      }));
      EditorNoteIcon.displayName = "EditorNoteIcon";
      var _default = exports.default = EditorNoteIcon;
    }
  });

  // node_modules/@atlaskit/icon/core/migration/discovery--editor-note.js
  var require_discovery_editor_note = __commonJS({
    "node_modules/@atlaskit/icon/core/migration/discovery--editor-note.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _react = _interopRequireDefault(require_react());
      var _discovery = _interopRequireDefault(require_discovery());
      var _note = _interopRequireDefault(require_note());
      function _interopRequireDefault(e) {
        return e && e.__esModule ? e : { default: e };
      }
      var DiscoveryIcon2 = (props) => /* @__PURE__ */ _react.default.createElement(_discovery.default, Object.assign({
        LEGACY_fallbackIcon: _note.default
        // eslint-disable-next-line @repo/internal/react/no-unsafe-spread-props
      }, props));
      DiscoveryIcon2.Name = "DiscoveryIconMigration";
      var _default = exports.default = DiscoveryIcon2;
    }
  });

  // node_modules/@atlaskit/icon/core/question-circle.js
  var require_question_circle = __commonJS({
    "node_modules/@atlaskit/icon/core/question-circle.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _react = _interopRequireDefault(require_react());
      var _baseNew = _interopRequireDefault(require_base_new());
      function _interopRequireDefault(e) {
        return e && e.__esModule ? e : { default: e };
      }
      var QuestionCircleIcon2 = (props) => /* @__PURE__ */ _react.default.createElement(_baseNew.default, Object.assign({
        dangerouslySetGlyph: `<path fill="currentcolor" fill-rule="evenodd" d="M8 1.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8m8-3c-.586 0-1 .414-1 1H5.5c0-1.414 1.086-2.5 2.5-2.5s2.5 1.086 2.5 2.5c0 1.133-.713 1.706-1.162 2.058-.511.402-.588.494-.588.692v.75h-1.5v-.75c0-.977.689-1.507 1.078-1.806l.084-.065C8.838 6.544 9 6.367 9 6c0-.586-.414-1-1-1" clip-rule="evenodd"/><path fill="currentcolor" d="M9 11.5a1 1 0 1 1-2 0 1 1 0 0 1 2 0"/>`
        // eslint-disable-next-line @repo/internal/react/no-unsafe-spread-props
      }, props));
      QuestionCircleIcon2.displayName = "QuestionCircleIcon";
      var _default = exports.default = QuestionCircleIcon2;
    }
  });

  // node_modules/@atlaskit/icon/glyph/question-circle.js
  var require_question_circle2 = __commonJS({
    "node_modules/@atlaskit/icon/glyph/question-circle.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _react = _interopRequireDefault(require_react());
      var _base = require_base();
      var _questionCircle = _interopRequireDefault(require_question_circle());
      function _interopRequireDefault(e) {
        return e && e.__esModule ? e : { default: e };
      }
      var QuestionCircleIcon2 = (props) => /* @__PURE__ */ _react.default.createElement(_base.IconFacade, Object.assign({
        dangerouslySetGlyph: `<svg width="24" height="24" viewBox="0 0 24 24" role="presentation"><g fill-rule="evenodd"><circle cx="12" cy="12" r="10" fill="currentcolor"/><circle cx="12" cy="18" r="1" fill="inherit"/><path fill="inherit" d="M15.89 9.05a3.98 3.98 0 0 0-2.957-2.942C10.321 5.514 8.017 7.446 8 9.95l.005.147a.99.99 0 0 0 .982.904c.552 0 1-.447 1.002-.998a2.004 2.004 0 0 1 4.007-.002c0 1.102-.898 2-2.003 2H12a1 1 0 0 0-1 .987v2.014a1.001 1.001 0 0 0 2.004 0v-.782c0-.217.145-.399.35-.472A3.99 3.99 0 0 0 15.89 9.05"/></g></svg>`
      }, props, {
        newIcon: _questionCircle.default
      }));
      QuestionCircleIcon2.displayName = "QuestionCircleIcon";
      var _default = exports.default = QuestionCircleIcon2;
    }
  });

  // node_modules/@atlaskit/icon/core/migration/question-circle.js
  var require_question_circle3 = __commonJS({
    "node_modules/@atlaskit/icon/core/migration/question-circle.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _react = _interopRequireDefault(require_react());
      var _questionCircle = _interopRequireDefault(require_question_circle());
      var _questionCircle2 = _interopRequireDefault(require_question_circle2());
      function _interopRequireDefault(e) {
        return e && e.__esModule ? e : { default: e };
      }
      var QuestionCircleIcon2 = (props) => /* @__PURE__ */ _react.default.createElement(_questionCircle.default, Object.assign({
        LEGACY_fallbackIcon: _questionCircle2.default
        // eslint-disable-next-line @repo/internal/react/no-unsafe-spread-props
      }, props));
      QuestionCircleIcon2.Name = "QuestionCircleIconMigration";
      var _default = exports.default = QuestionCircleIcon2;
    }
  });

  // node_modules/@atlaskit/icon/core/status-information.js
  var require_status_information = __commonJS({
    "node_modules/@atlaskit/icon/core/status-information.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _react = _interopRequireDefault(require_react());
      var _baseNew = _interopRequireDefault(require_base_new());
      function _interopRequireDefault(e) {
        return e && e.__esModule ? e : { default: e };
      }
      var StatusInformationIcon = (props) => /* @__PURE__ */ _react.default.createElement(_baseNew.default, Object.assign({
        dangerouslySetGlyph: `<path fill="currentcolor" fill-rule="evenodd" d="M8 0a8 8 0 1 1 0 16A8 8 0 0 1 8 0M6.5 6.75v1.5h.75v4.25h1.5v-5A.75.75 0 0 0 8 6.75zM8 3.5a1 1 0 1 0 0 2 1 1 0 0 0 0-2" clip-rule="evenodd"/>`
        // eslint-disable-next-line @repo/internal/react/no-unsafe-spread-props
      }, props));
      StatusInformationIcon.displayName = "StatusInformationIcon";
      var _default = exports.default = StatusInformationIcon;
    }
  });

  // node_modules/@atlaskit/icon/glyph/info.js
  var require_info = __commonJS({
    "node_modules/@atlaskit/icon/glyph/info.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _react = _interopRequireDefault(require_react());
      var _base = require_base();
      var _statusInformation = _interopRequireDefault(require_status_information());
      function _interopRequireDefault(e) {
        return e && e.__esModule ? e : { default: e };
      }
      var InfoIcon2 = (props) => /* @__PURE__ */ _react.default.createElement(_base.IconFacade, Object.assign({
        dangerouslySetGlyph: `<svg width="24" height="24" viewBox="0 0 24 24" role="presentation"><g fill-rule="evenodd"><path fill="currentcolor" d="M2 12c0 5.523 4.477 10 10 10s10-4.477 10-10S17.523 2 12 2 2 6.477 2 12"/><rect width="2" height="7" x="11" y="10" fill="inherit" rx="1"/><circle cx="12" cy="8" r="1" fill="inherit"/></g></svg>`
      }, props, {
        newIcon: _statusInformation.default
      }));
      InfoIcon2.displayName = "InfoIcon";
      var _default = exports.default = InfoIcon2;
    }
  });

  // node_modules/@atlaskit/icon/core/migration/status-information--info.js
  var require_status_information_info = __commonJS({
    "node_modules/@atlaskit/icon/core/migration/status-information--info.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _react = _interopRequireDefault(require_react());
      var _statusInformation = _interopRequireDefault(require_status_information());
      var _info = _interopRequireDefault(require_info());
      function _interopRequireDefault(e) {
        return e && e.__esModule ? e : { default: e };
      }
      var StatusInformationIcon = (props) => /* @__PURE__ */ _react.default.createElement(_statusInformation.default, Object.assign({
        LEGACY_fallbackIcon: _info.default
        // eslint-disable-next-line @repo/internal/react/no-unsafe-spread-props
      }, props));
      StatusInformationIcon.Name = "StatusInformationIconMigration";
      var _default = exports.default = StatusInformationIcon;
    }
  });

  // node_modules/@atlaskit/icon/core/status-success.js
  var require_status_success = __commonJS({
    "node_modules/@atlaskit/icon/core/status-success.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _react = _interopRequireDefault(require_react());
      var _baseNew = _interopRequireDefault(require_base_new());
      function _interopRequireDefault(e) {
        return e && e.__esModule ? e : { default: e };
      }
      var StatusSuccessIcon = (props) => /* @__PURE__ */ _react.default.createElement(_baseNew.default, Object.assign({
        dangerouslySetGlyph: `<path fill="currentcolor" fill-rule="evenodd" d="M8 0a8 8 0 1 1 0 16A8 8 0 0 1 8 0M6.75 9.828 4.826 7.52l-1.152.96 2.5 3a.75.75 0 0 0 1.152 0l5-6-1.152-.96z" clip-rule="evenodd"/>`
        // eslint-disable-next-line @repo/internal/react/no-unsafe-spread-props
      }, props));
      StatusSuccessIcon.displayName = "StatusSuccessIcon";
      var _default = exports.default = StatusSuccessIcon;
    }
  });

  // node_modules/@atlaskit/icon/glyph/check-circle.js
  var require_check_circle = __commonJS({
    "node_modules/@atlaskit/icon/glyph/check-circle.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _react = _interopRequireDefault(require_react());
      var _base = require_base();
      var _statusSuccess = _interopRequireDefault(require_status_success());
      function _interopRequireDefault(e) {
        return e && e.__esModule ? e : { default: e };
      }
      var CheckCircleIcon = (props) => /* @__PURE__ */ _react.default.createElement(_base.IconFacade, Object.assign({
        dangerouslySetGlyph: `<svg width="24" height="24" viewBox="0 0 24 24" role="presentation"><g fill-rule="evenodd"><circle cx="12" cy="12" r="10" fill="currentcolor"/><path fill="inherit" d="M9.707 11.293a1 1 0 1 0-1.414 1.414l2 2a1 1 0 0 0 1.414 0l4-4a1 1 0 1 0-1.414-1.414L11 12.586z"/></g></svg>`
      }, props, {
        newIcon: _statusSuccess.default
      }));
      CheckCircleIcon.displayName = "CheckCircleIcon";
      var _default = exports.default = CheckCircleIcon;
    }
  });

  // node_modules/@atlaskit/icon/core/migration/status-success--check-circle.js
  var require_status_success_check_circle = __commonJS({
    "node_modules/@atlaskit/icon/core/migration/status-success--check-circle.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _react = _interopRequireDefault(require_react());
      var _statusSuccess = _interopRequireDefault(require_status_success());
      var _checkCircle = _interopRequireDefault(require_check_circle());
      function _interopRequireDefault(e) {
        return e && e.__esModule ? e : { default: e };
      }
      var StatusSuccessIcon = (props) => /* @__PURE__ */ _react.default.createElement(_statusSuccess.default, Object.assign({
        LEGACY_fallbackIcon: _checkCircle.default
        // eslint-disable-next-line @repo/internal/react/no-unsafe-spread-props
      }, props));
      StatusSuccessIcon.Name = "StatusSuccessIconMigration";
      var _default = exports.default = StatusSuccessIcon;
    }
  });

  // node_modules/dayjs/plugin/quarterOfYear.js
  var require_quarterOfYear = __commonJS({
    "node_modules/dayjs/plugin/quarterOfYear.js"(exports, module2) {
      !(function(t, n) {
        "object" == typeof exports && "undefined" != typeof module2 ? module2.exports = n() : "function" == typeof define && define.amd ? define(n) : (t = "undefined" != typeof globalThis ? globalThis : t || self).dayjs_plugin_quarterOfYear = n();
      })(exports, (function() {
        "use strict";
        var t = "month", n = "quarter";
        return function(e, i) {
          var r = i.prototype;
          r.quarter = function(t2) {
            return this.$utils().u(t2) ? Math.ceil((this.month() + 1) / 3) : this.month(this.month() % 3 + 3 * (t2 - 1));
          };
          var s = r.add;
          r.add = function(e2, i2) {
            return e2 = Number(e2), this.$utils().p(i2) === n ? this.add(3 * e2, t) : s.bind(this)(e2, i2);
          };
          var u = r.startOf;
          r.startOf = function(e2, i2) {
            var r2 = this.$utils(), s2 = !!r2.u(i2) || i2;
            if (r2.p(e2) === n) {
              var o = this.quarter() - 1;
              return s2 ? this.month(3 * o).startOf(t).startOf("day") : this.month(3 * o + 2).endOf(t).endOf("day");
            }
            return u.bind(this)(e2, i2);
          };
        };
      }));
    }
  });

  // node_modules/dayjs/dayjs.min.js
  var require_dayjs_min = __commonJS({
    "node_modules/dayjs/dayjs.min.js"(exports, module2) {
      !(function(t, e) {
        "object" == typeof exports && "undefined" != typeof module2 ? module2.exports = e() : "function" == typeof define && define.amd ? define(e) : (t = "undefined" != typeof globalThis ? globalThis : t || self).dayjs = e();
      })(exports, (function() {
        "use strict";
        var t = 1e3, e = 6e4, n = 36e5, r = "millisecond", i = "second", s = "minute", u = "hour", a = "day", o = "week", c = "month", f = "quarter", h = "year", d = "date", l = "Invalid Date", $ = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t2) {
          var e2 = ["th", "st", "nd", "rd"], n2 = t2 % 100;
          return "[" + t2 + (e2[(n2 - 20) % 10] || e2[n2] || e2[0]) + "]";
        } }, m = function(t2, e2, n2) {
          var r2 = String(t2);
          return !r2 || r2.length >= e2 ? t2 : "" + Array(e2 + 1 - r2.length).join(n2) + t2;
        }, v = { s: m, z: function(t2) {
          var e2 = -t2.utcOffset(), n2 = Math.abs(e2), r2 = Math.floor(n2 / 60), i2 = n2 % 60;
          return (e2 <= 0 ? "+" : "-") + m(r2, 2, "0") + ":" + m(i2, 2, "0");
        }, m: function t2(e2, n2) {
          if (e2.date() < n2.date()) return -t2(n2, e2);
          var r2 = 12 * (n2.year() - e2.year()) + (n2.month() - e2.month()), i2 = e2.clone().add(r2, c), s2 = n2 - i2 < 0, u2 = e2.clone().add(r2 + (s2 ? -1 : 1), c);
          return +(-(r2 + (n2 - i2) / (s2 ? i2 - u2 : u2 - i2)) || 0);
        }, a: function(t2) {
          return t2 < 0 ? Math.ceil(t2) || 0 : Math.floor(t2);
        }, p: function(t2) {
          return { M: c, y: h, w: o, d: a, D: d, h: u, m: s, s: i, ms: r, Q: f }[t2] || String(t2 || "").toLowerCase().replace(/s$/, "");
        }, u: function(t2) {
          return void 0 === t2;
        } }, g = "en", D = {};
        D[g] = M;
        var p = "$isDayjsObject", S = function(t2) {
          return t2 instanceof _ || !(!t2 || !t2[p]);
        }, w2 = function t2(e2, n2, r2) {
          var i2;
          if (!e2) return g;
          if ("string" == typeof e2) {
            var s2 = e2.toLowerCase();
            D[s2] && (i2 = s2), n2 && (D[s2] = n2, i2 = s2);
            var u2 = e2.split("-");
            if (!i2 && u2.length > 1) return t2(u2[0]);
          } else {
            var a2 = e2.name;
            D[a2] = e2, i2 = a2;
          }
          return !r2 && i2 && (g = i2), i2 || !r2 && g;
        }, O = function(t2, e2) {
          if (S(t2)) return t2.clone();
          var n2 = "object" == typeof e2 ? e2 : {};
          return n2.date = t2, n2.args = arguments, new _(n2);
        }, b = v;
        b.l = w2, b.i = S, b.w = function(t2, e2) {
          return O(t2, { locale: e2.$L, utc: e2.$u, x: e2.$x, $offset: e2.$offset });
        };
        var _ = (function() {
          function M2(t2) {
            this.$L = w2(t2.locale, null, true), this.parse(t2), this.$x = this.$x || t2.x || {}, this[p] = true;
          }
          var m2 = M2.prototype;
          return m2.parse = function(t2) {
            this.$d = (function(t3) {
              var e2 = t3.date, n2 = t3.utc;
              if (null === e2) return /* @__PURE__ */ new Date(NaN);
              if (b.u(e2)) return /* @__PURE__ */ new Date();
              if (e2 instanceof Date) return new Date(e2);
              if ("string" == typeof e2 && !/Z$/i.test(e2)) {
                var r2 = e2.match($);
                if (r2) {
                  var i2 = r2[2] - 1 || 0, s2 = (r2[7] || "0").substring(0, 3);
                  return n2 ? new Date(Date.UTC(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2)) : new Date(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2);
                }
              }
              return new Date(e2);
            })(t2), this.init();
          }, m2.init = function() {
            var t2 = this.$d;
            this.$y = t2.getFullYear(), this.$M = t2.getMonth(), this.$D = t2.getDate(), this.$W = t2.getDay(), this.$H = t2.getHours(), this.$m = t2.getMinutes(), this.$s = t2.getSeconds(), this.$ms = t2.getMilliseconds();
          }, m2.$utils = function() {
            return b;
          }, m2.isValid = function() {
            return !(this.$d.toString() === l);
          }, m2.isSame = function(t2, e2) {
            var n2 = O(t2);
            return this.startOf(e2) <= n2 && n2 <= this.endOf(e2);
          }, m2.isAfter = function(t2, e2) {
            return O(t2) < this.startOf(e2);
          }, m2.isBefore = function(t2, e2) {
            return this.endOf(e2) < O(t2);
          }, m2.$g = function(t2, e2, n2) {
            return b.u(t2) ? this[e2] : this.set(n2, t2);
          }, m2.unix = function() {
            return Math.floor(this.valueOf() / 1e3);
          }, m2.valueOf = function() {
            return this.$d.getTime();
          }, m2.startOf = function(t2, e2) {
            var n2 = this, r2 = !!b.u(e2) || e2, f2 = b.p(t2), l2 = function(t3, e3) {
              var i2 = b.w(n2.$u ? Date.UTC(n2.$y, e3, t3) : new Date(n2.$y, e3, t3), n2);
              return r2 ? i2 : i2.endOf(a);
            }, $2 = function(t3, e3) {
              return b.w(n2.toDate()[t3].apply(n2.toDate("s"), (r2 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e3)), n2);
            }, y2 = this.$W, M3 = this.$M, m3 = this.$D, v2 = "set" + (this.$u ? "UTC" : "");
            switch (f2) {
              case h:
                return r2 ? l2(1, 0) : l2(31, 11);
              case c:
                return r2 ? l2(1, M3) : l2(0, M3 + 1);
              case o:
                var g2 = this.$locale().weekStart || 0, D2 = (y2 < g2 ? y2 + 7 : y2) - g2;
                return l2(r2 ? m3 - D2 : m3 + (6 - D2), M3);
              case a:
              case d:
                return $2(v2 + "Hours", 0);
              case u:
                return $2(v2 + "Minutes", 1);
              case s:
                return $2(v2 + "Seconds", 2);
              case i:
                return $2(v2 + "Milliseconds", 3);
              default:
                return this.clone();
            }
          }, m2.endOf = function(t2) {
            return this.startOf(t2, false);
          }, m2.$set = function(t2, e2) {
            var n2, o2 = b.p(t2), f2 = "set" + (this.$u ? "UTC" : ""), l2 = (n2 = {}, n2[a] = f2 + "Date", n2[d] = f2 + "Date", n2[c] = f2 + "Month", n2[h] = f2 + "FullYear", n2[u] = f2 + "Hours", n2[s] = f2 + "Minutes", n2[i] = f2 + "Seconds", n2[r] = f2 + "Milliseconds", n2)[o2], $2 = o2 === a ? this.$D + (e2 - this.$W) : e2;
            if (o2 === c || o2 === h) {
              var y2 = this.clone().set(d, 1);
              y2.$d[l2]($2), y2.init(), this.$d = y2.set(d, Math.min(this.$D, y2.daysInMonth())).$d;
            } else l2 && this.$d[l2]($2);
            return this.init(), this;
          }, m2.set = function(t2, e2) {
            return this.clone().$set(t2, e2);
          }, m2.get = function(t2) {
            return this[b.p(t2)]();
          }, m2.add = function(r2, f2) {
            var d2, l2 = this;
            r2 = Number(r2);
            var $2 = b.p(f2), y2 = function(t2) {
              var e2 = O(l2);
              return b.w(e2.date(e2.date() + Math.round(t2 * r2)), l2);
            };
            if ($2 === c) return this.set(c, this.$M + r2);
            if ($2 === h) return this.set(h, this.$y + r2);
            if ($2 === a) return y2(1);
            if ($2 === o) return y2(7);
            var M3 = (d2 = {}, d2[s] = e, d2[u] = n, d2[i] = t, d2)[$2] || 1, m3 = this.$d.getTime() + r2 * M3;
            return b.w(m3, this);
          }, m2.subtract = function(t2, e2) {
            return this.add(-1 * t2, e2);
          }, m2.format = function(t2) {
            var e2 = this, n2 = this.$locale();
            if (!this.isValid()) return n2.invalidDate || l;
            var r2 = t2 || "YYYY-MM-DDTHH:mm:ssZ", i2 = b.z(this), s2 = this.$H, u2 = this.$m, a2 = this.$M, o2 = n2.weekdays, c2 = n2.months, f2 = n2.meridiem, h2 = function(t3, n3, i3, s3) {
              return t3 && (t3[n3] || t3(e2, r2)) || i3[n3].slice(0, s3);
            }, d2 = function(t3) {
              return b.s(s2 % 12 || 12, t3, "0");
            }, $2 = f2 || function(t3, e3, n3) {
              var r3 = t3 < 12 ? "AM" : "PM";
              return n3 ? r3.toLowerCase() : r3;
            };
            return r2.replace(y, (function(t3, r3) {
              return r3 || (function(t4) {
                switch (t4) {
                  case "YY":
                    return String(e2.$y).slice(-2);
                  case "YYYY":
                    return b.s(e2.$y, 4, "0");
                  case "M":
                    return a2 + 1;
                  case "MM":
                    return b.s(a2 + 1, 2, "0");
                  case "MMM":
                    return h2(n2.monthsShort, a2, c2, 3);
                  case "MMMM":
                    return h2(c2, a2);
                  case "D":
                    return e2.$D;
                  case "DD":
                    return b.s(e2.$D, 2, "0");
                  case "d":
                    return String(e2.$W);
                  case "dd":
                    return h2(n2.weekdaysMin, e2.$W, o2, 2);
                  case "ddd":
                    return h2(n2.weekdaysShort, e2.$W, o2, 3);
                  case "dddd":
                    return o2[e2.$W];
                  case "H":
                    return String(s2);
                  case "HH":
                    return b.s(s2, 2, "0");
                  case "h":
                    return d2(1);
                  case "hh":
                    return d2(2);
                  case "a":
                    return $2(s2, u2, true);
                  case "A":
                    return $2(s2, u2, false);
                  case "m":
                    return String(u2);
                  case "mm":
                    return b.s(u2, 2, "0");
                  case "s":
                    return String(e2.$s);
                  case "ss":
                    return b.s(e2.$s, 2, "0");
                  case "SSS":
                    return b.s(e2.$ms, 3, "0");
                  case "Z":
                    return i2;
                }
                return null;
              })(t3) || i2.replace(":", "");
            }));
          }, m2.utcOffset = function() {
            return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
          }, m2.diff = function(r2, d2, l2) {
            var $2, y2 = this, M3 = b.p(d2), m3 = O(r2), v2 = (m3.utcOffset() - this.utcOffset()) * e, g2 = this - m3, D2 = function() {
              return b.m(y2, m3);
            };
            switch (M3) {
              case h:
                $2 = D2() / 12;
                break;
              case c:
                $2 = D2();
                break;
              case f:
                $2 = D2() / 3;
                break;
              case o:
                $2 = (g2 - v2) / 6048e5;
                break;
              case a:
                $2 = (g2 - v2) / 864e5;
                break;
              case u:
                $2 = g2 / n;
                break;
              case s:
                $2 = g2 / e;
                break;
              case i:
                $2 = g2 / t;
                break;
              default:
                $2 = g2;
            }
            return l2 ? $2 : b.a($2);
          }, m2.daysInMonth = function() {
            return this.endOf(c).$D;
          }, m2.$locale = function() {
            return D[this.$L];
          }, m2.locale = function(t2, e2) {
            if (!t2) return this.$L;
            var n2 = this.clone(), r2 = w2(t2, e2, true);
            return r2 && (n2.$L = r2), n2;
          }, m2.clone = function() {
            return b.w(this.$d, this);
          }, m2.toDate = function() {
            return new Date(this.valueOf());
          }, m2.toJSON = function() {
            return this.isValid() ? this.toISOString() : null;
          }, m2.toISOString = function() {
            return this.$d.toISOString();
          }, m2.toString = function() {
            return this.$d.toUTCString();
          }, M2;
        })(), k = _.prototype;
        return O.prototype = k, [["$ms", r], ["$s", i], ["$m", s], ["$H", u], ["$W", a], ["$M", c], ["$y", h], ["$D", d]].forEach((function(t2) {
          k[t2[1]] = function(e2) {
            return this.$g(e2, t2[0], t2[1]);
          };
        })), O.extend = function(t2, e2) {
          return t2.$i || (t2(e2, _, O), t2.$i = true), O;
        }, O.locale = w2, O.isDayjs = S, O.unix = function(t2) {
          return O(1e3 * t2);
        }, O.en = D[g], O.Ls = D, O.p = {}, O;
      }));
    }
  });

  // node_modules/react/cjs/react-jsx-runtime.production.min.js
  var require_react_jsx_runtime_production_min = __commonJS({
    "node_modules/react/cjs/react-jsx-runtime.production.min.js"(exports) {
      "use strict";
      var f = require_react();
      var k = Symbol.for("react.element");
      var l = Symbol.for("react.fragment");
      var m = Object.prototype.hasOwnProperty;
      var n = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner;
      var p = { key: true, ref: true, __self: true, __source: true };
      function q(c, a, g) {
        var b, d = {}, e = null, h = null;
        void 0 !== g && (e = "" + g);
        void 0 !== a.key && (e = "" + a.key);
        void 0 !== a.ref && (h = a.ref);
        for (b in a) m.call(a, b) && !p.hasOwnProperty(b) && (d[b] = a[b]);
        if (c && c.defaultProps) for (b in a = c.defaultProps, a) void 0 === d[b] && (d[b] = a[b]);
        return { $$typeof: k, type: c, key: e, ref: h, props: d, _owner: n.current };
      }
      exports.Fragment = l;
      exports.jsx = q;
      exports.jsxs = q;
    }
  });

  // node_modules/react/jsx-runtime.js
  var require_jsx_runtime = __commonJS({
    "node_modules/react/jsx-runtime.js"(exports, module2) {
      "use strict";
      if (true) {
        module2.exports = require_react_jsx_runtime_production_min();
      } else {
        module2.exports = null;
      }
    }
  });

  // node_modules/@atlaskit/icon/core/chevron-down.js
  var require_chevron_down = __commonJS({
    "node_modules/@atlaskit/icon/core/chevron-down.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _react = _interopRequireDefault(require_react());
      var _baseNew = _interopRequireDefault(require_base_new());
      function _interopRequireDefault(e) {
        return e && e.__esModule ? e : { default: e };
      }
      var ChevronDownIcon = (props) => /* @__PURE__ */ _react.default.createElement(_baseNew.default, Object.assign({
        dangerouslySetGlyph: `<path fill="currentcolor" d="m14.53 6.03-6 6a.75.75 0 0 1-1.004.052l-.056-.052-6-6 1.06-1.06L8 10.44l5.47-5.47z"/>`
        // eslint-disable-next-line @repo/internal/react/no-unsafe-spread-props
      }, props));
      ChevronDownIcon.displayName = "ChevronDownIcon";
      var _default = exports.default = ChevronDownIcon;
    }
  });

  // node_modules/@atlaskit/icon/glyph/chevron-down.js
  var require_chevron_down2 = __commonJS({
    "node_modules/@atlaskit/icon/glyph/chevron-down.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _react = _interopRequireDefault(require_react());
      var _base = require_base();
      var _chevronDown = _interopRequireDefault(require_chevron_down());
      function _interopRequireDefault(e) {
        return e && e.__esModule ? e : { default: e };
      }
      var ChevronDownIcon = (props) => /* @__PURE__ */ _react.default.createElement(_base.IconFacade, Object.assign({
        dangerouslySetGlyph: `<svg width="24" height="24" viewBox="0 0 24 24" role="presentation"><path fill="currentcolor" fill-rule="evenodd" d="M8.292 10.293a1.01 1.01 0 0 0 0 1.419l2.939 2.965c.218.215.5.322.779.322s.556-.107.769-.322l2.93-2.955a1.01 1.01 0 0 0 0-1.419.987.987 0 0 0-1.406 0l-2.298 2.317-2.307-2.327a.99.99 0 0 0-1.406 0"/></svg>`
      }, props, {
        newIcon: _chevronDown.default
      }));
      ChevronDownIcon.displayName = "ChevronDownIcon";
      var _default = exports.default = ChevronDownIcon;
    }
  });

  // node_modules/@atlaskit/icon/core/migration/chevron-down.js
  var require_chevron_down3 = __commonJS({
    "node_modules/@atlaskit/icon/core/migration/chevron-down.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _react = _interopRequireDefault(require_react());
      var _chevronDown = _interopRequireDefault(require_chevron_down());
      var _chevronDown2 = _interopRequireDefault(require_chevron_down2());
      function _interopRequireDefault(e) {
        return e && e.__esModule ? e : { default: e };
      }
      var ChevronDownIcon = (props) => /* @__PURE__ */ _react.default.createElement(_chevronDown.default, Object.assign({
        LEGACY_fallbackIcon: _chevronDown2.default
        // eslint-disable-next-line @repo/internal/react/no-unsafe-spread-props
      }, props));
      ChevronDownIcon.Name = "ChevronDownIconMigration";
      var _default = exports.default = ChevronDownIcon;
    }
  });

  // node_modules/@atlaskit/icon/core/cross-circle.js
  var require_cross_circle = __commonJS({
    "node_modules/@atlaskit/icon/core/cross-circle.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _react = _interopRequireDefault(require_react());
      var _baseNew = _interopRequireDefault(require_base_new());
      function _interopRequireDefault(e) {
        return e && e.__esModule ? e : { default: e };
      }
      var CrossCircleIcon = (props) => /* @__PURE__ */ _react.default.createElement(_baseNew.default, Object.assign({
        dangerouslySetGlyph: `<path fill="currentcolor" fill-rule="evenodd" d="M8 0a8 8 0 1 0 0 16A8 8 0 0 0 8 0m4.03 5.03L9.06 8l2.97 2.97-1.06 1.06L8 9.06l-2.97 2.97-1.06-1.06L6.94 8 3.97 5.03l1.06-1.06L8 6.94l2.97-2.97z" clip-rule="evenodd"/>`
        // eslint-disable-next-line @repo/internal/react/no-unsafe-spread-props
      }, props));
      CrossCircleIcon.displayName = "CrossCircleIcon";
      var _default = exports.default = CrossCircleIcon;
    }
  });

  // node_modules/@atlaskit/icon/glyph/select-clear.js
  var require_select_clear = __commonJS({
    "node_modules/@atlaskit/icon/glyph/select-clear.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _react = _interopRequireDefault(require_react());
      var _base = require_base();
      var _crossCircle = _interopRequireDefault(require_cross_circle());
      function _interopRequireDefault(e) {
        return e && e.__esModule ? e : { default: e };
      }
      var SelectClearIcon = (props) => /* @__PURE__ */ _react.default.createElement(_base.IconFacade, Object.assign({
        dangerouslySetGlyph: `<svg width="24" height="24" viewBox="0 0 24 24" role="presentation"><g fill-rule="evenodd"><circle cx="12" cy="12" r="9" fill="currentcolor"/><path fill="inherit" d="M16.155 14.493a1.174 1.174 0 1 1-1.662 1.663L12 13.662l-2.494 2.494a1.17 1.17 0 0 1-1.662 0 1.176 1.176 0 0 1 0-1.663L10.337 12 7.844 9.507a1.176 1.176 0 0 1 1.662-1.662L12 10.338l2.493-2.493a1.174 1.174 0 1 1 1.662 1.662L13.662 12z"/></g></svg>`
      }, props, {
        newIcon: _crossCircle.default
      }));
      SelectClearIcon.displayName = "SelectClearIcon";
      var _default = exports.default = SelectClearIcon;
    }
  });

  // node_modules/@atlaskit/icon/core/migration/cross-circle--select-clear.js
  var require_cross_circle_select_clear = __commonJS({
    "node_modules/@atlaskit/icon/core/migration/cross-circle--select-clear.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _react = _interopRequireDefault(require_react());
      var _crossCircle = _interopRequireDefault(require_cross_circle());
      var _selectClear = _interopRequireDefault(require_select_clear());
      function _interopRequireDefault(e) {
        return e && e.__esModule ? e : { default: e };
      }
      var CrossCircleIcon = (props) => /* @__PURE__ */ _react.default.createElement(_crossCircle.default, Object.assign({
        LEGACY_fallbackIcon: _selectClear.default
        // eslint-disable-next-line @repo/internal/react/no-unsafe-spread-props
      }, props));
      CrossCircleIcon.Name = "CrossCircleIconMigration";
      var _default = exports.default = CrossCircleIcon;
    }
  });

  // src/components/FloatingButton/FloatingButton.tsx
  var import_react139 = __toESM(require_react());

  // node_modules/dexie/import-wrapper.mjs
  var import_dexie = __toESM(require_dexie(), 1);
  var DexieSymbol = Symbol.for("Dexie");
  var Dexie = globalThis[DexieSymbol] || (globalThis[DexieSymbol] = import_dexie.default);
  if (import_dexie.default.semVer !== Dexie.semVer) {
    throw new Error(`Two different versions of Dexie loaded in the same app: ${import_dexie.default.semVer} and ${Dexie.semVer}`);
  }
  var {
    liveQuery,
    mergeRanges,
    rangesOverlap,
    RangeSet,
    cmp,
    Entity,
    PropModification,
    replacePrefix,
    add,
    remove
  } = Dexie;
  var import_wrapper_default = Dexie;

  // node_modules/dexie-react-hooks/dist/dexie-react-hooks.mjs
  var import_react = __toESM(require_react(), 1);
  function useObservable(observableFactory, arg2, arg3) {
    var deps;
    var defaultResult;
    if (typeof observableFactory === "function") {
      deps = arg2 || [];
      defaultResult = arg3;
    } else {
      deps = [];
      defaultResult = arg2;
    }
    var monitor = import_react.default.useRef({
      hasResult: false,
      result: defaultResult,
      error: null
    });
    var _a2 = import_react.default.useReducer(function(x) {
      return x + 1;
    }, 0);
    _a2[0];
    var triggerUpdate = _a2[1];
    var observable = import_react.default.useMemo(function() {
      var observable2 = typeof observableFactory === "function" ? observableFactory() : observableFactory;
      if (!observable2 || typeof observable2.subscribe !== "function") {
        if (observableFactory === observable2) {
          throw new TypeError("Given argument to useObservable() was neither a valid observable nor a function.");
        } else {
          throw new TypeError("Observable factory given to useObservable() did not return a valid observable.");
        }
      }
      if (!monitor.current.hasResult && typeof window !== "undefined") {
        if (typeof observable2.hasValue !== "function" || observable2.hasValue()) {
          if (typeof observable2.getValue === "function") {
            monitor.current.result = observable2.getValue();
            monitor.current.hasResult = true;
          } else {
            var subscription = observable2.subscribe(function(val) {
              monitor.current.result = val;
              monitor.current.hasResult = true;
            });
            if (typeof subscription === "function") {
              subscription();
            } else {
              subscription.unsubscribe();
            }
          }
        }
      }
      return observable2;
    }, deps);
    import_react.default.useDebugValue(monitor.current.result);
    import_react.default.useEffect(function() {
      var subscription = observable.subscribe(function(val) {
        var current = monitor.current;
        if (current.error !== null || current.result !== val) {
          current.error = null;
          current.result = val;
          current.hasResult = true;
          triggerUpdate();
        }
      }, function(err) {
        var current = monitor.current;
        if (current.error !== err) {
          current.error = err;
          triggerUpdate();
        }
      });
      return typeof subscription === "function" ? subscription : subscription.unsubscribe.bind(subscription);
    }, deps);
    if (monitor.current.error)
      throw monitor.current.error;
    return monitor.current.result;
  }
  function useLiveQuery(querier, deps, defaultResult) {
    return useObservable(function() {
      return liveQuery(querier);
    }, deps || [], defaultResult);
  }

  // src/utils/database.ts
  var db = new import_wrapper_default("AtlasXrayDB");
  db.version(9).stores({
    projectView: "projectKey",
    projectStatusHistory: "id,projectKey",
    projectUpdates: "id,projectKey",
    projectImages: "id,projectKey,mediaId",
    meta: "key"
  });
  async function setProjectView(projectKey, data) {
    await db.projectView.put({ projectKey, ...data });
  }
  async function setMeta(key, value) {
    await db.meta.put({ key, value });
  }
  async function getMeta(key) {
    const entry = await db.meta.get(key);
    return entry ? entry.value : null;
  }
  async function setItem(key, value) {
    await setMeta(key, value);
  }
  async function getItem(key) {
    return getMeta(key);
  }
  function upsertProjectUpdates(nodes) {
    console.log("nodes", nodes);
    const rows = nodes.map((n) => ({
      id: n.id ?? n.uuid,
      projectKey: n.project?.key,
      creationDate: n.creationDate ? new Date(n.creationDate).toISOString() : void 0,
      state: n.newState?.projectStateValue,
      missedUpdate: !!n.missedUpdate,
      targetDate: n.newTargetDate,
      newDueDate: n.newDueDate?.label,
      oldDueDate: n.oldDueDate?.label,
      oldState: n.oldState?.projectStateValue,
      summary: n.summary,
      details: n.notes ? JSON.stringify(n.notes) : null
    }));
    return db.projectUpdates.bulkPut(rows);
  }
  function upsertProjectStatusHistory(nodes, projectKey) {
    if (!projectKey) {
      console.warn("[AtlasXray] upsertProjectStatusHistory called with undefined projectKey. Skipping.");
      return Promise.resolve();
    }
    const rows = nodes.map((n) => ({
      id: n.id ?? n.uuid,
      projectKey,
      creationDate: n.creationDate,
      startDate: n.startDate,
      targetDate: n.targetDate
    }));
    return db.projectStatusHistory.bulkPut(rows);
  }
  async function storeProjectImage(projectKey, mediaId, imageData, mimeType) {
    await db.projectImages.put({
      id: `${projectKey}-${mediaId}`,
      projectKey,
      mediaId,
      imageData,
      mimeType,
      storedAt: (/* @__PURE__ */ new Date()).toISOString()
    });
  }
  async function getProjectImage(projectKey, mediaId) {
    const image = await db.projectImages.get(`${projectKey}-${mediaId}`);
    return image ? { imageData: image.imageData, mimeType: image.mimeType } : null;
  }

  // src/components/StatusTimelineHeatmap/StatusTimelineHeatmapRow.tsx
  var import_react114 = __toESM(require_react());

  // node_modules/@babel/runtime/helpers/esm/extends.js
  function _extends() {
    return _extends = Object.assign ? Object.assign.bind() : function(n) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
      }
      return n;
    }, _extends.apply(null, arguments);
  }

  // node_modules/@atlaskit/tooltip/dist/esm/tooltip.js
  init_slicedToArray();
  init_defineProperty();
  var import_react38 = __toESM(require_react());
  var import_bind_event_listener3 = __toESM(require_dist());

  // node_modules/@atlaskit/analytics-next/dist/esm/events/AnalyticsEvent.js
  init_typeof();
  init_classCallCheck();
  init_createClass();
  init_defineProperty();
  function ownKeys(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r && (o = o.filter(function(r2) {
        return Object.getOwnPropertyDescriptor(e, r2).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread(e) {
    for (var r = 1; r < arguments.length; r++) {
      var t = null != arguments[r] ? arguments[r] : {};
      r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
        _defineProperty(e, r2, t[r2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
        Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
      });
    }
    return e;
  }
  var AnalyticsEvent = /* @__PURE__ */ (function() {
    function AnalyticsEvent2(props) {
      var _this = this;
      _classCallCheck(this, AnalyticsEvent2);
      _defineProperty(this, "_isAnalyticsEvent", true);
      _defineProperty(this, "clone", function() {
        var payload = _objectSpread({}, _this.payload);
        return new AnalyticsEvent2({
          payload
        });
      });
      this.payload = props.payload;
    }
    return _createClass(AnalyticsEvent2, [{
      key: "update",
      value: function update(updater) {
        if (typeof updater === "function") {
          this.payload = updater(this.payload);
        }
        if (_typeof(updater) === "object") {
          this.payload = _objectSpread(_objectSpread({}, this.payload), updater);
        }
        return this;
      }
    }]);
  })();

  // node_modules/@atlaskit/analytics-next/dist/esm/events/UIAnalyticsEvent.js
  init_toConsumableArray();
  init_classCallCheck();
  init_createClass();

  // node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js
  init_typeof();

  // node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
  function _assertThisInitialized(e) {
    if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e;
  }

  // node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js
  function _possibleConstructorReturn(t, e) {
    if (e && ("object" == _typeof(e) || "function" == typeof e)) return e;
    if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
    return _assertThisInitialized(t);
  }

  // node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js
  function _getPrototypeOf(t) {
    return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
      return t2.__proto__ || Object.getPrototypeOf(t2);
    }, _getPrototypeOf(t);
  }

  // node_modules/@babel/runtime/helpers/esm/superPropBase.js
  function _superPropBase(t, o) {
    for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t)); ) ;
    return t;
  }

  // node_modules/@babel/runtime/helpers/esm/get.js
  function _get() {
    return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(e, t, r) {
      var p = _superPropBase(e, t);
      if (p) {
        var n = Object.getOwnPropertyDescriptor(p, t);
        return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value;
      }
    }, _get.apply(null, arguments);
  }

  // node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
  function _setPrototypeOf(t, e) {
    return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
      return t2.__proto__ = e2, t2;
    }, _setPrototypeOf(t, e);
  }

  // node_modules/@babel/runtime/helpers/esm/inherits.js
  function _inherits(t, e) {
    if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
    t.prototype = Object.create(e && e.prototype, {
      constructor: {
        value: t,
        writable: true,
        configurable: true
      }
    }), Object.defineProperty(t, "prototype", {
      writable: false
    }), e && _setPrototypeOf(t, e);
  }

  // node_modules/@atlaskit/analytics-next/dist/esm/events/UIAnalyticsEvent.js
  init_defineProperty();
  function _callSuper(t, o, e) {
    return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
  }
  function _isNativeReflectConstruct() {
    try {
      var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
    } catch (t2) {
    }
    return (_isNativeReflectConstruct = function _isNativeReflectConstruct4() {
      return !!t;
    })();
  }
  function _superPropGet(t, o, e, r) {
    var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e);
    return 2 & r && "function" == typeof p ? function(t2) {
      return p.apply(e, t2);
    } : p;
  }
  var UIAnalyticsEvent = /* @__PURE__ */ (function(_AnalyticsEvent) {
    function UIAnalyticsEvent2(props) {
      var _this;
      _classCallCheck(this, UIAnalyticsEvent2);
      _this = _callSuper(this, UIAnalyticsEvent2, [props]);
      _defineProperty(_this, "_isUIAnalyticsEvent", true);
      _defineProperty(_this, "clone", function() {
        if (_this.hasFired) {
          if (false) {
            console.warn("Cannot clone an event after it's been fired.");
          }
          return null;
        }
        var context = _toConsumableArray(_this.context);
        var handlers = _toConsumableArray(_this.handlers);
        var payload = JSON.parse(JSON.stringify(_this.payload));
        return new UIAnalyticsEvent2({
          context,
          handlers,
          payload
        });
      });
      _defineProperty(_this, "fire", function(channel) {
        if (_this.hasFired) {
          if (false) {
            console.warn("Cannot fire an event twice.");
          }
          return;
        }
        _this.handlers.forEach(function(handler) {
          return handler(_this, channel);
        });
        _this.hasFired = true;
      });
      _this.context = props.context || [];
      _this.handlers = props.handlers || [];
      _this.hasFired = false;
      return _this;
    }
    _inherits(UIAnalyticsEvent2, _AnalyticsEvent);
    return _createClass(UIAnalyticsEvent2, [{
      key: "update",
      value: function update(updater) {
        if (this.hasFired) {
          if (false) {
            console.warn("Cannot update an event after it's been fired.");
          }
          return this;
        }
        return _superPropGet(UIAnalyticsEvent2, "update", this, 3)([updater]);
      }
    }]);
  })(AnalyticsEvent);

  // node_modules/@atlaskit/analytics-next/dist/esm/utils/isModernContextEnabledEnv.js
  var _process$env;
  var isModernContextEnabledEnv_default = typeof process !== "undefined" && process !== null && ((_process$env = process.env) === null || _process$env === void 0 ? void 0 : _process$env["ANALYTICS_NEXT_MODERN_CONTEXT"]);

  // node_modules/@atlaskit/analytics-next-stable-react-context/dist/esm/context.js
  var import_react2 = __toESM(require_react());
  var AnalyticsNextContext = (0, import_react2.createContext)({
    getAtlaskitAnalyticsContext: function() {
      return [];
    },
    getAtlaskitAnalyticsEventHandlers: function() {
      return [];
    }
  });
  var context_default = AnalyticsNextContext;

  // node_modules/@atlaskit/analytics-next-stable-react-context/dist/esm/index.js
  var esm_default = context_default;

  // node_modules/@atlaskit/analytics-next/dist/esm/hooks/useAnalyticsContext.js
  var import_react3 = __toESM(require_react());
  var useAnalyticsContext = function useAnalyticsContext2() {
    return (0, import_react3.useContext)(esm_default);
  };

  // node_modules/@atlaskit/analytics-next/dist/esm/hooks/useTrackedRef.js
  var import_react4 = __toESM(require_react());
  var useTrackedRef = function useTrackedRef2(value) {
    var ref = (0, import_react4.useRef)(value);
    ref.current = value;
    return ref;
  };

  // node_modules/@atlaskit/analytics-next/dist/esm/components/AnalyticsContext/index.js
  var import_react7 = __toESM(require_react());
  var import_platform_feature_flags = __toESM(require_cjs3());

  // node_modules/@atlaskit/analytics-next/dist/esm/components/AnalyticsContext/LegacyAnalyticsContext.js
  init_toConsumableArray();
  init_classCallCheck();
  init_createClass();
  init_defineProperty();
  var import_react5 = __toESM(require_react());
  var import_prop_types = __toESM(require_prop_types());
  function _callSuper2(t, o, e) {
    return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct2() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
  }
  function _isNativeReflectConstruct2() {
    try {
      var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
    } catch (t2) {
    }
    return (_isNativeReflectConstruct2 = function _isNativeReflectConstruct4() {
      return !!t;
    })();
  }
  var ContextTypes = {
    getAtlaskitAnalyticsContext: import_prop_types.default.func,
    getAtlaskitAnalyticsEventHandlers: import_prop_types.default.func
  };
  var noop = function noop2() {
    return [];
  };
  var AnalyticsContext = /* @__PURE__ */ (function(_Component) {
    function AnalyticsContext4(props) {
      var _this;
      _classCallCheck(this, AnalyticsContext4);
      _this = _callSuper2(this, AnalyticsContext4, [props]);
      _defineProperty(_this, "getChildContext", function() {
        return {
          getAtlaskitAnalyticsContext: _this.getAnalyticsContext
        };
      });
      _defineProperty(_this, "getAnalyticsContext", function() {
        var data = _this.props.data;
        var _this$context$getAtla = _this.context.getAtlaskitAnalyticsContext, getAtlaskitAnalyticsContext = _this$context$getAtla === void 0 ? noop : _this$context$getAtla;
        return [].concat(_toConsumableArray(getAtlaskitAnalyticsContext()), [data]);
      });
      _defineProperty(_this, "getAnalyticsEventHandlers", function() {
        var _this$context$getAtla2 = _this.context.getAtlaskitAnalyticsEventHandlers, getAtlaskitAnalyticsEventHandlers = _this$context$getAtla2 === void 0 ? noop : _this$context$getAtla2;
        return getAtlaskitAnalyticsEventHandlers();
      });
      _this.contextValue = {
        getAtlaskitAnalyticsContext: _this.getAnalyticsContext,
        getAtlaskitAnalyticsEventHandlers: _this.getAnalyticsEventHandlers
      };
      return _this;
    }
    _inherits(AnalyticsContext4, _Component);
    return _createClass(AnalyticsContext4, [{
      key: "render",
      value: function render() {
        var children = this.props.children;
        return /* @__PURE__ */ import_react5.default.createElement(esm_default.Provider, {
          value: this.contextValue
        }, children);
      }
    }]);
  })(import_react5.Component);
  _defineProperty(AnalyticsContext, "contextTypes", ContextTypes);
  _defineProperty(AnalyticsContext, "childContextTypes", ContextTypes);
  var LegacyAnalyticsContext_default = AnalyticsContext;

  // node_modules/@atlaskit/analytics-next/dist/esm/components/AnalyticsContext/ModernAnalyticsContext.js
  init_toConsumableArray();
  var import_react6 = __toESM(require_react());
  var AnalyticsContext2 = function AnalyticsContext3(_ref2) {
    var data = _ref2.data, children = _ref2.children;
    var dataRef = useTrackedRef(data);
    var _useAnalyticsContext = useAnalyticsContext(), getAtlaskitAnalyticsEventHandlers = _useAnalyticsContext.getAtlaskitAnalyticsEventHandlers, getOriginalAnalyticsContext = _useAnalyticsContext.getAtlaskitAnalyticsContext;
    var getAtlaskitAnalyticsContext = (0, import_react6.useCallback)(function() {
      return [].concat(_toConsumableArray(getOriginalAnalyticsContext()), [dataRef.current]);
    }, [getOriginalAnalyticsContext, dataRef]);
    var value = (0, import_react6.useMemo)(function() {
      return {
        getAtlaskitAnalyticsContext,
        getAtlaskitAnalyticsEventHandlers
      };
    }, [getAtlaskitAnalyticsContext, getAtlaskitAnalyticsEventHandlers]);
    return /* @__PURE__ */ import_react6.default.createElement(esm_default.Provider, {
      value
    }, children);
  };
  var ModernAnalyticsContext_default = AnalyticsContext2;

  // node_modules/@atlaskit/analytics-next/dist/esm/components/AnalyticsContext/index.js
  var ExportedAnalyticsContext = function ExportedAnalyticsContext2(props) {
    var isModernContext = isModernContextEnabledEnv_default || (0, import_platform_feature_flags.fg)("analytics-next-use-modern-context_jira");
    return isModernContext ? /* @__PURE__ */ import_react7.default.createElement(ModernAnalyticsContext_default, props) : /* @__PURE__ */ import_react7.default.createElement(LegacyAnalyticsContext_default, props);
  };
  var AnalyticsContext_default = ExportedAnalyticsContext;

  // node_modules/@atlaskit/analytics-next/dist/esm/hocs/withAnalyticsContext.js
  init_defineProperty();

  // node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js
  function _objectWithoutPropertiesLoose(r, e) {
    if (null == r) return {};
    var t = {};
    for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
      if (-1 !== e.indexOf(n)) continue;
      t[n] = r[n];
    }
    return t;
  }

  // node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js
  function _objectWithoutProperties(e, t) {
    if (null == e) return {};
    var o, r, i = _objectWithoutPropertiesLoose(e, t);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e);
      for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
    }
    return i;
  }

  // node_modules/@atlaskit/analytics-next/dist/esm/hocs/withAnalyticsContext.js
  var import_react8 = __toESM(require_react());
  var _excluded = ["analyticsContext"];
  function ownKeys2(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r && (o = o.filter(function(r2) {
        return Object.getOwnPropertyDescriptor(e, r2).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread2(e) {
    for (var r = 1; r < arguments.length; r++) {
      var t = null != arguments[r] ? arguments[r] : {};
      r % 2 ? ownKeys2(Object(t), true).forEach(function(r2) {
        _defineProperty(e, r2, t[r2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys2(Object(t)).forEach(function(r2) {
        Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
      });
    }
    return e;
  }
  var withAnalyticsContext = function withAnalyticsContext2(defaultData) {
    return function(WrappedComponent) {
      var WithAnalyticsContext = /* @__PURE__ */ (0, import_react8.forwardRef)(function(_ref2, ref) {
        var analyticsContext = _ref2.analyticsContext, rest = _objectWithoutProperties(_ref2, _excluded);
        var analyticsData = (0, import_react8.useMemo)(function() {
          return _objectSpread2(_objectSpread2({}, defaultData), analyticsContext);
        }, [analyticsContext]);
        return /* @__PURE__ */ import_react8.default.createElement(AnalyticsContext_default, {
          data: analyticsData
        }, /* @__PURE__ */ import_react8.default.createElement(WrappedComponent, _extends({}, rest, {
          ref
        })));
      });
      WithAnalyticsContext.displayName = "WithAnalyticsContext(".concat(WrappedComponent.displayName || WrappedComponent.name, ")");
      return WithAnalyticsContext;
    };
  };
  var withAnalyticsContext_default = withAnalyticsContext;

  // node_modules/@atlaskit/analytics-next/dist/esm/hocs/withAnalyticsEvents.js
  var import_react11 = __toESM(require_react());

  // node_modules/use-memo-one/dist/use-memo-one.esm.js
  var import_react9 = __toESM(require_react());
  function areInputsEqual(newInputs, lastInputs) {
    if (newInputs.length !== lastInputs.length) {
      return false;
    }
    for (var i = 0; i < newInputs.length; i++) {
      if (newInputs[i] !== lastInputs[i]) {
        return false;
      }
    }
    return true;
  }
  function useMemoOne(getResult, inputs) {
    var initial = (0, import_react9.useState)(function() {
      return {
        inputs,
        result: getResult()
      };
    })[0];
    var isFirstRun = (0, import_react9.useRef)(true);
    var committed = (0, import_react9.useRef)(initial);
    var useCache = isFirstRun.current || Boolean(inputs && committed.current.inputs && areInputsEqual(inputs, committed.current.inputs));
    var cache = useCache ? committed.current : {
      inputs,
      result: getResult()
    };
    (0, import_react9.useEffect)(function() {
      isFirstRun.current = false;
      committed.current = cache;
    }, [cache]);
    return cache.result;
  }
  function useCallbackOne(callback, inputs) {
    return useMemoOne(function() {
      return callback;
    }, inputs);
  }

  // node_modules/@atlaskit/analytics-next/dist/esm/hooks/useAnalyticsEvents.js
  function useAnalyticsEvents() {
    var analyticsContext = useAnalyticsContext();
    var createAnalyticsEvent = useCallbackOne(function(payload) {
      return new UIAnalyticsEvent({
        context: analyticsContext.getAtlaskitAnalyticsContext(),
        handlers: analyticsContext.getAtlaskitAnalyticsEventHandlers(),
        payload
      });
    }, [analyticsContext]);
    return {
      createAnalyticsEvent
    };
  }

  // node_modules/@atlaskit/analytics-next/dist/esm/hooks/usePatchedProps.js
  init_defineProperty();
  init_typeof();
  var import_react10 = __toESM(require_react());
  function ownKeys3(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r && (o = o.filter(function(r2) {
        return Object.getOwnPropertyDescriptor(e, r2).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread3(e) {
    for (var r = 1; r < arguments.length; r++) {
      var t = null != arguments[r] ? arguments[r] : {};
      r % 2 ? ownKeys3(Object(t), true).forEach(function(r2) {
        _defineProperty(e, r2, t[r2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys3(Object(t)).forEach(function(r2) {
        Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
      });
    }
    return e;
  }
  function usePatchedProps() {
    var createEventMap = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var wrappedComponentProps = arguments.length > 1 ? arguments[1] : void 0;
    var _useAnalyticsEvents = useAnalyticsEvents(), createAnalyticsEvent = _useAnalyticsEvents.createAnalyticsEvent;
    var handlerCache = (0, import_react10.useRef)({});
    var patchedProps = (0, import_react10.useMemo)(function() {
      var cache = handlerCache.current;
      Object.keys(cache).filter(function(key) {
        return !(key in createEventMap);
      }).forEach(function(key) {
        return delete cache[key];
      });
      return Object.keys(createEventMap).reduce(function(p, k) {
        var eventCreator = createEventMap[k];
        if (!["object", "function"].includes(_typeof(eventCreator))) {
          return p;
        }
        var propValue = wrappedComponentProps[k];
        if (k in cache && cache[k].eventCreator === eventCreator && cache[k].propValue === propValue) {
          return _objectSpread3(_objectSpread3({}, p), {}, _defineProperty({}, k, cache[k].wrappedCallback));
        }
        var wrappedCallback = function wrappedCallback2() {
          var analyticsEvent = typeof eventCreator === "function" ? eventCreator(createAnalyticsEvent, wrappedComponentProps) : createAnalyticsEvent(eventCreator);
          if (propValue && typeof propValue === "function") {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            propValue.apply(void 0, args.concat([analyticsEvent]));
          }
        };
        cache[k] = {
          eventCreator,
          wrappedCallback,
          propValue
        };
        return _objectSpread3(_objectSpread3({}, p), {}, _defineProperty({}, k, wrappedCallback));
      }, {});
    }, [createEventMap, wrappedComponentProps, createAnalyticsEvent, handlerCache]);
    return {
      patchedEventProps: patchedProps
    };
  }

  // node_modules/@atlaskit/analytics-next/dist/esm/hocs/withAnalyticsEvents.js
  var withAnalyticsEvents = function withAnalyticsEvents2() {
    var createEventMap = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return function(WrappedComponent) {
      var WithAnalyticsEvents = /* @__PURE__ */ (0, import_react11.forwardRef)(function(props, ref) {
        var _usePatchedProps = usePatchedProps(createEventMap, props), patchedEventProps = _usePatchedProps.patchedEventProps;
        var _useAnalyticsEvents = useAnalyticsEvents(), createAnalyticsEvent = _useAnalyticsEvents.createAnalyticsEvent;
        return /* @__PURE__ */ import_react11.default.createElement(WrappedComponent, _extends({}, props, patchedEventProps, {
          createAnalyticsEvent,
          ref
        }));
      });
      WithAnalyticsEvents.displayName = "WithAnalyticsEvents(".concat(WrappedComponent.displayName || WrappedComponent.name, ")");
      return WithAnalyticsEvents;
    };
  };
  var withAnalyticsEvents_default = withAnalyticsEvents;

  // node_modules/@atlaskit/analytics-next/dist/esm/hooks/usePlatformLeafEventHandler.js
  init_defineProperty();
  var import_react12 = __toESM(require_react());
  function ownKeys4(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r && (o = o.filter(function(r2) {
        return Object.getOwnPropertyDescriptor(e, r2).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread4(e) {
    for (var r = 1; r < arguments.length; r++) {
      var t = null != arguments[r] ? arguments[r] : {};
      r % 2 ? ownKeys4(Object(t), true).forEach(function(r2) {
        _defineProperty(e, r2, t[r2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys4(Object(t)).forEach(function(r2) {
        Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
      });
    }
    return e;
  }
  function usePlatformLeafEventHandler(_ref2) {
    var fn2 = _ref2.fn, action = _ref2.action, componentName = _ref2.componentName, actionSubject = _ref2.actionSubject, packageName3 = _ref2.packageName, packageVersion3 = _ref2.packageVersion, analyticsData = _ref2.analyticsData;
    var _useAnalyticsEvents = useAnalyticsEvents(), createAnalyticsEvent = _useAnalyticsEvents.createAnalyticsEvent;
    var dataRef = useTrackedRef(analyticsData);
    var fnRef = useTrackedRef(fn2);
    var handler = (0, import_react12.useCallback)(function(value) {
      var analyticsEvent = createAnalyticsEvent({
        action,
        actionSubject: actionSubject || componentName,
        attributes: {
          componentName,
          packageName: packageName3,
          packageVersion: packageVersion3
        }
      });
      var context = _objectSpread4({
        componentName,
        packageName: packageName3,
        packageVersion: packageVersion3
      }, dataRef.current);
      analyticsEvent.context.push(context);
      var clone = analyticsEvent.clone();
      if (clone) {
        clone.fire("atlaskit");
      }
      fnRef.current(value, analyticsEvent);
    }, [
      // These are strings and won't change
      action,
      componentName,
      actionSubject,
      packageName3,
      packageVersion3,
      // This function is memoized in the context
      createAnalyticsEvent,
      // these are a stable ref because of the useTrackedRef hook
      dataRef,
      fnRef
    ]);
    return handler;
  }

  // node_modules/@atlaskit/analytics-next/dist/esm/hooks/usePlatformLeafSyntheticEventHandler.js
  init_defineProperty();
  var import_react13 = __toESM(require_react());
  function ownKeys5(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r && (o = o.filter(function(r2) {
        return Object.getOwnPropertyDescriptor(e, r2).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread5(e) {
    for (var r = 1; r < arguments.length; r++) {
      var t = null != arguments[r] ? arguments[r] : {};
      r % 2 ? ownKeys5(Object(t), true).forEach(function(r2) {
        _defineProperty(e, r2, t[r2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys5(Object(t)).forEach(function(r2) {
        Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
      });
    }
    return e;
  }
  function usePlatformLeafSyntheticEventHandler(_ref2) {
    var fn2 = _ref2.fn, action = _ref2.action, componentName = _ref2.componentName, packageName3 = _ref2.packageName, packageVersion3 = _ref2.packageVersion, analyticsData = _ref2.analyticsData;
    var _useAnalyticsEvents = useAnalyticsEvents(), createAnalyticsEvent = _useAnalyticsEvents.createAnalyticsEvent;
    var dataRef = useTrackedRef(analyticsData);
    var fnRef = useTrackedRef(fn2);
    var handler = (0, import_react13.useCallback)(function() {
      var analyticsEvent = createAnalyticsEvent({
        action,
        actionSubject: componentName,
        attributes: {
          componentName,
          packageName: packageName3,
          packageVersion: packageVersion3
        }
      });
      var context = _objectSpread5({
        componentName,
        packageName: packageName3,
        packageVersion: packageVersion3
      }, dataRef.current);
      analyticsEvent.context.push(context);
      var clone = analyticsEvent.clone();
      if (clone) {
        clone.fire("atlaskit");
      }
      fnRef.current(analyticsEvent);
    }, [
      // These are strings and won't change
      action,
      componentName,
      packageName3,
      packageVersion3,
      // This function is memoized in the context
      createAnalyticsEvent,
      // these are a stable ref because of the useTrackedRef hook
      dataRef,
      fnRef
    ]);
    return handler;
  }

  // node_modules/@atlaskit/analytics-next/dist/esm/utils/createAndFireEvent.js
  var createAndFireEvent_default = (function(channel) {
    return function(payload) {
      return function(createAnalyticsEvent) {
        var consumerEvent = createAnalyticsEvent(payload);
        var clonedEvent = consumerEvent.clone();
        if (clonedEvent) {
          clonedEvent.fire(channel);
        }
        return consumerEvent;
      };
    };
  });

  // node_modules/@atlaskit/ds-lib/dist/esm/utils/noop.js
  function noop3() {
  }

  // node_modules/@atlaskit/ds-lib/dist/esm/hooks/use-close-on-escape-press.js
  var import_react14 = __toESM(require_react());
  var import_bind_event_listener = __toESM(require_dist());
  var import_platform_feature_flags2 = __toESM(require_cjs3());

  // node_modules/@atlaskit/ds-lib/dist/esm/utils/keycodes.js
  var ESCAPE = "Escape";

  // node_modules/@atlaskit/ds-lib/dist/esm/hooks/use-close-on-escape-press.js
  function useCloseOnEscapePress(_ref2) {
    var onClose = _ref2.onClose, isDisabled = _ref2.isDisabled;
    var escapePressed = (0, import_react14.useRef)(false);
    var onKeyDown = (0, import_react14.useCallback)(function(e) {
      if (isDisabled || escapePressed.current || e.key !== ESCAPE) {
        return;
      }
      escapePressed.current = true;
      onClose(e);
    }, [onClose, isDisabled]);
    var onKeyUp = (0, import_react14.useCallback)(function() {
      escapePressed.current = false;
    }, []);
    (0, import_react14.useEffect)(function() {
      if (isDisabled && (0, import_platform_feature_flags2.fg)("platform_only_attach_escape_handler_on_view")) {
        return;
      }
      return (0, import_bind_event_listener.bindAll)(document, [{
        type: "keydown",
        listener: onKeyDown
      }, {
        type: "keyup",
        listener: onKeyUp
      }], {
        capture: false
      });
    }, [onKeyDown, onKeyUp, isDisabled]);
  }

  // node_modules/@atlaskit/ds-lib/dist/esm/hooks/use-stable-ref.js
  var import_react15 = __toESM(require_react());
  function useStableRef(value) {
    var ref = (0, import_react15.useRef)(value);
    (0, import_react15.useEffect)(function() {
      ref.current = value;
    }, [value]);
    return ref;
  }

  // node_modules/tiny-invariant/dist/esm/tiny-invariant.js
  var isProduction = true;
  var prefix = "Invariant failed";
  function invariant(condition, message2) {
    if (condition) {
      return;
    }
    if (isProduction) {
      throw new Error(prefix);
    }
    var provided = typeof message2 === "function" ? message2() : message2;
    var value = provided ? "".concat(prefix, ": ").concat(provided) : prefix;
    throw new Error(value);
  }

  // node_modules/@atlaskit/layering/dist/esm/components/open-layer-observer/open-layer-observer-context.js
  var import_react16 = __toESM(require_react());
  var OpenLayerObserverContext = /* @__PURE__ */ (0, import_react16.createContext)(null);

  // node_modules/@atlaskit/layering/dist/esm/components/open-layer-observer/use-notify-open-layer-observer.js
  var import_react19 = __toESM(require_react());

  // node_modules/@atlaskit/layering/dist/esm/components/open-layer-observer/use-open-layer-observer-namespace.js
  var import_react18 = __toESM(require_react());

  // node_modules/@atlaskit/layering/dist/esm/components/open-layer-observer/open-layer-observer-namespace-context.js
  var import_react17 = __toESM(require_react());
  var OpenLayerObserverNamespaceContext = /* @__PURE__ */ (0, import_react17.createContext)(null);

  // node_modules/@atlaskit/layering/dist/esm/components/open-layer-observer/use-open-layer-observer-namespace.js
  function useOpenLayerObserverNamespace() {
    var namespace = (0, import_react18.useContext)(OpenLayerObserverNamespaceContext);
    return namespace;
  }

  // node_modules/@atlaskit/layering/dist/esm/components/open-layer-observer/use-notify-open-layer-observer.js
  function useNotifyOpenLayerObserver(_ref2) {
    var isOpen = _ref2.isOpen, onClose = _ref2.onClose;
    var context = (0, import_react19.useContext)(OpenLayerObserverContext);
    var namespace = useOpenLayerObserverNamespace();
    (0, import_react19.useEffect)(function() {
      if (context === null) {
        return;
      }
      if (!isOpen) {
        return;
      }
      return context.onClose(onClose, {
        namespace
      });
    }, [context, isOpen, namespace, onClose]);
  }

  // node_modules/@atlaskit/motion/dist/esm/utils/durations.js
  var durations = {
    none: 0,
    small: 100,
    medium: 350,
    large: 700
  };
  var EXITING_MOTION_MULTIPLIER = 0.5;
  var exitingDurations = {
    none: durations.none,
    small: durations.small * EXITING_MOTION_MULTIPLIER,
    medium: durations.medium * EXITING_MOTION_MULTIPLIER,
    large: durations.large * EXITING_MOTION_MULTIPLIER
  };

  // node_modules/@atlaskit/motion/dist/esm/utils/curves.js
  var easeInOut = "cubic-bezier(0.15,1,0.3,1)";

  // node_modules/@atlaskit/motion/dist/esm/utils/accessibility.js
  init_slicedToArray();
  var import_react20 = __toESM(require_react());
  var isMatchMediaAvailable = function isMatchMediaAvailable2() {
    return typeof window !== "undefined" && "matchMedia" in window;
  };
  var isReducedMotion = function isReducedMotion2() {
    if (!isMatchMediaAvailable()) {
      return false;
    }
    var _window$matchMedia2 = window.matchMedia("(prefers-reduced-motion: reduce)"), matches = _window$matchMedia2.matches;
    return matches;
  };

  // node_modules/@atlaskit/motion/dist/esm/entering/fade-in.js
  var import_react26 = __toESM(require_react());

  // node_modules/@atlaskit/motion/dist/esm/entering/keyframes-motion.js
  init_slicedToArray();
  var import_react25 = __toESM(require_react());

  // node_modules/@compiled/react/dist/esm/runtime/ax.js
  var ATOMIC_GROUP_LENGTH = 5;
  function ax(classNames2) {
    if (!classNames2.length) {
      return;
    }
    if (classNames2.length === 1 && classNames2[0] && // checking to see if `classNames[0]` is a string that contains other classnames
    !classNames2[0].includes(" ")) {
      return classNames2[0];
    }
    const map = {};
    for (const value of classNames2) {
      if (!value) {
        continue;
      }
      const list = value.split(" ");
      for (const className of list) {
        const key = className.startsWith("_") ? className.slice(0, ATOMIC_GROUP_LENGTH) : className;
        map[key] = className;
      }
    }
    let result2 = "";
    for (const key in map) {
      result2 += map[key] + " ";
    }
    if (!result2) {
      return;
    }
    return result2.trimEnd();
  }

  // node_modules/@compiled/react/dist/esm/runtime/css-custom-property.js
  function cssCustomPropertyValue(value, suffix, prefix3) {
    if (value != void 0) {
      if (suffix) {
        if (prefix3) {
          return prefix3 + value + suffix;
        }
        return value + suffix;
      }
      return value;
    }
    return "var(--c-, )";
  }

  // node_modules/@atlaskit/motion/dist/esm/utils/timer-hooks.js
  var import_react21 = __toESM(require_react());
  var getHookDeps = function getHookDeps2(opts) {
    switch (opts.cleanup) {
      case "next-effect":
        return void 0;
      case "unmount":
      default:
        return [];
    }
  };
  var useSetTimeout = function useSetTimeout2() {
    var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      cleanup: "unmount"
    };
    var timeouts = (0, import_react21.useRef)([]);
    (0, import_react21.useEffect)(function() {
      return function() {
        if (timeouts.current.length) {
          timeouts.current.forEach(function(id) {
            return clearTimeout(id);
          });
          timeouts.current = [];
        }
      };
    }, getHookDeps(opts));
    return (0, import_react21.useCallback)(function(handler, timeout) {
      for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        args[_key - 2] = arguments[_key];
      }
      var id = setTimeout.apply(void 0, [function() {
        timeouts.current = timeouts.current.filter(function(timeoutId) {
          return timeoutId !== id;
        });
        handler();
      }, timeout].concat(args));
      timeouts.current.push(id);
    }, []);
  };

  // node_modules/@atlaskit/motion/dist/esm/entering/exiting-persistence.js
  init_slicedToArray();
  var import_react22 = __toESM(require_react());
  var emptyContext = {
    // Motions will always appear if not inside a exiting persistence component.
    appear: true,
    isExiting: false
  };
  var ExitingContext = /* @__PURE__ */ (0, import_react22.createContext)(emptyContext);
  var wrapChildWithContextProvider = function wrapChildWithContextProvider2(child) {
    var value = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : emptyContext;
    return /* @__PURE__ */ import_react22.default.createElement(ExitingContext.Provider, {
      key: "".concat(child.key, "-provider"),
      value
    }, child);
  };
  var childrenToArray = function childrenToArray2(children) {
    var childrenAsArray = [];
    import_react22.Children.toArray(children).forEach(function(child) {
      if (typeof child !== "boolean" && Boolean(child)) {
        childrenAsArray.push(child);
      }
    });
    return childrenAsArray;
  };
  var spliceNewElementsIntoPrevious = function spliceNewElementsIntoPrevious2(current, previous) {
    var splicedChildren = previous.concat([]);
    var previousMap = childrenToObj(previous);
    for (var i = 0; i < current.length; i++) {
      var child = current[i];
      var childIsNew = !previousMap[child.key];
      if (childIsNew) {
        splicedChildren.splice(i + 1, 0, child);
      }
    }
    return splicedChildren;
  };
  var childrenToObj = function childrenToObj2(children) {
    return children.reduce(function(acc, child) {
      acc[child.key] = child;
      return acc;
    }, {});
  };
  var getMissingKeys = function getMissingKeys2(current, previous) {
    var currentMapKeys = new Set(current.map(function(child) {
      return child.key;
    }));
    var missing = /* @__PURE__ */ new Set();
    for (var i = 0; i < previous.length; i++) {
      var element = previous[i];
      var _key = element.key;
      if (!currentMapKeys.has(_key)) {
        missing.add(_key);
      }
    }
    return missing;
  };
  var ExitingPersistence = /* @__PURE__ */ (0, import_react22.memo)(function(_ref2) {
    var _ref$appear = _ref2.appear, appear = _ref$appear === void 0 ? false : _ref$appear, children = _ref2.children, exitThenEnter = _ref2.exitThenEnter;
    var _useState = (0, import_react22.useState)([null, children]), _useState2 = _slicedToArray(_useState, 2), stateChildren = _useState2[0], setChildren = _useState2[1];
    var _useState3 = (0, import_react22.useState)([]), _useState4 = _slicedToArray(_useState3, 2), exitingChildren = _useState4[0], setExitingChildren = _useState4[1];
    var _useState5 = (0, import_react22.useState)(function() {
      return {
        appear,
        isExiting: false
      };
    }), _useState6 = _slicedToArray(_useState5, 2), defaultContext = _useState6[0], setDefaultContext = _useState6[1];
    (0, import_react22.useEffect)(function() {
      if (!defaultContext.appear) {
        setDefaultContext({
          appear: true,
          isExiting: false
        });
      }
    }, []);
    if (typeof stateChildren === "boolean") {
      return children;
    }
    var _stateChildren = _slicedToArray(stateChildren, 2), previousChildren = _stateChildren[0], currentChildren = _stateChildren[1];
    var previous = childrenToArray(previousChildren);
    var current = childrenToArray(currentChildren);
    if (currentChildren !== children) {
      setChildren([currentChildren, children]);
    }
    var missingKeys = getMissingKeys(current, previous);
    var isSomeChildRemoved = !!missingKeys.size;
    var visibleChildren = current;
    if (isSomeChildRemoved) {
      visibleChildren = spliceNewElementsIntoPrevious(current, previous);
    }
    if (exitThenEnter) {
      if (exitingChildren.length) {
        visibleChildren = exitingChildren;
      } else {
        var nextExitingChildren = visibleChildren.filter(function(child) {
          return missingKeys.has(child.key);
        });
        if (nextExitingChildren.length) {
          setExitingChildren(nextExitingChildren);
        }
      }
    }
    if (missingKeys.size) {
      visibleChildren = visibleChildren.map(function(child) {
        var isExiting = missingKeys.has(child.key);
        return wrapChildWithContextProvider(child, {
          appear: true,
          isExiting,
          onFinish: isExiting ? function() {
            missingKeys.delete(child.key);
            if (missingKeys.size === 0) {
              setChildren([null, children]);
              setExitingChildren([]);
            }
          } : void 0
        });
      });
    } else {
      visibleChildren = visibleChildren.map(function(child) {
        return wrapChildWithContextProvider(child, defaultContext);
      });
    }
    return visibleChildren;
  });
  var useExitingPersistence = function useExitingPersistence2() {
    return (0, import_react22.useContext)(ExitingContext);
  };
  ExitingPersistence.displayName = "ExitingPersistence";
  var exiting_persistence_default = ExitingPersistence;

  // node_modules/@atlaskit/motion/dist/esm/entering/staggered-entrance.js
  init_slicedToArray();
  var import_react24 = __toESM(require_react());

  // node_modules/@atlaskit/motion/dist/esm/utils/use-unique-id.js
  var import_react23 = __toESM(require_react());
  function useUniqueId() {
    var identifier2 = (0, import_react23.useRef)("");
    if (!identifier2.current) {
      identifier2.current = "_" + (Number(String(Math.random()).slice(2)) + Date.now() + Math.round(performance.now())).toString(36);
    }
    return identifier2.current;
  }

  // node_modules/@atlaskit/motion/dist/esm/entering/staggered-entrance.js
  var StaggeredEntranceContext = /* @__PURE__ */ (0, import_react24.createContext)(function() {
    return {
      isReady: true,
      delay: 0,
      ref: noop3
    };
  });
  var useStaggeredEntrance = function useStaggeredEntrance2() {
    var indentifier = useUniqueId();
    var context = (0, import_react24.useContext)(StaggeredEntranceContext);
    return context(indentifier);
  };

  // node_modules/@atlaskit/motion/dist/esm/entering/keyframes-motion.js
  var EnteringMotion = function EnteringMotion2(_ref2) {
    var children = _ref2.children, animationTimingFunction = _ref2.animationTimingFunction, _ref$animationTimingF = _ref2.animationTimingFunctionExiting, animationTimingFunctionExiting = _ref$animationTimingF === void 0 ? animationTimingFunction : _ref$animationTimingF, enteringAnimation = _ref2.enteringAnimation, _ref$exitingAnimation = _ref2.exitingAnimation, exitingAnimation = _ref$exitingAnimation === void 0 ? enteringAnimation : _ref$exitingAnimation, isPaused = _ref2.isPaused, onFinishMotion = _ref2.onFinish, _ref$duration = _ref2.duration, duration = _ref$duration === void 0 ? "large" : _ref$duration;
    var staggered = useStaggeredEntrance();
    var _useExitingPersistenc = useExitingPersistence(), isExiting = _useExitingPersistenc.isExiting, onExitFinished = _useExitingPersistenc.onFinish, appear = _useExitingPersistenc.appear;
    var setTimeout2 = useSetTimeout();
    var paused = isPaused || !staggered.isReady;
    var delay = isExiting ? 0 : staggered.delay;
    var state = isExiting ? "exiting" : "entering";
    var _useState = (0, import_react25.useState)(appear), _useState2 = _slicedToArray(_useState, 2), hasAnimationStyles = _useState2[0], setHasAnimationStyles = _useState2[1];
    (0, import_react25.useEffect)(function() {
      var isCancelled = false;
      if (paused) {
        return;
      }
      if (!appear) {
        onFinishMotion && onFinishMotion(state);
        return;
      }
      var onAnimationEnd = function onAnimationEnd2() {
        if (state === "exiting") {
          onExitFinished === null || onExitFinished === void 0 || onExitFinished();
        }
        if (!isCancelled) {
          setHasAnimationStyles(false);
        }
        onFinishMotion === null || onFinishMotion === void 0 || onFinishMotion(state);
      };
      if (isReducedMotion()) {
        onAnimationEnd();
        return;
      }
      setHasAnimationStyles(true);
      setTimeout2(onAnimationEnd, isExiting ? exitingDurations[duration] : durations[duration] + delay);
      return function() {
        isCancelled = true;
      };
    }, [onExitFinished, state, isExiting, duration, delay, paused, setTimeout2]);
    return children({
      ref: staggered.ref,
      // @ts-expect-error: `ax` is not typed correctly
      className: hasAnimationStyles ? ax([ax(["_1o51eoah _1y0co91m _1bumglyw _sedtglyw"]), paused && ax(["_1y0ctrqk"]), duration === "small" && ax(["_5sag1yx9"]), duration === "medium" && ax(["_5sag1ttt"]), duration === "large" && ax(["_5sagpwmj"]), isExiting && duration === "small" && ax(["_5sag14ed"]), isExiting && duration === "medium" && ax(["_5sagluct"]), isExiting && duration === "large" && ax(["_5sag1ttt"]), isExiting && ax(["_ju255cps _1o51q7pw"]), !isExiting && animationTimingFunction === "linear" && ax(["_1pglp3kn"]), !isExiting && animationTimingFunction === "ease-out" && ax(["_1pgldkwg"]), !isExiting && animationTimingFunction === "ease-in" && ax(["_1pgl1nzg"]), !isExiting && animationTimingFunction === "ease-in-40-out" && ax(["_1pgl5y64"]), !isExiting && animationTimingFunction === "ease-in-60-out" && ax(["_1pgl1ddy"]), !isExiting && animationTimingFunction === "ease-in-80-out" && ax(["_1pglannl"]), !isExiting && animationTimingFunction === "ease-in-out" && ax(["_1pgl1fu8"]), isExiting && animationTimingFunction === "linear" && ax(["_1pglp3kn"]), isExiting && animationTimingFunctionExiting === "ease-out" && ax(["_1pgldkwg"]), isExiting && animationTimingFunctionExiting === "ease-in" && ax(["_1pgl1nzg"]), isExiting && animationTimingFunctionExiting === "ease-in-40-out" && ax(["_1pgl5y64"]), isExiting && animationTimingFunctionExiting === "ease-in-60-out" && ax(["_1pgl1ddy"]), isExiting && animationTimingFunctionExiting === "ease-in-80-out" && ax(["_1pglannl"]), isExiting && animationTimingFunctionExiting === "ease-in-out" && ax(["_1pgl1fu8"]), (!isExiting && enteringAnimation === "fade-in" || isExiting && exitingAnimation === "fade-in") && ax(["_j7hq1cgr"]), (!isExiting && enteringAnimation === "fade-out" || isExiting && exitingAnimation === "fade-out") && ax(["_j7hq1lln"]), (!isExiting && enteringAnimation === "zoom-in" || isExiting && exitingAnimation === "zoom-in") && ax(["_j7hqe8p0"]), (!isExiting && enteringAnimation === "zoom-out" || isExiting && exitingAnimation === "zoom-out") && ax(["_j7hqy6ql"]), (!isExiting && enteringAnimation === "slide-in-from-top" || isExiting && exitingAnimation === "slide-in-from-top") && ax(["_j7hqqshu"]), (!isExiting && enteringAnimation === "slide-out-from-top" || isExiting && exitingAnimation === "slide-out-from-top") && ax(["_j7hq7ri4"]), (!isExiting && enteringAnimation === "slide-in-from-right" || isExiting && exitingAnimation === "slide-in-from-right") && ax(["_j7hqdfjr"]), (!isExiting && enteringAnimation === "slide-out-from-right" || isExiting && exitingAnimation === "slide-out-from-right") && ax(["_j7hqonfj"]), (!isExiting && enteringAnimation === "slide-in-from-bottom" || isExiting && exitingAnimation === "slide-in-from-bottom") && ax(["_j7hq1liq"]), (!isExiting && enteringAnimation === "slide-out-from-bottom" || isExiting && exitingAnimation === "slide-out-from-bottom") && ax(["_j7hqhnf1"]), (!isExiting && enteringAnimation === "slide-in-from-left" || isExiting && exitingAnimation === "slide-in-from-left") && ax(["_j7hq1bh1"]), (!isExiting && enteringAnimation === "slide-out-from-left" || isExiting && exitingAnimation === "slide-out-from-left") && ax(["_j7hqj08w"]), (!isExiting && enteringAnimation === "fade-in-from-top" || isExiting && exitingAnimation === "fade-in-from-top") && ax(["_j7hq2iua"]), (!isExiting && enteringAnimation === "fade-out-from-top" || isExiting && exitingAnimation === "fade-out-from-top") && ax(["_j7hq39va"]), (!isExiting && enteringAnimation === "fade-in-from-left" || isExiting && exitingAnimation === "fade-in-from-left") && ax(["_j7hq15m2"]), (!isExiting && enteringAnimation === "fade-out-from-left" || isExiting && exitingAnimation === "fade-out-from-left") && ax(["_j7hq1yiv"]), (!isExiting && enteringAnimation === "fade-in-from-bottom" || isExiting && exitingAnimation === "fade-in-from-bottom") && ax(["_j7hq1w00"]), (!isExiting && enteringAnimation === "fade-out-from-bottom" || isExiting && exitingAnimation === "fade-out-from-bottom") && ax(["_j7hqzy3z"]), (!isExiting && enteringAnimation === "fade-in-from-right" || isExiting && exitingAnimation === "fade-in-from-right") && ax(["_j7hqpqak"]), (!isExiting && enteringAnimation === "fade-out-from-right" || isExiting && exitingAnimation === "fade-out-from-right") && ax(["_j7hq1ebg"]), (!isExiting && enteringAnimation === "fade-in-from-top-constant" || isExiting && exitingAnimation === "fade-in-from-top-constant") && ax(["_j7hqm2e2"]), (!isExiting && enteringAnimation === "fade-out-from-top-constant" || isExiting && exitingAnimation === "fade-out-from-top-constant") && ax(["_j7hq97jn"]), (!isExiting && enteringAnimation === "fade-in-from-left-constant" || isExiting && exitingAnimation === "fade-in-from-left-constant") && ax(["_j7hqovgq"]), (!isExiting && enteringAnimation === "fade-out-from-left-constant" || isExiting && exitingAnimation === "fade-out-from-left-constant") && ax(["_j7hq15do"]), (!isExiting && enteringAnimation === "fade-in-from-bottom-constant" || isExiting && exitingAnimation === "fade-in-from-bottom-constant") && ax(["_j7hq797a"]), (!isExiting && enteringAnimation === "fade-out-from-bottom-constant" || isExiting && exitingAnimation === "fade-out-from-bottom-constant") && ax(["_j7hqwo7r"]), (!isExiting && enteringAnimation === "fade-in-from-right-constant" || isExiting && exitingAnimation === "fade-in-from-right-constant") && ax(["_j7hqt8u5"]), (!isExiting && enteringAnimation === "fade-out-from-right-constant" || isExiting && exitingAnimation === "fade-out-from-right-constant") && ax(["_j7hq1pgp"])]) : "",
      style: {
        animationDelay: "".concat(delay, "ms")
      }
    }, state);
  };
  var keyframes_motion_default = EnteringMotion;

  // node_modules/@atlaskit/motion/dist/esm/entering/fade-in.js
  var invertedDirection = {
    top: "bottom",
    bottom: "top",
    left: "right",
    right: "left"
  };
  var FadeIn = function FadeIn2(_ref2) {
    var children = _ref2.children, _ref$duration = _ref2.duration, duration = _ref$duration === void 0 ? "large" : _ref$duration, entranceDirection = _ref2.entranceDirection, exitDirection = _ref2.exitDirection, _ref$distance = _ref2.distance, distance = _ref$distance === void 0 ? "proportional" : _ref$distance, onFinish = _ref2.onFinish, isPaused = _ref2.isPaused;
    var invertedEntranceDirection = entranceDirection !== void 0 ? invertedDirection[entranceDirection] : void 0;
    var isExitDirect = Boolean(exitDirection || invertedEntranceDirection) ? "fade-out-from-".concat(exitDirection || invertedEntranceDirection).concat(distance === "proportional" ? "" : "-constant") : "fade-out";
    return /* @__PURE__ */ import_react26.default.createElement(keyframes_motion_default, {
      duration,
      enteringAnimation: entranceDirection ? "fade-in-from-".concat(entranceDirection).concat(distance === "proportional" ? "" : "-constant") : "fade-in",
      exitingAnimation: isExitDirect,
      animationTimingFunction: "ease-in-out",
      onFinish,
      isPaused
    }, children);
  };
  var fade_in_default = FadeIn;

  // node_modules/@atlaskit/tooltip/dist/esm/tooltip.js
  var import_platform_feature_flags5 = __toESM(require_cjs3());

  // node_modules/@atlaskit/popper/dist/esm/popper.js
  init_toConsumableArray();
  init_slicedToArray();
  var import_react27 = __toESM(require_react());

  // node_modules/react-popper/lib/esm/Popper.js
  var React14 = __toESM(require_react());

  // node_modules/react-popper/lib/esm/Manager.js
  var React11 = __toESM(require_react());
  var ManagerReferenceNodeContext = React11.createContext();
  var ManagerReferenceNodeSetterContext = React11.createContext();
  function Manager(_ref2) {
    var children = _ref2.children;
    var _React$useState = React11.useState(null), referenceNode = _React$useState[0], setReferenceNode = _React$useState[1];
    var hasUnmounted = React11.useRef(false);
    React11.useEffect(function() {
      return function() {
        hasUnmounted.current = true;
      };
    }, []);
    var handleSetReferenceNode = React11.useCallback(function(node2) {
      if (!hasUnmounted.current) {
        setReferenceNode(node2);
      }
    }, []);
    return /* @__PURE__ */ React11.createElement(ManagerReferenceNodeContext.Provider, {
      value: referenceNode
    }, /* @__PURE__ */ React11.createElement(ManagerReferenceNodeSetterContext.Provider, {
      value: handleSetReferenceNode
    }, children));
  }

  // node_modules/react-popper/lib/esm/utils.js
  var React12 = __toESM(require_react());
  var unwrapArray = function unwrapArray2(arg) {
    return Array.isArray(arg) ? arg[0] : arg;
  };
  var safeInvoke = function safeInvoke2(fn2) {
    if (typeof fn2 === "function") {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      return fn2.apply(void 0, args);
    }
  };
  var setRef = function setRef2(ref, node2) {
    if (typeof ref === "function") {
      return safeInvoke(ref, node2);
    } else if (ref != null) {
      ref.current = node2;
    }
  };
  var fromEntries = function fromEntries2(entries) {
    return entries.reduce(function(acc, _ref2) {
      var key = _ref2[0], value = _ref2[1];
      acc[key] = value;
      return acc;
    }, {});
  };
  var useIsomorphicLayoutEffect = typeof window !== "undefined" && window.document && window.document.createElement ? React12.useLayoutEffect : React12.useEffect;

  // node_modules/react-popper/lib/esm/usePopper.js
  var React13 = __toESM(require_react());
  var ReactDOM = __toESM(require_react_dom());

  // node_modules/@popperjs/core/lib/enums.js
  var top = "top";
  var bottom = "bottom";
  var right = "right";
  var left = "left";
  var auto = "auto";
  var basePlacements = [top, bottom, right, left];
  var start = "start";
  var end = "end";
  var clippingParents = "clippingParents";
  var viewport = "viewport";
  var popper = "popper";
  var reference = "reference";
  var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
    return acc.concat([placement + "-" + start, placement + "-" + end]);
  }, []);
  var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
    return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
  }, []);
  var beforeRead = "beforeRead";
  var read = "read";
  var afterRead = "afterRead";
  var beforeMain = "beforeMain";
  var main = "main";
  var afterMain = "afterMain";
  var beforeWrite = "beforeWrite";
  var write = "write";
  var afterWrite = "afterWrite";
  var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

  // node_modules/@popperjs/core/lib/dom-utils/getNodeName.js
  function getNodeName(element) {
    return element ? (element.nodeName || "").toLowerCase() : null;
  }

  // node_modules/@popperjs/core/lib/dom-utils/getWindow.js
  function getWindow(node2) {
    if (node2 == null) {
      return window;
    }
    if (node2.toString() !== "[object Window]") {
      var ownerDocument = node2.ownerDocument;
      return ownerDocument ? ownerDocument.defaultView || window : window;
    }
    return node2;
  }

  // node_modules/@popperjs/core/lib/dom-utils/instanceOf.js
  function isElement(node2) {
    var OwnElement = getWindow(node2).Element;
    return node2 instanceof OwnElement || node2 instanceof Element;
  }
  function isHTMLElement(node2) {
    var OwnElement = getWindow(node2).HTMLElement;
    return node2 instanceof OwnElement || node2 instanceof HTMLElement;
  }
  function isShadowRoot(node2) {
    if (typeof ShadowRoot === "undefined") {
      return false;
    }
    var OwnElement = getWindow(node2).ShadowRoot;
    return node2 instanceof OwnElement || node2 instanceof ShadowRoot;
  }

  // node_modules/@popperjs/core/lib/modifiers/applyStyles.js
  function applyStyles(_ref2) {
    var state = _ref2.state;
    Object.keys(state.elements).forEach(function(name) {
      var style = state.styles[name] || {};
      var attributes = state.attributes[name] || {};
      var element = state.elements[name];
      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function(name2) {
        var value = attributes[name2];
        if (value === false) {
          element.removeAttribute(name2);
        } else {
          element.setAttribute(name2, value === true ? "" : value);
        }
      });
    });
  }
  function effect(_ref2) {
    var state = _ref2.state;
    var initialStyles = {
      popper: {
        position: state.options.strategy,
        left: "0",
        top: "0",
        margin: "0"
      },
      arrow: {
        position: "absolute"
      },
      reference: {}
    };
    Object.assign(state.elements.popper.style, initialStyles.popper);
    state.styles = initialStyles;
    if (state.elements.arrow) {
      Object.assign(state.elements.arrow.style, initialStyles.arrow);
    }
    return function() {
      Object.keys(state.elements).forEach(function(name) {
        var element = state.elements[name];
        var attributes = state.attributes[name] || {};
        var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
        var style = styleProperties.reduce(function(style2, property) {
          style2[property] = "";
          return style2;
        }, {});
        if (!isHTMLElement(element) || !getNodeName(element)) {
          return;
        }
        Object.assign(element.style, style);
        Object.keys(attributes).forEach(function(attribute) {
          element.removeAttribute(attribute);
        });
      });
    };
  }
  var applyStyles_default = {
    name: "applyStyles",
    enabled: true,
    phase: "write",
    fn: applyStyles,
    effect,
    requires: ["computeStyles"]
  };

  // node_modules/@popperjs/core/lib/utils/getBasePlacement.js
  function getBasePlacement(placement) {
    return placement.split("-")[0];
  }

  // node_modules/@popperjs/core/lib/utils/math.js
  var max = Math.max;
  var min = Math.min;
  var round = Math.round;

  // node_modules/@popperjs/core/lib/utils/userAgent.js
  function getUAString() {
    var uaData = navigator.userAgentData;
    if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
      return uaData.brands.map(function(item) {
        return item.brand + "/" + item.version;
      }).join(" ");
    }
    return navigator.userAgent;
  }

  // node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js
  function isLayoutViewport() {
    return !/^((?!chrome|android).)*safari/i.test(getUAString());
  }

  // node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js
  function getBoundingClientRect(element, includeScale, isFixedStrategy) {
    if (includeScale === void 0) {
      includeScale = false;
    }
    if (isFixedStrategy === void 0) {
      isFixedStrategy = false;
    }
    var clientRect = element.getBoundingClientRect();
    var scaleX = 1;
    var scaleY = 1;
    if (includeScale && isHTMLElement(element)) {
      scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
      scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
    }
    var _ref2 = isElement(element) ? getWindow(element) : window, visualViewport = _ref2.visualViewport;
    var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
    var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
    var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
    var width2 = clientRect.width / scaleX;
    var height = clientRect.height / scaleY;
    return {
      width: width2,
      height,
      top: y,
      right: x + width2,
      bottom: y + height,
      left: x,
      x,
      y
    };
  }

  // node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js
  function getLayoutRect(element) {
    var clientRect = getBoundingClientRect(element);
    var width2 = element.offsetWidth;
    var height = element.offsetHeight;
    if (Math.abs(clientRect.width - width2) <= 1) {
      width2 = clientRect.width;
    }
    if (Math.abs(clientRect.height - height) <= 1) {
      height = clientRect.height;
    }
    return {
      x: element.offsetLeft,
      y: element.offsetTop,
      width: width2,
      height
    };
  }

  // node_modules/@popperjs/core/lib/dom-utils/contains.js
  function contains(parent, child) {
    var rootNode = child.getRootNode && child.getRootNode();
    if (parent.contains(child)) {
      return true;
    } else if (rootNode && isShadowRoot(rootNode)) {
      var next2 = child;
      do {
        if (next2 && parent.isSameNode(next2)) {
          return true;
        }
        next2 = next2.parentNode || next2.host;
      } while (next2);
    }
    return false;
  }

  // node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js
  function getComputedStyle2(element) {
    return getWindow(element).getComputedStyle(element);
  }

  // node_modules/@popperjs/core/lib/dom-utils/isTableElement.js
  function isTableElement(element) {
    return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
  }

  // node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js
  function getDocumentElement(element) {
    return ((isElement(element) ? element.ownerDocument : (
      // $FlowFixMe[prop-missing]
      element.document
    )) || window.document).documentElement;
  }

  // node_modules/@popperjs/core/lib/dom-utils/getParentNode.js
  function getParentNode(element) {
    if (getNodeName(element) === "html") {
      return element;
    }
    return (
      // this is a quicker (but less type safe) way to save quite some bytes from the bundle
      // $FlowFixMe[incompatible-return]
      // $FlowFixMe[prop-missing]
      element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
      element.parentNode || // DOM Element detected
      (isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
      // $FlowFixMe[incompatible-call]: HTMLElement is a Node
      getDocumentElement(element)
    );
  }

  // node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js
  function getTrueOffsetParent(element) {
    if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
    getComputedStyle2(element).position === "fixed") {
      return null;
    }
    return element.offsetParent;
  }
  function getContainingBlock(element) {
    var isFirefox3 = /firefox/i.test(getUAString());
    var isIE = /Trident/i.test(getUAString());
    if (isIE && isHTMLElement(element)) {
      var elementCss = getComputedStyle2(element);
      if (elementCss.position === "fixed") {
        return null;
      }
    }
    var currentNode = getParentNode(element);
    if (isShadowRoot(currentNode)) {
      currentNode = currentNode.host;
    }
    while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
      var css7 = getComputedStyle2(currentNode);
      if (css7.transform !== "none" || css7.perspective !== "none" || css7.contain === "paint" || ["transform", "perspective"].indexOf(css7.willChange) !== -1 || isFirefox3 && css7.willChange === "filter" || isFirefox3 && css7.filter && css7.filter !== "none") {
        return currentNode;
      } else {
        currentNode = currentNode.parentNode;
      }
    }
    return null;
  }
  function getOffsetParent(element) {
    var window2 = getWindow(element);
    var offsetParent = getTrueOffsetParent(element);
    while (offsetParent && isTableElement(offsetParent) && getComputedStyle2(offsetParent).position === "static") {
      offsetParent = getTrueOffsetParent(offsetParent);
    }
    if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle2(offsetParent).position === "static")) {
      return window2;
    }
    return offsetParent || getContainingBlock(element) || window2;
  }

  // node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js
  function getMainAxisFromPlacement(placement) {
    return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
  }

  // node_modules/@popperjs/core/lib/utils/within.js
  function within(min3, value, max3) {
    return max(min3, min(value, max3));
  }
  function withinMaxClamp(min3, value, max3) {
    var v = within(min3, value, max3);
    return v > max3 ? max3 : v;
  }

  // node_modules/@popperjs/core/lib/utils/getFreshSideObject.js
  function getFreshSideObject() {
    return {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    };
  }

  // node_modules/@popperjs/core/lib/utils/mergePaddingObject.js
  function mergePaddingObject(paddingObject) {
    return Object.assign({}, getFreshSideObject(), paddingObject);
  }

  // node_modules/@popperjs/core/lib/utils/expandToHashMap.js
  function expandToHashMap(value, keys) {
    return keys.reduce(function(hashMap, key) {
      hashMap[key] = value;
      return hashMap;
    }, {});
  }

  // node_modules/@popperjs/core/lib/modifiers/arrow.js
  var toPaddingObject = function toPaddingObject2(padding, state) {
    padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
      placement: state.placement
    })) : padding;
    return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  };
  function arrow(_ref2) {
    var _state$modifiersData$;
    var state = _ref2.state, name = _ref2.name, options2 = _ref2.options;
    var arrowElement = state.elements.arrow;
    var popperOffsets2 = state.modifiersData.popperOffsets;
    var basePlacement = getBasePlacement(state.placement);
    var axis = getMainAxisFromPlacement(basePlacement);
    var isVertical = [left, right].indexOf(basePlacement) >= 0;
    var len = isVertical ? "height" : "width";
    if (!arrowElement || !popperOffsets2) {
      return;
    }
    var paddingObject = toPaddingObject(options2.padding, state);
    var arrowRect = getLayoutRect(arrowElement);
    var minProp = axis === "y" ? top : left;
    var maxProp = axis === "y" ? bottom : right;
    var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
    var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
    var arrowOffsetParent = getOffsetParent(arrowElement);
    var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
    var centerToReference = endDiff / 2 - startDiff / 2;
    var min3 = paddingObject[minProp];
    var max3 = clientSize - arrowRect[len] - paddingObject[maxProp];
    var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
    var offset3 = within(min3, center, max3);
    var axisProp = axis;
    state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset3, _state$modifiersData$.centerOffset = offset3 - center, _state$modifiersData$);
  }
  function effect2(_ref2) {
    var state = _ref2.state, options2 = _ref2.options;
    var _options$element = options2.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
    if (arrowElement == null) {
      return;
    }
    if (typeof arrowElement === "string") {
      arrowElement = state.elements.popper.querySelector(arrowElement);
      if (!arrowElement) {
        return;
      }
    }
    if (!contains(state.elements.popper, arrowElement)) {
      return;
    }
    state.elements.arrow = arrowElement;
  }
  var arrow_default = {
    name: "arrow",
    enabled: true,
    phase: "main",
    fn: arrow,
    effect: effect2,
    requires: ["popperOffsets"],
    requiresIfExists: ["preventOverflow"]
  };

  // node_modules/@popperjs/core/lib/utils/getVariation.js
  function getVariation(placement) {
    return placement.split("-")[1];
  }

  // node_modules/@popperjs/core/lib/modifiers/computeStyles.js
  var unsetSides = {
    top: "auto",
    right: "auto",
    bottom: "auto",
    left: "auto"
  };
  function roundOffsetsByDPR(_ref2, win) {
    var x = _ref2.x, y = _ref2.y;
    var dpr = win.devicePixelRatio || 1;
    return {
      x: round(x * dpr) / dpr || 0,
      y: round(y * dpr) / dpr || 0
    };
  }
  function mapToStyles(_ref2) {
    var _Object$assign2;
    var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position2 = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
    var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;
    var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
      x,
      y
    }) : {
      x,
      y
    };
    x = _ref3.x;
    y = _ref3.y;
    var hasX = offsets.hasOwnProperty("x");
    var hasY = offsets.hasOwnProperty("y");
    var sideX = left;
    var sideY = top;
    var win = window;
    if (adaptive) {
      var offsetParent = getOffsetParent(popper2);
      var heightProp = "clientHeight";
      var widthProp = "clientWidth";
      if (offsetParent === getWindow(popper2)) {
        offsetParent = getDocumentElement(popper2);
        if (getComputedStyle2(offsetParent).position !== "static" && position2 === "absolute") {
          heightProp = "scrollHeight";
          widthProp = "scrollWidth";
        }
      }
      offsetParent = offsetParent;
      if (placement === top || (placement === left || placement === right) && variation === end) {
        sideY = bottom;
        var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (
          // $FlowFixMe[prop-missing]
          offsetParent[heightProp]
        );
        y -= offsetY - popperRect.height;
        y *= gpuAcceleration ? 1 : -1;
      }
      if (placement === left || (placement === top || placement === bottom) && variation === end) {
        sideX = right;
        var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (
          // $FlowFixMe[prop-missing]
          offsetParent[widthProp]
        );
        x -= offsetX - popperRect.width;
        x *= gpuAcceleration ? 1 : -1;
      }
    }
    var commonStyles = Object.assign({
      position: position2
    }, adaptive && unsetSides);
    var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
      x,
      y
    }, getWindow(popper2)) : {
      x,
      y
    };
    x = _ref4.x;
    y = _ref4.y;
    if (gpuAcceleration) {
      var _Object$assign;
      return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
    }
    return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
  }
  function computeStyles(_ref5) {
    var state = _ref5.state, options2 = _ref5.options;
    var _options$gpuAccelerat = options2.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options2.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options2.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
    var commonStyles = {
      placement: getBasePlacement(state.placement),
      variation: getVariation(state.placement),
      popper: state.elements.popper,
      popperRect: state.rects.popper,
      gpuAcceleration,
      isFixed: state.options.strategy === "fixed"
    };
    if (state.modifiersData.popperOffsets != null) {
      state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
        offsets: state.modifiersData.popperOffsets,
        position: state.options.strategy,
        adaptive,
        roundOffsets
      })));
    }
    if (state.modifiersData.arrow != null) {
      state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
        offsets: state.modifiersData.arrow,
        position: "absolute",
        adaptive: false,
        roundOffsets
      })));
    }
    state.attributes.popper = Object.assign({}, state.attributes.popper, {
      "data-popper-placement": state.placement
    });
  }
  var computeStyles_default = {
    name: "computeStyles",
    enabled: true,
    phase: "beforeWrite",
    fn: computeStyles,
    data: {}
  };

  // node_modules/@popperjs/core/lib/modifiers/eventListeners.js
  var passive = {
    passive: true
  };
  function effect3(_ref2) {
    var state = _ref2.state, instance = _ref2.instance, options2 = _ref2.options;
    var _options$scroll = options2.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options2.resize, resize = _options$resize === void 0 ? true : _options$resize;
    var window2 = getWindow(state.elements.popper);
    var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.addEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.addEventListener("resize", instance.update, passive);
    }
    return function() {
      if (scroll) {
        scrollParents.forEach(function(scrollParent) {
          scrollParent.removeEventListener("scroll", instance.update, passive);
        });
      }
      if (resize) {
        window2.removeEventListener("resize", instance.update, passive);
      }
    };
  }
  var eventListeners_default = {
    name: "eventListeners",
    enabled: true,
    phase: "write",
    fn: function fn() {
    },
    effect: effect3,
    data: {}
  };

  // node_modules/@popperjs/core/lib/utils/getOppositePlacement.js
  var hash = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
  };
  function getOppositePlacement(placement) {
    return placement.replace(/left|right|bottom|top/g, function(matched) {
      return hash[matched];
    });
  }

  // node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js
  var hash2 = {
    start: "end",
    end: "start"
  };
  function getOppositeVariationPlacement(placement) {
    return placement.replace(/start|end/g, function(matched) {
      return hash2[matched];
    });
  }

  // node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js
  function getWindowScroll(node2) {
    var win = getWindow(node2);
    var scrollLeft = win.pageXOffset;
    var scrollTop = win.pageYOffset;
    return {
      scrollLeft,
      scrollTop
    };
  }

  // node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js
  function getWindowScrollBarX(element) {
    return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
  }

  // node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js
  function getViewportRect(element, strategy) {
    var win = getWindow(element);
    var html = getDocumentElement(element);
    var visualViewport = win.visualViewport;
    var width2 = html.clientWidth;
    var height = html.clientHeight;
    var x = 0;
    var y = 0;
    if (visualViewport) {
      width2 = visualViewport.width;
      height = visualViewport.height;
      var layoutViewport = isLayoutViewport();
      if (layoutViewport || !layoutViewport && strategy === "fixed") {
        x = visualViewport.offsetLeft;
        y = visualViewport.offsetTop;
      }
    }
    return {
      width: width2,
      height,
      x: x + getWindowScrollBarX(element),
      y
    };
  }

  // node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js
  function getDocumentRect(element) {
    var _element$ownerDocumen;
    var html = getDocumentElement(element);
    var winScroll = getWindowScroll(element);
    var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
    var width2 = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
    var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
    var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
    var y = -winScroll.scrollTop;
    if (getComputedStyle2(body || html).direction === "rtl") {
      x += max(html.clientWidth, body ? body.clientWidth : 0) - width2;
    }
    return {
      width: width2,
      height,
      x,
      y
    };
  }

  // node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js
  function isScrollParent(element) {
    var _getComputedStyle = getComputedStyle2(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
    return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
  }

  // node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js
  function getScrollParent(node2) {
    if (["html", "body", "#document"].indexOf(getNodeName(node2)) >= 0) {
      return node2.ownerDocument.body;
    }
    if (isHTMLElement(node2) && isScrollParent(node2)) {
      return node2;
    }
    return getScrollParent(getParentNode(node2));
  }

  // node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js
  function listScrollParents(element, list) {
    var _element$ownerDocumen;
    if (list === void 0) {
      list = [];
    }
    var scrollParent = getScrollParent(element);
    var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
    var win = getWindow(scrollParent);
    var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
    var updatedList = list.concat(target);
    return isBody ? updatedList : (
      // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
      updatedList.concat(listScrollParents(getParentNode(target)))
    );
  }

  // node_modules/@popperjs/core/lib/utils/rectToClientRect.js
  function rectToClientRect(rect) {
    return Object.assign({}, rect, {
      left: rect.x,
      top: rect.y,
      right: rect.x + rect.width,
      bottom: rect.y + rect.height
    });
  }

  // node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js
  function getInnerBoundingClientRect(element, strategy) {
    var rect = getBoundingClientRect(element, false, strategy === "fixed");
    rect.top = rect.top + element.clientTop;
    rect.left = rect.left + element.clientLeft;
    rect.bottom = rect.top + element.clientHeight;
    rect.right = rect.left + element.clientWidth;
    rect.width = element.clientWidth;
    rect.height = element.clientHeight;
    rect.x = rect.left;
    rect.y = rect.top;
    return rect;
  }
  function getClientRectFromMixedType(element, clippingParent, strategy) {
    return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
  }
  function getClippingParents(element) {
    var clippingParents2 = listScrollParents(getParentNode(element));
    var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle2(element).position) >= 0;
    var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
    if (!isElement(clipperElement)) {
      return [];
    }
    return clippingParents2.filter(function(clippingParent) {
      return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
    });
  }
  function getClippingRect(element, boundary, rootBoundary, strategy) {
    var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
    var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
    var firstClippingParent = clippingParents2[0];
    var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
      var rect = getClientRectFromMixedType(element, clippingParent, strategy);
      accRect.top = max(rect.top, accRect.top);
      accRect.right = min(rect.right, accRect.right);
      accRect.bottom = min(rect.bottom, accRect.bottom);
      accRect.left = max(rect.left, accRect.left);
      return accRect;
    }, getClientRectFromMixedType(element, firstClippingParent, strategy));
    clippingRect.width = clippingRect.right - clippingRect.left;
    clippingRect.height = clippingRect.bottom - clippingRect.top;
    clippingRect.x = clippingRect.left;
    clippingRect.y = clippingRect.top;
    return clippingRect;
  }

  // node_modules/@popperjs/core/lib/utils/computeOffsets.js
  function computeOffsets(_ref2) {
    var reference2 = _ref2.reference, element = _ref2.element, placement = _ref2.placement;
    var basePlacement = placement ? getBasePlacement(placement) : null;
    var variation = placement ? getVariation(placement) : null;
    var commonX = reference2.x + reference2.width / 2 - element.width / 2;
    var commonY = reference2.y + reference2.height / 2 - element.height / 2;
    var offsets;
    switch (basePlacement) {
      case top:
        offsets = {
          x: commonX,
          y: reference2.y - element.height
        };
        break;
      case bottom:
        offsets = {
          x: commonX,
          y: reference2.y + reference2.height
        };
        break;
      case right:
        offsets = {
          x: reference2.x + reference2.width,
          y: commonY
        };
        break;
      case left:
        offsets = {
          x: reference2.x - element.width,
          y: commonY
        };
        break;
      default:
        offsets = {
          x: reference2.x,
          y: reference2.y
        };
    }
    var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
    if (mainAxis != null) {
      var len = mainAxis === "y" ? "height" : "width";
      switch (variation) {
        case start:
          offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
          break;
        case end:
          offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
          break;
        default:
      }
    }
    return offsets;
  }

  // node_modules/@popperjs/core/lib/utils/detectOverflow.js
  function detectOverflow(state, options2) {
    if (options2 === void 0) {
      options2 = {};
    }
    var _options = options2, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
    var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
    var altContext = elementContext === popper ? reference : popper;
    var popperRect = state.rects.popper;
    var element = state.elements[altBoundary ? altContext : elementContext];
    var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
    var referenceClientRect = getBoundingClientRect(state.elements.reference);
    var popperOffsets2 = computeOffsets({
      reference: referenceClientRect,
      element: popperRect,
      strategy: "absolute",
      placement
    });
    var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
    var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
    var overflowOffsets = {
      top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
      bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
      left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
      right: elementClientRect.right - clippingClientRect.right + paddingObject.right
    };
    var offsetData = state.modifiersData.offset;
    if (elementContext === popper && offsetData) {
      var offset3 = offsetData[placement];
      Object.keys(overflowOffsets).forEach(function(key) {
        var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
        var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
        overflowOffsets[key] += offset3[axis] * multiply;
      });
    }
    return overflowOffsets;
  }

  // node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js
  function computeAutoPlacement(state, options2) {
    if (options2 === void 0) {
      options2 = {};
    }
    var _options = options2, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
    var variation = getVariation(placement);
    var placements2 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
      return getVariation(placement2) === variation;
    }) : basePlacements;
    var allowedPlacements = placements2.filter(function(placement2) {
      return allowedAutoPlacements.indexOf(placement2) >= 0;
    });
    if (allowedPlacements.length === 0) {
      allowedPlacements = placements2;
    }
    var overflows = allowedPlacements.reduce(function(acc, placement2) {
      acc[placement2] = detectOverflow(state, {
        placement: placement2,
        boundary,
        rootBoundary,
        padding
      })[getBasePlacement(placement2)];
      return acc;
    }, {});
    return Object.keys(overflows).sort(function(a, b) {
      return overflows[a] - overflows[b];
    });
  }

  // node_modules/@popperjs/core/lib/modifiers/flip.js
  function getExpandedFallbackPlacements(placement) {
    if (getBasePlacement(placement) === auto) {
      return [];
    }
    var oppositePlacement = getOppositePlacement(placement);
    return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
  }
  function flip(_ref2) {
    var state = _ref2.state, options2 = _ref2.options, name = _ref2.name;
    if (state.modifiersData[name]._skip) {
      return;
    }
    var _options$mainAxis = options2.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options2.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options2.fallbackPlacements, padding = options2.padding, boundary = options2.boundary, rootBoundary = options2.rootBoundary, altBoundary = options2.altBoundary, _options$flipVariatio = options2.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options2.allowedAutoPlacements;
    var preferredPlacement = state.options.placement;
    var basePlacement = getBasePlacement(preferredPlacement);
    var isBasePlacement = basePlacement === preferredPlacement;
    var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
    var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
      return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
        placement: placement2,
        boundary,
        rootBoundary,
        padding,
        flipVariations,
        allowedAutoPlacements
      }) : placement2);
    }, []);
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var checksMap = /* @__PURE__ */ new Map();
    var makeFallbackChecks = true;
    var firstFittingPlacement = placements2[0];
    for (var i = 0; i < placements2.length; i++) {
      var placement = placements2[i];
      var _basePlacement = getBasePlacement(placement);
      var isStartVariation = getVariation(placement) === start;
      var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
      var len = isVertical ? "width" : "height";
      var overflow = detectOverflow(state, {
        placement,
        boundary,
        rootBoundary,
        altBoundary,
        padding
      });
      var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
      if (referenceRect[len] > popperRect[len]) {
        mainVariationSide = getOppositePlacement(mainVariationSide);
      }
      var altVariationSide = getOppositePlacement(mainVariationSide);
      var checks = [];
      if (checkMainAxis) {
        checks.push(overflow[_basePlacement] <= 0);
      }
      if (checkAltAxis) {
        checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
      }
      if (checks.every(function(check2) {
        return check2;
      })) {
        firstFittingPlacement = placement;
        makeFallbackChecks = false;
        break;
      }
      checksMap.set(placement, checks);
    }
    if (makeFallbackChecks) {
      var numberOfChecks = flipVariations ? 3 : 1;
      var _loop = function _loop2(_i2) {
        var fittingPlacement = placements2.find(function(placement2) {
          var checks2 = checksMap.get(placement2);
          if (checks2) {
            return checks2.slice(0, _i2).every(function(check2) {
              return check2;
            });
          }
        });
        if (fittingPlacement) {
          firstFittingPlacement = fittingPlacement;
          return "break";
        }
      };
      for (var _i = numberOfChecks; _i > 0; _i--) {
        var _ret = _loop(_i);
        if (_ret === "break") break;
      }
    }
    if (state.placement !== firstFittingPlacement) {
      state.modifiersData[name]._skip = true;
      state.placement = firstFittingPlacement;
      state.reset = true;
    }
  }
  var flip_default = {
    name: "flip",
    enabled: true,
    phase: "main",
    fn: flip,
    requiresIfExists: ["offset"],
    data: {
      _skip: false
    }
  };

  // node_modules/@popperjs/core/lib/modifiers/hide.js
  function getSideOffsets(overflow, rect, preventedOffsets) {
    if (preventedOffsets === void 0) {
      preventedOffsets = {
        x: 0,
        y: 0
      };
    }
    return {
      top: overflow.top - rect.height - preventedOffsets.y,
      right: overflow.right - rect.width + preventedOffsets.x,
      bottom: overflow.bottom - rect.height + preventedOffsets.y,
      left: overflow.left - rect.width - preventedOffsets.x
    };
  }
  function isAnySideFullyClipped(overflow) {
    return [top, right, bottom, left].some(function(side) {
      return overflow[side] >= 0;
    });
  }
  function hide(_ref2) {
    var state = _ref2.state, name = _ref2.name;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var preventedOffsets = state.modifiersData.preventOverflow;
    var referenceOverflow = detectOverflow(state, {
      elementContext: "reference"
    });
    var popperAltOverflow = detectOverflow(state, {
      altBoundary: true
    });
    var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
    var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
    var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
    var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
    state.modifiersData[name] = {
      referenceClippingOffsets,
      popperEscapeOffsets,
      isReferenceHidden,
      hasPopperEscaped
    };
    state.attributes.popper = Object.assign({}, state.attributes.popper, {
      "data-popper-reference-hidden": isReferenceHidden,
      "data-popper-escaped": hasPopperEscaped
    });
  }
  var hide_default = {
    name: "hide",
    enabled: true,
    phase: "main",
    requiresIfExists: ["preventOverflow"],
    fn: hide
  };

  // node_modules/@popperjs/core/lib/modifiers/offset.js
  function distanceAndSkiddingToXY(placement, rects, offset3) {
    var basePlacement = getBasePlacement(placement);
    var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
    var _ref2 = typeof offset3 === "function" ? offset3(Object.assign({}, rects, {
      placement
    })) : offset3, skidding = _ref2[0], distance = _ref2[1];
    skidding = skidding || 0;
    distance = (distance || 0) * invertDistance;
    return [left, right].indexOf(basePlacement) >= 0 ? {
      x: distance,
      y: skidding
    } : {
      x: skidding,
      y: distance
    };
  }
  function offset(_ref2) {
    var state = _ref2.state, options2 = _ref2.options, name = _ref2.name;
    var _options$offset = options2.offset, offset3 = _options$offset === void 0 ? [0, 0] : _options$offset;
    var data = placements.reduce(function(acc, placement) {
      acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset3);
      return acc;
    }, {});
    var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;
    if (state.modifiersData.popperOffsets != null) {
      state.modifiersData.popperOffsets.x += x;
      state.modifiersData.popperOffsets.y += y;
    }
    state.modifiersData[name] = data;
  }
  var offset_default = {
    name: "offset",
    enabled: true,
    phase: "main",
    requires: ["popperOffsets"],
    fn: offset
  };

  // node_modules/@popperjs/core/lib/modifiers/popperOffsets.js
  function popperOffsets(_ref2) {
    var state = _ref2.state, name = _ref2.name;
    state.modifiersData[name] = computeOffsets({
      reference: state.rects.reference,
      element: state.rects.popper,
      strategy: "absolute",
      placement: state.placement
    });
  }
  var popperOffsets_default = {
    name: "popperOffsets",
    enabled: true,
    phase: "read",
    fn: popperOffsets,
    data: {}
  };

  // node_modules/@popperjs/core/lib/utils/getAltAxis.js
  function getAltAxis(axis) {
    return axis === "x" ? "y" : "x";
  }

  // node_modules/@popperjs/core/lib/modifiers/preventOverflow.js
  function preventOverflow(_ref2) {
    var state = _ref2.state, options2 = _ref2.options, name = _ref2.name;
    var _options$mainAxis = options2.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options2.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options2.boundary, rootBoundary = options2.rootBoundary, altBoundary = options2.altBoundary, padding = options2.padding, _options$tether = options2.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options2.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
    var overflow = detectOverflow(state, {
      boundary,
      rootBoundary,
      padding,
      altBoundary
    });
    var basePlacement = getBasePlacement(state.placement);
    var variation = getVariation(state.placement);
    var isBasePlacement = !variation;
    var mainAxis = getMainAxisFromPlacement(basePlacement);
    var altAxis = getAltAxis(mainAxis);
    var popperOffsets2 = state.modifiersData.popperOffsets;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
      placement: state.placement
    })) : tetherOffset;
    var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
      mainAxis: tetherOffsetValue,
      altAxis: tetherOffsetValue
    } : Object.assign({
      mainAxis: 0,
      altAxis: 0
    }, tetherOffsetValue);
    var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
    var data = {
      x: 0,
      y: 0
    };
    if (!popperOffsets2) {
      return;
    }
    if (checkMainAxis) {
      var _offsetModifierState$;
      var mainSide = mainAxis === "y" ? top : left;
      var altSide = mainAxis === "y" ? bottom : right;
      var len = mainAxis === "y" ? "height" : "width";
      var offset3 = popperOffsets2[mainAxis];
      var min3 = offset3 + overflow[mainSide];
      var max3 = offset3 - overflow[altSide];
      var additive = tether ? -popperRect[len] / 2 : 0;
      var minLen = variation === start ? referenceRect[len] : popperRect[len];
      var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
      var arrowElement = state.elements.arrow;
      var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
        width: 0,
        height: 0
      };
      var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
      var arrowPaddingMin = arrowPaddingObject[mainSide];
      var arrowPaddingMax = arrowPaddingObject[altSide];
      var arrowLen = within(0, referenceRect[len], arrowRect[len]);
      var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
      var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
      var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
      var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
      var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
      var tetherMin = offset3 + minOffset - offsetModifierValue - clientOffset;
      var tetherMax = offset3 + maxOffset - offsetModifierValue;
      var preventedOffset = within(tether ? min(min3, tetherMin) : min3, offset3, tether ? max(max3, tetherMax) : max3);
      popperOffsets2[mainAxis] = preventedOffset;
      data[mainAxis] = preventedOffset - offset3;
    }
    if (checkAltAxis) {
      var _offsetModifierState$2;
      var _mainSide = mainAxis === "x" ? top : left;
      var _altSide = mainAxis === "x" ? bottom : right;
      var _offset = popperOffsets2[altAxis];
      var _len = altAxis === "y" ? "height" : "width";
      var _min = _offset + overflow[_mainSide];
      var _max = _offset - overflow[_altSide];
      var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
      var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
      var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
      var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
      var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
      popperOffsets2[altAxis] = _preventedOffset;
      data[altAxis] = _preventedOffset - _offset;
    }
    state.modifiersData[name] = data;
  }
  var preventOverflow_default = {
    name: "preventOverflow",
    enabled: true,
    phase: "main",
    fn: preventOverflow,
    requiresIfExists: ["offset"]
  };

  // node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js
  function getHTMLElementScroll(element) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }

  // node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js
  function getNodeScroll(node2) {
    if (node2 === getWindow(node2) || !isHTMLElement(node2)) {
      return getWindowScroll(node2);
    } else {
      return getHTMLElementScroll(node2);
    }
  }

  // node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js
  function isElementScaled(element) {
    var rect = element.getBoundingClientRect();
    var scaleX = round(rect.width) / element.offsetWidth || 1;
    var scaleY = round(rect.height) / element.offsetHeight || 1;
    return scaleX !== 1 || scaleY !== 1;
  }
  function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
    if (isFixed === void 0) {
      isFixed = false;
    }
    var isOffsetParentAnElement = isHTMLElement(offsetParent);
    var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
    var documentElement = getDocumentElement(offsetParent);
    var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
    var scroll = {
      scrollLeft: 0,
      scrollTop: 0
    };
    var offsets = {
      x: 0,
      y: 0
    };
    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
      if (getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
      isScrollParent(documentElement)) {
        scroll = getNodeScroll(offsetParent);
      }
      if (isHTMLElement(offsetParent)) {
        offsets = getBoundingClientRect(offsetParent, true);
        offsets.x += offsetParent.clientLeft;
        offsets.y += offsetParent.clientTop;
      } else if (documentElement) {
        offsets.x = getWindowScrollBarX(documentElement);
      }
    }
    return {
      x: rect.left + scroll.scrollLeft - offsets.x,
      y: rect.top + scroll.scrollTop - offsets.y,
      width: rect.width,
      height: rect.height
    };
  }

  // node_modules/@popperjs/core/lib/utils/orderModifiers.js
  function order(modifiers) {
    var map = /* @__PURE__ */ new Map();
    var visited = /* @__PURE__ */ new Set();
    var result2 = [];
    modifiers.forEach(function(modifier) {
      map.set(modifier.name, modifier);
    });
    function sort(modifier) {
      visited.add(modifier.name);
      var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
      requires.forEach(function(dep2) {
        if (!visited.has(dep2)) {
          var depModifier = map.get(dep2);
          if (depModifier) {
            sort(depModifier);
          }
        }
      });
      result2.push(modifier);
    }
    modifiers.forEach(function(modifier) {
      if (!visited.has(modifier.name)) {
        sort(modifier);
      }
    });
    return result2;
  }
  function orderModifiers(modifiers) {
    var orderedModifiers = order(modifiers);
    return modifierPhases.reduce(function(acc, phase) {
      return acc.concat(orderedModifiers.filter(function(modifier) {
        return modifier.phase === phase;
      }));
    }, []);
  }

  // node_modules/@popperjs/core/lib/utils/debounce.js
  function debounce(fn2) {
    var pending;
    return function() {
      if (!pending) {
        pending = new Promise(function(resolve) {
          Promise.resolve().then(function() {
            pending = void 0;
            resolve(fn2());
          });
        });
      }
      return pending;
    };
  }

  // node_modules/@popperjs/core/lib/utils/mergeByName.js
  function mergeByName(modifiers) {
    var merged = modifiers.reduce(function(merged2, current) {
      var existing = merged2[current.name];
      merged2[current.name] = existing ? Object.assign({}, existing, current, {
        options: Object.assign({}, existing.options, current.options),
        data: Object.assign({}, existing.data, current.data)
      }) : current;
      return merged2;
    }, {});
    return Object.keys(merged).map(function(key) {
      return merged[key];
    });
  }

  // node_modules/@popperjs/core/lib/createPopper.js
  var DEFAULT_OPTIONS = {
    placement: "bottom",
    modifiers: [],
    strategy: "absolute"
  };
  function areValidElements() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return !args.some(function(element) {
      return !(element && typeof element.getBoundingClientRect === "function");
    });
  }
  function popperGenerator(generatorOptions) {
    if (generatorOptions === void 0) {
      generatorOptions = {};
    }
    var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions4 = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
    return function createPopper2(reference2, popper2, options2) {
      if (options2 === void 0) {
        options2 = defaultOptions4;
      }
      var state = {
        placement: "bottom",
        orderedModifiers: [],
        options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions4),
        modifiersData: {},
        elements: {
          reference: reference2,
          popper: popper2
        },
        attributes: {},
        styles: {}
      };
      var effectCleanupFns = [];
      var isDestroyed = false;
      var instance = {
        state,
        setOptions: function setOptions(setOptionsAction) {
          var options3 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
          cleanupModifierEffects();
          state.options = Object.assign({}, defaultOptions4, state.options, options3);
          state.scrollParents = {
            reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
            popper: listScrollParents(popper2)
          };
          var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
          state.orderedModifiers = orderedModifiers.filter(function(m) {
            return m.enabled;
          });
          runModifierEffects();
          return instance.update();
        },
        // Sync update – it will always be executed, even if not necessary. This
        // is useful for low frequency updates where sync behavior simplifies the
        // logic.
        // For high frequency updates (e.g. `resize` and `scroll` events), always
        // prefer the async Popper#update method
        forceUpdate: function forceUpdate() {
          if (isDestroyed) {
            return;
          }
          var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
          if (!areValidElements(reference3, popper3)) {
            return;
          }
          state.rects = {
            reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
            popper: getLayoutRect(popper3)
          };
          state.reset = false;
          state.placement = state.options.placement;
          state.orderedModifiers.forEach(function(modifier) {
            return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
          });
          for (var index2 = 0; index2 < state.orderedModifiers.length; index2++) {
            if (state.reset === true) {
              state.reset = false;
              index2 = -1;
              continue;
            }
            var _state$orderedModifie = state.orderedModifiers[index2], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
            if (typeof fn2 === "function") {
              state = fn2({
                state,
                options: _options,
                name,
                instance
              }) || state;
            }
          }
        },
        // Async and optimistically optimized update – it will not be executed if
        // not necessary (debounced to run at most once-per-tick)
        update: debounce(function() {
          return new Promise(function(resolve) {
            instance.forceUpdate();
            resolve(state);
          });
        }),
        destroy: function destroy() {
          cleanupModifierEffects();
          isDestroyed = true;
        }
      };
      if (!areValidElements(reference2, popper2)) {
        return instance;
      }
      instance.setOptions(options2).then(function(state2) {
        if (!isDestroyed && options2.onFirstUpdate) {
          options2.onFirstUpdate(state2);
        }
      });
      function runModifierEffects() {
        state.orderedModifiers.forEach(function(_ref2) {
          var name = _ref2.name, _ref$options = _ref2.options, options3 = _ref$options === void 0 ? {} : _ref$options, effect4 = _ref2.effect;
          if (typeof effect4 === "function") {
            var cleanupFn = effect4({
              state,
              name,
              instance,
              options: options3
            });
            var noopFn = function noopFn2() {
            };
            effectCleanupFns.push(cleanupFn || noopFn);
          }
        });
      }
      function cleanupModifierEffects() {
        effectCleanupFns.forEach(function(fn2) {
          return fn2();
        });
        effectCleanupFns = [];
      }
      return instance;
    };
  }

  // node_modules/@popperjs/core/lib/popper.js
  var defaultModifiers = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default, offset_default, flip_default, preventOverflow_default, arrow_default, hide_default];
  var createPopper = /* @__PURE__ */ popperGenerator({
    defaultModifiers
  });

  // node_modules/react-popper/lib/esm/usePopper.js
  var import_react_fast_compare = __toESM(require_react_fast_compare());
  var EMPTY_MODIFIERS = [];
  var usePopper = function usePopper2(referenceElement, popperElement, options2) {
    if (options2 === void 0) {
      options2 = {};
    }
    var prevOptions = React13.useRef(null);
    var optionsWithDefaults = {
      onFirstUpdate: options2.onFirstUpdate,
      placement: options2.placement || "bottom",
      strategy: options2.strategy || "absolute",
      modifiers: options2.modifiers || EMPTY_MODIFIERS
    };
    var _React$useState = React13.useState({
      styles: {
        popper: {
          position: optionsWithDefaults.strategy,
          left: "0",
          top: "0"
        },
        arrow: {
          position: "absolute"
        }
      },
      attributes: {}
    }), state = _React$useState[0], setState = _React$useState[1];
    var updateStateModifier = React13.useMemo(function() {
      return {
        name: "updateState",
        enabled: true,
        phase: "write",
        fn: function fn2(_ref2) {
          var state2 = _ref2.state;
          var elements = Object.keys(state2.elements);
          ReactDOM.flushSync(function() {
            setState({
              styles: fromEntries(elements.map(function(element) {
                return [element, state2.styles[element] || {}];
              })),
              attributes: fromEntries(elements.map(function(element) {
                return [element, state2.attributes[element]];
              }))
            });
          });
        },
        requires: ["computeStyles"]
      };
    }, []);
    var popperOptions = React13.useMemo(function() {
      var newOptions = {
        onFirstUpdate: optionsWithDefaults.onFirstUpdate,
        placement: optionsWithDefaults.placement,
        strategy: optionsWithDefaults.strategy,
        modifiers: [].concat(optionsWithDefaults.modifiers, [updateStateModifier, {
          name: "applyStyles",
          enabled: false
        }])
      };
      if ((0, import_react_fast_compare.default)(prevOptions.current, newOptions)) {
        return prevOptions.current || newOptions;
      } else {
        prevOptions.current = newOptions;
        return newOptions;
      }
    }, [optionsWithDefaults.onFirstUpdate, optionsWithDefaults.placement, optionsWithDefaults.strategy, optionsWithDefaults.modifiers, updateStateModifier]);
    var popperInstanceRef = React13.useRef();
    useIsomorphicLayoutEffect(function() {
      if (popperInstanceRef.current) {
        popperInstanceRef.current.setOptions(popperOptions);
      }
    }, [popperOptions]);
    useIsomorphicLayoutEffect(function() {
      if (referenceElement == null || popperElement == null) {
        return;
      }
      var createPopper2 = options2.createPopper || createPopper;
      var popperInstance = createPopper2(referenceElement, popperElement, popperOptions);
      popperInstanceRef.current = popperInstance;
      return function() {
        popperInstance.destroy();
        popperInstanceRef.current = null;
      };
    }, [referenceElement, popperElement, options2.createPopper]);
    return {
      state: popperInstanceRef.current ? popperInstanceRef.current.state : null,
      styles: state.styles,
      attributes: state.attributes,
      update: popperInstanceRef.current ? popperInstanceRef.current.update : null,
      forceUpdate: popperInstanceRef.current ? popperInstanceRef.current.forceUpdate : null
    };
  };

  // node_modules/react-popper/lib/esm/Popper.js
  var NOOP = function NOOP2() {
    return void 0;
  };
  var NOOP_PROMISE = function NOOP_PROMISE2() {
    return Promise.resolve(null);
  };
  var EMPTY_MODIFIERS2 = [];
  function Popper(_ref2) {
    var _ref$placement = _ref2.placement, placement = _ref$placement === void 0 ? "bottom" : _ref$placement, _ref$strategy = _ref2.strategy, strategy = _ref$strategy === void 0 ? "absolute" : _ref$strategy, _ref$modifiers = _ref2.modifiers, modifiers = _ref$modifiers === void 0 ? EMPTY_MODIFIERS2 : _ref$modifiers, referenceElement = _ref2.referenceElement, onFirstUpdate = _ref2.onFirstUpdate, innerRef = _ref2.innerRef, children = _ref2.children;
    var referenceNode = React14.useContext(ManagerReferenceNodeContext);
    var _React$useState = React14.useState(null), popperElement = _React$useState[0], setPopperElement = _React$useState[1];
    var _React$useState2 = React14.useState(null), arrowElement = _React$useState2[0], setArrowElement = _React$useState2[1];
    React14.useEffect(function() {
      setRef(innerRef, popperElement);
    }, [innerRef, popperElement]);
    var options2 = React14.useMemo(function() {
      return {
        placement,
        strategy,
        onFirstUpdate,
        modifiers: [].concat(modifiers, [{
          name: "arrow",
          enabled: arrowElement != null,
          options: {
            element: arrowElement
          }
        }])
      };
    }, [placement, strategy, onFirstUpdate, modifiers, arrowElement]);
    var _usePopper = usePopper(referenceElement || referenceNode, popperElement, options2), state = _usePopper.state, styles15 = _usePopper.styles, forceUpdate = _usePopper.forceUpdate, update = _usePopper.update;
    var childrenProps = React14.useMemo(function() {
      return {
        ref: setPopperElement,
        style: styles15.popper,
        placement: state ? state.placement : placement,
        hasPopperEscaped: state && state.modifiersData.hide ? state.modifiersData.hide.hasPopperEscaped : null,
        isReferenceHidden: state && state.modifiersData.hide ? state.modifiersData.hide.isReferenceHidden : null,
        arrowProps: {
          style: styles15.arrow,
          ref: setArrowElement
        },
        forceUpdate: forceUpdate || NOOP,
        update: update || NOOP_PROMISE
      };
    }, [setPopperElement, setArrowElement, placement, state, styles15, update, forceUpdate]);
    return unwrapArray(children)(childrenProps);
  }

  // node_modules/react-popper/lib/esm/Reference.js
  var React15 = __toESM(require_react());
  var import_warning = __toESM(require_warning());
  function Reference(_ref2) {
    var children = _ref2.children, innerRef = _ref2.innerRef;
    var setReferenceNode = React15.useContext(ManagerReferenceNodeSetterContext);
    var refHandler = React15.useCallback(function(node2) {
      setRef(innerRef, node2);
      safeInvoke(setReferenceNode, node2);
    }, [innerRef, setReferenceNode]);
    React15.useEffect(function() {
      return function() {
        return setRef(innerRef, null);
      };
    }, []);
    React15.useEffect(function() {
      (0, import_warning.default)(Boolean(setReferenceNode), "`Reference` should not be used outside of a `Manager` component.");
    }, [setReferenceNode]);
    return unwrapArray(children)({
      ref: refHandler
    });
  }

  // node_modules/@atlaskit/popper/dist/esm/max-size.js
  init_slicedToArray();
  function getMaxSizeModifiers(_ref2) {
    var viewportPadding2 = _ref2.viewportPadding;
    return [{
      /**
       * Performing DOM measurements in the 'read' phase,
       * which is the convention for popper modifiers
       */
      name: "maxSizeData",
      enabled: true,
      phase: "read",
      fn: function fn2(_ref22) {
        var state = _ref22.state, name = _ref22.name;
        if (!window.visualViewport) {
          return;
        }
        state.modifiersData[name] = {
          viewport: {
            width: window.visualViewport.width,
            height: window.visualViewport.height
          }
        };
      }
    }, {
      /**
       * Applying max size CSS
       */
      name: "maxSize",
      enabled: true,
      phase: "beforeWrite",
      requiresIfExists: ["offset", "preventOverflow", "flip"],
      fn: function fn2(_ref3) {
        var _data$viewport, _data$viewport2, _state$modifiersData$2, _state$modifiersData;
        var state = _ref3.state;
        var data = state.modifiersData.maxSizeData;
        if (typeof (data === null || data === void 0 || (_data$viewport = data.viewport) === null || _data$viewport === void 0 ? void 0 : _data$viewport.width) !== "number" || typeof (data === null || data === void 0 || (_data$viewport2 = data.viewport) === null || _data$viewport2 === void 0 ? void 0 : _data$viewport2.height) !== "number") {
          return;
        }
        var viewport2 = data.viewport;
        var _state$modifiersData$ = state.modifiersData.popperOffsets, popperOffsets2 = _state$modifiersData$ === void 0 ? {
          x: 0,
          y: 0
        } : _state$modifiersData$;
        var _state$placement$spli = state.placement.split("-"), _state$placement$spli2 = _slicedToArray(_state$placement$spli, 1), basePlacement = _state$placement$spli2[0];
        var placementOffset = (_state$modifiersData$2 = (_state$modifiersData = state.modifiersData) === null || _state$modifiersData === void 0 || (_state$modifiersData = _state$modifiersData.offset) === null || _state$modifiersData === void 0 ? void 0 : _state$modifiersData[state.placement]) !== null && _state$modifiersData$2 !== void 0 ? _state$modifiersData$2 : {
          x: 0,
          y: 0
        };
        var maxWidth = viewport2.width - 2 * viewportPadding2;
        var maxHeight = viewport2.height - 2 * viewportPadding2;
        if (basePlacement === "top") {
          maxHeight = state.rects.reference.y + // Viewport-relative position of reference element
          placementOffset.y - // Space between popper and reference
          viewportPadding2;
        }
        if (basePlacement === "bottom") {
          maxHeight = viewport2.height - popperOffsets2.y - // Viewport-relative position of popper
          viewportPadding2;
        }
        if (basePlacement === "left") {
          maxWidth = state.rects.reference.x + // Viewport-relative position of reference element
          placementOffset.x - // Space between popper and reference
          viewportPadding2;
        }
        if (basePlacement === "right") {
          maxWidth = viewport2.width - popperOffsets2.x - // Viewport-relative position of popper
          viewportPadding2;
        }
        state.styles.popper.maxWidth = "".concat(maxWidth, "px");
        state.styles.popper.maxHeight = "".concat(maxHeight, "px");
      }
    }];
  }

  // node_modules/@atlaskit/popper/dist/esm/popper.js
  var viewportPadding = 5;
  var constantModifiers = [{
    name: "flip",
    options: {
      flipVariations: false,
      padding: viewportPadding,
      boundary: "clippingParents",
      rootBoundary: "viewport"
    }
  }];
  function defaultChildrenFn() {
    return null;
  }
  var defaultOffset = [0, 8];
  function Popper2(_ref2) {
    var _ref$children = _ref2.children, children = _ref$children === void 0 ? defaultChildrenFn : _ref$children, _ref$offset = _ref2.offset, offset3 = _ref$offset === void 0 ? defaultOffset : _ref$offset, _ref$placement = _ref2.placement, placement = _ref$placement === void 0 ? "bottom-start" : _ref$placement, _ref$referenceElement = _ref2.referenceElement, referenceElement = _ref$referenceElement === void 0 ? void 0 : _ref$referenceElement, modifiers = _ref2.modifiers, _ref$strategy = _ref2.strategy, strategy = _ref$strategy === void 0 ? "fixed" : _ref$strategy, _ref$shouldFitViewpor = _ref2.shouldFitViewport, shouldFitViewport = _ref$shouldFitViewpor === void 0 ? false : _ref$shouldFitViewpor;
    var _offset = _slicedToArray(offset3, 2), offsetX = _offset[0], offsetY = _offset[1];
    var internalModifiers = (0, import_react27.useMemo)(function() {
      var preventOverflowModifier = {
        name: "preventOverflow",
        options: {
          padding: viewportPadding,
          rootBoundary: shouldFitViewport ? "viewport" : "document"
        }
      };
      var offsetModifier = {
        name: "offset",
        options: {
          offset: [offsetX, offsetY]
        }
      };
      var maxSizeModifiers = shouldFitViewport ? getMaxSizeModifiers({
        viewportPadding
      }) : [];
      return [].concat(constantModifiers, [preventOverflowModifier, offsetModifier], _toConsumableArray(maxSizeModifiers));
    }, [offsetX, offsetY, shouldFitViewport]);
    var mergedModifiers = (0, import_react27.useMemo)(function() {
      if (modifiers == null) {
        return internalModifiers;
      }
      return [].concat(_toConsumableArray(internalModifiers), _toConsumableArray(modifiers));
    }, [internalModifiers, modifiers]);
    return /* @__PURE__ */ import_react27.default.createElement(
      Popper,
      {
        modifiers: mergedModifiers,
        placement,
        strategy,
        referenceElement
      },
      children
    );
  }

  // node_modules/@atlaskit/portal/dist/esm/portal.js
  var import_react33 = __toESM(require_react());
  var import_platform_feature_flags3 = __toESM(require_cjs3());

  // node_modules/@atlaskit/portal/dist/esm/internal/components/internal-portal.js
  var import_react28 = __toESM(require_react());
  var import_react_dom = __toESM(require_react_dom());

  // node_modules/@atlaskit/portal/dist/esm/internal/constants.js
  var portalParentClassName = "atlaskit-portal-container";
  var portalParentSelector = "body > .atlaskit-portal-container";
  var portalClassName = "atlaskit-portal";

  // node_modules/@atlaskit/portal/dist/esm/internal/utils/portal-dom-utils.js
  var createContainer = function createContainer2(zIndex) {
    var container = document.createElement("div");
    container.className = portalClassName;
    container.style.zIndex = "".concat(zIndex);
    return container;
  };
  var getBody = function getBody2() {
    return document.body;
  };
  var getPortalParent = function getPortalParent2() {
    var parentElement = document.querySelector(portalParentSelector);
    if (!parentElement) {
      var _getBody;
      var parent = document.createElement("div");
      parent.className = portalParentClassName;
      parent.style.display = "flex";
      (_getBody = getBody()) === null || _getBody === void 0 || _getBody.appendChild(parent);
      return parent;
    }
    return parentElement;
  };
  var removePortalContainer = function removePortalContainer2(container) {
    getPortalParent().removeChild(container);
  };
  var appendPortalContainerIfNotAppended = function appendPortalContainerIfNotAppended2(container) {
    if (!container.parentElement) {
      getPortalParent().appendChild(container);
    }
  };
  var isDocumentDefined = function isDocumentDefined2() {
    return document !== void 0;
  };
  var createAtlaskitPortal = function createAtlaskitPortal2(zIndex) {
    if (isDocumentDefined()) {
      var atlaskitportal = document.createElement("div");
      atlaskitportal.className = portalClassName;
      atlaskitportal.style.zIndex = "".concat(zIndex);
      return atlaskitportal;
    }
  };
  var createPortalParent = function createPortalParent2() {
    if (isDocumentDefined()) {
      var parentElement = document.querySelector(portalParentSelector);
      if (!parentElement) {
        var _getBody2;
        var parent = document.createElement("div");
        parent.className = portalParentClassName;
        parent.style.display = "flex";
        (_getBody2 = getBody()) === null || _getBody2 === void 0 || _getBody2.appendChild(parent);
        return parent;
      }
      return parentElement;
    }
  };

  // node_modules/@atlaskit/portal/dist/esm/internal/components/internal-portal.js
  function InternalPortal(props) {
    var zIndex = props.zIndex, children = props.children;
    var container = (0, import_react28.useMemo)(function() {
      return createContainer(zIndex);
    }, [zIndex]);
    appendPortalContainerIfNotAppended(container);
    (0, import_react28.useEffect)(function() {
      return function() {
        removePortalContainer(container);
      };
    }, [container]);
    return /* @__PURE__ */ (0, import_react_dom.createPortal)(children, container);
  }

  // node_modules/@atlaskit/portal/dist/esm/internal/components/internal-portal-new.js
  init_slicedToArray();
  var import_react30 = __toESM(require_react());
  var import_react_dom2 = __toESM(require_react_dom());

  // node_modules/@atlaskit/portal/dist/esm/internal/hooks/use-isomorphic-layout-effect.js
  var import_react29 = __toESM(require_react());
  var useIsomorphicLayoutEffect2 = typeof window !== "undefined" ? import_react29.useLayoutEffect : import_react29.useEffect;

  // node_modules/@atlaskit/portal/dist/esm/internal/components/internal-portal-new.js
  function InternalPortalNew(props) {
    var zIndex = props.zIndex, children = props.children;
    var _useState = (0, import_react30.useState)(null), _useState2 = _slicedToArray(_useState, 2), atlaskitPortal = _useState2[0], setAtlaskitPortal = _useState2[1];
    useIsomorphicLayoutEffect2(function() {
      var tempPortalContainer = createAtlaskitPortal(zIndex);
      setAtlaskitPortal(tempPortalContainer);
      var portalParent = createPortalParent();
      if (!tempPortalContainer || !portalParent) {
        return;
      }
      portalParent.appendChild(tempPortalContainer);
      return function() {
        if (tempPortalContainer) {
          portalParent.removeChild(tempPortalContainer);
        }
        setAtlaskitPortal(null);
      };
    }, [zIndex]);
    var suspendedChildren = /* @__PURE__ */ import_react30.default.createElement(import_react30.Suspense, {
      fallback: null
    }, children);
    return atlaskitPortal ? /* @__PURE__ */ (0, import_react_dom2.createPortal)(suspendedChildren, atlaskitPortal) : null;
  }

  // node_modules/@atlaskit/portal/dist/esm/internal/hooks/use-is-subsequent-render.js
  init_slicedToArray();
  var import_react31 = __toESM(require_react());
  var useIsSubsequentRender = function useIsSubsequentRender2(mountStrategy) {
    var _useState = (0, import_react31.useState)(false), _useState2 = _slicedToArray(_useState, 2), isSubsequentRender = _useState2[0], setIsSubsequentRender = _useState2[1];
    var _useState3 = (0, import_react31.useState)(function() {
      return mountStrategy === "layoutEffect" ? useIsomorphicLayoutEffect2 : import_react31.useEffect;
    }), _useState4 = _slicedToArray(_useState3, 1), useMountEffect = _useState4[0];
    useMountEffect(function() {
      setIsSubsequentRender(true);
    }, []);
    return isSubsequentRender;
  };
  var use_is_subsequent_render_default = useIsSubsequentRender;

  // node_modules/@atlaskit/portal/dist/esm/internal/hooks/use-portal-event.js
  var import_react32 = __toESM(require_react());

  // node_modules/@atlaskit/portal/dist/esm/constants.js
  var PORTAL_MOUNT_EVENT = "akPortalMount";
  var PORTAL_UNMOUNT_EVENT = "akPortalUnmount";

  // node_modules/@atlaskit/portal/dist/esm/internal/utils/portal-custom-event.js
  var zIndexToName = {
    100: "card",
    200: "navigation",
    300: "dialog",
    400: "layer",
    500: "blanket",
    510: "modal",
    600: "flag",
    700: "spotlight",
    9999: "tooltip"
  };
  var getLayerName = function getLayerName2(zIndex) {
    return zIndexToName.hasOwnProperty(zIndex) ? zIndexToName[zIndex] : null;
  };
  var getEvent = function getEvent2(eventName, zIndex) {
    var detail = {
      layer: getLayerName(Number(zIndex)),
      zIndex
    };
    return new CustomEvent(eventName, {
      detail
    });
  };
  function firePortalEvent(eventName, zIndex) {
    var event = getEvent(eventName, zIndex);
    window.dispatchEvent(event);
  }

  // node_modules/@atlaskit/portal/dist/esm/internal/hooks/use-portal-event.js
  var useFirePortalEvent = function useFirePortalEvent2(zIndex) {
    var zIndexNumber = Number(zIndex);
    (0, import_react32.useEffect)(function() {
      firePortalEvent(PORTAL_MOUNT_EVENT, zIndexNumber);
      return function() {
        firePortalEvent(PORTAL_UNMOUNT_EVENT, zIndexNumber);
      };
    }, [zIndexNumber]);
  };
  var use_portal_event_default = useFirePortalEvent;

  // node_modules/@atlaskit/portal/dist/esm/portal.js
  function Portal(_ref2) {
    var _ref$zIndex = _ref2.zIndex, zIndex = _ref$zIndex === void 0 ? 0 : _ref$zIndex, children = _ref2.children, _ref$mountStrategy = _ref2.mountStrategy, mountStrategy = _ref$mountStrategy === void 0 ? "effect" : _ref$mountStrategy;
    var isSubsequentRender = use_is_subsequent_render_default(mountStrategy);
    use_portal_event_default(zIndex);
    return !(0, import_platform_feature_flags3.fg)("platform_design_system_team_portal_logic_r18_fix") ? isSubsequentRender ? /* @__PURE__ */ import_react33.default.createElement(InternalPortal, {
      zIndex
    }, children) : null : /* @__PURE__ */ import_react33.default.createElement(InternalPortalNew, {
      zIndex
    }, children);
  }

  // node_modules/@atlaskit/theme/dist/esm/colors.js
  var R50 = "#FFEBE6";
  var R500 = "#BF2600";
  var Y50 = "#FFFAE6";
  var Y500 = "#FF8B00";
  var G50 = "#E3FCEF";
  var G500 = "#006644";
  var B50 = "#DEEBFF";
  var B500 = "#0747A6";
  var P50 = "#EAE6FF";
  var P500 = "#403294";
  var N0 = "#FFFFFF";
  var N500 = "#42526E";
  var N800 = "#172B4D";
  var N100A = "rgba(9, 30, 66, 0.54)";

  // node_modules/@atlaskit/theme/dist/esm/constants.js
  var layers = {
    card: function card() {
      return 100;
    },
    navigation: function navigation() {
      return 200;
    },
    dialog: function dialog() {
      return 300;
    },
    layer: function layer() {
      return 400;
    },
    blanket: function blanket() {
      return 500;
    },
    modal: function modal() {
      return 510;
    },
    flag: function flag() {
      return 600;
    },
    spotlight: function spotlight() {
      return 700;
    },
    tooltip: function tooltip() {
      return 9999;
    }
  };

  // node_modules/@atlaskit/tooltip/dist/esm/internal/drag-manager.js
  var import_bind_event_listener2 = __toESM(require_dist());
  var registrations = /* @__PURE__ */ new Set();
  var cleanupEndEventListeners = null;
  function onDragStart() {
    if (cleanupEndEventListeners) {
      return;
    }
    cleanupEndEventListeners = (0, import_bind_event_listener2.bindAll)(window, [{
      type: "dragend",
      listener: onDragEnd
    }, {
      type: "pointerdown",
      listener: onDragEnd
    }, {
      type: "pointermove",
      listener: /* @__PURE__ */ (function() {
        var callCount = 0;
        return function listener() {
          if (callCount < 20) {
            callCount++;
            return;
          }
          onDragEnd();
        };
      })()
    }]);
    var clone = Array.from(registrations);
    clone.forEach(function(subscriber) {
      subscriber.onDragStart();
    });
  }
  function onDragEnd() {
    var _cleanupEndEventListe;
    (_cleanupEndEventListe = cleanupEndEventListeners) === null || _cleanupEndEventListe === void 0 || _cleanupEndEventListe();
    cleanupEndEventListeners = null;
    var clone = Array.from(registrations);
    clone.forEach(function(subscriber) {
      subscriber.onDragEnd();
    });
  }
  function bindStartEvents() {
    return (0, import_bind_event_listener2.bindAll)(window, [{
      type: "dragstart",
      listener: onDragStart
    }, {
      type: "dragenter",
      listener: onDragStart
    }]);
  }
  var cleanupStartEventListeners = null;
  function register(registration) {
    if (!cleanupStartEventListeners) {
      cleanupStartEventListeners = bindStartEvents();
    }
    registrations.add(registration);
    registration.onRegister({
      isDragging: cleanupEndEventListeners !== null
    });
    return function unregister() {
      registrations.delete(registration);
      if (registrations.size === 0) {
        var _cleanupStartEventLis;
        (_cleanupStartEventLis = cleanupStartEventListeners) === null || _cleanupStartEventLis === void 0 || _cleanupStartEventLis();
        cleanupStartEventListeners = null;
      }
    };
  }

  // node_modules/@atlaskit/tooltip/dist/esm/internal/shared-schedule.js
  var delayId = null;
  function clearScheduled() {
    if (delayId != null) {
      window.clearTimeout(delayId);
      delayId = null;
    }
  }
  function scheduleTimeout(fn2, delay) {
    clearScheduled();
    delayId = window.setTimeout(function() {
      delayId = null;
      fn2();
    }, delay);
  }

  // node_modules/@atlaskit/tooltip/dist/esm/internal/tooltip-manager.js
  var active = null;
  function show(entry) {
    var phase = "waiting-to-show";
    function isActive() {
      return Boolean(active && active.entry === entry);
    }
    function cleanup() {
      if (isActive()) {
        clearScheduled();
        active = null;
      }
    }
    function done() {
      if (isActive()) {
        entry.done();
      }
      phase = "done";
      cleanup();
    }
    function immediatelyHideAndDone() {
      if (isActive()) {
        entry.hide({
          isImmediate: true
        });
      }
      done();
    }
    function keep() {
      if (!isActive()) {
        return;
      }
      if (phase === "waiting-to-hide") {
        phase = "shown";
        clearScheduled();
        return;
      }
      if (phase === "hide-animating") {
        phase = "shown";
        clearScheduled();
        entry.show({
          isImmediate: false
        });
        return;
      }
    }
    function requestHide(_ref2) {
      var isImmediate = _ref2.isImmediate;
      if (!isActive()) {
        return;
      }
      if (phase === "waiting-to-show") {
        immediatelyHideAndDone();
        return;
      }
      if (phase === "waiting-to-hide") {
        return;
      }
      if (isImmediate) {
        immediatelyHideAndDone();
        return;
      }
      phase = "waiting-to-hide";
      scheduleTimeout(function() {
        phase = "hide-animating";
        entry.hide({
          isImmediate: false
        });
      }, entry.delay);
    }
    function finishHideAnimation() {
      if (isActive() && phase === "hide-animating") {
        done();
      }
    }
    function isVisible() {
      return phase === "shown" || phase === "waiting-to-hide" || phase === "hide-animating";
    }
    function getInitialMouse() {
      if (entry.source.type === "mouse") {
        return entry.source.mouse;
      }
      return null;
    }
    function start3() {
      var showImmediately = Boolean(active && active.isVisible());
      if (active) {
        clearScheduled();
        active.entry.hide({
          isImmediate: true
        });
        active.entry.done();
        active = null;
      }
      active = {
        entry,
        isVisible
      };
      function show2() {
        phase = "shown";
        entry.show({
          isImmediate: showImmediately
        });
      }
      if (showImmediately) {
        show2();
        return;
      }
      phase = "waiting-to-show";
      scheduleTimeout(show2, entry.delay);
    }
    start3();
    var result2 = {
      keep,
      abort: cleanup,
      isActive,
      requestHide,
      finishHideAnimation,
      mousePosition: getInitialMouse()
    };
    return result2;
  }

  // node_modules/@atlaskit/ds-lib/dist/esm/utils/use-id.js
  init_typeof();
  var import_react35 = __toESM(require_react());

  // node_modules/react-uid/dist/es2015/context.js
  var React19 = __toESM(require_react());

  // node_modules/react-uid/dist/es2015/uid.js
  var generateUID = function() {
    var counter2 = 1;
    var map = /* @__PURE__ */ new WeakMap();
    var uid2 = function(item, index2) {
      if (typeof item === "number" || typeof item === "string") {
        return index2 ? "idx-".concat(index2) : "val-".concat(item);
      }
      if (!map.has(item)) {
        map.set(item, counter2++);
        return uid2(item);
      }
      return "uid" + map.get(item);
    };
    return uid2;
  };
  var uid = generateUID();

  // node_modules/react-uid/dist/es2015/context.js
  var createSource = function(prefix3) {
    if (prefix3 === void 0) {
      prefix3 = "";
    }
    return {
      value: 1,
      prefix: prefix3,
      uid: generateUID()
    };
  };
  var counter = createSource();
  var source = React19.createContext(createSource());
  var getId = function(source2) {
    return source2.value++;
  };
  var getPrefix = function(source2) {
    return source2 ? source2.prefix : "";
  };

  // node_modules/react-uid/dist/es2015/hooks.js
  var React20 = __toESM(require_react());
  var import_react34 = __toESM(require_react());
  var generateUID2 = function(context) {
    var quartz = context || counter;
    var prefix3 = getPrefix(quartz);
    var id = getId(quartz);
    var uid2 = prefix3 + id;
    var gen = function(item) {
      return uid2 + quartz.uid(item);
    };
    return { uid: uid2, gen };
  };
  var useUIDState = function() {
    if (false) {
      if (!("useContext" in React20)) {
        throw new Error("Hooks API requires React 16.8+");
      }
    }
    var context = (0, import_react34.useContext)(source);
    var uid2 = (0, import_react34.useState)(function() {
      return generateUID2(context);
    })[0];
    return uid2;
  };
  var useUID = function() {
    var uid2 = useUIDState().uid;
    return uid2;
  };
  var useUIDSeed = function() {
    var gen = useUIDState().gen;
    return gen;
  };

  // node_modules/@atlaskit/ds-lib/dist/esm/utils/use-id.js
  var import_platform_feature_flags4 = __toESM(require_cjs3());
  var _React$useId;
  var react18UseId = (_React$useId = import_react35.default.useId) !== null && _React$useId !== void 0 ? _React$useId : void 0;
  function useId() {
    if (react18UseId && (0, import_platform_feature_flags4.fg)("platform-dst-react-18-use-id")) {
      return react18UseId();
    }
    return "uid".concat(useUID());
  }
  function useIdSeed() {
    if (react18UseId && (0, import_platform_feature_flags4.fg)("platform-dst-react-18-use-id")) {
      var uid2 = react18UseId();
      return function(id) {
        return "".concat(uid2, "-").concat(id.toString());
      };
    }
    return useUIDSeed();
  }

  // node_modules/@atlaskit/tooltip/dist/esm/internal/use-unique-id.js
  function useUniqueId2(prefix3, shouldRenderId) {
    var seed = useIdSeed();
    return shouldRenderId ? "".concat(seed(prefix3)) : void 0;
  }

  // node_modules/@atlaskit/tooltip/dist/esm/tooltip-container.js
  init_defineProperty();
  var React23 = __toESM(require_react());
  var import_react37 = __toESM(require_react());

  // node_modules/@atlaskit/tooltip/dist/esm/tooltip-primitive.js
  var React22 = __toESM(require_react());
  var import_react36 = __toESM(require_react());
  var TooltipPrimitive = /* @__PURE__ */ (0, import_react36.forwardRef)(function TooltipPrimitive2(_ref2, ref) {
    var style = _ref2.style, className = _ref2.className, children = _ref2.children, placement = _ref2.placement, testId = _ref2.testId, onMouseOut = _ref2.onMouseOut, onMouseOver = _ref2.onMouseOver, id = _ref2.id;
    return /* @__PURE__ */ React22.createElement("div", {
      ref,
      style,
      "data-testid": testId ? "".concat(testId, "--wrapper") : void 0
    }, /* @__PURE__ */ React22.createElement("div", {
      role: "tooltip",
      className: ax(["_80om73ad", className]),
      onMouseOut,
      onMouseOver,
      "data-placement": placement,
      "data-testid": testId,
      id
    }, children));
  });
  TooltipPrimitive.displayName = "TooltipPrimitive";
  var tooltip_primitive_default = TooltipPrimitive;

  // node_modules/@atlaskit/tooltip/dist/esm/tooltip-container.js
  function ownKeys6(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r && (o = o.filter(function(r2) {
        return Object.getOwnPropertyDescriptor(e, r2).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread6(e) {
    for (var r = 1; r < arguments.length; r++) {
      var t = null != arguments[r] ? arguments[r] : {};
      r % 2 ? ownKeys6(Object(t), true).forEach(function(r2) {
        _defineProperty(e, r2, t[r2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys6(Object(t)).forEach(function(r2) {
        Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
      });
    }
    return e;
  }
  var TooltipContainer = /* @__PURE__ */ (0, import_react37.forwardRef)(function TooltipContainer2(_ref2, ref) {
    var style = _ref2.style, className = _ref2.className, children = _ref2.children, truncate = _ref2.truncate, placement = _ref2.placement, testId = _ref2.testId, onMouseOut = _ref2.onMouseOut, onMouseOver = _ref2.onMouseOver, id = _ref2.id;
    return /* @__PURE__ */ React23.createElement(tooltip_primitive_default, {
      ref,
      // eslint-disable-next-line @atlaskit/ui-styling-standard/no-classname-prop -- Ignored via go/DSP-18766
      className: ax(["_2rko1sit _11c8dcr7 _vchhusvi _p12fp3fh _bfhkpioe _syaz1i9p _152tze3t _1e02ze3t _1i4q1hna _85i5v77o _1q51v77o _y4ti12x7 _bozg12x7 _slp31hna", truncate && "_1reo15vq _18m915vq _p12f1pna _1bto1l2s _o5721q9c", className]),
      placement,
      testId,
      id,
      onMouseOut,
      onMouseOver,
      style: _objectSpread6(_objectSpread6({}, style), {}, {
        "--_yr7xfv": cssCustomPropertyValue("var(--ds-background-neutral-bold, ".concat(N800, ")")),
        "--_ywovvi": cssCustomPropertyValue("var(--ds-text-inverse, ".concat(N0, ")"))
      })
    }, children);
  });
  TooltipContainer.displayName = "TooltipContainer";
  var tooltip_container_default = TooltipContainer;

  // node_modules/@atlaskit/tooltip/dist/esm/utilities.js
  function getMousePosition(mouseCoordinates) {
    var safeMouse = mouseCoordinates || {
      top: 0,
      left: 0
    };
    var getBoundingClientRect3 = function getBoundingClientRect4() {
      return {
        top: safeMouse.top,
        left: safeMouse.left,
        bottom: safeMouse.top,
        right: safeMouse.left,
        width: 0,
        height: 0
      };
    };
    return {
      getBoundingClientRect: getBoundingClientRect3,
      clientWidth: 0,
      clientHeight: 0
    };
  }

  // node_modules/@atlaskit/tooltip/dist/esm/tooltip.js
  function ownKeys7(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r && (o = o.filter(function(r2) {
        return Object.getOwnPropertyDescriptor(e, r2).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread7(e) {
    for (var r = 1; r < arguments.length; r++) {
      var t = null != arguments[r] ? arguments[r] : {};
      r % 2 ? ownKeys7(Object(t), true).forEach(function(r2) {
        _defineProperty(e, r2, t[r2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys7(Object(t)).forEach(function(r2) {
        Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
      });
    }
    return e;
  }
  var tooltipZIndex = layers.tooltip();
  var analyticsAttributes = {
    componentName: "tooltip",
    packageName: "@atlaskit/tooltip",
    packageVersion: "20.4.0"
  };
  var invertedDirection2 = {
    top: "bottom",
    bottom: "top",
    left: "right",
    right: "left"
  };
  var getDirectionFromPlacement = function getDirectionFromPlacement2(placement) {
    return placement.split("-")[0];
  };
  function Tooltip(_ref2) {
    var children = _ref2.children, _ref$position = _ref2.position, position2 = _ref$position === void 0 ? "bottom" : _ref$position, _ref$mousePosition = _ref2.mousePosition, mousePosition = _ref$mousePosition === void 0 ? "bottom" : _ref$mousePosition, content = _ref2.content, _ref$truncate = _ref2.truncate, truncate = _ref$truncate === void 0 ? false : _ref$truncate, _ref$component = _ref2.component, Container = _ref$component === void 0 ? tooltip_container_default : _ref$component, _ref$tag = _ref2.tag, TargetContainer = _ref$tag === void 0 ? "div" : _ref$tag, testId = _ref2.testId, _ref$delay = _ref2.delay, delay = _ref$delay === void 0 ? 300 : _ref$delay, _ref$onShow = _ref2.onShow, onShow = _ref$onShow === void 0 ? noop3 : _ref$onShow, _ref$onHide = _ref2.onHide, onHide = _ref$onHide === void 0 ? noop3 : _ref$onHide, canAppear = _ref2.canAppear, _ref$hideTooltipOnCli = _ref2.hideTooltipOnClick, hideTooltipOnClick = _ref$hideTooltipOnCli === void 0 ? false : _ref$hideTooltipOnCli, _ref$hideTooltipOnMou = _ref2.hideTooltipOnMouseDown, hideTooltipOnMouseDown = _ref$hideTooltipOnMou === void 0 ? false : _ref$hideTooltipOnMou, analyticsContext = _ref2.analyticsContext, _ref$strategy = _ref2.strategy, strategy = _ref$strategy === void 0 ? "fixed" : _ref$strategy, _ref$ignoreTooltipPoi = _ref2.ignoreTooltipPointerEvents, ignoreTooltipPointerEvents = _ref$ignoreTooltipPoi === void 0 ? false : _ref$ignoreTooltipPoi, _ref$isScreenReaderAn = _ref2.isScreenReaderAnnouncementDisabled, isScreenReaderAnnouncementDisabled = _ref$isScreenReaderAn === void 0 ? false : _ref$isScreenReaderAn;
    var tooltipPosition = position2 === "mouse" ? mousePosition : position2;
    var onShowHandler = usePlatformLeafSyntheticEventHandler(_objectSpread7({
      fn: onShow,
      action: "displayed",
      analyticsData: analyticsContext
    }, analyticsAttributes));
    var onHideHandler = usePlatformLeafSyntheticEventHandler(_objectSpread7({
      fn: onHide,
      action: "hidden",
      analyticsData: analyticsContext
    }, analyticsAttributes));
    var apiRef = (0, import_react38.useRef)(null);
    var _useState = (0, import_react38.useState)("hide"), _useState2 = _slicedToArray(_useState, 2), state = _useState2[0], setState = _useState2[1];
    var targetRef = (0, import_react38.useRef)(null);
    var containerRef = (0, import_react38.useRef)(null);
    var setImplicitRefFromChildren = function setImplicitRefFromChildren2(node2) {
      containerRef.current = node2;
      targetRef.current = node2 ? node2.firstElementChild : null;
    };
    var setDirectRef = (0, import_react38.useCallback)(function(node2) {
      targetRef.current = node2;
    }, []);
    var stableState = useStableRef(state);
    var onShowHandlerStable = useStableRef(onShowHandler);
    var onHideHandlerStable = useStableRef(onHideHandler);
    var delayStable = useStableRef(delay);
    var canAppearStable = useStableRef(canAppear);
    var hasCalledShowHandler = (0, import_react38.useRef)(false);
    var start3 = (0, import_react38.useCallback)(function(api4) {
      apiRef.current = api4;
      hasCalledShowHandler.current = false;
    }, []);
    var done = (0, import_react38.useCallback)(function() {
      if (!apiRef.current) {
        return;
      }
      if (hasCalledShowHandler.current) {
        onHideHandlerStable.current();
      }
      apiRef.current = null;
      hasCalledShowHandler.current = false;
      setState("hide");
    }, [onHideHandlerStable]);
    var abort2 = (0, import_react38.useCallback)(function() {
      if (!apiRef.current) {
        return;
      }
      apiRef.current.abort();
      if (hasCalledShowHandler.current) {
        onHideHandlerStable.current();
      }
      apiRef.current = null;
    }, [onHideHandlerStable]);
    (0, import_react38.useEffect)(function mount4() {
      return function unmount() {
        if (apiRef.current) {
          abort2();
        }
      };
    }, [abort2]);
    var isDraggingRef = (0, import_react38.useRef)(false);
    (0, import_react38.useEffect)(function() {
      return register({
        onRegister: function onRegister(_ref22) {
          var isDragging = _ref22.isDragging;
          isDraggingRef.current = isDragging;
        },
        onDragStart: function onDragStart2() {
          var _apiRef$current;
          (_apiRef$current = apiRef.current) === null || _apiRef$current === void 0 || _apiRef$current.requestHide({
            isImmediate: true
          });
          isDraggingRef.current = true;
        },
        onDragEnd: function onDragEnd2() {
          isDraggingRef.current = false;
        }
      });
    }, []);
    var tryShowTooltip = (0, import_react38.useCallback)(function(source2) {
      var _canAppearStable$curr;
      if (isDraggingRef.current) {
        return;
      }
      if (apiRef.current && !apiRef.current.isActive()) {
        abort2();
      }
      if (apiRef.current && apiRef.current.isActive()) {
        apiRef.current.keep();
        return;
      }
      if (canAppearStable.current && !((_canAppearStable$curr = canAppearStable.current) !== null && _canAppearStable$curr !== void 0 && _canAppearStable$curr.call(canAppearStable))) {
        return;
      }
      var entry = {
        source: source2,
        delay: delayStable.current,
        show: function show2(_ref3) {
          var isImmediate = _ref3.isImmediate;
          if (!hasCalledShowHandler.current) {
            hasCalledShowHandler.current = true;
            onShowHandlerStable.current();
          }
          setState(isImmediate ? "show-immediate" : "fade-in");
        },
        hide: function hide3(_ref4) {
          var isImmediate = _ref4.isImmediate;
          if (isImmediate) {
            setState("hide");
          } else {
            setState("before-fade-out");
          }
        },
        done
      };
      var api4 = show(entry);
      start3(api4);
    }, [canAppearStable, delayStable, done, start3, abort2, onShowHandlerStable]);
    var hideTooltipOnEsc = (0, import_react38.useCallback)(function() {
      var _apiRef$current2;
      (_apiRef$current2 = apiRef.current) === null || _apiRef$current2 === void 0 || _apiRef$current2.requestHide({
        isImmediate: true
      });
    }, [apiRef]);
    useCloseOnEscapePress({
      onClose: hideTooltipOnEsc,
      isDisabled: state === "hide" || state === "fade-out"
    });
    (0, import_react38.useEffect)(function() {
      if (state === "hide") {
        return noop3;
      }
      if (state === "before-fade-out") {
        setState("fade-out");
      }
      var unbind = (0, import_bind_event_listener3.bind)(window, {
        type: "scroll",
        listener: function listener() {
          if (apiRef.current) {
            apiRef.current.requestHide({
              isImmediate: true
            });
          }
        },
        options: {
          capture: true,
          passive: true,
          once: true
        }
      });
      return unbind;
    }, [state]);
    var onMouseDown = (0, import_react38.useCallback)(function() {
      if (hideTooltipOnMouseDown && apiRef.current) {
        apiRef.current.requestHide({
          isImmediate: true
        });
      }
    }, [hideTooltipOnMouseDown]);
    var onClick = (0, import_react38.useCallback)(function() {
      if (hideTooltipOnClick && apiRef.current) {
        apiRef.current.requestHide({
          isImmediate: true
        });
      }
    }, [hideTooltipOnClick]);
    var onMouseOver = (0, import_react38.useCallback)(function(event) {
      if (containerRef.current && event.target === containerRef.current) {
        return;
      }
      if (event.defaultPrevented) {
        return;
      }
      event.preventDefault();
      var source2 = position2 === "mouse" ? {
        type: "mouse",
        // TODO: ideally not recalculating this object each time
        mouse: getMousePosition({
          left: event.clientX,
          top: event.clientY
        })
      } : {
        type: "keyboard"
      };
      tryShowTooltip(source2);
    }, [position2, tryShowTooltip]);
    var onMouseOut = (0, import_react38.useCallback)(function(event) {
      if (containerRef.current && event.target === containerRef.current) {
        return;
      }
      if (event.defaultPrevented) {
        return;
      }
      event.preventDefault();
      if (apiRef.current) {
        apiRef.current.requestHide({
          isImmediate: false
        });
      }
    }, []);
    var onMouseMove = position2 === "mouse" ? function(event) {
      var _apiRef$current3;
      if ((_apiRef$current3 = apiRef.current) !== null && _apiRef$current3 !== void 0 && _apiRef$current3.isActive()) {
        apiRef.current.mousePosition = getMousePosition({
          left: event.clientX,
          top: event.clientY
        });
      }
    } : void 0;
    var onMouseOverTooltip = (0, import_react38.useCallback)(function() {
      if (apiRef.current && apiRef.current.isActive()) {
        apiRef.current.keep();
        return;
      }
    }, []);
    var onFocus3 = (0, import_react38.useCallback)(function(e) {
      try {
        if (!e.target.matches(":focus-visible") && (0, import_platform_feature_flags5.fg)("platform-tooltip-focus-visible-new")) {
          return;
        }
      } catch (_) {
      }
      tryShowTooltip({
        type: "keyboard"
      });
    }, [tryShowTooltip]);
    var onBlur3 = (0, import_react38.useCallback)(function() {
      if (apiRef.current) {
        apiRef.current.requestHide({
          isImmediate: false
        });
      }
    }, []);
    var onAnimationFinished = (0, import_react38.useCallback)(function(transition) {
      if (transition === "exiting" && stableState.current === "fade-out" && apiRef.current) {
        apiRef.current.finishHideAnimation();
      }
    }, [stableState]);
    var CastTargetContainer = TargetContainer;
    var shouldRenderTooltipPopup = state !== "hide" && Boolean(content);
    var shouldRenderHiddenContent = !isScreenReaderAnnouncementDisabled && shouldRenderTooltipPopup;
    var shouldRenderTooltipChildren = state !== "hide" && state !== "fade-out";
    var handleOpenLayerObserverCloseSignal = (0, import_react38.useCallback)(function() {
      var _apiRef$current4;
      (_apiRef$current4 = apiRef.current) === null || _apiRef$current4 === void 0 || _apiRef$current4.requestHide({
        isImmediate: true
      });
    }, []);
    useNotifyOpenLayerObserver({
      // Layer is only visually open if both the tooltip popup (container) and children are rendered.
      isOpen: shouldRenderTooltipPopup && shouldRenderTooltipChildren,
      /**
       * We don't strictly need to provide an onClose callback at this time, as there is
       * already code that handles hiding the tooltip when a drag is started (and the only
       * usage right now is closing all layers when the user resizes the side nav).
       *
       * However, for future-proofing and semantic reasons, it makes sense to close the tooltip
       * whenever the open layer observer requests a close.
       */
      onClose: handleOpenLayerObserverCloseSignal
    });
    var getReferenceElement = function getReferenceElement2() {
      var _apiRef$current5;
      if (position2 === "mouse" && (_apiRef$current5 = apiRef.current) !== null && _apiRef$current5 !== void 0 && _apiRef$current5.mousePosition) {
        var _apiRef$current6;
        return (_apiRef$current6 = apiRef.current) === null || _apiRef$current6 === void 0 ? void 0 : _apiRef$current6.mousePosition;
      }
      return targetRef.current || void 0;
    };
    var tooltipIdForHiddenContent = useUniqueId2("tooltip", shouldRenderHiddenContent);
    var tooltipTriggerProps = {
      onMouseOver,
      onMouseOut,
      onMouseMove,
      onMouseDown,
      onClick,
      onFocus: onFocus3,
      onBlur: onBlur3
    };
    if (testId) {
      tooltipTriggerProps["data-testid"] = "".concat(testId, "--container");
    }
    var isChildrenAFunction = typeof children === "function";
    (0, import_react38.useEffect)(function() {
      if (isChildrenAFunction) {
        return;
      }
      var target = targetRef.current;
      if (!target || !tooltipIdForHiddenContent) {
        return;
      }
      target.setAttribute("aria-describedby", tooltipIdForHiddenContent);
      return function() {
        return target.removeAttribute("aria-describedby");
      };
    }, [isChildrenAFunction, tooltipIdForHiddenContent]);
    var hiddenContent = shouldRenderHiddenContent ? /* @__PURE__ */ import_react38.default.createElement("span", {
      "data-testid": testId ? "".concat(testId, "-hidden") : void 0,
      hidden: true,
      id: tooltipIdForHiddenContent
    }, typeof content === "function" ? content({}) : content) : null;
    return /* @__PURE__ */ import_react38.default.createElement(import_react38.default.Fragment, null, typeof children === "function" ? (
      // once we deprecate the wrapped approach, we can put the aria
      // attribute back into the tooltipTriggerProps and make it required
      // instead of optional in `types`
      /* @__PURE__ */ import_react38.default.createElement(import_react38.default.Fragment, null, children(_objectSpread7(_objectSpread7({}, tooltipTriggerProps), {}, {
        "aria-describedby": tooltipIdForHiddenContent,
        ref: setDirectRef
      })), hiddenContent)
    ) : /* @__PURE__ */ import_react38.default.createElement(CastTargetContainer, _extends({}, tooltipTriggerProps, {
      ref: setImplicitRefFromChildren,
      role: "presentation"
    }), children, hiddenContent), shouldRenderTooltipPopup ? /* @__PURE__ */ import_react38.default.createElement(Portal, {
      zIndex: tooltipZIndex
    }, /* @__PURE__ */ import_react38.default.createElement(Popper2, {
      placement: tooltipPosition,
      referenceElement: getReferenceElement(),
      strategy
    }, function(_ref5) {
      var ref = _ref5.ref, style = _ref5.style, update = _ref5.update, placement = _ref5.placement;
      var direction = position2 === "mouse" ? void 0 : invertedDirection2[getDirectionFromPlacement(placement)];
      return /* @__PURE__ */ import_react38.default.createElement(exiting_persistence_default, {
        appear: true
      }, shouldRenderTooltipChildren && /* @__PURE__ */ import_react38.default.createElement(fade_in_default, {
        distance: "constant",
        entranceDirection: direction,
        exitDirection: direction,
        onFinish: onAnimationFinished,
        duration: state !== "show-immediate" ? "medium" : "none"
      }, function(_ref6) {
        var className = _ref6.className;
        return /* @__PURE__ */ import_react38.default.createElement(Container, {
          ref,
          className: "Tooltip ".concat(className),
          style: _objectSpread7(_objectSpread7({}, style), ignoreTooltipPointerEvents && {
            pointerEvents: "none"
          }),
          truncate,
          placement: tooltipPosition,
          testId: getReferenceElement() ? testId : testId && "".concat(testId, "--unresolved"),
          onMouseOut,
          onMouseOver: onMouseOverTooltip
        }, typeof content === "function" ? content({
          update
        }) : content);
      }));
    })) : null);
  }
  var tooltip_default = Tooltip;

  // node_modules/@atlaskit/popup/dist/esm/popup.js
  init_slicedToArray();
  var React38 = __toESM(require_react());
  var import_react64 = __toESM(require_react());

  // node_modules/@atlaskit/layering/dist/esm/components/layering-context.js
  var import_react40 = __toESM(require_react());

  // node_modules/@atlaskit/platform-feature-flags-react/dist/esm/utils/component-with-condition/index.js
  var import_react39 = __toESM(require_react());
  function componentWithCondition(condition, ComponentTrue, ComponentFalse) {
    var ComponentWithCondition = /* @__PURE__ */ (0, import_react39.forwardRef)(function(props, ref) {
      return condition() ? /* @__PURE__ */ import_react39.default.createElement(ComponentTrue, _extends({}, props, {
        ref
      })) : /* @__PURE__ */ import_react39.default.createElement(ComponentFalse, _extends({}, props, {
        ref
      }));
    });
    if (ComponentTrue.name !== "") {
      ComponentWithCondition.displayName = "ComponentWithCondition[".concat(condition.name, "]");
    }
    return ComponentWithCondition;
  }

  // node_modules/@atlaskit/platform-feature-flags-react/dist/esm/utils/component-with-fg/index.js
  var import_platform_feature_flags6 = __toESM(require_cjs3());
  var componentWithFG = function componentWithFG2(featureFlagName, ComponentTrue, ComponentFalse) {
    return componentWithCondition(function() {
      return (0, import_platform_feature_flags6.fg)(featureFlagName);
    }, ComponentTrue, ComponentFalse);
  };

  // node_modules/@atlaskit/layering/dist/esm/classes/layer-node.js
  init_toConsumableArray();
  init_classCallCheck();
  init_createClass();
  var LayerNode = /* @__PURE__ */ (function() {
    function LayerNode2(id, parent) {
      _classCallCheck(this, LayerNode2);
      this.id = id;
      this.childNodes = [];
      this.parent = parent;
    }
    return _createClass(LayerNode2, [{
      key: "addChild",
      value: function addChild(node2) {
        this.childNodes.push(node2);
      }
    }, {
      key: "removeChild",
      value: function removeChild(node2) {
        this.childNodes = this.childNodes.filter(function(child) {
          return child.id !== node2.id;
        });
      }
    }, {
      key: "getLevel",
      value: function getLevel() {
        if (!this.parent) {
          return 1;
        }
        return this.parent.getLevel() + 1;
      }
    }, {
      key: "getHeight",
      value: function getHeight() {
        if (this.childNodes.length === 0) {
          return 1;
        }
        return Math.max.apply(Math, _toConsumableArray(this.childNodes.map(function(child) {
          return child.getHeight();
        }))) + 1;
      }
    }]);
  })();

  // node_modules/@atlaskit/layering/dist/esm/components/layering-context.js
  var LevelContext = /* @__PURE__ */ (0, import_react40.createContext)(0);
  var LevelNodeContext = /* @__PURE__ */ (0, import_react40.createContext)({
    current: null
  });
  var RootNodeContext = /* @__PURE__ */ (0, import_react40.createContext)({
    current: null
  });
  var TopLevelContext = /* @__PURE__ */ (0, import_react40.createContext)({
    topLevelRef: {
      current: null
    },
    layerList: {
      current: null
    },
    setTopLevel: noop3
  });
  var LevelProvider = function LevelProvider2(_ref2) {
    var children = _ref2.children, currentLevel = _ref2.currentLevel, levelNode = _ref2.node;
    (0, import_react40.useEffect)(function() {
      var levelNodeSafe = levelNode.current;
      var parentNode = levelNodeSafe.parent;
      parentNode === null || parentNode === void 0 || parentNode.addChild(levelNodeSafe);
      return function() {
        parentNode === null || parentNode === void 0 || parentNode.removeChild(levelNodeSafe);
      };
    }, [levelNode]);
    return /* @__PURE__ */ import_react40.default.createElement(LevelContext.Provider, {
      value: currentLevel
    }, /* @__PURE__ */ import_react40.default.createElement(LevelNodeContext.Provider, {
      value: levelNode
    }, children));
  };
  var LevelProviderOld = function LevelProviderOld2(_ref2) {
    var children = _ref2.children, currentLevel = _ref2.currentLevel;
    var _useContext = (0, import_react40.useContext)(TopLevelContext), layerList = _useContext.layerList;
    var id = (0, import_react40.useRef)(Math.random().toString(36));
    (0, import_react40.useEffect)(function() {
      var safeLayerList = layerList === null || layerList === void 0 ? void 0 : layerList.current;
      var safeId = id.current;
      if (!safeLayerList) {
        return;
      }
      safeLayerList.push(safeId);
      return function() {
        var index2 = safeLayerList.indexOf(safeId);
        if (index2 > -1) {
          safeLayerList.splice(index2, 1);
        }
      };
    }, [layerList, id]);
    return /* @__PURE__ */ import_react40.default.createElement(LevelContext.Provider, {
      value: currentLevel
    }, children);
  };
  var LayeringProvider = function LayeringProvider2(_ref3) {
    var children = _ref3.children;
    var topLevelRef = (0, import_react40.useRef)(0);
    var layerList = (0, import_react40.useRef)([]);
    var value = (0, import_react40.useMemo)(function() {
      return {
        topLevelRef,
        setTopLevel: function setTopLevel(level) {
          topLevelRef.current = level;
        },
        layerList
      };
    }, [topLevelRef, layerList]);
    return /* @__PURE__ */ import_react40.default.createElement(TopLevelContext.Provider, {
      value
    }, children);
  };
  var LayeringOld = function LayeringOld2(_ref4) {
    var children = _ref4.children, _ref4$isDisabled = _ref4.isDisabled, isDisabled = _ref4$isDisabled === void 0 ? true : _ref4$isDisabled;
    var currentLevel = (0, import_react40.useContext)(LevelContext);
    if (isDisabled) {
      return /* @__PURE__ */ import_react40.default.createElement(import_react40.default.Fragment, null, children);
    }
    var isNested = currentLevel > 0;
    var content = /* @__PURE__ */ import_react40.default.createElement(LevelProviderOld, {
      currentLevel: currentLevel + 1
    }, children);
    return isNested ? content : /* @__PURE__ */ import_react40.default.createElement(LayeringProvider, null, content);
  };
  var LayeringNew = function LayeringNew2(_ref5) {
    var children = _ref5.children, _ref5$isDisabled = _ref5.isDisabled, isDisabled = _ref5$isDisabled === void 0 ? true : _ref5$isDisabled;
    var currentLevel = (0, import_react40.useContext)(LevelContext);
    var parentNode = (0, import_react40.useContext)(LevelNodeContext);
    var newNode = (0, import_react40.useRef)(new LayerNode(Math.random().toString(36), parentNode.current));
    if (isDisabled) {
      return /* @__PURE__ */ import_react40.default.createElement(import_react40.default.Fragment, null, children);
    }
    var isNested = currentLevel > 0;
    var content = /* @__PURE__ */ import_react40.default.createElement(LevelProvider, {
      currentLevel: currentLevel + 1,
      node: newNode
    }, children);
    return isNested ? content : /* @__PURE__ */ import_react40.default.createElement(RootNodeContext.Provider, {
      value: newNode
    }, content);
  };
  var Layering = componentWithFG("layering-tree-graph", LayeringNew, LayeringOld);

  // node_modules/@atlaskit/layering/dist/esm/hooks/index.js
  var import_react41 = __toESM(require_react());
  var import_bind_event_listener4 = __toESM(require_dist());
  var import_platform_feature_flags7 = __toESM(require_cjs3());
  var ESCAPE2 = "Escape";
  function useCloseOnEscapePress2(_ref2) {
    var onClose = _ref2.onClose, isDisabled = _ref2.isDisabled;
    var escapePressed = (0, import_react41.useRef)(false);
    var _useLayering = useLayering(), isLayerDisabled = _useLayering.isLayerDisabled;
    var onKeyDown = (0, import_react41.useCallback)(function(e) {
      var isDisabledLayer = isLayerDisabled();
      if (isDisabled || escapePressed.current || e.key !== ESCAPE2 || isDisabledLayer) {
        return;
      }
      escapePressed.current = true;
      onClose(e);
    }, [onClose, isDisabled, isLayerDisabled]);
    var onKeyUp = (0, import_react41.useCallback)(function() {
      escapePressed.current = false;
    }, []);
    (0, import_react41.useEffect)(function() {
      return (0, import_bind_event_listener4.bindAll)(window, [{
        type: "keydown",
        listener: onKeyDown
      }, {
        type: "keyup",
        listener: onKeyUp
      }], {
        capture: false
      });
    }, [onKeyDown, onKeyUp]);
  }
  function useLayering() {
    var currentLevel = (0, import_react41.useContext)(LevelContext);
    var _useContext = (0, import_react41.useContext)(TopLevelContext), topLevelRef = _useContext.topLevelRef, layerList = _useContext.layerList;
    var layerNode;
    var rootNode;
    if ((0, import_platform_feature_flags7.fg)("layering-tree-graph")) {
      layerNode = (0, import_react41.useContext)(LevelNodeContext);
      rootNode = (0, import_react41.useContext)(RootNodeContext);
    }
    var isLayerDisabled = (0, import_react41.useCallback)(function() {
      var _layerList$current$le, _layerList$current;
      if ((0, import_platform_feature_flags7.fg)("layering-tree-graph")) {
        var _layerNode, _rootNode;
        if (!((_layerNode = layerNode) !== null && _layerNode !== void 0 && _layerNode.current) || !((_rootNode = rootNode) !== null && _rootNode !== void 0 && _rootNode.current)) {
          return false;
        }
        return layerNode.current.getLevel() < rootNode.current.getHeight();
      }
      return ((_layerList$current$le = layerList === null || layerList === void 0 || (_layerList$current = layerList.current) === null || _layerList$current === void 0 ? void 0 : _layerList$current.length) !== null && _layerList$current$le !== void 0 ? _layerList$current$le : 0) !== currentLevel;
    }, [currentLevel, layerList, layerNode, rootNode]);
    var getTopLevel = (0, import_react41.useCallback)(function() {
      var _rootNode2;
      return (_rootNode2 = rootNode) !== null && _rootNode2 !== void 0 && _rootNode2.current ? rootNode.current.getHeight() : null;
    }, [rootNode]);
    return (0, import_platform_feature_flags7.fg)("layering-tree-graph") ? {
      currentLevel,
      isLayerDisabled,
      getTopLevel
    } : {
      currentLevel,
      topLevelRef,
      isLayerDisabled,
      layerList
    };
  }

  // node_modules/@atlaskit/popup/dist/esm/popup.js
  var import_platform_feature_flags11 = __toESM(require_cjs3());

  // node_modules/@atlaskit/primitives/dist/esm/compiled/components/box.js
  var React27 = __toESM(require_react());
  var import_react43 = __toESM(require_react());

  // node_modules/@atlaskit/primitives/dist/esm/utils/surface-provider.js
  var import_react42 = __toESM(require_react());
  var SurfaceContext = /* @__PURE__ */ (0, import_react42.createContext)("elevation.surface");
  var useSurface = function useSurface2() {
    return (0, import_react42.useContext)(SurfaceContext);
  };
  SurfaceContext.displayName = "SurfaceProvider";

  // node_modules/@atlaskit/primitives/dist/esm/compiled/components/box.js
  var _excluded2 = ["as", "children", "backgroundColor", "padding", "paddingBlock", "paddingBlockStart", "paddingBlockEnd", "paddingInline", "paddingInlineStart", "paddingInlineEnd", "style", "testId", "xcss"];
  var _excluded22 = ["className"];
  var backgroundColorMap = {
    "color.background.accent.lime.subtlest": "_bfhkm890",
    "color.background.accent.lime.subtlest.hovered": "_bfhkd4y8",
    "color.background.accent.lime.subtlest.pressed": "_bfhk1fno",
    "color.background.accent.lime.subtler": "_bfhkz2ec",
    "color.background.accent.lime.subtler.hovered": "_bfhk1eds",
    "color.background.accent.lime.subtler.pressed": "_bfhk1hgz",
    "color.background.accent.lime.subtle": "_bfhkbq5w",
    "color.background.accent.lime.subtle.hovered": "_bfhkfoww",
    "color.background.accent.lime.subtle.pressed": "_bfhkhgj8",
    "color.background.accent.lime.bolder": "_bfhktde4",
    "color.background.accent.lime.bolder.hovered": "_bfhknzpa",
    "color.background.accent.lime.bolder.pressed": "_bfhk1b17",
    "color.background.accent.red.subtlest": "_bfhk1vk5",
    "color.background.accent.red.subtlest.hovered": "_bfhk1i6i",
    "color.background.accent.red.subtlest.pressed": "_bfhk1pbw",
    "color.background.accent.red.subtler": "_bfhk1rtt",
    "color.background.accent.red.subtler.hovered": "_bfhkrw5d",
    "color.background.accent.red.subtler.pressed": "_bfhk69rw",
    "color.background.accent.red.subtle": "_bfhkkrt9",
    "color.background.accent.red.subtle.hovered": "_bfhk1sou",
    "color.background.accent.red.subtle.pressed": "_bfhk1tf4",
    "color.background.accent.red.bolder": "_bfhkuibq",
    "color.background.accent.red.bolder.hovered": "_bfhk100f",
    "color.background.accent.red.bolder.pressed": "_bfhkprmn",
    "color.background.accent.orange.subtlest": "_bfhk1g3m",
    "color.background.accent.orange.subtlest.hovered": "_bfhkg4tm",
    "color.background.accent.orange.subtlest.pressed": "_bfhk1ya0",
    "color.background.accent.orange.subtler": "_bfhkf2vu",
    "color.background.accent.orange.subtler.hovered": "_bfhk1lml",
    "color.background.accent.orange.subtler.pressed": "_bfhkuxsx",
    "color.background.accent.orange.subtle": "_bfhk1g6e",
    "color.background.accent.orange.subtle.hovered": "_bfhk1oew",
    "color.background.accent.orange.subtle.pressed": "_bfhk1phk",
    "color.background.accent.orange.bolder": "_bfhkjgng",
    "color.background.accent.orange.bolder.hovered": "_bfhkhi52",
    "color.background.accent.orange.bolder.pressed": "_bfhkf767",
    "color.background.accent.yellow.subtlest": "_bfhk1ozg",
    "color.background.accent.yellow.subtlest.hovered": "_bfhk19g9",
    "color.background.accent.yellow.subtlest.pressed": "_bfhk31d1",
    "color.background.accent.yellow.subtler": "_bfhk3fv2",
    "color.background.accent.yellow.subtler.hovered": "_bfhklg04",
    "color.background.accent.yellow.subtler.pressed": "_bfhk1d44",
    "color.background.accent.yellow.subtle": "_bfhkry5t",
    "color.background.accent.yellow.subtle.hovered": "_bfhk17e6",
    "color.background.accent.yellow.subtle.pressed": "_bfhko0y5",
    "color.background.accent.yellow.bolder": "_bfhk1vop",
    "color.background.accent.yellow.bolder.hovered": "_bfhkkjqf",
    "color.background.accent.yellow.bolder.pressed": "_bfhk32kj",
    "color.background.accent.green.subtlest": "_bfhkn729",
    "color.background.accent.green.subtlest.hovered": "_bfhk3utz",
    "color.background.accent.green.subtlest.pressed": "_bfhkv5yf",
    "color.background.accent.green.subtler": "_bfhk1wnw",
    "color.background.accent.green.subtler.hovered": "_bfhkung8",
    "color.background.accent.green.subtler.pressed": "_bfhk1p19",
    "color.background.accent.green.subtle": "_bfhk1rsu",
    "color.background.accent.green.subtle.hovered": "_bfhk12e3",
    "color.background.accent.green.subtle.pressed": "_bfhk8h4p",
    "color.background.accent.green.bolder": "_bfhk1e5c",
    "color.background.accent.green.bolder.hovered": "_bfhka5yi",
    "color.background.accent.green.bolder.pressed": "_bfhk1azz",
    "color.background.accent.teal.subtlest": "_bfhk7xuz",
    "color.background.accent.teal.subtlest.hovered": "_bfhk108c",
    "color.background.accent.teal.subtlest.pressed": "_bfhk1j2h",
    "color.background.accent.teal.subtler": "_bfhk1a17",
    "color.background.accent.teal.subtler.hovered": "_bfhkg5py",
    "color.background.accent.teal.subtler.pressed": "_bfhkq7li",
    "color.background.accent.teal.subtle": "_bfhktdv8",
    "color.background.accent.teal.subtle.hovered": "_bfhkzh8h",
    "color.background.accent.teal.subtle.pressed": "_bfhk10ai",
    "color.background.accent.teal.bolder": "_bfhk2c8p",
    "color.background.accent.teal.bolder.hovered": "_bfhkl3ve",
    "color.background.accent.teal.bolder.pressed": "_bfhkse6l",
    "color.background.accent.blue.subtlest": "_bfhkavxe",
    "color.background.accent.blue.subtlest.hovered": "_bfhkay3p",
    "color.background.accent.blue.subtlest.pressed": "_bfhk1xmr",
    "color.background.accent.blue.subtler": "_bfhk4v9p",
    "color.background.accent.blue.subtler.hovered": "_bfhk16e6",
    "color.background.accent.blue.subtler.pressed": "_bfhk1uh7",
    "color.background.accent.blue.subtle": "_bfhk1j89",
    "color.background.accent.blue.subtle.hovered": "_bfhk1f4s",
    "color.background.accent.blue.subtle.pressed": "_bfhkqctv",
    "color.background.accent.blue.bolder": "_bfhkc8cv",
    "color.background.accent.blue.bolder.hovered": "_bfhk1cwi",
    "color.background.accent.blue.bolder.pressed": "_bfhkhcrq",
    "color.background.accent.purple.subtlest": "_bfhkp7j4",
    "color.background.accent.purple.subtlest.hovered": "_bfhkm0d5",
    "color.background.accent.purple.subtlest.pressed": "_bfhkgslw",
    "color.background.accent.purple.subtler": "_bfhk1jkz",
    "color.background.accent.purple.subtler.hovered": "_bfhk1wyu",
    "color.background.accent.purple.subtler.pressed": "_bfhk5fkp",
    "color.background.accent.purple.subtle": "_bfhkdh45",
    "color.background.accent.purple.subtle.hovered": "_bfhk1wob",
    "color.background.accent.purple.subtle.pressed": "_bfhkwz05",
    "color.background.accent.purple.bolder": "_bfhkygwo",
    "color.background.accent.purple.bolder.hovered": "_bfhkadgs",
    "color.background.accent.purple.bolder.pressed": "_bfhk1uro",
    "color.background.accent.magenta.subtlest": "_bfhk8tvm",
    "color.background.accent.magenta.subtlest.hovered": "_bfhkr3zd",
    "color.background.accent.magenta.subtlest.pressed": "_bfhk1een",
    "color.background.accent.magenta.subtler": "_bfhkv9ra",
    "color.background.accent.magenta.subtler.hovered": "_bfhk1r0p",
    "color.background.accent.magenta.subtler.pressed": "_bfhkxuzc",
    "color.background.accent.magenta.subtle": "_bfhk1mi6",
    "color.background.accent.magenta.subtle.hovered": "_bfhkrwyz",
    "color.background.accent.magenta.subtle.pressed": "_bfhk1ovh",
    "color.background.accent.magenta.bolder": "_bfhkc3uk",
    "color.background.accent.magenta.bolder.hovered": "_bfhk1ok8",
    "color.background.accent.magenta.bolder.pressed": "_bfhkwaw3",
    "color.background.accent.gray.subtlest": "_bfhk11bn",
    "color.background.accent.gray.subtlest.hovered": "_bfhk12j4",
    "color.background.accent.gray.subtlest.pressed": "_bfhk1lb4",
    "color.background.accent.gray.subtler": "_bfhk1v33",
    "color.background.accent.gray.subtler.hovered": "_bfhk1f7l",
    "color.background.accent.gray.subtler.pressed": "_bfhkd8a2",
    "color.background.accent.gray.subtle": "_bfhk1t05",
    "color.background.accent.gray.subtle.hovered": "_bfhk1a2l",
    "color.background.accent.gray.subtle.pressed": "_bfhk1z0s",
    "color.background.accent.gray.bolder": "_bfhk1t1b",
    "color.background.accent.gray.bolder.hovered": "_bfhke4nv",
    "color.background.accent.gray.bolder.pressed": "_bfhk82ra",
    "color.background.disabled": "_bfhksyzs",
    "color.background.input": "_bfhk1j9a",
    "color.background.input.hovered": "_bfhk1d5g",
    "color.background.input.pressed": "_bfhkr01l",
    "color.background.inverse.subtle": "_bfhk1vck",
    "color.background.inverse.subtle.hovered": "_bfhkmpja",
    "color.background.inverse.subtle.pressed": "_bfhk1gii",
    "color.background.neutral": "_bfhkm7j4",
    "color.background.neutral.hovered": "_bfhk15ej",
    "color.background.neutral.pressed": "_bfhkip91",
    "color.background.neutral.subtle": "_bfhksm61",
    "color.background.neutral.subtle.hovered": "_bfhk166n",
    "color.background.neutral.subtle.pressed": "_bfhk1dty",
    "color.background.neutral.bold": "_bfhkcdhy",
    "color.background.neutral.bold.hovered": "_bfhk1bsc",
    "color.background.neutral.bold.pressed": "_bfhk1b6k",
    "color.background.selected": "_bfhkfg4m",
    "color.background.selected.hovered": "_bfhki1yw",
    "color.background.selected.pressed": "_bfhk19ru",
    "color.background.selected.bold": "_bfhk1fvw",
    "color.background.selected.bold.hovered": "_bfhk18hz",
    "color.background.selected.bold.pressed": "_bfhkgr1v",
    "color.background.brand.subtlest": "_bfhk3wxy",
    "color.background.brand.subtlest.hovered": "_bfhkezq1",
    "color.background.brand.subtlest.pressed": "_bfhk2ggb",
    "color.background.brand.bold": "_bfhkb29m",
    "color.background.brand.bold.hovered": "_bfhku1se",
    "color.background.brand.bold.pressed": "_bfhkqkzo",
    "color.background.brand.boldest": "_bfhk15mt",
    "color.background.brand.boldest.hovered": "_bfhk1uwk",
    "color.background.brand.boldest.pressed": "_bfhk17jr",
    "color.background.danger": "_bfhk1gly",
    "color.background.danger.hovered": "_bfhk1yvi",
    "color.background.danger.pressed": "_bfhk1io2",
    "color.background.danger.bold": "_bfhkybec",
    "color.background.danger.bold.hovered": "_bfhks9hg",
    "color.background.danger.bold.pressed": "_bfhk9pqq",
    "color.background.warning": "_bfhk1tzq",
    "color.background.warning.hovered": "_bfhk1rd4",
    "color.background.warning.pressed": "_bfhk11dh",
    "color.background.warning.bold": "_bfhk190i",
    "color.background.warning.bold.hovered": "_bfhk1i4c",
    "color.background.warning.bold.pressed": "_bfhkrj9s",
    "color.background.success": "_bfhkmv6i",
    "color.background.success.hovered": "_bfhk1jgi",
    "color.background.success.pressed": "_bfhky4f1",
    "color.background.success.bold": "_bfhk8emd",
    "color.background.success.bold.hovered": "_bfhk1q4l",
    "color.background.success.bold.pressed": "_bfhkcrcn",
    "color.background.discovery": "_bfhk1nvp",
    "color.background.discovery.hovered": "_bfhk1xp7",
    "color.background.discovery.pressed": "_bfhkdlkp",
    "color.background.discovery.bold": "_bfhk1lri",
    "color.background.discovery.bold.hovered": "_bfhk1w72",
    "color.background.discovery.bold.pressed": "_bfhkrb53",
    "color.background.information": "_bfhk33gi",
    "color.background.information.hovered": "_bfhk1vps",
    "color.background.information.pressed": "_bfhk1s0z",
    "color.background.information.bold": "_bfhk14wj",
    "color.background.information.bold.hovered": "_bfhk1amz",
    "color.background.information.bold.pressed": "_bfhk5bth",
    "color.blanket": "_bfhk10xm",
    "color.blanket.selected": "_bfhk7wq0",
    "color.blanket.danger": "_bfhkrprw",
    "color.skeleton": "_bfhkn82g",
    "color.skeleton.subtle": "_bfhkh3tw",
    "elevation.surface": "_bfhkvuon",
    "elevation.surface.hovered": "_bfhk108i",
    "elevation.surface.pressed": "_bfhk1ji5",
    "elevation.surface.overlay": "_bfhk1bhr",
    "elevation.surface.overlay.hovered": "_bfhk16qz",
    "elevation.surface.overlay.pressed": "_bfhkvq0a",
    "elevation.surface.raised": "_bfhkhp5a",
    "elevation.surface.raised.hovered": "_bfhk1a0f",
    "elevation.surface.raised.pressed": "_bfhkf7u5",
    "elevation.surface.sunken": "_bfhkqbzx",
    "utility.elevation.surface.current": "_bfhkchd4"
  };
  var setSurfaceTokenMap = {
    "elevation.surface": "_1q1lvuon",
    "elevation.surface.hovered": "_1q1l108i",
    "elevation.surface.pressed": "_1q1l1ji5",
    "elevation.surface.overlay": "_1q1l1bhr",
    "elevation.surface.overlay.hovered": "_1q1l16qz",
    "elevation.surface.overlay.pressed": "_1q1lvq0a",
    "elevation.surface.raised": "_1q1lhp5a",
    "elevation.surface.raised.hovered": "_1q1l1a0f",
    "elevation.surface.raised.pressed": "_1q1lf7u5",
    "elevation.surface.sunken": "_1q1lqbzx"
  };
  var paddingBlockStartMap = {
    "space.0": "_1q51ze3t",
    "space.025": "_1q51v77o",
    "space.050": "_1q511b66",
    "space.075": "_1q5112x7",
    "space.100": "_1q51u2gc",
    "space.150": "_1q51utpp",
    "space.200": "_1q51pxbi",
    "space.250": "_1q51v47k",
    "space.300": "_1q511ejb",
    "space.400": "_1q51xy5q",
    "space.500": "_1q511jfw",
    "space.600": "_1q51oahv",
    "space.800": "_1q51xncg",
    "space.1000": "_1q511epz"
  };
  var paddingBlockEndMap = {
    "space.0": "_85i5ze3t",
    "space.025": "_85i5v77o",
    "space.050": "_85i51b66",
    "space.075": "_85i512x7",
    "space.100": "_85i5u2gc",
    "space.150": "_85i5utpp",
    "space.200": "_85i5pxbi",
    "space.250": "_85i5v47k",
    "space.300": "_85i51ejb",
    "space.400": "_85i5xy5q",
    "space.500": "_85i51jfw",
    "space.600": "_85i5oahv",
    "space.800": "_85i5xncg",
    "space.1000": "_85i51epz"
  };
  var paddingInlineStartMap = {
    "space.0": "_bozgze3t",
    "space.025": "_bozgv77o",
    "space.050": "_bozg1b66",
    "space.075": "_bozg12x7",
    "space.100": "_bozgu2gc",
    "space.150": "_bozgutpp",
    "space.200": "_bozgpxbi",
    "space.250": "_bozgv47k",
    "space.300": "_bozg1ejb",
    "space.400": "_bozgxy5q",
    "space.500": "_bozg1jfw",
    "space.600": "_bozgoahv",
    "space.800": "_bozgxncg",
    "space.1000": "_bozg1epz"
  };
  var paddingInlineEndMap = {
    "space.0": "_y4tize3t",
    "space.025": "_y4tiv77o",
    "space.050": "_y4ti1b66",
    "space.075": "_y4ti12x7",
    "space.100": "_y4tiu2gc",
    "space.150": "_y4tiutpp",
    "space.200": "_y4tipxbi",
    "space.250": "_y4tiv47k",
    "space.300": "_y4ti1ejb",
    "space.400": "_y4tixy5q",
    "space.500": "_y4ti1jfw",
    "space.600": "_y4tioahv",
    "space.800": "_y4tixncg",
    "space.1000": "_y4ti1epz"
  };
  var Box = /* @__PURE__ */ (0, import_react43.forwardRef)(
    function(_ref2, ref) {
      var _ref$as = _ref2.as, Component3 = _ref$as === void 0 ? "div" : _ref$as, children = _ref2.children, backgroundColor = _ref2.backgroundColor, padding = _ref2.padding, _ref$paddingBlock = _ref2.paddingBlock, paddingBlock = _ref$paddingBlock === void 0 ? padding : _ref$paddingBlock, _ref$paddingBlockStar = _ref2.paddingBlockStart, paddingBlockStart = _ref$paddingBlockStar === void 0 ? paddingBlock : _ref$paddingBlockStar, _ref$paddingBlockEnd = _ref2.paddingBlockEnd, paddingBlockEnd = _ref$paddingBlockEnd === void 0 ? paddingBlock : _ref$paddingBlockEnd, _ref$paddingInline = _ref2.paddingInline, paddingInline = _ref$paddingInline === void 0 ? padding : _ref$paddingInline, _ref$paddingInlineSta = _ref2.paddingInlineStart, paddingInlineStart = _ref$paddingInlineSta === void 0 ? paddingInline : _ref$paddingInlineSta, _ref$paddingInlineEnd = _ref2.paddingInlineEnd, paddingInlineEnd = _ref$paddingInlineEnd === void 0 ? paddingInline : _ref$paddingInlineEnd, style = _ref2.style, testId = _ref2.testId, xcss2 = _ref2.xcss, htmlAttributes = _objectWithoutProperties(_ref2, _excluded2);
      var _spreadClass = htmlAttributes.className, safeHtmlAttributes = _objectWithoutProperties(htmlAttributes, _excluded22);
      var node2 = /* @__PURE__ */ React27.createElement(
        Component3,
        _extends({
          style,
          ref,
          className: ax(["_19itglyw _vchhusvi _r06hglyw", backgroundColor && backgroundColorMap[backgroundColor], backgroundColor && isSurfaceToken(backgroundColor) && setSurfaceTokenMap[backgroundColor], paddingBlockStart && paddingBlockStartMap[paddingBlockStart], paddingBlockEnd && paddingBlockEndMap[paddingBlockEnd], paddingInlineStart && paddingInlineStartMap[paddingInlineStart], paddingInlineEnd && paddingInlineEndMap[paddingInlineEnd], xcss2])
        }, safeHtmlAttributes, {
          "data-testid": testId
        }),
        children
      );
      if (backgroundColor) {
        return /* @__PURE__ */ React27.createElement(SurfaceContext.Provider, {
          value: backgroundColor
        }, node2);
      }
      return node2;
    }
    // @ts-ignore This typescript error has been surpessed while locally enrolling `@atlaskit/primitives` into Jira
    // The return type of `BoxComponent` does not match the return type of `forwardRef` in React 18
  );
  var box_default = Box;
  function isSurfaceToken(backgroundColor) {
    return backgroundColor in setSurfaceTokenMap;
  }

  // node_modules/@atlaskit/primitives/dist/esm/compiled/components/inline.js
  var React30 = __toESM(require_react());
  var import_react47 = __toESM(require_react());

  // node_modules/@atlaskit/css/dist/esm/index.js
  var React28 = __toESM(require_react());

  // node_modules/@compiled/react/dist/esm/index.js
  var import_react44 = __toESM(require_react());

  // node_modules/@compiled/react/dist/esm/utils/error.js
  var createStrictSetupError = () => {
    return new Error(`
 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2557   \u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557\u2588\u2588\u2557     \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557
\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255D\u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2551     \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255D\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557
\u2588\u2588\u2551     \u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2554\u2588\u2588\u2588\u2588\u2554\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255D\u2588\u2588\u2551\u2588\u2588\u2551     \u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551  \u2588\u2588\u2551
\u2588\u2588\u2551     \u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2551\u255A\u2588\u2588\u2554\u255D\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u255D \u2588\u2588\u2551\u2588\u2588\u2551     \u2588\u2588\u2554\u2550\u2550\u255D  \u2588\u2588\u2551  \u2588\u2588\u2551
\u255A\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u255A\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255D\u2588\u2588\u2551 \u255A\u2550\u255D \u2588\u2588\u2551\u2588\u2588\u2551     \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255D
 \u255A\u2550\u2550\u2550\u2550\u2550\u255D \u255A\u2550\u2550\u2550\u2550\u2550\u255D \u255A\u2550\u255D     \u255A\u2550\u255D\u255A\u2550\u255D     \u255A\u2550\u255D\u255A\u2550\u2550\u2550\u2550\u2550\u2550\u255D\u255A\u2550\u2550\u2550\u2550\u2550\u2550\u255D\u255A\u2550\u2550\u2550\u2550\u2550\u255D

  @compiled/react

  Code was executed when it shouldn't have. To resolve make sure to:

  1. Set up Compiled.
  2. Configure importSources in your Compiled config to point to the module that exports the output of createStrictAPI().

  For more information visit https://compiledcssinjs.com/docs/installation and follow the instructions.
`);
  };

  // node_modules/@compiled/react/dist/esm/xcss-prop/index.js
  var cx = (...styles15) => {
    const actualStyles = styles15;
    return ax(actualStyles);
  };

  // node_modules/@compiled/react/dist/esm/create-strict-api/index.js
  function createStrictAPI() {
    return {
      css() {
        throw createStrictSetupError();
      },
      cssMap() {
        throw createStrictSetupError();
      },
      cx,
      XCSSProp() {
        throw createStrictSetupError();
      }
    };
  }

  // node_modules/@atlaskit/css/dist/esm/index.js
  var _createStrictAPI = createStrictAPI();
  var XCSSProp = _createStrictAPI.XCSSProp;
  var css = _createStrictAPI.css;
  var cssMap = _createStrictAPI.cssMap;
  var cx2 = _createStrictAPI.cx;

  // node_modules/@atlaskit/primitives/dist/esm/compiled/components/flex.js
  var React29 = __toESM(require_react());
  var import_react46 = __toESM(require_react());
  var _excluded3 = ["as", "role", "alignItems", "justifyContent", "gap", "columnGap", "rowGap", "children", "testId", "direction", "wrap", "xcss"];
  var rowGapMap = {
    "space.0": "_1p57ze3t",
    "space.025": "_1p57v77o",
    "space.050": "_1p571b66",
    "space.075": "_1p5712x7",
    "space.100": "_1p57u2gc",
    "space.150": "_1p57utpp",
    "space.200": "_1p57pxbi",
    "space.250": "_1p57v47k",
    "space.300": "_1p571ejb",
    "space.400": "_1p57xy5q",
    "space.500": "_1p571jfw",
    "space.600": "_1p57oahv",
    "space.800": "_1p57xncg",
    "space.1000": "_1p571epz"
  };
  var columnGapMap = {
    "space.0": "_gy1pze3t",
    "space.025": "_gy1pv77o",
    "space.050": "_gy1p1b66",
    "space.075": "_gy1p12x7",
    "space.100": "_gy1pu2gc",
    "space.150": "_gy1putpp",
    "space.200": "_gy1ppxbi",
    "space.250": "_gy1pv47k",
    "space.300": "_gy1p1ejb",
    "space.400": "_gy1pxy5q",
    "space.500": "_gy1p1jfw",
    "space.600": "_gy1poahv",
    "space.800": "_gy1pxncg",
    "space.1000": "_gy1p1epz"
  };
  var justifyContentMap = {
    start: "_1bahv2br",
    center: "_1bah1h6o",
    end: "_1bahh9n0",
    "space-between": "_1bah1yb4",
    "space-around": "_1bah1b1v",
    "space-evenly": "_1bahitcz",
    stretch: "_1bah1fhb"
  };
  var flexDirectionMap = {
    column: "_2lx21bp4",
    row: "_2lx2vrvc"
  };
  var flexWrapMap = {
    wrap: "_1n261g80",
    nowrap: "_1n261q9c"
  };
  var alignItemsMap = {
    start: "_4cvrv2br",
    center: "_4cvr1h6o",
    baseline: "_4cvr1q9y",
    end: "_4cvrh9n0",
    stretch: "_4cvr1fhb"
  };
  var styles = {
    root: "_1e0c1txw _vchhusvi"
  };
  var Flex = /* @__PURE__ */ (0, import_react46.memo)(/* @__PURE__ */ (0, import_react46.forwardRef)(function(_ref2, ref) {
    var _ref$as = _ref2.as, Component3 = _ref$as === void 0 ? "div" : _ref$as, role = _ref2.role, alignItems = _ref2.alignItems, justifyContent = _ref2.justifyContent, gap = _ref2.gap, columnGap = _ref2.columnGap, rowGap = _ref2.rowGap, children = _ref2.children, testId = _ref2.testId, direction = _ref2.direction, wrap4 = _ref2.wrap, xcss2 = _ref2.xcss, ariaAttributes = _objectWithoutProperties(_ref2, _excluded3);
    return /* @__PURE__ */ React29.createElement(Component3, _extends({}, ariaAttributes, {
      role,
      className: ax([styles.root, gap && columnGapMap[gap], columnGap && columnGapMap[columnGap], gap && rowGapMap[gap], rowGap && rowGapMap[rowGap], alignItems && alignItemsMap[alignItems], direction && flexDirectionMap[direction], justifyContent && justifyContentMap[justifyContent], wrap4 && flexWrapMap[wrap4], xcss2]),
      "data-testid": testId,
      ref
    }), children);
  }));
  Flex.displayName = "Flex";
  var flex_default = Flex;

  // node_modules/@atlaskit/primitives/dist/esm/compiled/components/inline.js
  var _excluded4 = ["as", "alignInline", "alignBlock", "shouldWrap", "spread", "grow", "space", "rowSpace", "separator", "xcss", "testId", "role", "children"];
  var styles2 = {
    separator: "_1mouze3t _195g1i6y _syazjjyb _lcxvglyw _uiztglyw",
    hug: "_16jlidpf",
    fill: "_1bsb1osq _16jlkb7n"
  };
  var Separator = function Separator2(_ref2) {
    var children = _ref2.children;
    return /* @__PURE__ */ React30.createElement("span", {
      className: ax([styles2.separator])
    }, children);
  };
  var Inline = /* @__PURE__ */ (0, import_react47.memo)(/* @__PURE__ */ (0, import_react47.forwardRef)(function(_ref2, ref) {
    var as = _ref2.as, alignInline = _ref2.alignInline, _ref2$alignBlock = _ref2.alignBlock, alignItems = _ref2$alignBlock === void 0 ? "start" : _ref2$alignBlock, _ref2$shouldWrap = _ref2.shouldWrap, shouldWrap = _ref2$shouldWrap === void 0 ? false : _ref2$shouldWrap, spread = _ref2.spread, grow = _ref2.grow, space = _ref2.space, rowSpace = _ref2.rowSpace, separator = _ref2.separator, xcss2 = _ref2.xcss, testId = _ref2.testId, role = _ref2.role, rawChildren = _ref2.children, ariaAttributes = _objectWithoutProperties(_ref2, _excluded4);
    var separatorComponent = typeof separator === "string" ? /* @__PURE__ */ React30.createElement(Separator, null, separator) : separator;
    var children = separatorComponent ? import_react47.Children.toArray(rawChildren).filter(Boolean).map(function(child, index2) {
      return /* @__PURE__ */ React30.createElement(import_react47.Fragment, {
        key: index2
      }, separator && index2 > 0 ? separatorComponent : null, child);
    }) : rawChildren;
    return /* @__PURE__ */ React30.createElement(flex_default, _extends({}, ariaAttributes, {
      as,
      role,
      alignItems,
      justifyContent: spread || alignInline,
      direction: "row",
      gap: space,
      rowGap: rowSpace,
      wrap: shouldWrap ? "wrap" : void 0,
      xcss: cx2(grow === "hug" && styles2.hug, grow === "fill" && styles2.fill, xcss2),
      testId,
      ref
    }), children);
  }));
  Inline.displayName = "Inline";
  var inline_default = Inline;

  // node_modules/@atlaskit/primitives/dist/esm/compiled/components/stack.js
  var React31 = __toESM(require_react());
  var import_react48 = __toESM(require_react());
  var _excluded5 = ["as", "alignInline", "alignBlock", "spread", "grow", "space", "children", "testId", "xcss", "role"];
  var styles3 = {
    hug: "_16jlidpf",
    fill: "_1bsb1osq _16jlkb7n"
  };
  var Stack = /* @__PURE__ */ (0, import_react48.memo)(/* @__PURE__ */ (0, import_react48.forwardRef)(function(_ref2, ref) {
    var as = _ref2.as, alignItems = _ref2.alignInline, _ref$alignBlock = _ref2.alignBlock, alignBlock = _ref$alignBlock === void 0 ? "stretch" : _ref$alignBlock, spread = _ref2.spread, grow = _ref2.grow, space = _ref2.space, children = _ref2.children, testId = _ref2.testId, xcss2 = _ref2.xcss, role = _ref2.role, ariaAttributes = _objectWithoutProperties(_ref2, _excluded5);
    return /* @__PURE__ */ React31.createElement(flex_default, _extends({}, ariaAttributes, {
      as,
      role,
      gap: space,
      direction: "column",
      alignItems,
      justifyContent: spread || alignBlock,
      xcss: cx2(grow === "hug" && styles3.hug, grow === "fill" && styles3.fill, xcss2),
      testId,
      ref
    }), children);
  }));
  Stack.displayName = "Stack";
  var stack_default = Stack;

  // node_modules/@atlaskit/primitives/dist/esm/compiled/components/text.js
  var React32 = __toESM(require_react());
  var import_react50 = __toESM(require_react());

  // node_modules/@atlaskit/primitives/dist/esm/utils/has-text-ancestor-context.js
  var import_react49 = __toESM(require_react());
  var HasTextAncestorContext = /* @__PURE__ */ (0, import_react49.createContext)(false);
  var useHasTextAncestor = function useHasTextAncestor2() {
    return (0, import_react49.useContext)(HasTextAncestorContext);
  };
  var HasTextAncestorProvider = HasTextAncestorContext.Provider;

  // node_modules/@atlaskit/primitives/dist/esm/compiled/components/text.js
  var asAllowlist = ["span", "p", "strong", "em"];
  var useColor = function useColor2(colorProp, hasTextAncestor) {
    var surface = useSurface();
    if (colorProp === "inherit") {
      return void 0;
    }
    if (colorProp) {
      return colorProp;
    }
    if (hasTextAncestor) {
      return void 0;
    }
    if (inverseColorMap.hasOwnProperty(surface)) {
      return inverseColorMap[surface];
    }
    return "color.text";
  };
  var styles4 = {
    root: "_19pkidpf _2hwxidpf _otyridpf _18u0idpf _1i4qfg65",
    "as.strong": "_k48pmoej",
    "as.em": "_zg8l1m30",
    "textAlign.center": "_y3gn1h6o",
    "textAlign.end": "_y3gnh9n0",
    "textAlign.start": "_y3gnv2br",
    truncation: "_1reo15vq _18m915vq _1e0ccj1k _sudp1e54",
    breakAll: "_1nmz9jpi"
  };
  var fontSizeMap = {
    medium: "_11c82smr",
    UNSAFE_small: "_11c8dcr7",
    large: "_11c81ixg",
    small: "_11c81o8v"
  };
  var fontWeightMap = {
    bold: "_k48pmoej",
    medium: "_k48p1wq8",
    regular: "_k48pi7a9",
    semibold: "_k48p1pd9"
  };
  var textColorMap = {
    "color.text": "_syaz1fxt",
    "color.text.accent.lime": "_syaz1tco",
    "color.text.accent.lime.bolder": "_syaz1ik3",
    "color.text.accent.red": "_syaz9lu1",
    "color.text.accent.red.bolder": "_syazhwvp",
    "color.text.accent.orange": "_syaz1q28",
    "color.text.accent.orange.bolder": "_syaz1vps",
    "color.text.accent.yellow": "_syazfb2s",
    "color.text.accent.yellow.bolder": "_syazekll",
    "color.text.accent.green": "_syazh55r",
    "color.text.accent.green.bolder": "_syaz1y78",
    "color.text.accent.teal": "_syaz17qg",
    "color.text.accent.teal.bolder": "_syaz12v7",
    "color.text.accent.blue": "_syazpnps",
    "color.text.accent.blue.bolder": "_syazsc1o",
    "color.text.accent.purple": "_syaz10m5",
    "color.text.accent.purple.bolder": "_syaz2ibx",
    "color.text.accent.magenta": "_syaz1s8m",
    "color.text.accent.magenta.bolder": "_syaz1qur",
    "color.text.accent.gray": "_syaz1dyx",
    "color.text.accent.gray.bolder": "_syaz1x9z",
    "color.text.disabled": "_syaz1lh4",
    "color.text.inverse": "_syaz15cr",
    "color.text.selected": "_syazaqb7",
    "color.text.brand": "_syaz1e6v",
    "color.text.danger": "_syaz1tmw",
    "color.text.warning": "_syazwx40",
    "color.text.warning.inverse": "_syazal3n",
    "color.text.success": "_syazy73q",
    "color.text.discovery": "_syazzjem",
    "color.text.information": "_syaze0os",
    "color.text.subtlest": "_syaz131l",
    "color.text.subtle": "_syaz1gjq",
    "color.link": "_syaz14q2",
    "color.link.pressed": "_syaz16c2",
    "color.link.visited": "_syazw7te",
    "color.link.visited.pressed": "_syazg3x0"
  };
  var inverseColorMap = {
    "color.background.neutral.bold": "color.text.inverse",
    "color.background.neutral.bold.hovered": "color.text.inverse",
    "color.background.neutral.bold.pressed": "color.text.inverse",
    "color.background.selected.bold": "color.text.inverse",
    "color.background.selected.bold.hovered": "color.text.inverse",
    "color.background.selected.bold.pressed": "color.text.inverse",
    "color.background.brand.bold": "color.text.inverse",
    "color.background.brand.bold.hovered": "color.text.inverse",
    "color.background.brand.bold.pressed": "color.text.inverse",
    "color.background.brand.boldest": "color.text.inverse",
    "color.background.brand.boldest.hovered": "color.text.inverse",
    "color.background.brand.boldest.pressed": "color.text.inverse",
    "color.background.danger.bold": "color.text.inverse",
    "color.background.danger.bold.hovered": "color.text.inverse",
    "color.background.danger.bold.pressed": "color.text.inverse",
    "color.background.warning.bold": "color.text.warning.inverse",
    "color.background.warning.bold.hovered": "color.text.warning.inverse",
    "color.background.warning.bold.pressed": "color.text.warning.inverse",
    "color.background.success.bold": "color.text.inverse",
    "color.background.success.bold.hovered": "color.text.inverse",
    "color.background.success.bold.pressed": "color.text.inverse",
    "color.background.discovery.bold": "color.text.inverse",
    "color.background.discovery.bold.hovered": "color.text.inverse",
    "color.background.discovery.bold.pressed": "color.text.inverse",
    "color.background.information.bold": "color.text.inverse",
    "color.background.information.bold.hovered": "color.text.inverse",
    "color.background.information.bold.pressed": "color.text.inverse"
  };
  var Text2 = /* @__PURE__ */ (0, import_react50.forwardRef)(function(_ref2, ref) {
    var _ref$as = _ref2.as, Component3 = _ref$as === void 0 ? "span" : _ref$as, colorProp = _ref2.color, align = _ref2.align, testId = _ref2.testId, id = _ref2.id, size2 = _ref2.size, weight = _ref2.weight, maxLines = _ref2.maxLines, xcss2 = _ref2.xcss, children = _ref2.children;
    invariant(asAllowlist.includes(Component3), '@atlaskit/primitives: Text received an invalid "as" value of "'.concat(Component3, '"'));
    var hasTextAncestor = useHasTextAncestor();
    var color = useColor(colorProp, hasTextAncestor);
    if (!size2 && !hasTextAncestor) {
      size2 = "medium";
    }
    var component = /* @__PURE__ */ React32.createElement(Component3, {
      id,
      className: ax([styles4.root, size2 && fontSizeMap[size2], color && textColorMap[color], maxLines && styles4.truncation, maxLines === 1 && styles4.breakAll, align && styles4["textAlign.".concat(align)], weight && fontWeightMap[weight], Component3 === "em" && styles4["as.em"], Component3 === "strong" && styles4["as.strong"], xcss2]),
      style: {
        WebkitLineClamp: maxLines
      },
      "data-testid": testId,
      ref
    }, children);
    if (hasTextAncestor) {
      return component;
    }
    return /* @__PURE__ */ React32.createElement(HasTextAncestorProvider, {
      value: true
    }, component);
  });
  var text_default = Text2;

  // node_modules/@atlaskit/primitives/dist/esm/compiled/components/pressable.js
  var React34 = __toESM(require_react());
  var import_react53 = __toESM(require_react());

  // node_modules/@atlaskit/ds-lib/dist/esm/utils/device-check.js
  function testPlatform(re) {
    var _window$navigator$use;
    return typeof window !== "undefined" && window.navigator != null ? (
      //@ts-expect-error ignore userAgentData type issue
      re.test(((_window$navigator$use = window.navigator["userAgentData"]) === null || _window$navigator$use === void 0 ? void 0 : _window$navigator$use.platform) || window.navigator.platform)
    ) : false;
  }
  function isIPhone() {
    return testPlatform(/^iPhone/i);
  }
  function isMac() {
    return testPlatform(/^Mac/i);
  }
  function isIPad() {
    return testPlatform(/^iPad/i) || // iPadOS 13 lies and says it's a Mac, but we can distinguish by detecting touch support.
    isMac() && navigator.maxTouchPoints > 1;
  }
  function isIOS() {
    return isIPhone() || isIPad();
  }
  function isSafari() {
    if (typeof window !== "undefined" && window.navigator != null) {
      var _window$navigator$use2;
      var ua = (_window$navigator$use2 = window.navigator.userAgent) === null || _window$navigator$use2 === void 0 ? void 0 : _window$navigator$use2.toLowerCase();
      return ua ? ua.includes("safari") && !ua.includes("chrome") : false;
    }
    return false;
  }
  function isAppleDevice() {
    return isMac() || isIOS();
  }

  // node_modules/@atlaskit/interaction-context/dist/esm/index.js
  var import_react51 = __toESM(require_react());
  var esm_default2 = /* @__PURE__ */ (0, import_react51.createContext)(null);

  // node_modules/@atlaskit/primitives/dist/esm/compiled/components/focusable.js
  init_defineProperty();
  var React33 = __toESM(require_react());
  var import_react52 = __toESM(require_react());
  var _excluded6 = ["as", "children", "isInset", "testId", "style", "xcss"];
  var _excluded23 = ["className"];
  function ownKeys8(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r && (o = o.filter(function(r2) {
        return Object.getOwnPropertyDescriptor(e, r2).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread8(e) {
    for (var r = 1; r < arguments.length; r++) {
      var t = null != arguments[r] ? arguments[r] : {};
      r % 2 ? ownKeys8(Object(t), true).forEach(function(r2) {
        _defineProperty(e, r2, t[r2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys8(Object(t)).forEach(function(r2) {
        Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
      });
    }
    return e;
  }
  var Focusable = /* @__PURE__ */ (0, import_react52.forwardRef)(function(_ref2, ref) {
    var _ref$as = _ref2.as, Component3 = _ref$as === void 0 ? "button" : _ref$as, children = _ref2.children, isInset = _ref2.isInset, testId = _ref2.testId, style = _ref2.style, xcss2 = _ref2.xcss, htmlAttributes = _objectWithoutProperties(_ref2, _excluded6);
    var _spreadClass = htmlAttributes.className, safeHtmlAttributes = _objectWithoutProperties(htmlAttributes, _excluded23);
    return /* @__PURE__ */ React33.createElement(Component3, _extends({}, safeHtmlAttributes, {
      // @ts-ignore Expression produces a union type that is too complex to represent. We may be able to narrow the type here but unsure.
      ref,
      className: ax(["_mizu194a _1ah31bk5 _ra3xnqa1 _128m1bk5 _1cvmnqa1 _4davt94y", isInset && "_1ah3115h _2mwq115h", xcss2]),
      "data-testid": testId,
      style: _objectSpread8(_objectSpread8({}, style), {}, {
        "--_1203r2w": cssCustomPropertyValue("calc(0px - ".concat("var(--ds-border-width-outline, 2px)", ")"))
      })
    }), children);
  });
  var focusable_default = Focusable;

  // node_modules/@atlaskit/primitives/dist/esm/compiled/components/pressable.js
  var _excluded7 = ["children", "isDisabled", "type", "onClick", "interactionName", "componentName", "analyticsContext", "style", "testId", "xcss", "tabIndex"];
  var _excluded24 = ["className"];
  var styles5 = {
    root: "_19itglyw _vchhusvi _r06hglyw _80omtlke",
    disabled: "_80om13gf"
  };
  var Pressable = /* @__PURE__ */ (0, import_react53.forwardRef)(function(_ref2, ref) {
    var children = _ref2.children, isDisabled = _ref2.isDisabled, _ref$type = _ref2.type, type = _ref$type === void 0 ? "button" : _ref$type, _ref$onClick = _ref2.onClick, providedOnClick = _ref$onClick === void 0 ? noop3 : _ref$onClick, interactionName = _ref2.interactionName, componentName = _ref2.componentName, analyticsContext = _ref2.analyticsContext, style = _ref2.style, testId = _ref2.testId, xcss2 = _ref2.xcss, tabIndex = _ref2.tabIndex, htmlAttributes = _objectWithoutProperties(_ref2, _excluded7);
    var interactionContext = (0, import_react53.useContext)(esm_default2);
    var handleClick = (0, import_react53.useCallback)(function(e, analyticsEvent) {
      interactionContext && interactionContext.tracePress(interactionName, e.timeStamp);
      providedOnClick(e, analyticsEvent);
    }, [providedOnClick, interactionContext, interactionName]);
    var onClick = usePlatformLeafEventHandler({
      fn: handleClick,
      action: "clicked",
      componentName: componentName || "Pressable",
      packageName: "@atlaskit/primitives",
      packageVersion: "14.11.2",
      analyticsData: analyticsContext,
      actionSubject: "button"
    });
    var _spreadClass = htmlAttributes.className, safeHtmlAttributes = _objectWithoutProperties(htmlAttributes, _excluded24);
    return /* @__PURE__ */ React34.createElement(
      focusable_default,
      _extends({
        as: "button",
        tabIndex: tabIndex !== null && tabIndex !== void 0 ? tabIndex : isSafari() && !isDisabled ? 0 : void 0,
        style
      }, safeHtmlAttributes, {
        type,
        onClick,
        disabled: isDisabled,
        xcss: cx(styles5.root, isDisabled && styles5.disabled, xcss2),
        testId,
        ref
      }),
      children
    );
  });
  var pressable_default = Pressable;

  // node_modules/@atlaskit/tokens/dist/esm/index.js
  init_constants();

  // node_modules/@atlaskit/visually-hidden/dist/esm/visually-hidden.js
  var React35 = __toESM(require_react());
  var VisuallyHidden = function VisuallyHidden2(_ref2) {
    var children = _ref2.children, testId = _ref2.testId, role = _ref2.role, id = _ref2.id;
    return /* @__PURE__ */ React35.createElement("span", {
      id,
      "data-testid": testId,
      role,
      className: ax(["_ca0qidpf _u5f3idpf _n3tdidpf _19bvidpf _19itidpf _1reo15vq _18m915vq _1bsbt94y _4t3it94y _kqswstnw _ogto7mnp _uiztglyw _o5721q9c"])
    }, children);
  };
  var visually_hidden_default = VisuallyHidden;

  // node_modules/@atlaskit/primitives/dist/esm/compiled/responsive/media-helper.js
  var media = {
    above: {
      // TODO: Should this even exist, we don't want `css({ [media.above.xxs]: { … } })` because that just adds duplicates styles!
      xxs: "@media all",
      xs: "@media (min-width: 30rem)",
      sm: "@media (min-width: 48rem)",
      md: "@media (min-width: 64rem)",
      lg: "@media (min-width: 90rem)",
      xl: "@media (min-width: 110.5rem)"
    },
    only: {
      xxs: "@media (min-width: 0rem) and (max-width: 29.99rem)",
      xs: "@media (min-width: 30rem) and (max-width: 47.99rem)",
      sm: "@media (min-width: 48rem) and (max-width: 63.99rem)",
      md: "@media (min-width: 64rem) and (max-width: 89.99rem)",
      lg: "@media (min-width: 90rem) and (max-width: 110.49rem)",
      xl: "@media (min-width: 110.5rem)"
    },
    below: {
      xs: "@media not all and (min-width: 30rem)",
      sm: "@media not all and (min-width: 48rem)",
      md: "@media not all and (min-width: 64rem)",
      lg: "@media not all and (min-width: 90rem)",
      xl: "@media not all and (min-width: 110.5rem)"
    }
  };

  // node_modules/@atlaskit/primitives/dist/esm/compiled/responsive/use-media-query.js
  var import_react55 = __toESM(require_react());
  var import_bind_event_listener5 = __toESM(require_dist());
  var _window;
  var _window$matchMedia;
  var _window2;
  var _window2$matchMedia;
  var _window3;
  var _window3$matchMedia;
  var _window4;
  var _window4$matchMedia;
  var _window5;
  var _window5$matchMedia;
  var _window6;
  var _window6$matchMedia;
  var _window7;
  var _window7$matchMedia;
  var _window8;
  var _window8$matchMedia;
  var _window9;
  var _window9$matchMedia;
  var _window0;
  var _window0$matchMedia;
  var _window1;
  var _window1$matchMedia;
  var queries = {
    "above.xxs": typeof window === "undefined" ? void 0 : (_window = window) === null || _window === void 0 || (_window$matchMedia = _window.matchMedia) === null || _window$matchMedia === void 0 ? void 0 : _window$matchMedia.call(_window, media.above.xxs.replace("@media ", "").trim()),
    "above.xs": typeof window === "undefined" ? void 0 : (_window2 = window) === null || _window2 === void 0 || (_window2$matchMedia = _window2.matchMedia) === null || _window2$matchMedia === void 0 ? void 0 : _window2$matchMedia.call(_window2, media.above.xs.replace("@media ", "").trim()),
    "above.sm": typeof window === "undefined" ? void 0 : (_window3 = window) === null || _window3 === void 0 || (_window3$matchMedia = _window3.matchMedia) === null || _window3$matchMedia === void 0 ? void 0 : _window3$matchMedia.call(_window3, media.above.sm.replace("@media ", "").trim()),
    "above.md": typeof window === "undefined" ? void 0 : (_window4 = window) === null || _window4 === void 0 || (_window4$matchMedia = _window4.matchMedia) === null || _window4$matchMedia === void 0 ? void 0 : _window4$matchMedia.call(_window4, media.above.md.replace("@media ", "").trim()),
    "above.lg": typeof window === "undefined" ? void 0 : (_window5 = window) === null || _window5 === void 0 || (_window5$matchMedia = _window5.matchMedia) === null || _window5$matchMedia === void 0 ? void 0 : _window5$matchMedia.call(_window5, media.above.lg.replace("@media ", "").trim()),
    "above.xl": typeof window === "undefined" ? void 0 : (_window6 = window) === null || _window6 === void 0 || (_window6$matchMedia = _window6.matchMedia) === null || _window6$matchMedia === void 0 ? void 0 : _window6$matchMedia.call(_window6, media.above.xl.replace("@media ", "").trim()),
    "below.xs": typeof window === "undefined" ? void 0 : (_window7 = window) === null || _window7 === void 0 || (_window7$matchMedia = _window7.matchMedia) === null || _window7$matchMedia === void 0 ? void 0 : _window7$matchMedia.call(_window7, media.below.xs.replace("@media ", "").trim()),
    "below.sm": typeof window === "undefined" ? void 0 : (_window8 = window) === null || _window8 === void 0 || (_window8$matchMedia = _window8.matchMedia) === null || _window8$matchMedia === void 0 ? void 0 : _window8$matchMedia.call(_window8, media.below.sm.replace("@media ", "").trim()),
    "below.md": typeof window === "undefined" ? void 0 : (_window9 = window) === null || _window9 === void 0 || (_window9$matchMedia = _window9.matchMedia) === null || _window9$matchMedia === void 0 ? void 0 : _window9$matchMedia.call(_window9, media.below.md.replace("@media ", "").trim()),
    "below.lg": typeof window === "undefined" ? void 0 : (_window0 = window) === null || _window0 === void 0 || (_window0$matchMedia = _window0.matchMedia) === null || _window0$matchMedia === void 0 ? void 0 : _window0$matchMedia.call(_window0, media.below.lg.replace("@media ", "").trim()),
    "below.xl": typeof window === "undefined" ? void 0 : (_window1 = window) === null || _window1 === void 0 || (_window1$matchMedia = _window1.matchMedia) === null || _window1$matchMedia === void 0 ? void 0 : _window1$matchMedia.call(_window1, media.below.xl.replace("@media ", "").trim())
  };
  var UNSAFE_useMediaQuery = function UNSAFE_useMediaQuery2(queryString, listener) {
    var listenerRef = (0, import_react55.useRef)(listener);
    (0, import_react55.useEffect)(function() {
      listenerRef.current = listener;
    }, [listener]);
    var hasListener = !!listener;
    var mq = queries[queryString];
    (0, import_react55.useLayoutEffect)(
      function() {
        listenerRef.current = listener;
        if (!mq || !hasListener || !listenerRef.current) {
          return;
        }
        return (0, import_bind_event_listener5.bind)(mq, {
          type: "change",
          listener: function listener2(event) {
            return listenerRef.current(event);
          }
        });
      },
      // eslint-disable-next-line react-hooks/exhaustive-deps -- explicitly do not trigger the effect on `listener` reference change, only on a boolean representation of it.
      [mq, hasListener]
    );
    return mq || null;
  };

  // node_modules/@atlaskit/popup/dist/esm/popper-wrapper.js
  init_toConsumableArray();
  init_slicedToArray();
  var React37 = __toESM(require_react());
  var import_react60 = __toESM(require_react());
  var import_platform_feature_flags10 = __toESM(require_cjs3());

  // node_modules/@atlaskit/popup/dist/esm/reposition-on-update.js
  var import_react56 = __toESM(require_react());
  var RepositionOnUpdate = function RepositionOnUpdate2(_ref2) {
    var children = _ref2.children, update = _ref2.update;
    var isFirstRenderRef = (0, import_react56.useRef)(true);
    (0, import_react56.useLayoutEffect)(function() {
      if (isFirstRenderRef.current) {
        isFirstRenderRef.current = false;
        return;
      }
      update();
    }, [update]);
    return /* @__PURE__ */ import_react56.default.createElement(import_react56.Fragment, null, children);
  };

  // node_modules/@atlaskit/popup/dist/esm/use-close-manager.js
  var import_react58 = __toESM(require_react());
  var import_bind_event_listener6 = __toESM(require_dist());
  var import_platform_feature_flags8 = __toESM(require_cjs3());

  // node_modules/@atlaskit/popup/dist/esm/utils/is-element-interactive.js
  var interactiveTags = ["button", "a", "input", "select", "textarea"];
  var isInteractiveElement = function isInteractiveElement2(element) {
    if (interactiveTags.includes(element.tagName.toLowerCase())) {
      return true;
    }
    if (element.getAttribute("tabindex") !== null || element.hasAttribute("contenteditable")) {
      return true;
    }
    return false;
  };

  // node_modules/@atlaskit/popup/dist/esm/utils/use-animation-frame.js
  var import_react57 = __toESM(require_react());
  var useAnimationFrame = function useAnimationFrame2() {
    var animationsRef = (0, import_react57.useRef)([]);
    var requestFrame = (0, import_react57.useCallback)(function(callback) {
      var id = requestAnimationFrame(callback);
      animationsRef.current.push(id);
      return id;
    }, []);
    var cancelFrame = (0, import_react57.useCallback)(function(id) {
      cancelAnimationFrame(id);
      animationsRef.current = animationsRef.current.filter(function(frameId) {
        return frameId !== id;
      });
    }, []);
    var cancelAllFrames = (0, import_react57.useCallback)(function() {
      animationsRef.current.forEach(function(id) {
        return cancelAnimationFrame(id);
      });
      animationsRef.current = [];
    }, []);
    return {
      requestFrame,
      cancelFrame,
      cancelAllFrames
    };
  };

  // node_modules/@atlaskit/popup/dist/esm/use-close-manager.js
  var useCloseManager = function useCloseManager2(_ref2) {
    var isOpen = _ref2.isOpen, onClose = _ref2.onClose, popupRef = _ref2.popupRef, triggerRef = _ref2.triggerRef, autoFocus = _ref2.autoFocus, shouldDisableFocusTrap = _ref2.shouldDisableFocusTrap, capture = _ref2.shouldUseCaptureOnOutsideClick, shouldCloseOnTab = _ref2.shouldCloseOnTab, shouldRenderToParent = _ref2.shouldRenderToParent;
    var _useLayering = useLayering(), isLayerDisabled = _useLayering.isLayerDisabled, currentLevel = _useLayering.currentLevel;
    var _useAnimationFrame = useAnimationFrame(), requestFrame = _useAnimationFrame.requestFrame, cancelAllFrames = _useAnimationFrame.cancelAllFrames;
    (0, import_react58.useEffect)(function() {
      if (!isOpen || !popupRef) {
        return noop3;
      }
      var inIframe = window && window.self !== window.top && (0, import_platform_feature_flags8.fg)("fix-dropdown-close-outside-iframe");
      var closePopup = function closePopup2(event) {
        if (onClose) {
          var _currentLevel = null;
          if (event.target instanceof HTMLElement) {
            var _event$target$closest;
            _currentLevel = (_event$target$closest = event.target.closest("[data-ds--level]")) === null || _event$target$closest === void 0 ? void 0 : _event$target$closest.getAttribute("data-ds--level");
          }
          _currentLevel ? onClose(event, Number(_currentLevel)) : onClose(event);
        }
        if (shouldDisableFocusTrap && (0, import_platform_feature_flags8.fg)("platform_dst_popup-disable-focuslock")) {
          requestFrame(function() {
            triggerRef === null || triggerRef === void 0 || triggerRef.setAttribute("tabindex", "0");
            if (popupRef && autoFocus) {
              popupRef.setAttribute("tabindex", "0");
            }
          });
        }
      };
      var onClick = function onClick2(event) {
        var target = event.target;
        var doesDomNodeExist = document.body.contains(target);
        if (!doesDomNodeExist && !inIframe) {
          return;
        }
        if (isLayerDisabled()) {
          if (target instanceof HTMLElement) {
            var _target$closest;
            var layeredElement = (_target$closest = target.closest) === null || _target$closest === void 0 ? void 0 : _target$closest.call(target, "[data-ds--level]");
            if (layeredElement) {
              var closeType = layeredElement.getAttribute("[data-ds--close--type]");
              if (closeType === "single") {
                return;
              }
              var levelOfClickedLayer = layeredElement.getAttribute("data-ds--level");
              if (levelOfClickedLayer && Number(levelOfClickedLayer) > currentLevel) {
                return;
              }
            }
          }
        }
        var isClickOnPopup = popupRef && popupRef.contains(target);
        var isClickOnTrigger = triggerRef && triggerRef.contains(target);
        if (!isClickOnPopup && !isClickOnTrigger) {
          closePopup(event);
          if (document.activeElement && !isInteractiveElement(document.activeElement) && (0, import_platform_feature_flags8.fg)("platform_dst_popup-disable-focuslock")) {
            triggerRef === null || triggerRef === void 0 || triggerRef.focus();
          }
        }
      };
      var onKeyDown = function onKeyDown2(event) {
        if ((0, import_platform_feature_flags8.fg)("platform_dst_popup-disable-focuslock")) {
          var key = event.key, shiftKey = event.shiftKey;
          if (shiftKey && key === "Tab" && !shouldRenderToParent) {
            if (isLayerDisabled()) {
              return;
            }
            requestFrame(function() {
              var isPopupFocusOut = popupRef && !popupRef.contains(document.activeElement);
              if (isPopupFocusOut) {
                closePopup(event);
                if (currentLevel === 1) {
                  triggerRef === null || triggerRef === void 0 || triggerRef.focus();
                }
              }
            });
            return;
          }
          if (key === "Tab") {
            var _document$activeEleme;
            if (shouldCloseOnTab) {
              if (isLayerDisabled()) {
                return;
              }
              closePopup(event);
              return;
            }
            if (isLayerDisabled() && (_document$activeEleme = document.activeElement) !== null && _document$activeEleme !== void 0 && _document$activeEleme.closest("[aria-modal]")) {
              return;
            }
            if (shouldDisableFocusTrap) {
              if (shouldRenderToParent) {
                requestFrame(function() {
                  var isPopupFocusOut = popupRef && !popupRef.contains(document.activeElement);
                  if (isPopupFocusOut) {
                    closePopup(event);
                  }
                });
              } else {
                requestFrame(function() {
                  if (!document.hasFocus()) {
                    closePopup(event);
                  }
                });
              }
              return;
            }
          }
          if (isLayerDisabled()) {
            return;
          }
          if (key === "Escape" || key === "Esc") {
            if (triggerRef && autoFocus) {
              triggerRef.focus();
            }
            closePopup(event);
          }
        } else {
          if (isLayerDisabled()) {
            return;
          }
          var _key = event.key;
          if (_key === "Escape" || _key === "Esc" || shouldCloseOnTab && _key === "Tab") {
            closePopup(event);
          }
        }
      };
      var parentUnbind;
      if (inIframe && isOpen) {
        parentUnbind = (0, import_bind_event_listener6.bind)(window.parent.window, {
          type: "click",
          listener: onClick,
          options: {
            capture
          }
        });
      }
      var unbind = noop3;
      if ((0, import_platform_feature_flags8.fg)("popup-onclose-fix")) {
        setTimeout(function() {
          unbind = (0, import_bind_event_listener6.bindAll)(window, [{
            type: "click",
            listener: onClick,
            options: {
              capture
            }
          }, {
            type: "keydown",
            listener: onKeyDown
          }]);
        }, 0);
      } else {
        unbind = (0, import_bind_event_listener6.bindAll)(window, [{
          type: "click",
          listener: onClick,
          options: {
            capture
          }
        }, {
          type: "keydown",
          listener: onKeyDown
        }]);
      }
      var unbindBlur = noop3;
      unbindBlur = (0, import_bind_event_listener6.bind)(window, {
        type: "blur",
        listener: function onBlur3(e) {
          if (isLayerDisabled() || !(document.activeElement instanceof HTMLIFrameElement)) {
            return;
          }
          closePopup(e);
        }
      });
      return function() {
        var _parentUnbind;
        if ((0, import_platform_feature_flags8.fg)("popup-onclose-fix")) {
          setTimeout(function() {
            unbind();
          }, 0);
        } else {
          unbind();
        }
        cancelAllFrames();
        (_parentUnbind = parentUnbind) === null || _parentUnbind === void 0 || _parentUnbind();
        unbindBlur();
      };
    }, [isOpen, onClose, popupRef, triggerRef, autoFocus, shouldDisableFocusTrap, capture, isLayerDisabled, shouldCloseOnTab, currentLevel, shouldRenderToParent, requestFrame, cancelAllFrames]);
  };

  // node_modules/@atlaskit/popup/dist/esm/use-focus-manager.js
  var import_react59 = __toESM(require_react());
  var import_focus_trap = __toESM(require_focus_trap());
  var import_platform_feature_flags9 = __toESM(require_cjs3());
  var useFocusManager = function useFocusManager2(_ref2) {
    var initialFocusRef = _ref2.initialFocusRef, popupRef = _ref2.popupRef, triggerRef = _ref2.triggerRef, autoFocus = _ref2.autoFocus, shouldCloseOnTab = _ref2.shouldCloseOnTab, shouldDisableFocusTrap = _ref2.shouldDisableFocusTrap, shouldReturnFocus = _ref2.shouldReturnFocus, shouldRenderToParent = _ref2.shouldRenderToParent;
    var _useAnimationFrame = useAnimationFrame(), requestFrame = _useAnimationFrame.requestFrame, cancelAllFrames = _useAnimationFrame.cancelAllFrames;
    var _useLayering = useLayering(), currentLevel = _useLayering.currentLevel;
    (0, import_react59.useEffect)(function() {
      if (!popupRef || shouldCloseOnTab) {
        return noop3;
      }
      if (shouldDisableFocusTrap && (0, import_platform_feature_flags9.fg)("platform_dst_popup-disable-focuslock")) {
        var isDropdown = popupRef.matches("[id^=ds--dropdown--]");
        var popups = document.querySelectorAll('[data-ds--level="'.concat(currentLevel - 1, '"]'));
        if (!(popups[popups.length - 1] && !shouldRenderToParent && isDropdown)) {
          requestFrame(function() {
            triggerRef === null || triggerRef === void 0 || triggerRef.setAttribute("tabindex", "-1");
            if (popupRef && autoFocus) {
              popupRef.setAttribute("tabindex", "-1");
            }
            (initialFocusRef || popupRef).focus();
          });
          return noop3;
        }
      }
      var trapConfig = {
        clickOutsideDeactivates: true,
        escapeDeactivates: true,
        initialFocus: initialFocusRef || popupRef,
        fallbackFocus: popupRef,
        returnFocusOnDeactivate: shouldReturnFocus
      };
      var focusTrap = (0, import_focus_trap.default)(popupRef, trapConfig);
      requestFrame(function() {
        focusTrap.activate();
      });
      return function() {
        cancelAllFrames();
        focusTrap.deactivate();
      };
    }, [popupRef, triggerRef, autoFocus, initialFocusRef, shouldCloseOnTab, shouldDisableFocusTrap, requestFrame, cancelAllFrames, shouldReturnFocus, shouldRenderToParent, currentLevel]);
  };

  // node_modules/@atlaskit/popup/dist/esm/popper-wrapper.js
  var _excluded8 = ["shouldRenderToParent", "shouldFitContainer", "children", "appearance", "className", "isReferenceHidden"];
  var wrapperStyles = {
    root: "_2rkoglpi _1e0c1ule _vchhusvi _1pby1nn1 _bfhk1bhr _16qs1cd0 _syaz1fxt _1q1l1bhr _nt751r31 _49pcglyw _1hvw1o36"
  };
  var focusRingStyles = {
    root: "_mizu194a _1ah31bk5 _ra3xnqa1 _128m1bk5 _1cvmnqa1 _4davt94y"
  };
  var DefaultPopupComponent = /* @__PURE__ */ (0, import_react60.forwardRef)(function(props, ref) {
    var shouldRenderToParent = props.shouldRenderToParent, shouldFitContainer = props.shouldFitContainer, children = props.children, appearance = props.appearance, className = props.className, isReferenceHidden = props.isReferenceHidden, htmlAttributes = _objectWithoutProperties(props, _excluded8);
    return /* @__PURE__ */ React37.createElement("div", _extends({
      // eslint-disable-next-line @atlaskit/ui-styling-standard/no-classname-prop
      className: ax([wrapperStyles.root, appearance === "UNSAFE_modal-below-sm" && "_dk5d1b66 _c71ldtre _kqsw1n9t _152t1b66", !shouldRenderToParent && "_1reo1wug _18m91wug", shouldFitContainer && "_1bsb1osq", className])
    }, htmlAttributes, {
      ref
    }), children);
  });
  function PopperWrapper(_ref2) {
    var xcss2 = _ref2.xcss, isOpen = _ref2.isOpen, id = _ref2.id, offset3 = _ref2.offset, testId = _ref2.testId, content = _ref2.content, fallbackPlacements = _ref2.fallbackPlacements, onClose = _ref2.onClose, boundary = _ref2.boundary, rootBoundary = _ref2.rootBoundary, shouldFlip = _ref2.shouldFlip, _ref$placement = _ref2.placement, placement = _ref$placement === void 0 ? "auto" : _ref$placement, _ref$popupComponent = _ref2.popupComponent, PopupContainer = _ref$popupComponent === void 0 ? DefaultPopupComponent : _ref$popupComponent, _ref$autoFocus = _ref2.autoFocus, autoFocus = _ref$autoFocus === void 0 ? true : _ref$autoFocus, triggerRef = _ref2.triggerRef, shouldUseCaptureOnOutsideClick = _ref2.shouldUseCaptureOnOutsideClick, shouldRenderToParent = _ref2.shouldRenderToParent, shouldFitContainer = _ref2.shouldFitContainer, shouldDisableFocusLock = _ref2.shouldDisableFocusLock, _ref$shouldReturnFocu = _ref2.shouldReturnFocus, shouldReturnFocus = _ref$shouldReturnFocu === void 0 ? true : _ref$shouldReturnFocu, strategy = _ref2.strategy, role = _ref2.role, label = _ref2.label, titleId = _ref2.titleId, modifiers = _ref2.modifiers, shouldFitViewport = _ref2.shouldFitViewport, _ref$appearance = _ref2.appearance, appearance = _ref$appearance === void 0 ? "default" : _ref$appearance;
    var _useState = (0, import_react60.useState)(null), _useState2 = _slicedToArray(_useState, 2), popupRef = _useState2[0], setPopupRef = _useState2[1];
    var _useState3 = (0, import_react60.useState)(null), _useState4 = _slicedToArray(_useState3, 2), initialFocusRef = _useState4[0], setInitialFocusRef = _useState4[1];
    var shouldCloseOnTab = shouldRenderToParent && shouldDisableFocusLock;
    var shouldDisableFocusTrap = role !== "dialog";
    useFocusManager({
      initialFocusRef,
      popupRef,
      shouldCloseOnTab,
      triggerRef,
      autoFocus,
      shouldDisableFocusTrap,
      shouldReturnFocus
    });
    useCloseManager({
      isOpen,
      onClose,
      popupRef,
      triggerRef,
      shouldUseCaptureOnOutsideClick,
      shouldCloseOnTab,
      autoFocus,
      shouldDisableFocusTrap,
      shouldRenderToParent
    });
    var _useLayering = useLayering(), currentLevel = _useLayering.currentLevel;
    var mergedModifiers = (0, import_react60.useMemo)(function() {
      return [{
        name: "flip",
        enabled: shouldFlip,
        options: {
          rootBoundary,
          boundary,
          fallbackPlacements
        }
      }].concat(_toConsumableArray(modifiers || []));
    }, [shouldFlip, rootBoundary, boundary, fallbackPlacements, modifiers]);
    return /* @__PURE__ */ React37.createElement(Popper2, {
      placement,
      offset: offset3,
      modifiers: mergedModifiers,
      strategy,
      shouldFitViewport
    }, function(_ref22) {
      var _ref3 = _ref22.ref, style = _ref22.style, placement2 = _ref22.placement, update = _ref22.update, isReferenceHidden = _ref22.isReferenceHidden;
      var popupContainer = /* @__PURE__ */ React37.createElement(
        PopupContainer,
        {
          className: ax([
            xcss2,
            // @ts-expect-error: `ax` is not typed correctly
            !initialFocusRef && // eslint-disable-next-line @atlaskit/platform/ensure-feature-flag-prefix
            (0, import_platform_feature_flags10.fg)("platform-design-system-apply-popup-wrapper-focus") && focusRingStyles.root
          ]),
          appearance,
          id,
          "data-ds--level": currentLevel,
          "data-placement": placement2,
          "data-testid": testId,
          role,
          "aria-label": label,
          "aria-labelledby": titleId,
          ref: function ref(node2) {
            if (node2) {
              if (typeof _ref3 === "function") {
                _ref3(node2);
              } else {
                _ref3.current = node2;
              }
              setPopupRef(node2);
            }
          },
          style: appearance === "UNSAFE_modal-below-sm" ? {} : style,
          tabIndex: autoFocus ? 0 : void 0,
          shouldRenderToParent,
          shouldFitContainer,
          isReferenceHidden
        },
        /* @__PURE__ */ React37.createElement(RepositionOnUpdate, {
          update
        }, content({
          update,
          isOpen,
          onClose,
          setInitialFocusRef
        }))
      );
      return /* @__PURE__ */ React37.createElement(import_react60.Fragment, null, popupContainer, appearance === "UNSAFE_modal-below-sm" && /* @__PURE__ */ React37.createElement("div", {
        className: ax(["_1r04idpf _kqsw1n9t _bfhk10xm"])
      }));
    });
  }
  var popper_wrapper_default = PopperWrapper;

  // node_modules/@atlaskit/popup/dist/esm/use-appearance.js
  init_slicedToArray();
  var import_react61 = __toESM(require_react());
  function usePopupAppearance(_ref2) {
    var _appearance = _ref2.appearance, _shouldRenderToParent = _ref2.shouldRenderToParent;
    var mq = UNSAFE_useMediaQuery("below.sm", function(e) {
      setIsSmallViewport(!!e.matches);
    });
    var _useState = (0, import_react61.useState)(!!(mq !== null && mq !== void 0 && mq.matches)), _useState2 = _slicedToArray(_useState, 2), isSmallViewport = _useState2[0], setIsSmallViewport = _useState2[1];
    var appearance = _appearance === "UNSAFE_modal-below-sm" && isSmallViewport ? "UNSAFE_modal-below-sm" : "default";
    var shouldRenderToParent = _shouldRenderToParent && appearance === "default";
    return {
      appearance,
      shouldRenderToParent
    };
  }

  // node_modules/@atlaskit/popup/dist/esm/use-get-memoized-merged-trigger-ref.js
  init_slicedToArray();
  var import_react62 = __toESM(require_react());

  // node_modules/memoize-one/dist/memoize-one.esm.js
  var safeIsNaN = Number.isNaN || function ponyfill(value) {
    return typeof value === "number" && value !== value;
  };
  function isEqual2(first, second) {
    if (first === second) {
      return true;
    }
    if (safeIsNaN(first) && safeIsNaN(second)) {
      return true;
    }
    return false;
  }
  function areInputsEqual2(newInputs, lastInputs) {
    if (newInputs.length !== lastInputs.length) {
      return false;
    }
    for (var i = 0; i < newInputs.length; i++) {
      if (!isEqual2(newInputs[i], lastInputs[i])) {
        return false;
      }
    }
    return true;
  }
  function memoizeOne(resultFn, isEqual3) {
    if (isEqual3 === void 0) {
      isEqual3 = areInputsEqual2;
    }
    var cache = null;
    function memoized() {
      var newArgs = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        newArgs[_i] = arguments[_i];
      }
      if (cache && cache.lastThis === this && isEqual3(newArgs, cache.lastArgs)) {
        return cache.lastResult;
      }
      var lastResult = resultFn.apply(this, newArgs);
      cache = {
        lastResult,
        lastArgs: newArgs,
        lastThis: this
      };
      return lastResult;
    }
    memoized.clear = function clear() {
      cache = null;
    };
    return memoized;
  }

  // node_modules/@atlaskit/popup/dist/esm/use-get-memoized-merged-trigger-ref.js
  var useGetMemoizedMergedTriggerRef = function useGetMemoizedMergedTriggerRef2() {
    var _useState = (0, import_react62.useState)(function() {
      return memoizeOne(function(ref, setTriggerRef, isOpen) {
        return function(node2) {
          if (node2 && isOpen) {
            if (typeof ref === "function") {
              ref(node2);
            } else if (ref) {
              ref.current = node2;
            }
            setTriggerRef(node2);
          }
        };
      });
    }), _useState2 = _slicedToArray(_useState, 1), getMemoizedMergedTriggerRef = _useState2[0];
    return getMemoizedMergedTriggerRef;
  };

  // node_modules/@atlaskit/popup/dist/esm/use-get-memoized-merged-trigger-ref-new.js
  init_slicedToArray();
  var import_react63 = __toESM(require_react());
  var useGetMemoizedMergedTriggerRefNew = function useGetMemoizedMergedTriggerRefNew2() {
    var _useState = (0, import_react63.useState)(function() {
      return memoizeOne(function(ref, setTriggerRef) {
        return function(node2) {
          if (node2) {
            if (typeof ref === "function") {
              ref(node2);
            } else if (ref) {
              ref.current = node2;
            }
            setTriggerRef(node2);
          }
        };
      });
    }), _useState2 = _slicedToArray(_useState, 1), getMemoizedMergedTriggerRefNew = _useState2[0];
    return getMemoizedMergedTriggerRefNew;
  };

  // node_modules/@atlaskit/popup/dist/esm/popup.js
  var defaultLayer = 400;
  var wrapperStyles2 = {
    root: "_kqswh2mm"
  };
  var Popup = /* @__PURE__ */ (0, import_react64.memo)(function(_ref2) {
    var xcss2 = _ref2.xcss, _ref$appearance = _ref2.appearance, inAppearance = _ref$appearance === void 0 ? "default" : _ref$appearance, isOpen = _ref2.isOpen, providedId = _ref2.id, offset3 = _ref2.offset, testId = _ref2.testId, trigger = _ref2.trigger, content = _ref2.content, onClose = _ref2.onClose, boundary = _ref2.boundary, _ref$rootBoundary = _ref2.rootBoundary, rootBoundary = _ref$rootBoundary === void 0 ? "viewport" : _ref$rootBoundary, _ref$shouldFlip = _ref2.shouldFlip, shouldFlip = _ref$shouldFlip === void 0 ? true : _ref$shouldFlip, _ref$placement = _ref2.placement, placement = _ref$placement === void 0 ? "auto" : _ref$placement, fallbackPlacements = _ref2.fallbackPlacements, PopupContainer = _ref2.popupComponent, _ref$autoFocus = _ref2.autoFocus, autoFocus = _ref$autoFocus === void 0 ? true : _ref$autoFocus, _ref$zIndex = _ref2.zIndex, zIndex = _ref$zIndex === void 0 ? defaultLayer : _ref$zIndex, _ref$shouldUseCapture = _ref2.shouldUseCaptureOnOutsideClick, shouldUseCaptureOnOutsideClick = _ref$shouldUseCapture === void 0 ? false : _ref$shouldUseCapture, _ref$shouldRenderToPa = _ref2.shouldRenderToParent, inShouldRenderToParent = _ref$shouldRenderToPa === void 0 ? false : _ref$shouldRenderToPa, _ref$shouldFitContain = _ref2.shouldFitContainer, shouldFitContainer = _ref$shouldFitContain === void 0 ? false : _ref$shouldFitContain, _ref$shouldDisableFoc = _ref2.shouldDisableFocusLock, shouldDisableFocusLock = _ref$shouldDisableFoc === void 0 ? false : _ref$shouldDisableFoc, _ref$shouldReturnFocu = _ref2.shouldReturnFocus, shouldReturnFocus = _ref$shouldReturnFocu === void 0 ? true : _ref$shouldReturnFocu, strategy = _ref2.strategy, role = _ref2.role, label = _ref2.label, titleId = _ref2.titleId, modifiers = _ref2.modifiers, shouldFitViewport = _ref2.shouldFitViewport;
    var _useState = (0, import_react64.useState)(null), _useState2 = _slicedToArray(_useState, 2), triggerRef = _useState2[0], setTriggerRef = _useState2[1];
    var getMergedTriggerRef = useGetMemoizedMergedTriggerRef();
    var getMergedTriggerRefNew = useGetMemoizedMergedTriggerRefNew();
    var generatedId = useId();
    var _usePopupAppearance = usePopupAppearance({
      appearance: inAppearance,
      shouldRenderToParent: inShouldRenderToParent
    }), appearance = _usePopupAppearance.appearance, shouldRenderToParent = _usePopupAppearance.shouldRenderToParent;
    var id = providedId || generatedId;
    var handleOpenLayerObserverCloseSignal = (0, import_react64.useCallback)(function() {
      onClose === null || onClose === void 0 || onClose(null);
    }, [onClose]);
    useNotifyOpenLayerObserver({
      isOpen,
      onClose: handleOpenLayerObserverCloseSignal
    });
    var renderPopperWrapper = /* @__PURE__ */ React38.createElement(Layering, {
      isDisabled: false
    }, /* @__PURE__ */ React38.createElement(popper_wrapper_default, {
      xcss: xcss2,
      appearance,
      content,
      isOpen,
      placement,
      fallbackPlacements,
      boundary,
      rootBoundary,
      shouldFlip,
      offset: offset3,
      popupComponent: PopupContainer,
      id,
      testId,
      onClose,
      autoFocus,
      shouldUseCaptureOnOutsideClick,
      shouldRenderToParent: shouldRenderToParent || shouldFitContainer,
      shouldFitContainer,
      shouldDisableFocusLock,
      shouldReturnFocus,
      triggerRef,
      strategy: shouldFitContainer ? "absolute" : strategy,
      role,
      label,
      titleId,
      modifiers,
      shouldFitViewport
    }));
    var popupContent = /* @__PURE__ */ React38.createElement(Manager, null, /* @__PURE__ */ React38.createElement(Reference, null, function(_ref22) {
      var ref = _ref22.ref;
      return trigger({
        ref: !(0, import_platform_feature_flags11.fg)("platform-design-system-popup-ref") ? getMergedTriggerRef(ref, setTriggerRef, isOpen) : getMergedTriggerRefNew(ref, setTriggerRef),
        "aria-controls": isOpen ? id : void 0,
        "aria-expanded": isOpen,
        "aria-haspopup": role === "dialog" && (0, import_platform_feature_flags11.fg)("platform_dst_popup-disable-focuslock") ? "dialog" : true
      });
    }), isOpen && (shouldRenderToParent || shouldFitContainer ? renderPopperWrapper : /* @__PURE__ */ React38.createElement(Portal, {
      zIndex
    }, renderPopperWrapper)));
    if (shouldFitContainer) {
      return /* @__PURE__ */ React38.createElement(box_default, {
        xcss: wrapperStyles2.root
      }, popupContent);
    }
    return popupContent;
  });

  // node_modules/@atlaskit/popup/dist/esm/index.js
  var esm_default3 = Popup;

  // node_modules/@atlaskit/button/dist/esm/new-button/variants/default/button.js
  var import_react72 = __toESM(require_react());

  // node_modules/@atlaskit/button/dist/esm/new-button/variants/shared/button-base.js
  var import_react69 = __toESM(require_react());

  // node_modules/@atlaskit/ds-lib/dist/esm/utils/merge-refs.js
  function mergeRefs(refs) {
    return function(value) {
      refs.forEach(function(ref) {
        if (typeof ref === "function") {
          ref(value);
        } else if (ref !== null) {
          ref.current = value;
        }
      });
    };
  }

  // node_modules/@atlaskit/ds-lib/dist/esm/hooks/use-auto-focus.js
  var import_react65 = __toESM(require_react());
  function useAutoFocus(ref, autoFocus) {
    var initialMount = (0, import_react65.useRef)(true);
    (0, import_react65.useEffect)(function() {
      if (ref && initialMount.current && autoFocus && ref.current) {
        ref.current.focus();
      }
      initialMount.current = false;
    }, [autoFocus, ref]);
  }

  // node_modules/@atlaskit/button/dist/esm/new-button/variants/shared/button-base.js
  var import_platform_feature_flags12 = __toESM(require_cjs3());

  // node_modules/@atlaskit/button/dist/esm/new-button/containers/split-button/split-button-context.js
  var import_react66 = __toESM(require_react());
  var SplitButtonContext = /* @__PURE__ */ (0, import_react66.createContext)(void 0);
  var useSplitButtonContext = function useSplitButtonContext2() {
    var context = (0, import_react66.useContext)(SplitButtonContext);
    if (!context) {
      return void 0;
    }
    if (context.appearance === "navigation") {
      var newContext = {
        spacing: "default",
        appearance: "subtle",
        isDisabled: false,
        isActiveOverSelected: false,
        isNavigationSplitButton: true,
        isHighlighted: context.isHighlighted
      };
      return newContext;
    }
    var splitButtonContext = {
      spacing: context.spacing,
      appearance: context.appearance,
      isDisabled: context.isDisabled,
      isActiveOverSelected: true,
      isNavigationSplitButton: false,
      isHighlighted: false
    };
    return splitButtonContext;
  };

  // node_modules/@atlaskit/button/dist/esm/new-button/variants/shared/block-events.js
  function abort(event) {
    event.preventDefault();
    event.stopPropagation();
  }
  var tabKeyCode = 9;
  function onKey(event) {
    if (event.keyCode === tabKeyCode) {
      return;
    }
    abort(event);
  }
  function blockEvents(shouldBlockEvents, events) {
    return shouldBlockEvents ? {
      onMouseDownCapture: abort,
      onMouseUpCapture: abort,
      onKeyDownCapture: onKey,
      onKeyUpCapture: onKey,
      onTouchStartCapture: abort,
      onTouchEndCapture: abort,
      onPointerDownCapture: abort,
      onPointerUpCapture: abort,
      onClickCapture: abort,
      // Just smashing the existing onClick for good measure
      onClick: abort
    } : events;
  }

  // node_modules/@atlaskit/button/dist/esm/new-button/variants/shared/loading-overlay.js
  var import_react68 = __toESM(require_react());

  // node_modules/@atlaskit/spinner/dist/esm/spinner.js
  var import_react67 = __toESM(require_react());

  // node_modules/@atlaskit/spinner/dist/esm/constants.js
  var presetSizes = {
    xsmall: 12,
    small: 16,
    medium: 24,
    large: 48,
    xlarge: 96
  };

  // node_modules/@atlaskit/spinner/dist/esm/spinner.js
  function getStrokeColor(appearance) {
    return appearance === "inherit" ? "var(--ds-icon-subtle, ".concat(N500, ")") : "var(--ds-icon-inverse, ".concat(N0, ")");
  }
  var styles6 = {
    rotateStyles: "_j7hqsf8s _5sag12kz _tip812c5 _1pgl2qsq _8hrz1h6o",
    loadInStyles: "_j7hq1ky6 _5sag9cwz _1pgl1ytf _1o51q7pw",
    wrapperStyles: "_1e0c116y _s7n4nkob",
    circleStyles: "_lswuglyw _7ljx1dhp _1snbbs82 _jcxd7g3v _1tjm1onz"
  };
  var useLayoutEffect5 = typeof window === "undefined" ? import_react67.useEffect : import_react67.useLayoutEffect;
  var Spinner = /* @__PURE__ */ import_react67.default.memo(/* @__PURE__ */ import_react67.default.forwardRef(function Spinner2(_ref2, ref) {
    var _ref$appearance = _ref2.appearance, appearance = _ref$appearance === void 0 ? "inherit" : _ref$appearance, _ref$delay = _ref2.delay, delay = _ref$delay === void 0 ? 0 : _ref$delay, interactionName = _ref2.interactionName, label = _ref2.label, _ref$size = _ref2.size, providedSize = _ref$size === void 0 ? "medium" : _ref$size, testId = _ref2.testId;
    var size2 = typeof providedSize === "number" ? providedSize : presetSizes[providedSize];
    var animationDelay = "".concat(delay, "ms");
    var stroke = getStrokeColor(appearance);
    var context = (0, import_react67.useContext)(esm_default2);
    useLayoutEffect5(function() {
      if (context != null) {
        return context.hold(interactionName);
      }
    }, [context, interactionName]);
    return /* @__PURE__ */ import_react67.default.createElement("span", {
      "data-testid": testId ? "".concat(testId, "-wrapper") : "spinner-wrapper",
      style: {
        animationDelay,
        width: size2,
        height: size2
      },
      className: ax([styles6.wrapperStyles, styles6.rotateStyles])
    }, /* @__PURE__ */ import_react67.default.createElement("svg", {
      height: size2,
      width: size2,
      viewBox: "0 0 16 16",
      xmlns: "http://www.w3.org/2000/svg",
      "data-testid": testId,
      ref,
      "aria-label": label || void 0,
      // eslint-disable-next-line @atlaskit/ui-styling-standard/enforce-style-prop -- Ignored via go/DSP-18766
      style: {
        animationDelay
      },
      role: label ? "img" : "none",
      className: ax([styles6.loadInStyles])
    }, /* @__PURE__ */ import_react67.default.createElement("circle", {
      cx: "8",
      cy: "8",
      r: "7",
      style: {
        stroke
      },
      className: ax([styles6.circleStyles])
    })));
  }));
  var spinner_default = Spinner;

  // node_modules/@atlaskit/button/dist/esm/new-button/variants/shared/loading-overlay.js
  function getIconSpacing(spacing) {
    switch (spacing) {
      case "compact":
        return "small";
      default:
        return "medium";
    }
  }
  function getSpinnerAppearance(_ref2) {
    var appearance = _ref2.appearance, isDisabled = _ref2.isDisabled, isSelected = _ref2.isSelected;
    if (isDisabled || isSelected) {
      return "inherit";
    }
    if (appearance === "primary" || appearance === "danger" || appearance === "discovery") {
      return "invert";
    }
    return "inherit";
  }
  function renderLoadingOverlay(_ref2) {
    var appearance = _ref2.appearance, spacing = _ref2.spacing, isDisabled = _ref2.isDisabled, isSelected = _ref2.isSelected, testId = _ref2.testId;
    return /* @__PURE__ */ import_react68.default.createElement(spinner_default, {
      size: getIconSpacing(spacing),
      appearance: getSpinnerAppearance({
        appearance,
        isDisabled,
        isSelected
      }),
      testId: testId ? "".concat(testId, "--loading-spinner") : void 0
    });
  }

  // node_modules/@atlaskit/button/dist/esm/new-button/variants/shared/button-base.js
  var _excluded9 = ["appearance", "autoFocus", "isDisabled", "isLoading", "isSelected", "isIconButton", "isCircle", "hasIconBefore", "hasIconAfter", "shouldFitContainer", "spacing", "ariaLabel", "ariaLabelledBy", "children", "interactionName", "onClick", "onMouseDown", "onMouseDownCapture", "onMouseUp", "onMouseUpCapture", "onKeyDown", "onKeyDownCapture", "onKeyUp", "onKeyUpCapture", "onTouchStart", "onTouchStartCapture", "onTouchEnd", "onTouchEndCapture", "onPointerDown", "onPointerDownCapture", "onPointerUp", "onPointerUpCapture", "onClickCapture", "testId", "analyticsContext", "componentName", "role", "onMouseOver", "onMouseOut", "onFocus", "onBlur", "onMouseMove", "type"];
  var _excluded25 = ["className", "css", "as", "style"];
  var LOADING_LABEL = ", Loading";
  var styles7 = {
    base: "_2rkosqtm _11c82smr _v5649dqc _189eidpf _1rjc12x7 _1e0c116y _vchhusvi _1bsb1wug _p12f1osq _kqswh2mm _4cvr1q9y _1bah1h6o _gy1p1b66 _1o9zidpf _4t3iviql _k48p1wq8 _y4tiutpp _bozgutpp _y3gn1h6o _s7n4nkob _14mj1kw7 _9v7aze3t _1tv3nqa1 _39yqe4h9 _11fnglyw _18postnw",
    linkDecorationUnset: "_4bfu1r31 _1hmsglyw _ajmmnqa1 _1a3b1r31 _4fprglyw _5goinqa1 _9oik1r31 _1bnxglyw _jf4cnqa1 _1nrm1r31 _c2waglyw _1iohnqa1",
    disabled: "_80om13gf _syaz1lh4 _30l31lh4 _9h8h1lh4",
    sharedDisabled: "_bfhk1fvb _irr31fvb _1di61fvb",
    spacingCompact: "_1rjcv77o _gy1p1b66 _4t3i1k8s _y4tiutpp _bozgutpp _s7n4nkob",
    circle: "_2rko14q2",
    fullWidth: "_1bsb1osq",
    loading: "_80om15jw",
    iconButton: "_4t3iviql _1bsbviql _y4tize3t _bozgze3t",
    iconButtonCompact: "_4t3i1k8s _1bsb1k8s",
    buttonIconBefore: "_bozgu2gc",
    buttonIconAfter: "_y4tiu2gc",
    splitButton: "_g0pbb4wl",
    loadingOverlay: "_1reo15vq _18m915vq _1e0c1txw _kqswstnw _4cvr1h6o _1bah1h6o _u7coze3t _152tze3t _rjxpze3t _1e02ze3t",
    navigationSplitButton: "_1bsb1tcg _bfhksm61 _y4ti12x7 _bozg12x7"
  };
  var defaultStyles = {
    root: "_bfhk1j54 _syaz10s3 _105310s3 _f8pj10s3 _30l310s3 _9h8h10s3",
    rootRefreshed: "_bfhksm61 _syaz1gjq _8l3mmuej _aetrb3bt _10531gjq _f8pj1gjq _30l31gjq _9h8h1gjq",
    interactive: "_irr3yw9d _30l310s3 _1di6ih13 _9h8h10s3",
    interactiveRefreshed: "_irr3166n _30l31gjq _1di61dty _9h8h1gjq",
    disabledRefreshed: "_bfhk1j28 _8l3m13gt _irr31j28 _1di61j28"
  };
  var primaryStyles = {
    root: "_bfhkomb0 _syaz15cr _105315cr _f8pj15cr _30l315cr _9h8h15cr",
    interactive: "_30l315cr _irr31wqm _9h8h15cr _1di617hq"
  };
  var warningStyles = {
    root: "_bfhk1ikc _syazal3n _1053al3n _f8pjal3n _30l3al3n _9h8hal3n",
    interactive: "_30l3al3n _irr31j43 _9h8hal3n _1di6h4op"
  };
  var dangerStyles = {
    root: "_bfhk1v7l _syaz15cr _105315cr _f8pj15cr _30l315cr _9h8h15cr",
    interactive: "_30l315cr _irr31rwk _9h8h15cr _1di6yycf"
  };
  var discoveryStyles = {
    root: "_bfhk1vbi _syaz15cr _105315cr _f8pj15cr _30l315cr _9h8h15cr",
    interactive: "_30l315cr _irr37gr8 _9h8h15cr _1di61wu2"
  };
  var subtleStyles = {
    root: "_bfhkqtfy _syaz10s3 _105310s3 _f8pj10s3 _30l310s3 _9h8h10s3",
    rootRefreshed: "_bfhkqtfy _syaz1gjq _10531gjq _f8pj1gjq _30l31gjq _9h8h1gjq",
    interactive: "_irr34mfv _30l310s3 _1di619qy _9h8h10s3",
    interactiveRefreshed: "_irr34mfv _30l31gjq _1di619qy _9h8h1gjq",
    disabledRefreshed: "_bfhk1j28 _8l3m13gt _irr31j28 _1di61j28"
  };
  var selectedStyles = {
    root: "_bfhk7btw _syaz1pke _10531pke _f8pj1pke _30l31pke _9h8h1pke",
    rootRefreshed: "_bfhkfg4m _syaz1ldt _8l3mcoux _aetrb3bt _10531ldt _f8pj1ldt _30l31ldt _9h8h1ldt",
    insideSplitButton: "_1pbycs5v",
    interactive: "_irr3t71w _30l31pke _1di6yssv _9h8h1pke",
    warning: "_bfhkvdtc _syaz16q2 _30l31pke _irr3vdtc _9h8h1pke _1di6vdtc",
    danger: "_bfhkbeib _syaz1pke _30l31pke _irr3beib _9h8h1pke _1di6beib",
    discovery: "_bfhk1g49 _syaz1pke _30l31pke _irr31g49 _9h8h1pke _1di61g49"
  };
  var ButtonBase = /* @__PURE__ */ import_react69.default.forwardRef(function(_ref2, ref) {
    var propAppearance = _ref2.appearance, _ref$autoFocus = _ref2.autoFocus, autoFocus = _ref$autoFocus === void 0 ? false : _ref$autoFocus, _ref$isDisabled = _ref2.isDisabled, propIsDisabled = _ref$isDisabled === void 0 ? false : _ref$isDisabled, _ref$isLoading = _ref2.isLoading, isLoading = _ref$isLoading === void 0 ? false : _ref$isLoading, _ref$isSelected = _ref2.isSelected, propIsSelected = _ref$isSelected === void 0 ? false : _ref$isSelected, _ref$isIconButton = _ref2.isIconButton, isIconButton = _ref$isIconButton === void 0 ? false : _ref$isIconButton, _ref$isCircle = _ref2.isCircle, isCircle = _ref$isCircle === void 0 ? false : _ref$isCircle, _ref$hasIconBefore = _ref2.hasIconBefore, hasIconBefore = _ref$hasIconBefore === void 0 ? false : _ref$hasIconBefore, _ref$hasIconAfter = _ref2.hasIconAfter, hasIconAfter = _ref$hasIconAfter === void 0 ? false : _ref$hasIconAfter, _ref$shouldFitContain = _ref2.shouldFitContainer, shouldFitContainer = _ref$shouldFitContain === void 0 ? false : _ref$shouldFitContain, _ref$spacing = _ref2.spacing, propSpacing = _ref$spacing === void 0 ? "default" : _ref$spacing, ariaLabel = _ref2.ariaLabel, ariaLabelledBy = _ref2.ariaLabelledBy, children = _ref2.children, interactionName = _ref2.interactionName, onClick = _ref2.onClick, onMouseDown = _ref2.onMouseDown, onMouseDownCapture = _ref2.onMouseDownCapture, onMouseUp = _ref2.onMouseUp, onMouseUpCapture = _ref2.onMouseUpCapture, onKeyDown = _ref2.onKeyDown, onKeyDownCapture = _ref2.onKeyDownCapture, onKeyUp = _ref2.onKeyUp, onKeyUpCapture = _ref2.onKeyUpCapture, onTouchStart = _ref2.onTouchStart, onTouchStartCapture = _ref2.onTouchStartCapture, onTouchEnd = _ref2.onTouchEnd, onTouchEndCapture = _ref2.onTouchEndCapture, onPointerDown = _ref2.onPointerDown, onPointerDownCapture = _ref2.onPointerDownCapture, onPointerUp = _ref2.onPointerUp, onPointerUpCapture = _ref2.onPointerUpCapture, onClickCapture = _ref2.onClickCapture, testId = _ref2.testId, analyticsContext = _ref2.analyticsContext, componentName = _ref2.componentName, role = _ref2.role, onMouseOver = _ref2.onMouseOver, onMouseOut = _ref2.onMouseOut, onFocus3 = _ref2.onFocus, onBlur3 = _ref2.onBlur, onMouseMove = _ref2.onMouseMove, type = _ref2.type, unsafeRest = _objectWithoutProperties(_ref2, _excluded9);
    var localRef = (0, import_react69.useRef)(null);
    var splitButtonContext = useSplitButtonContext();
    var loadingLabelId = useId();
    var isSplitButton = Boolean(splitButtonContext);
    var isNavigationSplitButton = (splitButtonContext === null || splitButtonContext === void 0 ? void 0 : splitButtonContext.isNavigationSplitButton) || false;
    var isDefaultAppearanceSplitButton = (splitButtonContext === null || splitButtonContext === void 0 ? void 0 : splitButtonContext.appearance) === "default";
    var appearance = isDefaultAppearanceSplitButton && (0, import_platform_feature_flags12.fg)("platform-component-visual-refresh") ? "subtle" : propAppearance || (splitButtonContext === null || splitButtonContext === void 0 ? void 0 : splitButtonContext.appearance) || "default";
    var spacing = (splitButtonContext === null || splitButtonContext === void 0 ? void 0 : splitButtonContext.spacing) || propSpacing;
    var isDisabled = (splitButtonContext === null || splitButtonContext === void 0 ? void 0 : splitButtonContext.isDisabled) || propIsDisabled;
    var isInteractive = !isDisabled && !isLoading;
    var isEffectivelyDisabled = isDisabled || isLoading;
    var isSelected = propIsSelected && !isDisabled;
    useAutoFocus(localRef, autoFocus);
    var _className = unsafeRest.className, _css = unsafeRest.css, _as = unsafeRest.as, _style = unsafeRest.style, saferRest = _objectWithoutProperties(unsafeRest, _excluded25);
    return /* @__PURE__ */ import_react69.default.createElement(pressable_default, _extends({}, saferRest, {
      componentName: componentName || "button",
      analyticsContext,
      role,
      ref: mergeRefs([localRef, ref]),
      xcss: cx2(
        styles7.base,
        appearance === "default" && ((0, import_platform_feature_flags12.fg)("platform-component-visual-refresh") ? defaultStyles.rootRefreshed : defaultStyles.root),
        appearance === "default" && isInteractive && ((0, import_platform_feature_flags12.fg)("platform-component-visual-refresh") ? defaultStyles.interactiveRefreshed : defaultStyles.interactive),
        appearance === "primary" && primaryStyles.root,
        appearance === "primary" && isInteractive && primaryStyles.interactive,
        appearance === "warning" && warningStyles.root,
        appearance === "warning" && isInteractive && warningStyles.interactive,
        appearance === "danger" && dangerStyles.root,
        appearance === "danger" && isInteractive && dangerStyles.interactive,
        appearance === "discovery" && discoveryStyles.root,
        appearance === "discovery" && isInteractive && discoveryStyles.interactive,
        appearance === "subtle" && ((0, import_platform_feature_flags12.fg)("platform-component-visual-refresh") ? subtleStyles.rootRefreshed : subtleStyles.root),
        appearance === "subtle" && isInteractive && ((0, import_platform_feature_flags12.fg)("platform-component-visual-refresh") ? subtleStyles.interactiveRefreshed : subtleStyles.interactive),
        styles7.linkDecorationUnset,
        isSelected && ((0, import_platform_feature_flags12.fg)("platform-component-visual-refresh") ? selectedStyles.rootRefreshed : selectedStyles.root),
        isSelected && isSplitButton && selectedStyles.insideSplitButton,
        isSelected && isInteractive && selectedStyles.interactive,
        // TODO: remove me once we kill color fallbacks
        isSelected && appearance === "danger" && selectedStyles.danger,
        // TODO: remove me once we kill color fallbacks
        isSelected && appearance === "warning" && selectedStyles.warning,
        // TODO: remove me once we kill color fallbacks
        isSelected && appearance === "discovery" && selectedStyles.discovery,
        isDisabled && styles7.disabled,
        isDisabled && (!(0, import_platform_feature_flags12.fg)("platform-component-visual-refresh") || appearance !== "default" && appearance !== "subtle") && styles7.sharedDisabled,
        isDisabled && appearance === "default" && ((0, import_platform_feature_flags12.fg)("platform-component-visual-refresh") ? defaultStyles.disabledRefreshed : defaultStyles.disabled),
        isCircle && !isSplitButton && styles7.circle,
        spacing === "compact" && styles7.spacingCompact,
        hasIconBefore && styles7.buttonIconBefore,
        shouldFitContainer && styles7.fullWidth,
        hasIconAfter && styles7.buttonIconAfter,
        isIconButton && styles7.iconButton,
        isIconButton && spacing === "compact" && styles7.iconButtonCompact,
        isLoading && styles7.loading,
        isSplitButton && styles7.splitButton,
        isNavigationSplitButton && styles7.navigationSplitButton
      ),
      isDisabled: isEffectivelyDisabled,
      "aria-label": isLoading && ariaLabel && !ariaLabelledBy ? "".concat(ariaLabel, " ").concat(LOADING_LABEL) : ariaLabel,
      "aria-labelledby": isLoading && ariaLabelledBy ? "".concat(ariaLabelledBy, " ").concat(loadingLabelId) : ariaLabelledBy,
      onClick
    }, blockEvents(isEffectivelyDisabled, {
      onMouseDownCapture,
      onMouseUpCapture,
      onKeyDownCapture,
      onKeyUpCapture,
      onTouchStartCapture,
      onTouchEndCapture,
      onPointerDownCapture,
      onPointerUpCapture,
      onClickCapture
    }), {
      testId,
      onMouseOver,
      onFocus: onFocus3,
      onMouseMove,
      onBlur: onBlur3,
      type,
      interactionName,
      onMouseDown,
      onMouseUp,
      onKeyDown,
      onMouseOut,
      onKeyUp,
      onTouchStart,
      onTouchEnd,
      onPointerDown,
      onPointerUp
    }), /* @__PURE__ */ import_react69.default.createElement(SplitButtonContext.Provider, {
      value: void 0
    }, children, isLoading && /* @__PURE__ */ import_react69.default.createElement("span", {
      className: ax([styles7.loadingOverlay])
    }, renderLoadingOverlay({
      spacing,
      appearance,
      isDisabled,
      isSelected,
      testId
    })), isLoading && (ariaLabelledBy || !ariaLabel) && /* @__PURE__ */ import_react69.default.createElement(visually_hidden_default, {
      id: loadingLabelId
    }, LOADING_LABEL)));
  });
  var button_base_default = ButtonBase;

  // node_modules/@atlaskit/button/dist/esm/new-button/variants/shared/content.js
  var import_react70 = __toESM(require_react());
  var styles8 = {
    text: "_1reo15vq _18m915vq _16jlkb7n _1o9zkb7n _1bto1l2s _o5721q9c",
    icon: "_1e0c1txw _16jlidpf _1o9zidpf _1wpz1h6o _1wybidpf _vwz4idpf _uiztglyw",
    beforeIcon: "_1he91b66 _w795v77o",
    afterIcon: "_1he9v77o _w7951b66",
    common: "_v564g17y",
    fade: "_tzy4idpf"
  };
  var Content = function Content2(_ref2) {
    var children = _ref2.children, _ref$type = _ref2.type, type = _ref$type === void 0 ? "text" : _ref$type, isLoading = _ref2.isLoading, position2 = _ref2.position;
    return /* @__PURE__ */ import_react70.default.createElement("span", {
      className: ax([styles8.common, type === "text" && styles8.text, type === "icon" && styles8.icon, isLoading && styles8.fade, position2 === "before" && styles8.beforeIcon, position2 === "after" && styles8.afterIcon])
    }, children);
  };
  var content_default = Content;

  // node_modules/@atlaskit/button/dist/esm/new-button/variants/shared/icon-renderer.js
  var import_react71 = __toESM(require_react());
  function isIconRenderProp(func) {
    return !func.displayName && // most function components and class components have a displayName, negate them
    !func.render && // forwardRef doesn't require a display name, however it does include a render function, negate them
    typeof func === "function";
  }
  var IconRenderer = function IconRenderer2(_ref2) {
    var Icon = _ref2.icon;
    return (
      // @ts-ignore - TS2322 TypeScript 5.9.2 upgrade
      /* @__PURE__ */ import_react71.default.createElement(import_react71.default.Fragment, null, isIconRenderProp(Icon) ? Icon({
        label: "",
        color: "currentColor"
      }) : /* @__PURE__ */ import_react71.default.createElement(Icon, {
        label: "",
        color: "currentColor"
      }))
    );
  };
  var icon_renderer_default = IconRenderer;

  // node_modules/@atlaskit/button/dist/esm/new-button/variants/default/button.js
  var _excluded10 = ["analyticsContext", "appearance", "aria-label", "aria-labelledby", "autoFocus", "children", "iconAfter", "iconBefore", "interactionName", "isDisabled", "isLoading", "isSelected", "onClick", "onClickCapture", "onKeyDownCapture", "onKeyUpCapture", "onMouseDownCapture", "onMouseUpCapture", "onPointerDownCapture", "onPointerUpCapture", "onTouchEndCapture", "onTouchStartCapture", "shouldFitContainer", "spacing", "testId", "type"];
  var _excluded26 = ["className", "css", "as", "style"];
  var Button = /* @__PURE__ */ import_react72.default.memo(/* @__PURE__ */ import_react72.default.forwardRef(function Button2(_ref2, ref) {
    var analyticsContext = _ref2.analyticsContext, appearance = _ref2.appearance, ariaLabel = _ref2["aria-label"], ariaLabelledBy = _ref2["aria-labelledby"], autoFocus = _ref2.autoFocus, children = _ref2.children, iconAfter = _ref2.iconAfter, iconBefore = _ref2.iconBefore, interactionName = _ref2.interactionName, isDisabled = _ref2.isDisabled, _ref$isLoading = _ref2.isLoading, isLoading = _ref$isLoading === void 0 ? false : _ref$isLoading, isSelected = _ref2.isSelected, onClick = _ref2.onClick, onClickCapture = _ref2.onClickCapture, onKeyDownCapture = _ref2.onKeyDownCapture, onKeyUpCapture = _ref2.onKeyUpCapture, onMouseDownCapture = _ref2.onMouseDownCapture, onMouseUpCapture = _ref2.onMouseUpCapture, onPointerDownCapture = _ref2.onPointerDownCapture, onPointerUpCapture = _ref2.onPointerUpCapture, onTouchEndCapture = _ref2.onTouchEndCapture, onTouchStartCapture = _ref2.onTouchStartCapture, shouldFitContainer = _ref2.shouldFitContainer, spacing = _ref2.spacing, testId = _ref2.testId, _ref$type = _ref2.type, type = _ref$type === void 0 ? "button" : _ref$type, unsafeRest = _objectWithoutProperties(_ref2, _excluded10);
    var _className = unsafeRest.className, _css = unsafeRest.css, _as = unsafeRest.as, _style = unsafeRest.style, saferRest = _objectWithoutProperties(unsafeRest, _excluded26);
    return /* @__PURE__ */ import_react72.default.createElement(button_base_default, _extends({
      analyticsContext,
      ref,
      appearance,
      autoFocus,
      isDisabled,
      isLoading,
      isSelected,
      hasIconBefore: Boolean(iconBefore),
      hasIconAfter: Boolean(iconAfter),
      shouldFitContainer,
      spacing,
      ariaLabel,
      ariaLabelledBy,
      onClick,
      onClickCapture,
      onKeyDownCapture,
      onKeyUpCapture,
      onMouseDownCapture,
      onMouseUpCapture,
      onPointerDownCapture,
      onPointerUpCapture,
      onTouchStartCapture,
      onTouchEndCapture,
      testId,
      componentName: "Button",
      type,
      interactionName
    }, saferRest), /* @__PURE__ */ import_react72.default.createElement(import_react72.Fragment, null, iconBefore && /* @__PURE__ */ import_react72.default.createElement(content_default, {
      type: "icon",
      position: "before",
      isLoading
    }, /* @__PURE__ */ import_react72.default.createElement(icon_renderer_default, {
      icon: iconBefore
    })), children && /* @__PURE__ */ import_react72.default.createElement(content_default, {
      isLoading
    }, children), iconAfter && /* @__PURE__ */ import_react72.default.createElement(content_default, {
      type: "icon",
      position: "after",
      isLoading
    }, /* @__PURE__ */ import_react72.default.createElement(icon_renderer_default, {
      icon: iconAfter
    }))));
  }));
  Button.displayName = "Button";
  var button_default = Button;

  // node_modules/@atlaskit/button/dist/esm/new-button/variants/icon/button.js
  var import_react73 = __toESM(require_react());
  var _excluded11 = ["aria-label", "aria-labelledby", "analyticsContext", "appearance", "autoFocus", "icon", "interactionName", "isDisabled", "isLoading", "isSelected", "isTooltipDisabled", "label", "onClick", "onClickCapture", "onKeyDownCapture", "onKeyUpCapture", "onMouseDownCapture", "onMouseUpCapture", "onPointerDownCapture", "onPointerUpCapture", "onTouchEndCapture", "onTouchStartCapture", "shape", "spacing", "testId", "tooltip", "type"];
  var _excluded27 = ["className", "css", "as", "style"];
  var IconButton = /* @__PURE__ */ import_react73.default.memo(/* @__PURE__ */ import_react73.default.forwardRef(function Button3(_ref2, ref) {
    var _tooltip$content;
    var preventedAriaLabel = _ref2["aria-label"], ariaLabelledBy = _ref2["aria-labelledby"], analyticsContext = _ref2.analyticsContext, appearance = _ref2.appearance, autoFocus = _ref2.autoFocus, icon = _ref2.icon, interactionName = _ref2.interactionName, isDisabled = _ref2.isDisabled, _ref$isLoading = _ref2.isLoading, isLoading = _ref$isLoading === void 0 ? false : _ref$isLoading, isSelected = _ref2.isSelected, _ref$isTooltipDisable = _ref2.isTooltipDisabled, isTooltipDisabled = _ref$isTooltipDisable === void 0 ? true : _ref$isTooltipDisable, label = _ref2.label, _onClick = _ref2.onClick, onClickCapture = _ref2.onClickCapture, onKeyDownCapture = _ref2.onKeyDownCapture, onKeyUpCapture = _ref2.onKeyUpCapture, onMouseDownCapture = _ref2.onMouseDownCapture, onMouseUpCapture = _ref2.onMouseUpCapture, onPointerDownCapture = _ref2.onPointerDownCapture, onPointerUpCapture = _ref2.onPointerUpCapture, onTouchEndCapture = _ref2.onTouchEndCapture, onTouchStartCapture = _ref2.onTouchStartCapture, shape = _ref2.shape, spacing = _ref2.spacing, testId = _ref2.testId, tooltip2 = _ref2.tooltip, _ref$type = _ref2.type, type = _ref$type === void 0 ? "button" : _ref$type, unsafeRest = _objectWithoutProperties(_ref2, _excluded11);
    var _className = unsafeRest.className, _css = unsafeRest.css, _as = unsafeRest.as, _style = unsafeRest.style, saferRest = _objectWithoutProperties(unsafeRest, _excluded27);
    if (isTooltipDisabled) {
      return /* @__PURE__ */ import_react73.default.createElement(button_base_default, _extends({}, saferRest, {
        ref,
        appearance,
        autoFocus,
        isDisabled,
        isLoading,
        isSelected,
        isIconButton: true,
        isCircle: shape === "circle",
        hasIconBefore: !!icon,
        spacing,
        ariaLabelledBy,
        onClick: _onClick,
        onClickCapture,
        onKeyDownCapture,
        onKeyUpCapture,
        onMouseDownCapture,
        onMouseUpCapture,
        onPointerDownCapture,
        onPointerUpCapture,
        onTouchStartCapture,
        onTouchEndCapture,
        testId,
        componentName: "IconButton",
        analyticsContext,
        type,
        interactionName
      }), /* @__PURE__ */ import_react73.default.createElement(content_default, {
        type: "icon",
        isLoading
      }, /* @__PURE__ */ import_react73.default.createElement(icon_renderer_default, {
        icon
      }), /* @__PURE__ */ import_react73.default.createElement(visually_hidden_default, null, label)));
    }
    return /* @__PURE__ */ import_react73.default.createElement(tooltip_default, {
      content: (_tooltip$content = tooltip2 === null || tooltip2 === void 0 ? void 0 : tooltip2.content) !== null && _tooltip$content !== void 0 ? _tooltip$content : label,
      testId: tooltip2 === null || tooltip2 === void 0 ? void 0 : tooltip2.testId,
      position: tooltip2 === null || tooltip2 === void 0 ? void 0 : tooltip2.position,
      delay: tooltip2 === null || tooltip2 === void 0 ? void 0 : tooltip2.delay,
      onShow: tooltip2 === null || tooltip2 === void 0 ? void 0 : tooltip2.onShow,
      onHide: tooltip2 === null || tooltip2 === void 0 ? void 0 : tooltip2.onHide,
      mousePosition: tooltip2 === null || tooltip2 === void 0 ? void 0 : tooltip2.mousePosition,
      analyticsContext: tooltip2 === null || tooltip2 === void 0 ? void 0 : tooltip2.analyticsContext,
      strategy: tooltip2 === null || tooltip2 === void 0 ? void 0 : tooltip2.strategy,
      tag: tooltip2 === null || tooltip2 === void 0 ? void 0 : tooltip2.tag,
      truncate: tooltip2 === null || tooltip2 === void 0 ? void 0 : tooltip2.truncate,
      component: tooltip2 === null || tooltip2 === void 0 ? void 0 : tooltip2.component,
      hideTooltipOnClick: tooltip2 === null || tooltip2 === void 0 ? void 0 : tooltip2.hideTooltipOnClick,
      hideTooltipOnMouseDown: tooltip2 === null || tooltip2 === void 0 ? void 0 : tooltip2.hideTooltipOnMouseDown,
      ignoreTooltipPointerEvents: tooltip2 === null || tooltip2 === void 0 ? void 0 : tooltip2.ignoreTooltipPointerEvents
    }, function(triggerProps) {
      return /* @__PURE__ */ import_react73.default.createElement(button_base_default, _extends({}, saferRest, {
        appearance,
        autoFocus,
        isDisabled,
        isLoading,
        isSelected,
        isIconButton: true,
        isCircle: shape === "circle",
        hasIconBefore: false,
        spacing,
        ariaLabelledBy,
        onClick: function onClick(e, analyticsEvent) {
          var _triggerProps$onClick;
          _onClick === null || _onClick === void 0 || _onClick(e, analyticsEvent);
          (_triggerProps$onClick = triggerProps.onClick) === null || _triggerProps$onClick === void 0 || _triggerProps$onClick.call(triggerProps, e);
        },
        onMouseOver: function onMouseOver(e) {
          var _triggerProps$onMouse, _saferRest$onMouseOve;
          (_triggerProps$onMouse = triggerProps.onMouseOver) === null || _triggerProps$onMouse === void 0 || _triggerProps$onMouse.call(triggerProps, e);
          (_saferRest$onMouseOve = saferRest.onMouseOver) === null || _saferRest$onMouseOve === void 0 || _saferRest$onMouseOve.call(saferRest, e);
        },
        onMouseOut: function onMouseOut(e) {
          var _triggerProps$onMouse2, _saferRest$onMouseOut;
          (_triggerProps$onMouse2 = triggerProps.onMouseOut) === null || _triggerProps$onMouse2 === void 0 || _triggerProps$onMouse2.call(triggerProps, e);
          (_saferRest$onMouseOut = saferRest.onMouseOut) === null || _saferRest$onMouseOut === void 0 || _saferRest$onMouseOut.call(saferRest, e);
        },
        onMouseMove: function onMouseMove(e) {
          var _triggerProps$onMouse3, _saferRest$onMouseMov;
          (_triggerProps$onMouse3 = triggerProps.onMouseMove) === null || _triggerProps$onMouse3 === void 0 || _triggerProps$onMouse3.call(triggerProps, e);
          (_saferRest$onMouseMov = saferRest.onMouseMove) === null || _saferRest$onMouseMov === void 0 || _saferRest$onMouseMov.call(saferRest, e);
        },
        onMouseDown: function onMouseDown(e) {
          var _triggerProps$onMouse4, _saferRest$onMouseDow;
          (_triggerProps$onMouse4 = triggerProps.onMouseDown) === null || _triggerProps$onMouse4 === void 0 || _triggerProps$onMouse4.call(triggerProps, e);
          (_saferRest$onMouseDow = saferRest.onMouseDown) === null || _saferRest$onMouseDow === void 0 || _saferRest$onMouseDow.call(saferRest, e);
        },
        onFocus: function onFocus3(e) {
          var _triggerProps$onFocus, _saferRest$onFocus;
          (_triggerProps$onFocus = triggerProps.onFocus) === null || _triggerProps$onFocus === void 0 || _triggerProps$onFocus.call(triggerProps, e);
          (_saferRest$onFocus = saferRest.onFocus) === null || _saferRest$onFocus === void 0 || _saferRest$onFocus.call(saferRest, e);
        },
        onBlur: function onBlur3(e) {
          var _triggerProps$onBlur, _saferRest$onBlur;
          (_triggerProps$onBlur = triggerProps.onBlur) === null || _triggerProps$onBlur === void 0 || _triggerProps$onBlur.call(triggerProps, e);
          (_saferRest$onBlur = saferRest.onBlur) === null || _saferRest$onBlur === void 0 || _saferRest$onBlur.call(saferRest, e);
        },
        ref: mergeRefs([ref, triggerProps === null || triggerProps === void 0 ? void 0 : triggerProps.ref].filter(Boolean)),
        onMouseDownCapture,
        onMouseUpCapture,
        onKeyDownCapture,
        onKeyUpCapture,
        onTouchStartCapture,
        onTouchEndCapture,
        onPointerDownCapture,
        onPointerUpCapture,
        onClickCapture,
        type,
        testId,
        analyticsContext,
        interactionName,
        componentName: "IconButton"
      }), /* @__PURE__ */ import_react73.default.createElement(content_default, {
        type: "icon",
        isLoading
      }, /* @__PURE__ */ import_react73.default.createElement(icon_renderer_default, {
        icon
      }), /* @__PURE__ */ import_react73.default.createElement(visually_hidden_default, null, label)));
    });
  }));
  IconButton.displayName = "IconButton";
  var button_default2 = IconButton;

  // node_modules/@atlaskit/modal-dialog/dist/esm/modal-dialog.js
  var import_react91 = __toESM(require_react());

  // node_modules/@atlaskit/modal-dialog/dist/esm/internal/components/modal-wrapper.js
  var React55 = __toESM(require_react());
  var import_react90 = __toESM(require_react());

  // node_modules/react-focus-lock/dist/es2015/Combination.js
  var import_react80 = __toESM(require_react());

  // node_modules/react-focus-lock/dist/es2015/Lock.js
  var import_react77 = __toESM(require_react());

  // node_modules/focus-lock/dist/es2015/constants.js
  var FOCUS_GROUP = "data-focus-lock";
  var FOCUS_DISABLED = "data-focus-lock-disabled";
  var FOCUS_ALLOW = "data-no-focus-lock";
  var FOCUS_AUTO = "data-autofocus-inside";
  var FOCUS_NO_AUTOFOCUS = "data-no-autofocus";

  // node_modules/use-callback-ref/dist/es2015/assignRef.js
  function assignRef(ref, value) {
    if (typeof ref === "function") {
      ref(value);
    } else if (ref) {
      ref.current = value;
    }
    return ref;
  }

  // node_modules/use-callback-ref/dist/es2015/useRef.js
  var import_react74 = __toESM(require_react());
  function useCallbackRef(initialValue, callback) {
    var ref = (0, import_react74.useState)(function() {
      return {
        // value
        value: initialValue,
        // last callback
        callback,
        // "memoized" public interface
        facade: {
          get current() {
            return ref.value;
          },
          set current(value) {
            var last = ref.value;
            if (last !== value) {
              ref.value = value;
              ref.callback(value, last);
            }
          }
        }
      };
    })[0];
    ref.callback = callback;
    return ref.facade;
  }

  // node_modules/use-callback-ref/dist/es2015/useMergeRef.js
  var React46 = __toESM(require_react());
  var useIsomorphicLayoutEffect3 = typeof window !== "undefined" ? React46.useLayoutEffect : React46.useEffect;
  var currentValues = /* @__PURE__ */ new WeakMap();
  function useMergeRefs(refs, defaultValue) {
    var callbackRef = useCallbackRef(defaultValue || null, function(newValue) {
      return refs.forEach(function(ref) {
        return assignRef(ref, newValue);
      });
    });
    useIsomorphicLayoutEffect3(function() {
      var oldValue = currentValues.get(callbackRef);
      if (oldValue) {
        var prevRefs_1 = new Set(oldValue);
        var nextRefs_1 = new Set(refs);
        var current_1 = callbackRef.current;
        prevRefs_1.forEach(function(ref) {
          if (!nextRefs_1.has(ref)) {
            assignRef(ref, null);
          }
        });
        nextRefs_1.forEach(function(ref) {
          if (!prevRefs_1.has(ref)) {
            assignRef(ref, current_1);
          }
        });
      }
      currentValues.set(callbackRef, refs);
    }, [refs]);
    return callbackRef;
  }

  // node_modules/react-focus-lock/dist/es2015/FocusGuard.js
  var import_react75 = __toESM(require_react());
  var hiddenGuard = {
    width: "1px",
    height: "0px",
    padding: 0,
    overflow: "hidden",
    position: "fixed",
    top: "1px",
    left: "1px"
  };
  var InFocusGuard = function InFocusGuard2(_ref2) {
    var _ref$children = _ref2.children, children = _ref$children === void 0 ? null : _ref$children;
    return /* @__PURE__ */ import_react75.default.createElement(import_react75.Fragment, null, /* @__PURE__ */ import_react75.default.createElement("div", {
      key: "guard-first",
      "data-focus-guard": true,
      "data-focus-auto-guard": true,
      style: hiddenGuard
    }), children, children && /* @__PURE__ */ import_react75.default.createElement("div", {
      key: "guard-last",
      "data-focus-guard": true,
      "data-focus-auto-guard": true,
      style: hiddenGuard
    }));
  };
  InFocusGuard.propTypes = false ? {
    children: import_prop_types.default.node
  } : {};

  // node_modules/tslib/tslib.es6.mjs
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  function __extends(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }
  var __assign = function() {
    __assign = Object.assign || function __assign2(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
      return t;
    };
    return __assign.apply(this, arguments);
  };
  function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
          t[p[i]] = s[p[i]];
      }
    return t;
  }
  function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  }
  function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() {
      if (t[0] & 1) throw t[1];
      return t[1];
    }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
    return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f) throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_ = 0)), _) try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        if (y = 0, t) op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2]) _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
      if (op[0] & 5) throw op[1];
      return { value: op[0] ? op[1] : void 0, done: true };
    }
  }
  function __spreadArray(to, from2, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from2.length, ar; i < l; i++) {
      if (ar || !(i in from2)) {
        if (!ar) ar = Array.prototype.slice.call(from2, 0, i);
        ar[i] = from2[i];
      }
    }
    return to.concat(ar || Array.prototype.slice.call(from2));
  }

  // node_modules/use-sidecar/dist/es2015/medium.js
  function ItoI(a) {
    return a;
  }
  function innerCreateMedium(defaults, middleware2) {
    if (middleware2 === void 0) {
      middleware2 = ItoI;
    }
    var buffer = [];
    var assigned = false;
    var medium = {
      read: function() {
        if (assigned) {
          throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
        }
        if (buffer.length) {
          return buffer[buffer.length - 1];
        }
        return defaults;
      },
      useMedium: function(data) {
        var item = middleware2(data, assigned);
        buffer.push(item);
        return function() {
          buffer = buffer.filter(function(x) {
            return x !== item;
          });
        };
      },
      assignSyncMedium: function(cb) {
        assigned = true;
        while (buffer.length) {
          var cbs = buffer;
          buffer = [];
          cbs.forEach(cb);
        }
        buffer = {
          push: function(x) {
            return cb(x);
          },
          filter: function() {
            return buffer;
          }
        };
      },
      assignMedium: function(cb) {
        assigned = true;
        var pendingQueue = [];
        if (buffer.length) {
          var cbs = buffer;
          buffer = [];
          cbs.forEach(cb);
          pendingQueue = buffer;
        }
        var executeQueue = function() {
          var cbs2 = pendingQueue;
          pendingQueue = [];
          cbs2.forEach(cb);
        };
        var cycle = function() {
          return Promise.resolve().then(executeQueue);
        };
        cycle();
        buffer = {
          push: function(x) {
            pendingQueue.push(x);
            cycle();
          },
          filter: function(filter) {
            pendingQueue = pendingQueue.filter(filter);
            return buffer;
          }
        };
      }
    };
    return medium;
  }
  function createMedium(defaults, middleware2) {
    if (middleware2 === void 0) {
      middleware2 = ItoI;
    }
    return innerCreateMedium(defaults, middleware2);
  }
  function createSidecarMedium(options2) {
    if (options2 === void 0) {
      options2 = {};
    }
    var medium = innerCreateMedium(null);
    medium.options = __assign({ async: true, ssr: false }, options2);
    return medium;
  }

  // node_modules/react-focus-lock/dist/es2015/medium.js
  var mediumFocus = createMedium({}, function(_ref2) {
    var target = _ref2.target, currentTarget = _ref2.currentTarget;
    return {
      target,
      currentTarget
    };
  });
  var mediumBlur = createMedium();
  var mediumEffect = createMedium();
  var mediumSidecar = createSidecarMedium({
    async: true,
    ssr: typeof document !== "undefined"
  });

  // node_modules/react-focus-lock/dist/es2015/scope.js
  var import_react76 = __toESM(require_react());
  var focusScope = /* @__PURE__ */ (0, import_react76.createContext)(void 0);

  // node_modules/react-focus-lock/dist/es2015/Lock.js
  var emptyArray = [];
  var FocusLock = /* @__PURE__ */ (0, import_react77.forwardRef)(function FocusLockUI(props, parentRef) {
    var _extends2;
    var _useState = (0, import_react77.useState)(), realObserved = _useState[0], setObserved = _useState[1];
    var observed = (0, import_react77.useRef)();
    var isActive = (0, import_react77.useRef)(false);
    var originalFocusedElement = (0, import_react77.useRef)(null);
    var _useState2 = (0, import_react77.useState)({}), update = _useState2[1];
    var children = props.children, _props$disabled = props.disabled, disabled = _props$disabled === void 0 ? false : _props$disabled, _props$noFocusGuards = props.noFocusGuards, noFocusGuards = _props$noFocusGuards === void 0 ? false : _props$noFocusGuards, _props$persistentFocu = props.persistentFocus, persistentFocus = _props$persistentFocu === void 0 ? false : _props$persistentFocu, _props$crossFrame = props.crossFrame, crossFrame = _props$crossFrame === void 0 ? true : _props$crossFrame, _props$autoFocus = props.autoFocus, autoFocus = _props$autoFocus === void 0 ? true : _props$autoFocus, allowTextSelection = props.allowTextSelection, group = props.group, className = props.className, whiteList = props.whiteList, hasPositiveIndices = props.hasPositiveIndices, _props$shards = props.shards, shards = _props$shards === void 0 ? emptyArray : _props$shards, _props$as = props.as, Container = _props$as === void 0 ? "div" : _props$as, _props$lockProps = props.lockProps, containerProps = _props$lockProps === void 0 ? {} : _props$lockProps, SideCar = props.sideCar, _props$returnFocus = props.returnFocus, shouldReturnFocus = _props$returnFocus === void 0 ? false : _props$returnFocus, focusOptions = props.focusOptions, onActivationCallback = props.onActivation, onDeactivationCallback = props.onDeactivation;
    var _useState3 = (0, import_react77.useState)({}), id = _useState3[0];
    var onActivation = (0, import_react77.useCallback)(function(_ref2) {
      var captureFocusRestore2 = _ref2.captureFocusRestore;
      if (!originalFocusedElement.current) {
        var _document;
        var activeElement = (_document = document) == null ? void 0 : _document.activeElement;
        originalFocusedElement.current = activeElement;
        if (activeElement !== document.body) {
          originalFocusedElement.current = captureFocusRestore2(activeElement);
        }
      }
      if (observed.current && onActivationCallback) {
        onActivationCallback(observed.current);
      }
      isActive.current = true;
      update();
    }, [onActivationCallback]);
    var onDeactivation = (0, import_react77.useCallback)(function() {
      isActive.current = false;
      if (onDeactivationCallback) {
        onDeactivationCallback(observed.current);
      }
      update();
    }, [onDeactivationCallback]);
    var returnFocus = (0, import_react77.useCallback)(function(allowDefer) {
      var focusRestore = originalFocusedElement.current;
      if (focusRestore) {
        var returnFocusTo = (typeof focusRestore === "function" ? focusRestore() : focusRestore) || document.body;
        var howToReturnFocus = typeof shouldReturnFocus === "function" ? shouldReturnFocus(returnFocusTo) : shouldReturnFocus;
        if (howToReturnFocus) {
          var returnFocusOptions = typeof howToReturnFocus === "object" ? howToReturnFocus : void 0;
          originalFocusedElement.current = null;
          if (allowDefer) {
            Promise.resolve().then(function() {
              return returnFocusTo.focus(returnFocusOptions);
            });
          } else {
            returnFocusTo.focus(returnFocusOptions);
          }
        }
      }
    }, [shouldReturnFocus]);
    var onFocus3 = (0, import_react77.useCallback)(function(event) {
      if (isActive.current) {
        mediumFocus.useMedium(event);
      }
    }, []);
    var onBlur3 = mediumBlur.useMedium;
    var setObserveNode = (0, import_react77.useCallback)(function(newObserved) {
      if (observed.current !== newObserved) {
        observed.current = newObserved;
        setObserved(newObserved);
      }
    }, []);
    if (false) {
      if (typeof allowTextSelection !== "undefined") {
        console.warn("React-Focus-Lock: allowTextSelection is deprecated and enabled by default");
      }
      (0, import_react77.useEffect)(function() {
        if (!observed.current && typeof Container !== "string") {
          console.error("FocusLock: could not obtain ref to internal node");
        }
      }, []);
    }
    var lockProps = _extends((_extends2 = {}, _extends2[FOCUS_DISABLED] = disabled && "disabled", _extends2[FOCUS_GROUP] = group, _extends2), containerProps);
    var hasLeadingGuards = noFocusGuards !== true;
    var hasTailingGuards = hasLeadingGuards && noFocusGuards !== "tail";
    var mergedRef = useMergeRefs([parentRef, setObserveNode]);
    var focusScopeValue = (0, import_react77.useMemo)(function() {
      return {
        observed,
        shards,
        enabled: !disabled,
        active: isActive.current
      };
    }, [disabled, isActive.current, shards, realObserved]);
    return /* @__PURE__ */ import_react77.default.createElement(import_react77.Fragment, null, hasLeadingGuards && [
      /* @__PURE__ */ import_react77.default.createElement("div", {
        key: "guard-first",
        "data-focus-guard": true,
        tabIndex: disabled ? -1 : 0,
        style: hiddenGuard
      }),
      hasPositiveIndices ? /* @__PURE__ */ import_react77.default.createElement("div", {
        key: "guard-nearest",
        "data-focus-guard": true,
        tabIndex: disabled ? -1 : 1,
        style: hiddenGuard
      }) : null
    ], !disabled && /* @__PURE__ */ import_react77.default.createElement(SideCar, {
      id,
      sideCar: mediumSidecar,
      observed: realObserved,
      disabled,
      persistentFocus,
      crossFrame,
      autoFocus,
      whiteList,
      shards,
      onActivation,
      onDeactivation,
      returnFocus,
      focusOptions,
      noFocusGuards
    }), /* @__PURE__ */ import_react77.default.createElement(Container, _extends({
      ref: mergedRef
    }, lockProps, {
      className,
      onBlur: onBlur3,
      onFocus: onFocus3
    }), /* @__PURE__ */ import_react77.default.createElement(focusScope.Provider, {
      value: focusScopeValue
    }, children)), hasTailingGuards && /* @__PURE__ */ import_react77.default.createElement("div", {
      "data-focus-guard": true,
      tabIndex: disabled ? -1 : 0,
      style: hiddenGuard
    }));
  });
  FocusLock.propTypes = false ? {
    children: import_prop_types.node,
    disabled: import_prop_types.bool,
    returnFocus: (0, import_prop_types.oneOfType)([import_prop_types.bool, import_prop_types.object, import_prop_types.func]),
    focusOptions: import_prop_types.object,
    noFocusGuards: import_prop_types.bool,
    hasPositiveIndices: import_prop_types.bool,
    allowTextSelection: import_prop_types.bool,
    autoFocus: import_prop_types.bool,
    persistentFocus: import_prop_types.bool,
    crossFrame: import_prop_types.bool,
    group: import_prop_types.string,
    className: import_prop_types.string,
    whiteList: import_prop_types.func,
    shards: (0, import_prop_types.arrayOf)(import_prop_types.any),
    as: (0, import_prop_types.oneOfType)([import_prop_types.string, import_prop_types.func, import_prop_types.object]),
    lockProps: import_prop_types.object,
    onActivation: import_prop_types.func,
    onDeactivation: import_prop_types.func,
    sideCar: import_prop_types.any.isRequired
  } : {};
  var Lock_default = FocusLock;

  // node_modules/react-focus-lock/dist/es2015/Trap.js
  var import_react79 = __toESM(require_react());

  // node_modules/@babel/runtime/helpers/esm/inheritsLoose.js
  function _inheritsLoose(t, o) {
    t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o);
  }

  // node_modules/react-clientside-effect/lib/index.es.js
  init_defineProperty();
  var import_react78 = __toESM(require_react());
  function withSideEffect(reducePropsToState2, handleStateChangeOnClient2) {
    if (false) {
      if (typeof reducePropsToState2 !== "function") {
        throw new Error("Expected reducePropsToState to be a function.");
      }
      if (typeof handleStateChangeOnClient2 !== "function") {
        throw new Error("Expected handleStateChangeOnClient to be a function.");
      }
    }
    function getDisplayName(WrappedComponent) {
      return WrappedComponent.displayName || WrappedComponent.name || "Component";
    }
    return function wrap4(WrappedComponent) {
      if (false) {
        if (typeof WrappedComponent !== "function") {
          throw new Error("Expected WrappedComponent to be a React component.");
        }
      }
      var mountedInstances = [];
      var state;
      function emitChange() {
        state = reducePropsToState2(mountedInstances.map(function(instance) {
          return instance.props;
        }));
        handleStateChangeOnClient2(state);
      }
      var SideEffect = /* @__PURE__ */ (function(_PureComponent) {
        _inheritsLoose(SideEffect2, _PureComponent);
        function SideEffect2() {
          return _PureComponent.apply(this, arguments) || this;
        }
        SideEffect2.peek = function peek2() {
          return state;
        };
        var _proto = SideEffect2.prototype;
        _proto.componentDidMount = function componentDidMount() {
          mountedInstances.push(this);
          emitChange();
        };
        _proto.componentDidUpdate = function componentDidUpdate() {
          emitChange();
        };
        _proto.componentWillUnmount = function componentWillUnmount() {
          var index2 = mountedInstances.indexOf(this);
          mountedInstances.splice(index2, 1);
          emitChange();
        };
        _proto.render = function render() {
          return /* @__PURE__ */ import_react78.default.createElement(WrappedComponent, this.props);
        };
        return SideEffect2;
      })(import_react78.PureComponent);
      _defineProperty(SideEffect, "displayName", "SideEffect(" + getDisplayName(WrappedComponent) + ")");
      return SideEffect;
    };
  }
  var index_es_default = withSideEffect;

  // node_modules/focus-lock/dist/es2015/utils/array.js
  var toArray = function(a) {
    var ret = Array(a.length);
    for (var i = 0; i < a.length; ++i) {
      ret[i] = a[i];
    }
    return ret;
  };
  var asArray = function(a) {
    return Array.isArray(a) ? a : [a];
  };
  var getFirst = function(a) {
    return Array.isArray(a) ? a[0] : a;
  };

  // node_modules/focus-lock/dist/es2015/utils/is.js
  var isElementHidden = function(node2) {
    if (node2.nodeType !== Node.ELEMENT_NODE) {
      return false;
    }
    var computedStyle = window.getComputedStyle(node2, null);
    if (!computedStyle || !computedStyle.getPropertyValue) {
      return false;
    }
    return computedStyle.getPropertyValue("display") === "none" || computedStyle.getPropertyValue("visibility") === "hidden";
  };
  var getParentNode2 = function(node2) {
    return node2.parentNode && node2.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      node2.parentNode.host
    ) : node2.parentNode;
  };
  var isTopNode = function(node2) {
    return node2 === document || node2 && node2.nodeType === Node.DOCUMENT_NODE;
  };
  var isInert = function(node2) {
    return node2.hasAttribute("inert");
  };
  var isVisibleUncached = function(node2, checkParent) {
    return !node2 || isTopNode(node2) || !isElementHidden(node2) && !isInert(node2) && checkParent(getParentNode2(node2));
  };
  var isVisibleCached = function(visibilityCache, node2) {
    var cached = visibilityCache.get(node2);
    if (cached !== void 0) {
      return cached;
    }
    var result2 = isVisibleUncached(node2, isVisibleCached.bind(void 0, visibilityCache));
    visibilityCache.set(node2, result2);
    return result2;
  };
  var isAutoFocusAllowedUncached = function(node2, checkParent) {
    return node2 && !isTopNode(node2) ? isAutoFocusAllowed(node2) ? checkParent(getParentNode2(node2)) : false : true;
  };
  var isAutoFocusAllowedCached = function(cache, node2) {
    var cached = cache.get(node2);
    if (cached !== void 0) {
      return cached;
    }
    var result2 = isAutoFocusAllowedUncached(node2, isAutoFocusAllowedCached.bind(void 0, cache));
    cache.set(node2, result2);
    return result2;
  };
  var getDataset = function(node2) {
    return node2.dataset;
  };
  var isHTMLButtonElement = function(node2) {
    return node2.tagName === "BUTTON";
  };
  var isHTMLInputElement = function(node2) {
    return node2.tagName === "INPUT";
  };
  var isRadioElement = function(node2) {
    return isHTMLInputElement(node2) && node2.type === "radio";
  };
  var notHiddenInput = function(node2) {
    return !((isHTMLInputElement(node2) || isHTMLButtonElement(node2)) && (node2.type === "hidden" || node2.disabled));
  };
  var isAutoFocusAllowed = function(node2) {
    var attribute = node2.getAttribute(FOCUS_NO_AUTOFOCUS);
    return ![true, "true", ""].includes(attribute);
  };
  var isGuard = function(node2) {
    var _a2;
    return Boolean(node2 && ((_a2 = getDataset(node2)) === null || _a2 === void 0 ? void 0 : _a2.focusGuard));
  };
  var isNotAGuard = function(node2) {
    return !isGuard(node2);
  };
  var isDefined = function(x) {
    return Boolean(x);
  };

  // node_modules/focus-lock/dist/es2015/utils/tabOrder.js
  var tabSort = function(a, b) {
    var aTab = Math.max(0, a.tabIndex);
    var bTab = Math.max(0, b.tabIndex);
    var tabDiff = aTab - bTab;
    var indexDiff = a.index - b.index;
    if (tabDiff) {
      if (!aTab) {
        return 1;
      }
      if (!bTab) {
        return -1;
      }
    }
    return tabDiff || indexDiff;
  };
  var getTabIndex = function(node2) {
    if (node2.tabIndex < 0) {
      if (!node2.hasAttribute("tabindex")) {
        return 0;
      }
    }
    return node2.tabIndex;
  };
  var orderByTabIndex = function(nodes, filterNegative, keepGuards) {
    return toArray(nodes).map(function(node2, index2) {
      var tabIndex = getTabIndex(node2);
      return {
        node: node2,
        index: index2,
        tabIndex: keepGuards && tabIndex === -1 ? (node2.dataset || {}).focusGuard ? 0 : -1 : tabIndex
      };
    }).filter(function(data) {
      return !filterNegative || data.tabIndex >= 0;
    }).sort(tabSort);
  };

  // node_modules/focus-lock/dist/es2015/utils/tabbables.js
  var tabbables = [
    "button:enabled",
    "select:enabled",
    "textarea:enabled",
    "input:enabled",
    // elements with explicit roles will also use explicit tabindex
    // '[role="button"]',
    "a[href]",
    "area[href]",
    "summary",
    "iframe",
    "object",
    "embed",
    "audio[controls]",
    "video[controls]",
    "[tabindex]",
    "[contenteditable]",
    "[autofocus]"
  ];

  // node_modules/focus-lock/dist/es2015/utils/tabUtils.js
  var queryTabbables = tabbables.join(",");
  var queryGuardTabbables = "".concat(queryTabbables, ", [data-focus-guard]");
  var getFocusablesWithShadowDom = function(parent, withGuards) {
    return toArray((parent.shadowRoot || parent).children).reduce(function(acc, child) {
      return acc.concat(child.matches(withGuards ? queryGuardTabbables : queryTabbables) ? [child] : [], getFocusablesWithShadowDom(child));
    }, []);
  };
  var getFocusablesWithIFrame = function(parent, withGuards) {
    var _a2;
    if (parent instanceof HTMLIFrameElement && ((_a2 = parent.contentDocument) === null || _a2 === void 0 ? void 0 : _a2.body)) {
      return getFocusables([parent.contentDocument.body], withGuards);
    }
    return [parent];
  };
  var getFocusables = function(parents, withGuards) {
    return parents.reduce(function(acc, parent) {
      var _a2;
      var focusableWithShadowDom = getFocusablesWithShadowDom(parent, withGuards);
      var focusableWithIframes = (_a2 = []).concat.apply(_a2, focusableWithShadowDom.map(function(node2) {
        return getFocusablesWithIFrame(node2, withGuards);
      }));
      return acc.concat(
        // add all tabbables inside and within shadow DOMs in DOM order
        focusableWithIframes,
        // add if node is tabbable itself
        parent.parentNode ? toArray(parent.parentNode.querySelectorAll(queryTabbables)).filter(function(node2) {
          return node2 === parent;
        }) : []
      );
    }, []);
  };
  var getParentAutofocusables = function(parent) {
    var parentFocus = parent.querySelectorAll("[".concat(FOCUS_AUTO, "]"));
    return toArray(parentFocus).map(function(node2) {
      return getFocusables([node2]);
    }).reduce(function(acc, nodes) {
      return acc.concat(nodes);
    }, []);
  };

  // node_modules/focus-lock/dist/es2015/utils/DOMutils.js
  var filterFocusable = function(nodes, visibilityCache) {
    return toArray(nodes).filter(function(node2) {
      return isVisibleCached(visibilityCache, node2);
    }).filter(function(node2) {
      return notHiddenInput(node2);
    });
  };
  var filterAutoFocusable = function(nodes, cache) {
    if (cache === void 0) {
      cache = /* @__PURE__ */ new Map();
    }
    return toArray(nodes).filter(function(node2) {
      return isAutoFocusAllowedCached(cache, node2);
    });
  };
  var getTabbableNodes = function(topNodes, visibilityCache, withGuards) {
    return orderByTabIndex(filterFocusable(getFocusables(topNodes, withGuards), visibilityCache), true, withGuards);
  };
  var getFocusableNodes = function(topNodes, visibilityCache) {
    return orderByTabIndex(filterFocusable(getFocusables(topNodes), visibilityCache), false);
  };
  var parentAutofocusables = function(topNode, visibilityCache) {
    return filterFocusable(getParentAutofocusables(topNode), visibilityCache);
  };
  var contains2 = function(scope, element) {
    if (scope.shadowRoot) {
      return contains2(scope.shadowRoot, element);
    } else {
      if (Object.getPrototypeOf(scope).contains !== void 0 && Object.getPrototypeOf(scope).contains.call(scope, element)) {
        return true;
      }
      return toArray(scope.children).some(function(child) {
        var _a2;
        if (child instanceof HTMLIFrameElement) {
          var iframeBody = (_a2 = child.contentDocument) === null || _a2 === void 0 ? void 0 : _a2.body;
          if (iframeBody) {
            return contains2(iframeBody, element);
          }
          return false;
        }
        return contains2(child, element);
      });
    }
  };

  // node_modules/focus-lock/dist/es2015/utils/all-affected.js
  var filterNested = function(nodes) {
    var contained = /* @__PURE__ */ new Set();
    var l = nodes.length;
    for (var i = 0; i < l; i += 1) {
      for (var j = i + 1; j < l; j += 1) {
        var position2 = nodes[i].compareDocumentPosition(nodes[j]);
        if ((position2 & Node.DOCUMENT_POSITION_CONTAINED_BY) > 0) {
          contained.add(j);
        }
        if ((position2 & Node.DOCUMENT_POSITION_CONTAINS) > 0) {
          contained.add(i);
        }
      }
    }
    return nodes.filter(function(_, index2) {
      return !contained.has(index2);
    });
  };
  var getTopParent = function(node2) {
    return node2.parentNode ? getTopParent(node2.parentNode) : node2;
  };
  var getAllAffectedNodes = function(node2) {
    var nodes = asArray(node2);
    return nodes.filter(Boolean).reduce(function(acc, currentNode) {
      var group = currentNode.getAttribute(FOCUS_GROUP);
      acc.push.apply(acc, group ? filterNested(toArray(getTopParent(currentNode).querySelectorAll("[".concat(FOCUS_GROUP, '="').concat(group, '"]:not([').concat(FOCUS_DISABLED, '="disabled"])')))) : [currentNode]);
      return acc;
    }, []);
  };

  // node_modules/focus-lock/dist/es2015/utils/safe.js
  var safeProbe = function(cb) {
    try {
      return cb();
    } catch (e) {
      return void 0;
    }
  };

  // node_modules/focus-lock/dist/es2015/utils/getActiveElement.js
  var getActiveElement = function(inDocument) {
    if (inDocument === void 0) {
      inDocument = document;
    }
    if (!inDocument || !inDocument.activeElement) {
      return void 0;
    }
    var activeElement = inDocument.activeElement;
    return activeElement.shadowRoot ? getActiveElement(activeElement.shadowRoot) : activeElement instanceof HTMLIFrameElement && safeProbe(function() {
      return activeElement.contentWindow.document;
    }) ? getActiveElement(activeElement.contentWindow.document) : activeElement;
  };

  // node_modules/focus-lock/dist/es2015/focusInside.js
  var focusInFrame = function(frame, activeElement) {
    return frame === activeElement;
  };
  var focusInsideIframe = function(topNode, activeElement) {
    return Boolean(toArray(topNode.querySelectorAll("iframe")).some(function(node2) {
      return focusInFrame(node2, activeElement);
    }));
  };
  var focusInside = function(topNode, activeElement) {
    if (activeElement === void 0) {
      activeElement = getActiveElement(getFirst(topNode).ownerDocument);
    }
    if (!activeElement || activeElement.dataset && activeElement.dataset.focusGuard) {
      return false;
    }
    return getAllAffectedNodes(topNode).some(function(node2) {
      return contains2(node2, activeElement) || focusInsideIframe(node2, activeElement);
    });
  };

  // node_modules/focus-lock/dist/es2015/focusIsHidden.js
  var focusIsHidden = function(inDocument) {
    if (inDocument === void 0) {
      inDocument = document;
    }
    var activeElement = getActiveElement(inDocument);
    if (!activeElement) {
      return false;
    }
    return toArray(inDocument.querySelectorAll("[".concat(FOCUS_ALLOW, "]"))).some(function(node2) {
      return contains2(node2, activeElement);
    });
  };

  // node_modules/focus-lock/dist/es2015/utils/correctFocus.js
  var findSelectedRadio = function(node2, nodes) {
    return nodes.filter(isRadioElement).filter(function(el) {
      return el.name === node2.name;
    }).filter(function(el) {
      return el.checked;
    })[0] || node2;
  };
  var correctNode = function(node2, nodes) {
    if (isRadioElement(node2) && node2.name) {
      return findSelectedRadio(node2, nodes);
    }
    return node2;
  };
  var correctNodes = function(nodes) {
    var resultSet = /* @__PURE__ */ new Set();
    nodes.forEach(function(node2) {
      return resultSet.add(correctNode(node2, nodes));
    });
    return nodes.filter(function(node2) {
      return resultSet.has(node2);
    });
  };

  // node_modules/focus-lock/dist/es2015/utils/firstFocus.js
  var pickFirstFocus = function(nodes) {
    if (nodes[0] && nodes.length > 1) {
      return correctNode(nodes[0], nodes);
    }
    return nodes[0];
  };
  var pickFocusable = function(nodes, node2) {
    return nodes.indexOf(correctNode(node2, nodes));
  };

  // node_modules/focus-lock/dist/es2015/solver.js
  var NEW_FOCUS = "NEW_FOCUS";
  var newFocus = function(innerNodes, innerTabbables, outerNodes, activeElement, lastNode) {
    var cnt = innerNodes.length;
    var firstFocus = innerNodes[0];
    var lastFocus = innerNodes[cnt - 1];
    var isOnGuard = isGuard(activeElement);
    if (activeElement && innerNodes.indexOf(activeElement) >= 0) {
      return void 0;
    }
    var activeIndex = activeElement !== void 0 ? outerNodes.indexOf(activeElement) : -1;
    var lastIndex = lastNode ? outerNodes.indexOf(lastNode) : activeIndex;
    var lastNodeInside = lastNode ? innerNodes.indexOf(lastNode) : -1;
    if (activeIndex === -1) {
      if (lastNodeInside !== -1) {
        return lastNodeInside;
      }
      return NEW_FOCUS;
    }
    if (lastNodeInside === -1) {
      return NEW_FOCUS;
    }
    var indexDiff = activeIndex - lastIndex;
    var firstNodeIndex = outerNodes.indexOf(firstFocus);
    var lastNodeIndex = outerNodes.indexOf(lastFocus);
    var correctedNodes = correctNodes(outerNodes);
    var currentFocusableIndex = activeElement !== void 0 ? correctedNodes.indexOf(activeElement) : -1;
    var previousFocusableIndex = lastNode ? correctedNodes.indexOf(lastNode) : currentFocusableIndex;
    var tabbableNodes = correctedNodes.filter(function(node2) {
      return node2.tabIndex >= 0;
    });
    var currentTabbableIndex = activeElement !== void 0 ? tabbableNodes.indexOf(activeElement) : -1;
    var previousTabbableIndex = lastNode ? tabbableNodes.indexOf(lastNode) : currentTabbableIndex;
    var focusIndexDiff = currentTabbableIndex >= 0 && previousTabbableIndex >= 0 ? (
      // old/new are tabbables, measure distance in tabbable space
      previousTabbableIndex - currentTabbableIndex
    ) : (
      // or else measure in focusable space
      previousFocusableIndex - currentFocusableIndex
    );
    if (!indexDiff && lastNodeInside >= 0) {
      return lastNodeInside;
    }
    if (innerTabbables.length === 0) {
      return lastNodeInside;
    }
    var returnFirstNode = pickFocusable(innerNodes, innerTabbables[0]);
    var returnLastNode = pickFocusable(innerNodes, innerTabbables[innerTabbables.length - 1]);
    if (activeIndex <= firstNodeIndex && isOnGuard && Math.abs(indexDiff) > 1) {
      return returnLastNode;
    }
    if (activeIndex >= lastNodeIndex && isOnGuard && Math.abs(indexDiff) > 1) {
      return returnFirstNode;
    }
    if (indexDiff && Math.abs(focusIndexDiff) > 1) {
      return lastNodeInside;
    }
    if (activeIndex <= firstNodeIndex) {
      return returnLastNode;
    }
    if (activeIndex > lastNodeIndex) {
      return returnFirstNode;
    }
    if (indexDiff) {
      if (Math.abs(indexDiff) > 1) {
        return lastNodeInside;
      }
      return (cnt + lastNodeInside + indexDiff) % cnt;
    }
    return void 0;
  };

  // node_modules/focus-lock/dist/es2015/utils/auto-focus.js
  var findAutoFocused = function(autoFocusables) {
    return function(node2) {
      var _a2;
      var autofocus = (_a2 = getDataset(node2)) === null || _a2 === void 0 ? void 0 : _a2.autofocus;
      return (
        // @ts-expect-error
        node2.autofocus || //
        autofocus !== void 0 && autofocus !== "false" || //
        autoFocusables.indexOf(node2) >= 0
      );
    };
  };
  var pickAutofocus = function(nodesIndexes, orderedNodes, groups) {
    var nodes = nodesIndexes.map(function(_a2) {
      var node2 = _a2.node;
      return node2;
    });
    var autoFocusable = filterAutoFocusable(nodes.filter(findAutoFocused(groups)));
    if (autoFocusable && autoFocusable.length) {
      return pickFirstFocus(autoFocusable);
    }
    return pickFirstFocus(filterAutoFocusable(orderedNodes));
  };

  // node_modules/focus-lock/dist/es2015/utils/parenting.js
  var getParents = function(node2, parents) {
    if (parents === void 0) {
      parents = [];
    }
    parents.push(node2);
    if (node2.parentNode) {
      getParents(node2.parentNode.host || node2.parentNode, parents);
    }
    return parents;
  };
  var getCommonParent = function(nodeA, nodeB) {
    var parentsA = getParents(nodeA);
    var parentsB = getParents(nodeB);
    for (var i = 0; i < parentsA.length; i += 1) {
      var currentParent = parentsA[i];
      if (parentsB.indexOf(currentParent) >= 0) {
        return currentParent;
      }
    }
    return false;
  };
  var getTopCommonParent = function(baseActiveElement, leftEntry, rightEntries) {
    var activeElements = asArray(baseActiveElement);
    var leftEntries = asArray(leftEntry);
    var activeElement = activeElements[0];
    var topCommon = false;
    leftEntries.filter(Boolean).forEach(function(entry) {
      topCommon = getCommonParent(topCommon || entry, entry) || topCommon;
      rightEntries.filter(Boolean).forEach(function(subEntry) {
        var common = getCommonParent(activeElement, subEntry);
        if (common) {
          if (!topCommon || contains2(common, topCommon)) {
            topCommon = common;
          } else {
            topCommon = getCommonParent(common, topCommon);
          }
        }
      });
    });
    return topCommon;
  };
  var allParentAutofocusables = function(entries, visibilityCache) {
    return entries.reduce(function(acc, node2) {
      return acc.concat(parentAutofocusables(node2, visibilityCache));
    }, []);
  };

  // node_modules/focus-lock/dist/es2015/focusSolver.js
  var reorderNodes = function(srcNodes, dstNodes) {
    var remap = /* @__PURE__ */ new Map();
    dstNodes.forEach(function(entity) {
      return remap.set(entity.node, entity);
    });
    return srcNodes.map(function(node2) {
      return remap.get(node2);
    }).filter(isDefined);
  };
  var focusSolver = function(topNode, lastNode) {
    var activeElement = getActiveElement(asArray(topNode).length > 0 ? document : getFirst(topNode).ownerDocument);
    var entries = getAllAffectedNodes(topNode).filter(isNotAGuard);
    var commonParent = getTopCommonParent(activeElement || topNode, topNode, entries);
    var visibilityCache = /* @__PURE__ */ new Map();
    var anyFocusable = getFocusableNodes(entries, visibilityCache);
    var innerElements = anyFocusable.filter(function(_a2) {
      var node2 = _a2.node;
      return isNotAGuard(node2);
    });
    if (!innerElements[0]) {
      return void 0;
    }
    var outerNodes = getFocusableNodes([commonParent], visibilityCache).map(function(_a2) {
      var node2 = _a2.node;
      return node2;
    });
    var orderedInnerElements = reorderNodes(outerNodes, innerElements);
    var innerFocusables = orderedInnerElements.map(function(_a2) {
      var node2 = _a2.node;
      return node2;
    });
    var innerTabbable = orderedInnerElements.filter(function(_a2) {
      var tabIndex = _a2.tabIndex;
      return tabIndex >= 0;
    }).map(function(_a2) {
      var node2 = _a2.node;
      return node2;
    });
    var newId = newFocus(innerFocusables, innerTabbable, outerNodes, activeElement, lastNode);
    if (newId === NEW_FOCUS) {
      var focusNode = (
        // first try only tabbable, and the fallback to all focusable, as long as at least one element should be picked for focus
        pickAutofocus(anyFocusable, innerTabbable, allParentAutofocusables(entries, visibilityCache)) || pickAutofocus(anyFocusable, innerFocusables, allParentAutofocusables(entries, visibilityCache))
      );
      if (focusNode) {
        return { node: focusNode };
      } else {
        console.warn("focus-lock: cannot find any node to move focus into");
        return void 0;
      }
    }
    if (newId === void 0) {
      return newId;
    }
    return orderedInnerElements[newId];
  };

  // node_modules/focus-lock/dist/es2015/focusables.js
  var expandFocusableNodes = function(topNode) {
    var entries = getAllAffectedNodes(topNode).filter(isNotAGuard);
    var commonParent = getTopCommonParent(topNode, topNode, entries);
    var outerNodes = orderByTabIndex(getFocusables([commonParent], true), true, true);
    var innerElements = getFocusables(entries, false);
    return outerNodes.map(function(_a2) {
      var node2 = _a2.node, index2 = _a2.index;
      return {
        node: node2,
        index: index2,
        lockItem: innerElements.indexOf(node2) >= 0,
        guard: isGuard(node2)
      };
    });
  };

  // node_modules/focus-lock/dist/es2015/commands.js
  var focusOn = function(target, focusOptions) {
    if (!target) {
      return;
    }
    if ("focus" in target) {
      target.focus(focusOptions);
    }
    if ("contentWindow" in target && target.contentWindow) {
      target.contentWindow.focus();
    }
  };

  // node_modules/focus-lock/dist/es2015/moveFocusInside.js
  var guardCount = 0;
  var lockDisabled = false;
  var moveFocusInside = function(topNode, lastNode, options2) {
    if (options2 === void 0) {
      options2 = {};
    }
    var focusable = focusSolver(topNode, lastNode);
    if (lockDisabled) {
      return;
    }
    if (focusable) {
      if (guardCount > 2) {
        console.error("FocusLock: focus-fighting detected. Only one focus management system could be active. See https://github.com/theKashey/focus-lock/#focus-fighting");
        lockDisabled = true;
        setTimeout(function() {
          lockDisabled = false;
        }, 1);
        return;
      }
      guardCount++;
      focusOn(focusable.node, options2.focusOptions);
      guardCount--;
    }
  };

  // node_modules/focus-lock/dist/es2015/return-focus.js
  function weakRef(value) {
    if (!value)
      return null;
    if (typeof WeakRef === "undefined") {
      return function() {
        return value || null;
      };
    }
    var w2 = value ? new WeakRef(value) : null;
    return function() {
      return (w2 === null || w2 === void 0 ? void 0 : w2.deref()) || null;
    };
  }
  var recordElementLocation = function(element) {
    if (!element) {
      return null;
    }
    var stack = [];
    var currentElement = element;
    while (currentElement && currentElement !== document.body) {
      stack.push({
        current: weakRef(currentElement),
        parent: weakRef(currentElement.parentElement),
        left: weakRef(currentElement.previousElementSibling),
        right: weakRef(currentElement.nextElementSibling)
      });
      currentElement = currentElement.parentElement;
    }
    return {
      element: weakRef(element),
      stack,
      ownerDocument: element.ownerDocument
    };
  };
  var restoreFocusTo = function(location2) {
    var _a2, _b, _c, _d, _e;
    if (!location2) {
      return void 0;
    }
    var stack = location2.stack, ownerDocument = location2.ownerDocument;
    var visibilityCache = /* @__PURE__ */ new Map();
    for (var _i = 0, stack_1 = stack; _i < stack_1.length; _i++) {
      var line2 = stack_1[_i];
      var parent_1 = (_a2 = line2.parent) === null || _a2 === void 0 ? void 0 : _a2.call(line2);
      if (parent_1 && ownerDocument.contains(parent_1)) {
        var left2 = (_b = line2.left) === null || _b === void 0 ? void 0 : _b.call(line2);
        var savedCurrent = line2.current();
        var current = parent_1.contains(savedCurrent) ? savedCurrent : void 0;
        var right2 = (_c = line2.right) === null || _c === void 0 ? void 0 : _c.call(line2);
        var focusables = getTabbableNodes([parent_1], visibilityCache);
        var aim = (
          // that is element itself
          (_e = (_d = current !== null && current !== void 0 ? current : (
            // or something in it's place
            left2 === null || left2 === void 0 ? void 0 : left2.nextElementSibling
          )) !== null && _d !== void 0 ? _d : (
            // or somebody to the right, still close enough
            right2
          )) !== null && _e !== void 0 ? _e : (
            // or somebody to the left, something?
            left2
          )
        );
        while (aim) {
          for (var _f = 0, focusables_1 = focusables; _f < focusables_1.length; _f++) {
            var focusable = focusables_1[_f];
            if (aim === null || aim === void 0 ? void 0 : aim.contains(focusable.node)) {
              return focusable.node;
            }
          }
          aim = aim.nextElementSibling;
        }
        if (focusables.length) {
          return focusables[0].node;
        }
      }
    }
    return void 0;
  };
  var captureFocusRestore = function(targetElement) {
    var location2 = recordElementLocation(targetElement);
    return function() {
      return restoreFocusTo(location2);
    };
  };

  // node_modules/focus-lock/dist/es2015/sibling.js
  var getRelativeFocusable = function(element, scope, useTabbables) {
    if (!element || !scope) {
      console.error("no element or scope given");
      return {};
    }
    var shards = asArray(scope);
    if (shards.every(function(shard) {
      return !contains2(shard, element);
    })) {
      console.error("Active element is not contained in the scope");
      return {};
    }
    var focusables = useTabbables ? getTabbableNodes(shards, /* @__PURE__ */ new Map()) : getFocusableNodes(shards, /* @__PURE__ */ new Map());
    var current = focusables.findIndex(function(_a2) {
      var node2 = _a2.node;
      return node2 === element;
    });
    if (current === -1) {
      return void 0;
    }
    return {
      prev: focusables[current - 1],
      next: focusables[current + 1],
      first: focusables[0],
      last: focusables[focusables.length - 1]
    };
  };
  var getBoundary = function(shards, useTabbables) {
    var set = useTabbables ? getTabbableNodes(asArray(shards), /* @__PURE__ */ new Map()) : getFocusableNodes(asArray(shards), /* @__PURE__ */ new Map());
    return {
      first: set[0],
      last: set[set.length - 1]
    };
  };
  var defaultOptions = function(options2) {
    return Object.assign({
      scope: document.body,
      cycle: true,
      onlyTabbable: true
    }, options2);
  };
  var moveFocus = function(fromElement, options2, cb) {
    if (options2 === void 0) {
      options2 = {};
    }
    var newOptions = defaultOptions(options2);
    var solution = getRelativeFocusable(fromElement, newOptions.scope, newOptions.onlyTabbable);
    if (!solution) {
      return;
    }
    var target = cb(solution, newOptions.cycle);
    if (target) {
      focusOn(target.node, newOptions.focusOptions);
    }
  };
  var focusNextElement = function(fromElement, options2) {
    if (options2 === void 0) {
      options2 = {};
    }
    moveFocus(fromElement, options2, function(_a2, cycle) {
      var next2 = _a2.next, first = _a2.first;
      return next2 || cycle && first;
    });
  };
  var focusPrevElement = function(fromElement, options2) {
    if (options2 === void 0) {
      options2 = {};
    }
    moveFocus(fromElement, options2, function(_a2, cycle) {
      var prev2 = _a2.prev, last = _a2.last;
      return prev2 || cycle && last;
    });
  };
  var pickBoundary = function(scope, options2, what) {
    var _a2;
    var boundary = getBoundary(scope, (_a2 = options2.onlyTabbable) !== null && _a2 !== void 0 ? _a2 : true);
    var node2 = boundary[what];
    if (node2) {
      focusOn(node2.node, options2.focusOptions);
    }
  };
  var focusFirstElement = function(scope, options2) {
    if (options2 === void 0) {
      options2 = {};
    }
    pickBoundary(scope, options2, "first");
  };
  var focusLastElement = function(scope, options2) {
    if (options2 === void 0) {
      options2 = {};
    }
    pickBoundary(scope, options2, "last");
  };

  // node_modules/react-focus-lock/dist/es2015/util.js
  function deferAction(action) {
    setTimeout(action, 1);
  }
  var extractRef = function extractRef2(ref) {
    return ref && "current" in ref ? ref.current : ref;
  };

  // node_modules/react-focus-lock/dist/es2015/Trap.js
  var focusOnBody = function focusOnBody2() {
    return document && document.activeElement === document.body;
  };
  var isFreeFocus = function isFreeFocus2() {
    return focusOnBody() || focusIsHidden();
  };
  var lastActiveTrap = null;
  var lastActiveFocus = null;
  var tryRestoreFocus = function tryRestoreFocus2() {
    return null;
  };
  var lastPortaledElement = null;
  var focusWasOutsideWindow = false;
  var windowFocused = false;
  var defaultWhitelist = function defaultWhitelist2() {
    return true;
  };
  var focusWhitelisted = function focusWhitelisted2(activeElement) {
    return (lastActiveTrap.whiteList || defaultWhitelist)(activeElement);
  };
  var recordPortal = function recordPortal2(observerNode, portaledElement) {
    lastPortaledElement = {
      observerNode,
      portaledElement
    };
  };
  var focusIsPortaledPair = function focusIsPortaledPair2(element) {
    return lastPortaledElement && lastPortaledElement.portaledElement === element;
  };
  function autoGuard(startIndex, end2, step, allNodes) {
    var lastGuard = null;
    var i = startIndex;
    do {
      var item = allNodes[i];
      if (item.guard) {
        if (item.node.dataset.focusAutoGuard) {
          lastGuard = item;
        }
      } else if (item.lockItem) {
        if (i !== startIndex) {
          return;
        }
        lastGuard = null;
      } else {
        break;
      }
    } while ((i += step) !== end2);
    if (lastGuard) {
      lastGuard.node.tabIndex = 0;
    }
  }
  var focusWasOutside = function focusWasOutside2(crossFrameOption) {
    if (crossFrameOption) {
      return Boolean(focusWasOutsideWindow);
    }
    return focusWasOutsideWindow === "meanwhile";
  };
  var checkInHost = function checkInHost2(check2, el, boundary) {
    return el && (el.host === check2 && (!el.activeElement || boundary.contains(el.activeElement)) || el.parentNode && checkInHost2(check2, el.parentNode, boundary));
  };
  var withinHost = function withinHost2(activeElement, workingArea) {
    return workingArea.some(function(area) {
      return checkInHost(activeElement, area, area);
    });
  };
  var getNodeFocusables = function getNodeFocusables2(nodes) {
    return getFocusableNodes(nodes, /* @__PURE__ */ new Map());
  };
  var isNotFocusable = function isNotFocusable2(node2) {
    return !getNodeFocusables([node2.parentNode]).some(function(el) {
      return el.node === node2;
    });
  };
  var activateTrap = function activateTrap2() {
    var result2 = false;
    if (lastActiveTrap) {
      var _lastActiveTrap = lastActiveTrap, observed = _lastActiveTrap.observed, persistentFocus = _lastActiveTrap.persistentFocus, autoFocus = _lastActiveTrap.autoFocus, shards = _lastActiveTrap.shards, crossFrame = _lastActiveTrap.crossFrame, focusOptions = _lastActiveTrap.focusOptions, noFocusGuards = _lastActiveTrap.noFocusGuards;
      var workingNode = observed || lastPortaledElement && lastPortaledElement.portaledElement;
      if (focusOnBody() && lastActiveFocus && lastActiveFocus !== document.body) {
        if (!document.body.contains(lastActiveFocus) || isNotFocusable(lastActiveFocus)) {
          var newTarget = tryRestoreFocus();
          if (newTarget) {
            newTarget.focus();
          }
        }
      }
      var activeElement = document && document.activeElement;
      if (workingNode) {
        var workingArea = [workingNode].concat(shards.map(extractRef).filter(Boolean));
        var shouldForceRestoreFocus = function shouldForceRestoreFocus2() {
          if (!focusWasOutside(crossFrame) || !noFocusGuards || !lastActiveFocus || windowFocused) {
            return false;
          }
          var nodes = getNodeFocusables(workingArea);
          var lastIndex = nodes.findIndex(function(_ref2) {
            var node2 = _ref2.node;
            return node2 === lastActiveFocus;
          });
          return lastIndex === 0 || lastIndex === nodes.length - 1;
        };
        if (!activeElement || focusWhitelisted(activeElement)) {
          if (persistentFocus || shouldForceRestoreFocus() || !isFreeFocus() || !lastActiveFocus && autoFocus) {
            if (workingNode && !(focusInside(workingArea) || activeElement && withinHost(activeElement, workingArea) || focusIsPortaledPair(activeElement, workingNode))) {
              if (document && !lastActiveFocus && activeElement && !autoFocus) {
                if (activeElement.blur) {
                  activeElement.blur();
                }
                document.body.focus();
              } else {
                result2 = moveFocusInside(workingArea, lastActiveFocus, {
                  focusOptions
                });
                lastPortaledElement = {};
              }
            }
            lastActiveFocus = document && document.activeElement;
            if (lastActiveFocus !== document.body) {
              tryRestoreFocus = captureFocusRestore(lastActiveFocus);
            }
            focusWasOutsideWindow = false;
          }
        }
        if (document && activeElement !== document.activeElement && document.querySelector("[data-focus-auto-guard]")) {
          var newActiveElement = document && document.activeElement;
          var allNodes = expandFocusableNodes(workingArea);
          var focusedIndex = allNodes.map(function(_ref2) {
            var node2 = _ref2.node;
            return node2;
          }).indexOf(newActiveElement);
          if (focusedIndex > -1) {
            allNodes.filter(function(_ref3) {
              var guard = _ref3.guard, node2 = _ref3.node;
              return guard && node2.dataset.focusAutoGuard;
            }).forEach(function(_ref4) {
              var node2 = _ref4.node;
              return node2.removeAttribute("tabIndex");
            });
            autoGuard(focusedIndex, allNodes.length, 1, allNodes);
            autoGuard(focusedIndex, -1, -1, allNodes);
          }
        }
      }
    }
    return result2;
  };
  var onTrap = function onTrap2(event) {
    if (activateTrap() && event) {
      event.stopPropagation();
      event.preventDefault();
    }
  };
  var onBlur = function onBlur2() {
    return deferAction(activateTrap);
  };
  var onFocus = function onFocus2(event) {
    var source2 = event.target;
    var currentNode = event.currentTarget;
    if (!currentNode.contains(source2)) {
      recordPortal(currentNode, source2);
    }
  };
  var FocusWatcher = function FocusWatcher2() {
    return null;
  };
  var FocusTrap = function FocusTrap2(_ref5) {
    var children = _ref5.children;
    return /* @__PURE__ */ import_react79.default.createElement("div", {
      onBlur,
      onFocus
    }, children);
  };
  FocusTrap.propTypes = false ? {
    children: import_prop_types.default.node.isRequired
  } : {};
  var onWindowFocus = function onWindowFocus2() {
    windowFocused = true;
  };
  var onWindowBlur = function onWindowBlur2() {
    windowFocused = false;
    focusWasOutsideWindow = "just";
    deferAction(function() {
      focusWasOutsideWindow = "meanwhile";
    });
  };
  var attachHandler = function attachHandler2() {
    document.addEventListener("focusin", onTrap);
    document.addEventListener("focusout", onBlur);
    window.addEventListener("focus", onWindowFocus);
    window.addEventListener("blur", onWindowBlur);
  };
  var detachHandler = function detachHandler2() {
    document.removeEventListener("focusin", onTrap);
    document.removeEventListener("focusout", onBlur);
    window.removeEventListener("focus", onWindowFocus);
    window.removeEventListener("blur", onWindowBlur);
  };
  function reducePropsToState(propsList) {
    return propsList.filter(function(_ref6) {
      var disabled = _ref6.disabled;
      return !disabled;
    });
  }
  var focusLockAPI = {
    moveFocusInside,
    focusInside,
    focusNextElement,
    focusPrevElement,
    focusFirstElement,
    focusLastElement,
    captureFocusRestore
  };
  function handleStateChangeOnClient(traps) {
    var trap = traps.slice(-1)[0];
    if (trap && !lastActiveTrap) {
      attachHandler();
    }
    var lastTrap = lastActiveTrap;
    var sameTrap = lastTrap && trap && trap.id === lastTrap.id;
    lastActiveTrap = trap;
    if (lastTrap && !sameTrap) {
      lastTrap.onDeactivation();
      if (!traps.filter(function(_ref7) {
        var id = _ref7.id;
        return id === lastTrap.id;
      }).length) {
        lastTrap.returnFocus(!trap);
      }
    }
    if (trap) {
      lastActiveFocus = null;
      if (!sameTrap || lastTrap.observed !== trap.observed) {
        trap.onActivation(focusLockAPI);
      }
      activateTrap(true);
      deferAction(activateTrap);
    } else {
      detachHandler();
      lastActiveFocus = null;
    }
  }
  mediumFocus.assignSyncMedium(onFocus);
  mediumBlur.assignMedium(onBlur);
  mediumEffect.assignMedium(function(cb) {
    return cb(focusLockAPI);
  });
  var Trap_default = index_es_default(reducePropsToState, handleStateChangeOnClient)(FocusWatcher);

  // node_modules/react-focus-lock/dist/es2015/Combination.js
  var FocusLockCombination = /* @__PURE__ */ (0, import_react80.forwardRef)(function FocusLockUICombination(props, ref) {
    return /* @__PURE__ */ import_react80.default.createElement(Lock_default, _extends({
      sideCar: Trap_default,
      ref
    }, props));
  });
  var _ref = Lock_default.propTypes || {};
  var sideCar = _ref.sideCar;
  var propTypes = _objectWithoutPropertiesLoose(_ref, ["sideCar"]);
  FocusLockCombination.propTypes = false ? propTypes : {};
  var Combination_default = FocusLockCombination;

  // node_modules/react-focus-lock/dist/es2015/index.js
  var es2015_default = Combination_default;

  // node_modules/@atlaskit/modal-dialog/dist/esm/internal/components/modal-wrapper.js
  var import_react_scrolllock = __toESM(require_dist2());

  // node_modules/@atlaskit/blanket/dist/esm/blanket.js
  init_defineProperty();
  var React52 = __toESM(require_react());
  var import_react81 = __toESM(require_react());
  function ownKeys9(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r && (o = o.filter(function(r2) {
        return Object.getOwnPropertyDescriptor(e, r2).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread9(e) {
    for (var r = 1; r < arguments.length; r++) {
      var t = null != arguments[r] ? arguments[r] : {};
      r % 2 ? ownKeys9(Object(t), true).forEach(function(r2) {
        _defineProperty(e, r2, t[r2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys9(Object(t)).forEach(function(r2) {
        Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
      });
    }
    return e;
  }
  var packageName = "@atlaskit/blanket";
  var packageVersion = "15.0.8";
  var analyticsAttributes2 = {
    componentName: "blanket",
    packageName,
    packageVersion
  };
  var Blanket = /* @__PURE__ */ (0, import_react81.memo)(/* @__PURE__ */ (0, import_react81.forwardRef)(function Blanket2(_ref2, ref) {
    var _ref$shouldAllowClick = _ref2.shouldAllowClickThrough, shouldAllowClickThrough = _ref$shouldAllowClick === void 0 ? false : _ref$shouldAllowClick, _ref$isTinted = _ref2.isTinted, isTinted = _ref$isTinted === void 0 ? false : _ref$isTinted, _ref$onBlanketClicked = _ref2.onBlanketClicked, onBlanketClicked = _ref$onBlanketClicked === void 0 ? noop3 : _ref$onBlanketClicked, testId = _ref2.testId, children = _ref2.children, analyticsContext = _ref2.analyticsContext;
    var mouseDownTarget = (0, import_react81.useRef)(null);
    var onBlanketClickedWithAnalytics = usePlatformLeafEventHandler(_objectSpread9({
      fn: onBlanketClicked,
      action: "clicked",
      analyticsData: analyticsContext
    }, analyticsAttributes2));
    var blanketClickOutsideChildren = (0, import_react81.useCallback)(function(e) {
      return e.currentTarget === e.target && mouseDownTarget.current === e.target ? onBlanketClickedWithAnalytics(e) : void 0;
    }, [onBlanketClickedWithAnalytics]);
    var onClick = shouldAllowClickThrough ? void 0 : blanketClickOutsideChildren;
    var onMouseDown = (0, import_react81.useCallback)(function(e) {
      mouseDownTarget.current = e.target;
    }, []);
    return /* @__PURE__ */ React52.createElement("div", {
      role: "presentation",
      onClick,
      onMouseDown,
      "data-testid": testId,
      ref,
      className: ax(["_1r04idpf _kqsw1n9t _1pbybfng _bfhk705f _18m91wug _lcxv1wug", shouldAllowClickThrough && "_lcxvglyw", !isTinted && "_bfhk1j28"]),
      style: {
        "--_10avjlk": cssCustomPropertyValue("var(--ds-blanket, ".concat(N100A, ")"))
      }
    }, children);
  }));
  Blanket.displayName = "Blanket";
  var blanket_default = Blanket;

  // node_modules/@atlaskit/modal-dialog/dist/esm/internal/hooks/use-modal-stack.js
  init_slicedToArray();
  var import_react85 = __toESM(require_react());

  // node_modules/@atlaskit/ds-lib/dist/esm/hooks/use-lazy-ref.js
  var import_react82 = __toESM(require_react());
  var uniqueReferencedValue = {};
  function useLazyRef(initializer) {
    var ref = (0, import_react82.useRef)(uniqueReferencedValue);
    if (ref.current === uniqueReferencedValue) {
      ref.current = initializer();
    }
    return ref;
  }

  // node_modules/@atlaskit/ds-lib/dist/esm/hooks/use-lazy-callback.js
  function useLazyCallback(callback) {
    var ref = useLazyRef(function() {
      return callback;
    });
    return ref.current;
  }

  // node_modules/@atlaskit/ds-lib/dist/esm/hooks/use-previous-value.js
  var import_react83 = __toESM(require_react());
  function usePreviousValue(value) {
    var ref = (0, import_react83.useRef)();
    (0, import_react83.useEffect)(function() {
      ref.current = value;
    }, [value]);
    return ref.current;
  }

  // node_modules/@atlaskit/ds-lib/dist/esm/hooks/use-state-ref.js
  init_slicedToArray();
  var import_react84 = __toESM(require_react());
  function useStateRef(initialState) {
    var _useState = (0, import_react84.useState)(initialState), _useState2 = _slicedToArray(_useState, 2), value = _useState2[0], setValue = _useState2[1];
    var valueRef = (0, import_react84.useRef)(value);
    valueRef.current = value;
    return [valueRef, setValue];
  }

  // node_modules/@atlaskit/modal-dialog/dist/esm/internal/hooks/use-modal-stack.js
  var modalStackRegister = [];
  function useModalStack(_ref2) {
    var onStackChange = _ref2.onStackChange;
    var _useExitingPersistenc = useExitingPersistence(), isExiting = _useExitingPersistenc.isExiting;
    var _useStateRef = useStateRef(0), _useStateRef2 = _slicedToArray(_useStateRef, 2), stackIndexRef = _useStateRef2[0], setStackIndex = _useStateRef2[1];
    var currentStackIndex = stackIndexRef.current;
    var previousStackIndex = usePreviousValue(stackIndexRef.current);
    var updateStack = useLazyCallback(function() {
      var newStackIndex = modalStackRegister.indexOf(updateStack);
      if (stackIndexRef.current !== newStackIndex) {
        setStackIndex(newStackIndex);
        stackIndexRef.current = newStackIndex;
      }
    });
    (0, import_react85.useEffect)(function() {
      var currentStackIndex2 = modalStackRegister.indexOf(updateStack);
      if (!isExiting && currentStackIndex2 === -1) {
        modalStackRegister.unshift(updateStack);
      }
      if (isExiting && currentStackIndex2 !== -1) {
        modalStackRegister.splice(currentStackIndex2, 1);
      }
      modalStackRegister.forEach(function(cb) {
        return cb();
      });
    }, [updateStack, isExiting]);
    (0, import_react85.useEffect)(function() {
      return function() {
        var currentStackIndex2 = modalStackRegister.indexOf(updateStack);
        if (currentStackIndex2 !== -1) {
          modalStackRegister.splice(currentStackIndex2, 1);
          modalStackRegister.forEach(function(cb) {
            return cb();
          });
        }
      };
    }, [updateStack]);
    (0, import_react85.useEffect)(function() {
      if (previousStackIndex === void 0) {
        return;
      }
      if (previousStackIndex !== currentStackIndex) {
        onStackChange(currentStackIndex);
      }
    }, [onStackChange, previousStackIndex, currentStackIndex]);
    return currentStackIndex;
  }

  // node_modules/@atlaskit/modal-dialog/dist/esm/internal/hooks/use-prevent-programmatic-scroll.js
  init_slicedToArray();
  var import_react86 = __toESM(require_react());
  var import_bind_event_listener7 = __toESM(require_dist());
  function getScrollDistance() {
    var _document$documentEle, _document$body;
    return window.pageYOffset || ((_document$documentEle = document.documentElement) === null || _document$documentEle === void 0 ? void 0 : _document$documentEle.scrollTop) || ((_document$body = document.body) === null || _document$body === void 0 ? void 0 : _document$body.scrollTop) || 0;
  }
  function usePreventProgrammaticScroll() {
    var _useState = (0, import_react86.useState)(0), _useState2 = _slicedToArray(_useState, 2), scrollTopOffset = _useState2[0], setScrollTopOffset = _useState2[1];
    (0, import_react86.useLayoutEffect)(function() {
      setScrollTopOffset(getScrollDistance());
    }, []);
    var onWindowScroll = (0, import_react86.useCallback)(function() {
      if (getScrollDistance() !== scrollTopOffset) {
        window.scrollTo(window.pageXOffset, scrollTopOffset);
      }
    }, [scrollTopOffset]);
    (0, import_react86.useEffect)(function() {
      return (0, import_bind_event_listener7.bind)(window, {
        type: "scroll",
        listener: onWindowScroll
      });
    }, [onWindowScroll]);
    return scrollTopOffset;
  }

  // node_modules/@atlaskit/modal-dialog/dist/esm/internal/components/modal-dialog.js
  init_slicedToArray();
  init_typeof();
  var React54 = __toESM(require_react());
  var import_react89 = __toESM(require_react());

  // node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/public-utils/combine.js
  function combine() {
    for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {
      fns[_key] = arguments[_key];
    }
    return function cleanup() {
      fns.forEach(function(fn2) {
        return fn2();
      });
    };
  }

  // node_modules/@atlaskit/modal-dialog/dist/esm/internal/context.js
  var import_react87 = __toESM(require_react());
  var ModalContext = /* @__PURE__ */ (0, import_react87.createContext)(null);
  var ScrollContext = /* @__PURE__ */ (0, import_react87.createContext)(null);

  // node_modules/@atlaskit/modal-dialog/dist/esm/internal/hooks/use-on-motion-finish.js
  var import_react88 = __toESM(require_react());
  function useOnMotionFinish(_ref2) {
    var onOpenComplete = _ref2.onOpenComplete, onCloseComplete = _ref2.onCloseComplete;
    var motionRef = (0, import_react88.useRef)(null);
    var onMotionFinish = (0, import_react88.useCallback)(function(state) {
      if (state === "entering" && onOpenComplete) {
        onOpenComplete(motionRef.current, true);
      }
      if (state === "exiting" && onCloseComplete) {
        onCloseComplete(motionRef.current);
      }
    }, [onOpenComplete, onCloseComplete]);
    return [motionRef, onMotionFinish];
  }

  // node_modules/@atlaskit/modal-dialog/dist/esm/internal/pragmatic-drag-and-drop/disable-dragging-to-cross-origin-iframes/element.js
  var import_bind_event_listener12 = __toESM(require_dist());

  // node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/adapter/element-adapter.js
  init_slicedToArray();
  var import_bind_event_listener11 = __toESM(require_dist());

  // node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/honey-pot-fix/get-element-from-point-without-honey-pot.js
  init_slicedToArray();

  // node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/honey-pot-fix/honey-pot-data-attribute.js
  var honeyPotDataAttribute = "data-pdnd-honey-pot";

  // node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/honey-pot-fix/is-honey-pot-element.js
  function isHoneyPotElement(target) {
    return target instanceof Element && target.hasAttribute(honeyPotDataAttribute);
  }

  // node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/honey-pot-fix/get-element-from-point-without-honey-pot.js
  function getElementFromPointWithoutHoneypot(client2) {
    var _document$elementsFro = document.elementsFromPoint(client2.x, client2.y), _document$elementsFro2 = _slicedToArray(_document$elementsFro, 2), top2 = _document$elementsFro2[0], second = _document$elementsFro2[1];
    if (!top2) {
      return null;
    }
    if (isHoneyPotElement(top2)) {
      return second !== null && second !== void 0 ? second : null;
    }
    return top2;
  }

  // node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/honey-pot-fix/make-honey-pot-fix.js
  init_defineProperty();
  var import_bind_event_listener8 = __toESM(require_dist());

  // node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/util/max-z-index.js
  var maxZIndex = 2147483647;

  // node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/honey-pot-fix/make-honey-pot-fix.js
  function ownKeys10(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r && (o = o.filter(function(r2) {
        return Object.getOwnPropertyDescriptor(e, r2).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread10(e) {
    for (var r = 1; r < arguments.length; r++) {
      var t = null != arguments[r] ? arguments[r] : {};
      r % 2 ? ownKeys10(Object(t), true).forEach(function(r2) {
        _defineProperty(e, r2, t[r2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys10(Object(t)).forEach(function(r2) {
        Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
      });
    }
    return e;
  }
  var honeyPotSize = 2;
  var halfHoneyPotSize = honeyPotSize / 2;
  function floorToClosestPixel(point) {
    return {
      x: Math.floor(point.x),
      y: Math.floor(point.y)
    };
  }
  function pullBackByHalfHoneyPotSize(point) {
    return {
      x: point.x - halfHoneyPotSize,
      y: point.y - halfHoneyPotSize
    };
  }
  function preventGoingBackwardsOffScreen(point) {
    return {
      x: Math.max(point.x, 0),
      y: Math.max(point.y, 0)
    };
  }
  function preventGoingForwardsOffScreen(point) {
    return {
      x: Math.min(point.x, window.innerWidth - honeyPotSize),
      y: Math.min(point.y, window.innerHeight - honeyPotSize)
    };
  }
  function getHoneyPotRectFor(_ref2) {
    var client2 = _ref2.client;
    var point = preventGoingForwardsOffScreen(preventGoingBackwardsOffScreen(pullBackByHalfHoneyPotSize(floorToClosestPixel(client2))));
    return DOMRect.fromRect({
      x: point.x,
      y: point.y,
      width: honeyPotSize,
      height: honeyPotSize
    });
  }
  function getRectStyles(_ref2) {
    var clientRect = _ref2.clientRect;
    return {
      left: "".concat(clientRect.left, "px"),
      top: "".concat(clientRect.top, "px"),
      width: "".concat(clientRect.width, "px"),
      height: "".concat(clientRect.height, "px")
    };
  }
  function isWithin(_ref3) {
    var client2 = _ref3.client, clientRect = _ref3.clientRect;
    return (
      // is within horizontal bounds
      client2.x >= clientRect.x && client2.x <= clientRect.x + clientRect.width && // is within vertical bounds
      client2.y >= clientRect.y && client2.y <= clientRect.y + clientRect.height
    );
  }
  function mountHoneyPot(_ref4) {
    var initial = _ref4.initial;
    var element = document.createElement("div");
    element.setAttribute(honeyPotDataAttribute, "true");
    var clientRect = getHoneyPotRectFor({
      client: initial
    });
    Object.assign(element.style, _objectSpread10(_objectSpread10({
      // Setting a background color explicitly to avoid any inherited styles.
      // Looks like this could be `opacity: 0`, but worried that _might_
      // cause the element to be ignored on some platforms.
      // When debugging, set backgroundColor to something like "red".
      backgroundColor: "transparent",
      position: "fixed",
      // Being explicit to avoid inheriting styles
      padding: 0,
      margin: 0,
      boxSizing: "border-box"
    }, getRectStyles({
      clientRect
    })), {}, {
      // We want this element to absorb pointer events,
      // it's kind of the whole point 😉
      pointerEvents: "auto",
      // Want to make sure the honey pot is top of everything else.
      // Don't need to worry about native drag previews, as they will
      // have been rendered (and removed) before the honey pot is rendered
      zIndex: maxZIndex
    }));
    document.body.appendChild(element);
    var unbindPointerMove = (0, import_bind_event_listener8.bind)(window, {
      type: "pointermove",
      listener: function listener(event) {
        var client2 = {
          x: event.clientX,
          y: event.clientY
        };
        clientRect = getHoneyPotRectFor({
          client: client2
        });
        Object.assign(element.style, getRectStyles({
          clientRect
        }));
      },
      // using capture so we are less likely to be impacted by event stopping
      options: {
        capture: true
      }
    });
    return function finish(_ref5) {
      var current = _ref5.current;
      unbindPointerMove();
      if (isWithin({
        client: current,
        clientRect
      })) {
        element.remove();
        return;
      }
      function cleanup() {
        unbindPostDragEvents();
        element.remove();
      }
      var unbindPostDragEvents = (0, import_bind_event_listener8.bindAll)(window, [
        {
          type: "pointerdown",
          listener: cleanup
        },
        {
          type: "pointermove",
          listener: cleanup
        },
        {
          type: "focusin",
          listener: cleanup
        },
        {
          type: "focusout",
          listener: cleanup
        },
        // a 'pointerdown' should happen before 'dragstart', but just being super safe
        {
          type: "dragstart",
          listener: cleanup
        },
        // if the user has dragged something out of the window
        // and then is dragging something back into the window
        // the first events we will see are "dragenter" (and then "dragover").
        // So if we see any of these we need to clear the post drag fix.
        {
          type: "dragenter",
          listener: cleanup
        },
        {
          type: "dragover",
          listener: cleanup
        }
        // Not adding a "wheel" event listener, as "wheel" by itself does not
        // resolve the bug.
      ], {
        // Using `capture` so less likely to be impacted by other code stopping events
        capture: true
      });
    };
  }
  function makeHoneyPotFix() {
    var latestPointerMove = null;
    function bindEvents() {
      latestPointerMove = null;
      return (0, import_bind_event_listener8.bind)(window, {
        type: "pointermove",
        listener: function listener(event) {
          latestPointerMove = {
            x: event.clientX,
            y: event.clientY
          };
        },
        // listening for pointer move in capture phase
        // so we are less likely to be impacted by events being stopped.
        options: {
          capture: true
        }
      });
    }
    function getOnPostDispatch() {
      var finish = null;
      return function onPostEvent(_ref6) {
        var eventName = _ref6.eventName, payload = _ref6.payload;
        if (eventName === "onDragStart") {
          var input = payload.location.initial.input;
          var initial = latestPointerMove !== null && latestPointerMove !== void 0 ? latestPointerMove : {
            x: input.clientX,
            y: input.clientY
          };
          finish = mountHoneyPot({
            initial
          });
        }
        if (eventName === "onDrop") {
          var _finish;
          var _input = payload.location.current.input;
          (_finish = finish) === null || _finish === void 0 || _finish({
            current: {
              x: _input.clientX,
              y: _input.clientY
            }
          });
          finish = null;
          latestPointerMove = null;
        }
      };
    }
    return {
      bindEvents,
      getOnPostDispatch
    };
  }

  // node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/ledger/lifecycle-manager.js
  init_toConsumableArray();
  var import_bind_event_listener10 = __toESM(require_dist());

  // node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/public-utils/once.js
  function once(fn2) {
    var cache = null;
    return function wrapped() {
      if (!cache) {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        var result2 = fn2.apply(this, args);
        cache = {
          result: result2
        };
      }
      return cache.result;
    };
  }

  // node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/util/is-firefox.js
  var isFirefox = once(function isFirefox2() {
    if (false) {
      return false;
    }
    return navigator.userAgent.includes("Firefox");
  });

  // node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/util/is-safari.js
  var isSafari2 = once(function isSafari3() {
    if (false) {
      return false;
    }
    var _navigator = navigator, userAgent = _navigator.userAgent;
    return userAgent.includes("AppleWebKit") && !userAgent.includes("Chrome");
  });

  // node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/util/changing-window/count-events-for-safari.js
  var import_bind_event_listener9 = __toESM(require_dist());
  var symbols = {
    isLeavingWindow: Symbol("leaving"),
    isEnteringWindow: Symbol("entering")
  };
  function isEnteringWindowInSafari(_ref2) {
    var dragEnter = _ref2.dragEnter;
    if (!isSafari2()) {
      return false;
    }
    return dragEnter.hasOwnProperty(symbols.isEnteringWindow);
  }
  function isLeavingWindowInSafari(_ref2) {
    var dragLeave = _ref2.dragLeave;
    if (!isSafari2()) {
      return false;
    }
    return dragLeave.hasOwnProperty(symbols.isLeavingWindow);
  }
  (function fixSafari() {
    if (typeof window === "undefined") {
      return;
    }
    if (false) {
      return;
    }
    if (!isSafari2()) {
      return;
    }
    function getInitialState() {
      return {
        enterCount: 0,
        isOverWindow: false
      };
    }
    var state = getInitialState();
    function resetState() {
      state = getInitialState();
    }
    (0, import_bind_event_listener9.bindAll)(
      window,
      [{
        type: "dragstart",
        listener: function listener() {
          state.enterCount = 0;
          state.isOverWindow = true;
        }
      }, {
        type: "drop",
        listener: resetState
      }, {
        type: "dragend",
        listener: resetState
      }, {
        type: "dragenter",
        listener: function listener(event) {
          if (!state.isOverWindow && state.enterCount === 0) {
            event[symbols.isEnteringWindow] = true;
          }
          state.isOverWindow = true;
          state.enterCount++;
        }
      }, {
        type: "dragleave",
        listener: function listener(event) {
          state.enterCount--;
          if (state.isOverWindow && state.enterCount === 0) {
            event[symbols.isLeavingWindow] = true;
            state.isOverWindow = false;
          }
        }
      }],
      // using `capture: true` so that adding event listeners
      // in bubble phase will have the correct symbols
      {
        capture: true
      }
    );
  })();

  // node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/util/changing-window/is-from-another-window.js
  function isNodeLike(target) {
    return "nodeName" in target;
  }
  function isFromAnotherWindow(eventTarget) {
    return isNodeLike(eventTarget) && eventTarget.ownerDocument !== document;
  }

  // node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/util/changing-window/is-leaving-window.js
  function isLeavingWindow(_ref2) {
    var dragLeave = _ref2.dragLeave;
    var type = dragLeave.type, relatedTarget = dragLeave.relatedTarget;
    if (type !== "dragleave") {
      return false;
    }
    if (isSafari2()) {
      return isLeavingWindowInSafari({
        dragLeave
      });
    }
    if (relatedTarget == null) {
      return true;
    }
    if (isFirefox()) {
      return isFromAnotherWindow(relatedTarget);
    }
    return relatedTarget instanceof HTMLIFrameElement;
  }

  // node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/util/detect-broken-drag.js
  function getBindingsForBrokenDrags(_ref2) {
    var onDragEnd2 = _ref2.onDragEnd;
    return [
      // ## Detecting drag ending for removed draggables
      //
      // If a draggable element is removed during a drag and the user drops:
      // 1. if over a valid drop target: we get a "drop" event to know the drag is finished
      // 2. if not over a valid drop target (or cancelled): we get nothing
      // The "dragend" event will not fire on the source draggable if it has been
      // removed from the DOM.
      // So we need to figure out if a drag operation has finished by looking at other events
      // We can do this by looking at other events
      // ### First detection: "pointermove" events
      // 1. "pointermove" events cannot fire during a drag and drop operation
      // according to the spec. So if we get a "pointermove" it means that
      // the drag and drop operations has finished. So if we get a "pointermove"
      // we know that the drag is over
      // 2. 🦊😤 Drag and drop operations are _supposed_ to suppress
      // other pointer events. However, firefox will allow a few
      // pointer event to get through after a drag starts.
      // The most I've seen is 3
      {
        type: "pointermove",
        listener: /* @__PURE__ */ (function() {
          var callCount = 0;
          return function listener() {
            if (callCount < 20) {
              callCount++;
              return;
            }
            onDragEnd2();
          };
        })()
      },
      // ### Second detection: "pointerdown" events
      // If we receive this event then we know that a drag operation has finished
      // and potentially another one is about to start.
      // Note: `pointerdown` fires on all browsers / platforms before "dragstart"
      {
        type: "pointerdown",
        listener: onDragEnd2
      }
    ];
  }

  // node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/util/get-input.js
  function getInput(event) {
    return {
      altKey: event.altKey,
      button: event.button,
      buttons: event.buttons,
      ctrlKey: event.ctrlKey,
      metaKey: event.metaKey,
      shiftKey: event.shiftKey,
      clientX: event.clientX,
      clientY: event.clientY,
      pageX: event.pageX,
      pageY: event.pageY
    };
  }

  // node_modules/raf-schd/dist/raf-schd.esm.js
  var rafSchd = function rafSchd2(fn2) {
    var lastArgs = [];
    var frameId = null;
    var wrapperFn = function wrapperFn2() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      lastArgs = args;
      if (frameId) {
        return;
      }
      frameId = requestAnimationFrame(function() {
        frameId = null;
        fn2.apply(void 0, lastArgs);
      });
    };
    wrapperFn.cancel = function() {
      if (!frameId) {
        return;
      }
      cancelAnimationFrame(frameId);
      frameId = null;
    };
    return wrapperFn;
  };
  var raf_schd_esm_default = rafSchd;

  // node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/ledger/dispatch-consumer-event.js
  var scheduleOnDrag = raf_schd_esm_default(function(fn2) {
    return fn2();
  });
  var dragStart = /* @__PURE__ */ (function() {
    var scheduled = null;
    function schedule2(fn2) {
      var frameId = requestAnimationFrame(function() {
        scheduled = null;
        fn2();
      });
      scheduled = {
        frameId,
        fn: fn2
      };
    }
    function flush() {
      if (scheduled) {
        cancelAnimationFrame(scheduled.frameId);
        scheduled.fn();
        scheduled = null;
      }
    }
    return {
      schedule: schedule2,
      flush
    };
  })();
  function makeDispatch(_ref2) {
    var source2 = _ref2.source, initial = _ref2.initial, dispatchEvent2 = _ref2.dispatchEvent;
    var previous = {
      dropTargets: []
    };
    function safeDispatch(args) {
      dispatchEvent2(args);
      previous = {
        dropTargets: args.payload.location.current.dropTargets
      };
    }
    var dispatch = {
      start: function start3(_ref22) {
        var nativeSetDragImage = _ref22.nativeSetDragImage;
        var location2 = {
          current: initial,
          previous,
          initial
        };
        safeDispatch({
          eventName: "onGenerateDragPreview",
          payload: {
            source: source2,
            location: location2,
            nativeSetDragImage
          }
        });
        dragStart.schedule(function() {
          safeDispatch({
            eventName: "onDragStart",
            payload: {
              source: source2,
              location: location2
            }
          });
        });
      },
      dragUpdate: function dragUpdate(_ref3) {
        var current = _ref3.current;
        dragStart.flush();
        scheduleOnDrag.cancel();
        safeDispatch({
          eventName: "onDropTargetChange",
          payload: {
            source: source2,
            location: {
              initial,
              previous,
              current
            }
          }
        });
      },
      drag: function drag(_ref4) {
        var current = _ref4.current;
        scheduleOnDrag(function() {
          dragStart.flush();
          var location2 = {
            initial,
            previous,
            current
          };
          safeDispatch({
            eventName: "onDrag",
            payload: {
              source: source2,
              location: location2
            }
          });
        });
      },
      drop: function drop(_ref5) {
        var current = _ref5.current, updatedSourcePayload = _ref5.updatedSourcePayload;
        dragStart.flush();
        scheduleOnDrag.cancel();
        safeDispatch({
          eventName: "onDrop",
          payload: {
            source: updatedSourcePayload !== null && updatedSourcePayload !== void 0 ? updatedSourcePayload : source2,
            location: {
              current,
              previous,
              initial
            }
          }
        });
      }
    };
    return dispatch;
  }

  // node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/ledger/lifecycle-manager.js
  var globalState = {
    isActive: false
  };
  function canStart() {
    return !globalState.isActive;
  }
  function getNativeSetDragImage(event) {
    if (event.dataTransfer) {
      return event.dataTransfer.setDragImage.bind(event.dataTransfer);
    }
    return null;
  }
  function hasHierarchyChanged(_ref2) {
    var current = _ref2.current, next2 = _ref2.next;
    if (current.length !== next2.length) {
      return true;
    }
    for (var i = 0; i < current.length; i++) {
      if (current[i].element !== next2[i].element) {
        return true;
      }
    }
    return false;
  }
  function start2(_ref2) {
    var event = _ref2.event, dragType = _ref2.dragType, getDropTargetsOver = _ref2.getDropTargetsOver, dispatchEvent2 = _ref2.dispatchEvent;
    if (!canStart()) {
      return;
    }
    var initial = getStartLocation({
      event,
      dragType,
      getDropTargetsOver
    });
    globalState.isActive = true;
    var state = {
      current: initial
    };
    setDropEffectOnEvent({
      event,
      current: initial.dropTargets
    });
    var dispatch = makeDispatch({
      source: dragType.payload,
      dispatchEvent: dispatchEvent2,
      initial
    });
    function updateState(next2) {
      var hasChanged = hasHierarchyChanged({
        current: state.current.dropTargets,
        next: next2.dropTargets
      });
      state.current = next2;
      if (hasChanged) {
        dispatch.dragUpdate({
          current: state.current
        });
      }
    }
    function onUpdateEvent(event2) {
      var input = getInput(event2);
      var target = isHoneyPotElement(event2.target) ? getElementFromPointWithoutHoneypot({
        x: input.clientX,
        y: input.clientY
      }) : event2.target;
      var nextDropTargets = getDropTargetsOver({
        target,
        input,
        source: dragType.payload,
        current: state.current.dropTargets
      });
      if (nextDropTargets.length) {
        event2.preventDefault();
        setDropEffectOnEvent({
          event: event2,
          current: nextDropTargets
        });
      }
      updateState({
        dropTargets: nextDropTargets,
        input
      });
    }
    function cancel() {
      if (state.current.dropTargets.length) {
        updateState({
          dropTargets: [],
          input: state.current.input
        });
      }
      dispatch.drop({
        current: state.current,
        updatedSourcePayload: null
      });
      finish();
    }
    function finish() {
      globalState.isActive = false;
      unbindEvents();
    }
    var unbindEvents = (0, import_bind_event_listener10.bindAll)(
      window,
      [{
        // 👋 Note: we are repurposing the `dragover` event as our `drag` event
        // this is because firefox does not publish pointer coordinates during
        // a `drag` event, but does for every other type of drag event
        // `dragover` fires on all elements that are being dragged over
        // Because we are binding to `window` - our `dragover` is effectively the same as a `drag`
        // 🦊😤
        type: "dragover",
        listener: function listener(event2) {
          onUpdateEvent(event2);
          dispatch.drag({
            current: state.current
          });
        }
      }, {
        type: "dragenter",
        listener: onUpdateEvent
      }, {
        type: "dragleave",
        listener: function listener(event2) {
          if (!isLeavingWindow({
            dragLeave: event2
          })) {
            return;
          }
          updateState({
            input: state.current.input,
            dropTargets: []
          });
          if (dragType.startedFrom === "external") {
            cancel();
          }
        }
      }, {
        // A "drop" can only happen if the browser allowed the drop
        type: "drop",
        listener: function listener(event2) {
          state.current = {
            dropTargets: state.current.dropTargets,
            input: getInput(event2)
          };
          if (!state.current.dropTargets.length) {
            cancel();
            return;
          }
          event2.preventDefault();
          setDropEffectOnEvent({
            event: event2,
            current: state.current.dropTargets
          });
          dispatch.drop({
            current: state.current,
            // When dropping something native, we need to extract the latest
            // `.items` from the "drop" event as it is now accessible
            updatedSourcePayload: dragType.type === "external" ? dragType.getDropPayload(event2) : null
          });
          finish();
        }
      }, {
        // "dragend" fires when on the drag source (eg a draggable element)
        // when the drag is finished.
        // "dragend" will fire after "drop" (if there was a successful drop)
        // "dragend" does not fire if the draggable source has been removed during the drag
        // or for external drag sources (eg files)
        // This "dragend" listener will not fire if there was a successful drop
        // as we will have already removed the event listener
        type: "dragend",
        listener: function listener(event2) {
          state.current = {
            dropTargets: state.current.dropTargets,
            input: getInput(event2)
          };
          cancel();
        }
      }].concat(_toConsumableArray(getBindingsForBrokenDrags({
        onDragEnd: cancel
      }))),
      // Once we have started a managed drag operation it is important that we see / own all drag events
      // We got one adoption bug pop up where some code was stopping (`event.stopPropagation()`)
      // all "drop" events in the bubble phase on the `document.body`.
      // This meant that we never saw the "drop" event.
      {
        capture: true
      }
    );
    dispatch.start({
      nativeSetDragImage: getNativeSetDragImage(event)
    });
  }
  function setDropEffectOnEvent(_ref3) {
    var _current$;
    var event = _ref3.event, current = _ref3.current;
    var innerMost = (_current$ = current[0]) === null || _current$ === void 0 ? void 0 : _current$.dropEffect;
    if (innerMost != null && event.dataTransfer) {
      event.dataTransfer.dropEffect = innerMost;
    }
  }
  function getStartLocation(_ref4) {
    var event = _ref4.event, dragType = _ref4.dragType, getDropTargetsOver = _ref4.getDropTargetsOver;
    var input = getInput(event);
    if (dragType.startedFrom === "external") {
      return {
        input,
        dropTargets: []
      };
    }
    var dropTargets = getDropTargetsOver({
      input,
      source: dragType.payload,
      target: event.target,
      current: []
    });
    return {
      input,
      dropTargets
    };
  }
  var lifecycle = {
    canStart,
    start: start2
  };

  // node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/ledger/usage-ledger.js
  var ledger = /* @__PURE__ */ new Map();
  function registerUsage(_ref2) {
    var typeKey = _ref2.typeKey, mount4 = _ref2.mount;
    var entry = ledger.get(typeKey);
    if (entry) {
      entry.usageCount++;
      return entry;
    }
    var initial = {
      typeKey,
      unmount: mount4(),
      usageCount: 1
    };
    ledger.set(typeKey, initial);
    return initial;
  }
  function register2(args) {
    var entry = registerUsage(args);
    return function unregister() {
      entry.usageCount--;
      if (entry.usageCount > 0) {
        return;
      }
      entry.unmount();
      ledger.delete(args.typeKey);
    };
  }

  // node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/make-adapter/make-drop-target.js
  init_defineProperty();
  init_toConsumableArray();

  // node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/util/add-attribute.js
  function addAttribute(element, _ref2) {
    var attribute = _ref2.attribute, value = _ref2.value;
    element.setAttribute(attribute, value);
    return function() {
      return element.removeAttribute(attribute);
    };
  }

  // node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/make-adapter/make-drop-target.js
  function ownKeys11(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r && (o = o.filter(function(r2) {
        return Object.getOwnPropertyDescriptor(e, r2).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread11(e) {
    for (var r = 1; r < arguments.length; r++) {
      var t = null != arguments[r] ? arguments[r] : {};
      r % 2 ? ownKeys11(Object(t), true).forEach(function(r2) {
        _defineProperty(e, r2, t[r2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys11(Object(t)).forEach(function(r2) {
        Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
      });
    }
    return e;
  }
  function _createForOfIteratorHelper(r, e) {
    var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
    if (!t) {
      if (Array.isArray(r) || (t = _unsupportedIterableToArray2(r)) || e && r && "number" == typeof r.length) {
        t && (r = t);
        var _n = 0, F = function F2() {
        };
        return { s: F, n: function n() {
          return _n >= r.length ? { done: true } : { done: false, value: r[_n++] };
        }, e: function e2(r2) {
          throw r2;
        }, f: F };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var o, a = true, u = false;
    return { s: function s() {
      t = t.call(r);
    }, n: function n() {
      var r2 = t.next();
      return a = r2.done, r2;
    }, e: function e2(r2) {
      u = true, o = r2;
    }, f: function f() {
      try {
        a || null == t.return || t.return();
      } finally {
        if (u) throw o;
      }
    } };
  }
  function _unsupportedIterableToArray2(r, a) {
    if (r) {
      if ("string" == typeof r) return _arrayLikeToArray2(r, a);
      var t = {}.toString.call(r).slice(8, -1);
      return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray2(r, a) : void 0;
    }
  }
  function _arrayLikeToArray2(r, a) {
    (null == a || a > r.length) && (a = r.length);
    for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
    return n;
  }
  function copyReverse(array) {
    return array.slice(0).reverse();
  }
  function makeDropTarget(_ref2) {
    var typeKey = _ref2.typeKey, defaultDropEffect = _ref2.defaultDropEffect;
    var registry2 = /* @__PURE__ */ new WeakMap();
    var dropTargetDataAtt = "data-drop-target-for-".concat(typeKey);
    var dropTargetSelector = "[".concat(dropTargetDataAtt, "]");
    function addToRegistry(args) {
      registry2.set(args.element, args);
      return function() {
        return registry2.delete(args.element);
      };
    }
    function dropTargetForConsumers(args) {
      if (false) {
        var existing = registry2.get(args.element);
        if (existing) {
          console.warn("You have already registered a [".concat(typeKey, "] dropTarget on the same element"), {
            existing,
            proposed: args
          });
        }
        if (args.element instanceof HTMLIFrameElement) {
          console.warn("\n            We recommend not registering <iframe> elements as drop targets\n            as it can result in some strange browser event ordering.\n          ".replace(/\s{2,}/g, " ").trim());
        }
      }
      var cleanup = combine(addAttribute(args.element, {
        attribute: dropTargetDataAtt,
        value: "true"
      }), addToRegistry(args));
      return once(cleanup);
    }
    function getActualDropTargets(_ref22) {
      var _args$getData, _args$getData2, _args$getDropEffect, _args$getDropEffect2;
      var source2 = _ref22.source, target = _ref22.target, input = _ref22.input, _ref2$result = _ref22.result, result2 = _ref2$result === void 0 ? [] : _ref2$result;
      if (target == null) {
        return result2;
      }
      if (!(target instanceof Element)) {
        if (target instanceof Node) {
          return getActualDropTargets({
            source: source2,
            target: target.parentElement,
            input,
            result: result2
          });
        }
        return result2;
      }
      var closest = target.closest(dropTargetSelector);
      if (closest == null) {
        return result2;
      }
      var args = registry2.get(closest);
      if (args == null) {
        return result2;
      }
      var feedback = {
        input,
        source: source2,
        element: args.element
      };
      if (args.canDrop && !args.canDrop(feedback)) {
        return getActualDropTargets({
          source: source2,
          target: args.element.parentElement,
          input,
          result: result2
        });
      }
      var data = (_args$getData = (_args$getData2 = args.getData) === null || _args$getData2 === void 0 ? void 0 : _args$getData2.call(args, feedback)) !== null && _args$getData !== void 0 ? _args$getData : {};
      var dropEffect = (_args$getDropEffect = (_args$getDropEffect2 = args.getDropEffect) === null || _args$getDropEffect2 === void 0 ? void 0 : _args$getDropEffect2.call(args, feedback)) !== null && _args$getDropEffect !== void 0 ? _args$getDropEffect : defaultDropEffect;
      var record = {
        data,
        element: args.element,
        dropEffect,
        // we are collecting _actual_ drop targets, so these are
        // being applied _not_ due to stickiness
        isActiveDueToStickiness: false
      };
      return getActualDropTargets({
        source: source2,
        target: args.element.parentElement,
        input,
        // Using bubble ordering. Same ordering as `event.getPath()`
        result: [].concat(_toConsumableArray(result2), [record])
      });
    }
    function notifyCurrent(_ref3) {
      var eventName = _ref3.eventName, payload = _ref3.payload;
      var _iterator = _createForOfIteratorHelper(payload.location.current.dropTargets), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var _entry$eventName;
          var record = _step.value;
          var entry = registry2.get(record.element);
          var args = _objectSpread11(_objectSpread11({}, payload), {}, {
            self: record
          });
          entry === null || entry === void 0 || (_entry$eventName = entry[eventName]) === null || _entry$eventName === void 0 || _entry$eventName.call(
            entry,
            // I cannot seem to get the types right here.
            // TS doesn't seem to like that one event can need `nativeSetDragImage`
            // @ts-expect-error
            args
          );
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
    var actions = {
      onGenerateDragPreview: notifyCurrent,
      onDrag: notifyCurrent,
      onDragStart: notifyCurrent,
      onDrop: notifyCurrent,
      onDropTargetChange: function onDropTargetChange(_ref4) {
        var payload = _ref4.payload;
        var isCurrent = new Set(payload.location.current.dropTargets.map(function(record2) {
          return record2.element;
        }));
        var visited = /* @__PURE__ */ new Set();
        var _iterator2 = _createForOfIteratorHelper(payload.location.previous.dropTargets), _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
            var _entry$onDropTargetCh;
            var record = _step2.value;
            visited.add(record.element);
            var entry = registry2.get(record.element);
            var isOver = isCurrent.has(record.element);
            var args = _objectSpread11(_objectSpread11({}, payload), {}, {
              self: record
            });
            entry === null || entry === void 0 || (_entry$onDropTargetCh = entry.onDropTargetChange) === null || _entry$onDropTargetCh === void 0 || _entry$onDropTargetCh.call(entry, args);
            if (!isOver) {
              var _entry$onDragLeave;
              entry === null || entry === void 0 || (_entry$onDragLeave = entry.onDragLeave) === null || _entry$onDragLeave === void 0 || _entry$onDragLeave.call(entry, args);
            }
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
        var _iterator3 = _createForOfIteratorHelper(payload.location.current.dropTargets), _step3;
        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
            var _entry$onDropTargetCh2, _entry$onDragEnter;
            var _record = _step3.value;
            if (visited.has(_record.element)) {
              continue;
            }
            var _args = _objectSpread11(_objectSpread11({}, payload), {}, {
              self: _record
            });
            var _entry = registry2.get(_record.element);
            _entry === null || _entry === void 0 || (_entry$onDropTargetCh2 = _entry.onDropTargetChange) === null || _entry$onDropTargetCh2 === void 0 || _entry$onDropTargetCh2.call(_entry, _args);
            _entry === null || _entry === void 0 || (_entry$onDragEnter = _entry.onDragEnter) === null || _entry$onDragEnter === void 0 || _entry$onDragEnter.call(_entry, _args);
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
      }
    };
    function dispatchEvent2(args) {
      actions[args.eventName](args);
    }
    function getIsOver(_ref5) {
      var source2 = _ref5.source, target = _ref5.target, input = _ref5.input, current = _ref5.current;
      var actual = getActualDropTargets({
        source: source2,
        target,
        input
      });
      if (actual.length >= current.length) {
        return actual;
      }
      var lastCaptureOrdered = copyReverse(current);
      var actualCaptureOrdered = copyReverse(actual);
      var resultCaptureOrdered = [];
      for (var index2 = 0; index2 < lastCaptureOrdered.length; index2++) {
        var _argsForLast$getIsSti;
        var last = lastCaptureOrdered[index2];
        var fresh = actualCaptureOrdered[index2];
        if (fresh != null) {
          resultCaptureOrdered.push(fresh);
          continue;
        }
        var parent = resultCaptureOrdered[index2 - 1];
        var lastParent = lastCaptureOrdered[index2 - 1];
        if ((parent === null || parent === void 0 ? void 0 : parent.element) !== (lastParent === null || lastParent === void 0 ? void 0 : lastParent.element)) {
          break;
        }
        var argsForLast = registry2.get(last.element);
        if (!argsForLast) {
          break;
        }
        var feedback = {
          input,
          source: source2,
          element: argsForLast.element
        };
        if (argsForLast.canDrop && !argsForLast.canDrop(feedback)) {
          break;
        }
        if (!((_argsForLast$getIsSti = argsForLast.getIsSticky) !== null && _argsForLast$getIsSti !== void 0 && _argsForLast$getIsSti.call(argsForLast, feedback))) {
          break;
        }
        resultCaptureOrdered.push(_objectSpread11(_objectSpread11({}, last), {}, {
          // making it clear to consumers this drop target is active due to stickiness
          isActiveDueToStickiness: true
        }));
      }
      return copyReverse(resultCaptureOrdered);
    }
    return {
      dropTargetForConsumers,
      getIsOver,
      dispatchEvent: dispatchEvent2
    };
  }

  // node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/make-adapter/make-monitor.js
  init_defineProperty();
  function _createForOfIteratorHelper2(r, e) {
    var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
    if (!t) {
      if (Array.isArray(r) || (t = _unsupportedIterableToArray3(r)) || e && r && "number" == typeof r.length) {
        t && (r = t);
        var _n = 0, F = function F2() {
        };
        return { s: F, n: function n() {
          return _n >= r.length ? { done: true } : { done: false, value: r[_n++] };
        }, e: function e2(r2) {
          throw r2;
        }, f: F };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var o, a = true, u = false;
    return { s: function s() {
      t = t.call(r);
    }, n: function n() {
      var r2 = t.next();
      return a = r2.done, r2;
    }, e: function e2(r2) {
      u = true, o = r2;
    }, f: function f() {
      try {
        a || null == t.return || t.return();
      } finally {
        if (u) throw o;
      }
    } };
  }
  function _unsupportedIterableToArray3(r, a) {
    if (r) {
      if ("string" == typeof r) return _arrayLikeToArray3(r, a);
      var t = {}.toString.call(r).slice(8, -1);
      return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray3(r, a) : void 0;
    }
  }
  function _arrayLikeToArray3(r, a) {
    (null == a || a > r.length) && (a = r.length);
    for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
    return n;
  }
  function ownKeys12(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r && (o = o.filter(function(r2) {
        return Object.getOwnPropertyDescriptor(e, r2).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread12(e) {
    for (var r = 1; r < arguments.length; r++) {
      var t = null != arguments[r] ? arguments[r] : {};
      r % 2 ? ownKeys12(Object(t), true).forEach(function(r2) {
        _defineProperty(e, r2, t[r2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys12(Object(t)).forEach(function(r2) {
        Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
      });
    }
    return e;
  }
  function makeMonitor() {
    var registry2 = /* @__PURE__ */ new Set();
    var dragging = null;
    function tryAddToActive(monitor) {
      if (!dragging) {
        return;
      }
      if (!monitor.canMonitor || monitor.canMonitor(dragging.canMonitorArgs)) {
        dragging.active.add(monitor);
      }
    }
    function monitorForConsumers(args) {
      var entry = _objectSpread12({}, args);
      registry2.add(entry);
      tryAddToActive(entry);
      function cleanup() {
        registry2.delete(entry);
        if (dragging) {
          dragging.active.delete(entry);
        }
      }
      return once(cleanup);
    }
    function dispatchEvent2(_ref2) {
      var eventName = _ref2.eventName, payload = _ref2.payload;
      if (eventName === "onGenerateDragPreview") {
        dragging = {
          canMonitorArgs: {
            initial: payload.location.initial,
            source: payload.source
          },
          active: /* @__PURE__ */ new Set()
        };
        var _iterator = _createForOfIteratorHelper2(registry2), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var monitor = _step.value;
            tryAddToActive(monitor);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
      if (!dragging) {
        return;
      }
      var active2 = Array.from(dragging.active);
      for (var _i = 0, _active = active2; _i < _active.length; _i++) {
        var _monitor = _active[_i];
        if (dragging.active.has(_monitor)) {
          var _monitor$eventName;
          (_monitor$eventName = _monitor[eventName]) === null || _monitor$eventName === void 0 || _monitor$eventName.call(_monitor, payload);
        }
      }
      if (eventName === "onDrop") {
        dragging.active.clear();
        dragging = null;
      }
    }
    return {
      dispatchEvent: dispatchEvent2,
      monitorForConsumers
    };
  }

  // node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/make-adapter/make-adapter.js
  function makeAdapter(_ref2) {
    var typeKey = _ref2.typeKey, mount4 = _ref2.mount, dispatchEventToSource2 = _ref2.dispatchEventToSource, onPostDispatch = _ref2.onPostDispatch, defaultDropEffect = _ref2.defaultDropEffect;
    var monitorAPI = makeMonitor();
    var dropTargetAPI = makeDropTarget({
      typeKey,
      defaultDropEffect
    });
    function dispatchEvent2(args) {
      dispatchEventToSource2 === null || dispatchEventToSource2 === void 0 || dispatchEventToSource2(args);
      dropTargetAPI.dispatchEvent(args);
      monitorAPI.dispatchEvent(args);
      onPostDispatch === null || onPostDispatch === void 0 || onPostDispatch(args);
    }
    function start3(_ref22) {
      var event = _ref22.event, dragType = _ref22.dragType;
      lifecycle.start({
        event,
        dragType,
        getDropTargetsOver: dropTargetAPI.getIsOver,
        dispatchEvent: dispatchEvent2
      });
    }
    function registerUsage2() {
      function mountAdapter() {
        var api4 = {
          canStart: lifecycle.canStart,
          start: start3
        };
        return mount4(api4);
      }
      return register2({
        typeKey,
        mount: mountAdapter
      });
    }
    return {
      registerUsage: registerUsage2,
      dropTarget: dropTargetAPI.dropTargetForConsumers,
      monitor: monitorAPI.monitorForConsumers
    };
  }

  // node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/util/android.js
  var isAndroid = once(function isAndroid2() {
    return navigator.userAgent.toLocaleLowerCase().includes("android");
  });
  var androidFallbackText = "pdnd:android-fallback";

  // node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/util/media-types/text-media-type.js
  var textMediaType = "text/plain";

  // node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/util/media-types/url-media-type.js
  var URLMediaType = "text/uri-list";

  // node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/adapter/element-adapter-native-data-key.js
  var elementAdapterNativeDataKey = "application/vnd.pdnd";

  // node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/adapter/element-adapter.js
  var draggableRegistry = /* @__PURE__ */ new WeakMap();
  var honeyPotFix = makeHoneyPotFix();
  var adapter = makeAdapter({
    typeKey: "element",
    defaultDropEffect: "move",
    mount: function mount(api4) {
      return combine(honeyPotFix.bindEvents(), (0, import_bind_event_listener11.bind)(document, {
        type: "dragstart",
        listener: function listener(event) {
          var _entry$dragHandle, _entry$getInitialData, _entry$getInitialData2, _entry$dragHandle2, _entry$getInitialData3, _entry$getInitialData4;
          if (!api4.canStart(event)) {
            return;
          }
          if (event.defaultPrevented) {
            return;
          }
          if (!event.dataTransfer) {
            if (false) {
              console.warn("\n              It appears as though you have are not testing DragEvents correctly.\n\n              - If you are unit testing, ensure you have polyfilled DragEvent.\n              - If you are browser testing, ensure you are dispatching drag events correctly.\n\n              Please see our testing guides for more information:\n              https://atlassian.design/components/pragmatic-drag-and-drop/core-package/testing\n            ".replace(/ {2}/g, ""));
            }
            return;
          }
          var target = event.target;
          if (!(target instanceof HTMLElement)) {
            return null;
          }
          var entry = draggableRegistry.get(target);
          if (!entry) {
            return null;
          }
          var input = getInput(event);
          var feedback = {
            element: entry.element,
            dragHandle: (_entry$dragHandle = entry.dragHandle) !== null && _entry$dragHandle !== void 0 ? _entry$dragHandle : null,
            input
          };
          if (entry.canDrag && !entry.canDrag(feedback)) {
            event.preventDefault();
            return null;
          }
          if (entry.dragHandle) {
            var over = getElementFromPointWithoutHoneypot({
              x: input.clientX,
              y: input.clientY
            });
            if (!entry.dragHandle.contains(over)) {
              event.preventDefault();
              return null;
            }
          }
          var nativeData = (_entry$getInitialData = (_entry$getInitialData2 = entry.getInitialDataForExternal) === null || _entry$getInitialData2 === void 0 ? void 0 : _entry$getInitialData2.call(entry, feedback)) !== null && _entry$getInitialData !== void 0 ? _entry$getInitialData : null;
          if (nativeData) {
            for (var _i = 0, _Object$entries = Object.entries(nativeData); _i < _Object$entries.length; _i++) {
              var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2), key = _Object$entries$_i[0], data = _Object$entries$_i[1];
              event.dataTransfer.setData(key, data !== null && data !== void 0 ? data : "");
            }
          }
          if (isAndroid() && !event.dataTransfer.types.includes(textMediaType) && !event.dataTransfer.types.includes(URLMediaType)) {
            event.dataTransfer.setData(textMediaType, androidFallbackText);
          }
          event.dataTransfer.setData(elementAdapterNativeDataKey, "");
          var payload = {
            element: entry.element,
            dragHandle: (_entry$dragHandle2 = entry.dragHandle) !== null && _entry$dragHandle2 !== void 0 ? _entry$dragHandle2 : null,
            data: (_entry$getInitialData3 = (_entry$getInitialData4 = entry.getInitialData) === null || _entry$getInitialData4 === void 0 ? void 0 : _entry$getInitialData4.call(entry, feedback)) !== null && _entry$getInitialData3 !== void 0 ? _entry$getInitialData3 : {}
          };
          var dragType = {
            type: "element",
            payload,
            startedFrom: "internal"
          };
          api4.start({
            event,
            dragType
          });
        }
      }));
    },
    dispatchEventToSource: function dispatchEventToSource(_ref2) {
      var _draggableRegistry$ge, _draggableRegistry$ge2;
      var eventName = _ref2.eventName, payload = _ref2.payload;
      (_draggableRegistry$ge = draggableRegistry.get(payload.source.element)) === null || _draggableRegistry$ge === void 0 || (_draggableRegistry$ge2 = _draggableRegistry$ge[eventName]) === null || _draggableRegistry$ge2 === void 0 || _draggableRegistry$ge2.call(
        _draggableRegistry$ge,
        // I cannot seem to get the types right here.
        // TS doesn't seem to like that one event can need `nativeSetDragImage`
        // @ts-expect-error
        payload
      );
    },
    onPostDispatch: honeyPotFix.getOnPostDispatch()
  });
  var dropTargetForElements = adapter.dropTarget;
  var monitorForElements = adapter.monitor;

  // node_modules/@atlaskit/modal-dialog/dist/esm/internal/pragmatic-drag-and-drop/disable-dragging-to-cross-origin-iframes/make-fix-for-adapter.js
  init_toConsumableArray();
  function setStyle(el, _ref2) {
    var property = _ref2.property, rule = _ref2.rule, _ref$priority = _ref2.priority, priority = _ref$priority === void 0 ? "" : _ref$priority;
    var originalValue = el.style.getPropertyValue(property);
    var originalPriority = el.style.getPropertyPriority(property);
    el.style.setProperty(property, rule, priority);
    return function cleanup() {
      el.style.setProperty(property, originalValue, originalPriority);
    };
  }
  function hasSameOrigin(href1, href2) {
    var url1;
    var url2;
    try {
      url1 = new URL(href1);
      url2 = new URL(href2);
    } catch (error) {
      return false;
    }
    return url1.protocol === url2.protocol && url1.host === url2.host && url1.port === url2.port;
  }
  function isIframeOnAnotherDomain(iframe) {
    if (iframe.srcdoc) {
      return false;
    }
    if (iframe.src.startsWith("data:")) {
      return false;
    }
    return !hasSameOrigin(window.location.href, iframe.src);
  }
  var registry = /* @__PURE__ */ new Map();
  function applyFix(watchForEndOfInteraction) {
    var iframes = Array.from(document.querySelectorAll("iframe")).filter(isIframeOnAnotherDomain);
    var cleanups = iframes.map(function(iframe) {
      var entry = registry.get(iframe);
      if (!entry) {
        entry = {
          reset: setStyle(iframe, {
            property: "pointer-events",
            rule: "none",
            priority: "important"
          }),
          count: 1
        };
        registry.set(iframe, entry);
      } else {
        entry.count++;
      }
      return function cleanup() {
        entry.count--;
        if (entry.count < 1) {
          entry.reset();
          registry.delete(iframe);
        }
      };
    });
    function stop() {
      cleanupWatcher();
      combine.apply(void 0, _toConsumableArray(cleanups))();
    }
    var cleanupWatcher = watchForEndOfInteraction({
      stop
    });
  }
  function makeFixForAdapter(_ref2) {
    var watchForInteractionStart4 = _ref2.watchForInteractionStart, watchForInteractionEnd4 = _ref2.watchForInteractionEnd;
    var registrationCount = 0;
    var stopWatchingInteractionStart = null;
    function start3() {
      applyFix(watchForInteractionEnd4);
    }
    function registerUsage2() {
      if (registrationCount === 0) {
        stopWatchingInteractionStart = watchForInteractionStart4({
          start: start3
        });
      }
      registrationCount++;
      return function unregisterUsage() {
        var _stopWatchingInteract;
        registrationCount--;
        if (registrationCount !== 0) {
          return;
        }
        (_stopWatchingInteract = stopWatchingInteractionStart) === null || _stopWatchingInteract === void 0 || _stopWatchingInteract();
        stopWatchingInteractionStart = null;
      };
    }
    return {
      registerUsage: registerUsage2
    };
  }

  // node_modules/@atlaskit/modal-dialog/dist/esm/internal/pragmatic-drag-and-drop/disable-dragging-to-cross-origin-iframes/element.js
  function watchForInteractionEnd(_ref2) {
    var stop = _ref2.stop;
    var isDragging = false;
    function stopIfNotDragging() {
      if (isDragging) {
        return;
      }
      stop();
    }
    var unbindEvents = (0, import_bind_event_listener12.bindAll)(window, [{
      // Another interaction is starting, this fix should be removed.
      type: "pointerdown",
      listener: stop
    }, {
      // The user did not start a drag
      type: "pointerup",
      listener: stopIfNotDragging
    }, {
      // if a "dragstart" occurs and the flag is not set,
      // then a drag has not started.
      // Note: could not use "pointercancel" as it is not
      // published in Safari
      // → https://bugs.webkit.org/show_bug.cgi?id=222632
      type: "dragstart",
      listener: stopIfNotDragging,
      // Need to come after the element adapter
      options: {
        capture: false
      }
    }], {
      // Listening in the capture phase to increase resilience
      // against events being stopped.
      capture: true,
      // Being super clear these should only run once
      once: true
    });
    var unbindMonitor = monitorForElements({
      onGenerateDragPreview: function onGenerateDragPreview() {
        isDragging = true;
      },
      onDrop: function onDrop() {
        isDragging = false;
        stop();
      }
    });
    return combine(unbindEvents, unbindMonitor);
  }
  function watchForInteractionStart(_ref2) {
    var start3 = _ref2.start;
    return (0, import_bind_event_listener12.bind)(window, {
      // Note: Using "mousedown" rather than "pointerdown" due to a Safari bug.
      // Safari not publish a "pointerdown" on the interaction after a drag
      // → https://bugs.webkit.org/show_bug.cgi?id=279749
      type: "mousedown",
      listener: function listener(event) {
        if (event.target instanceof HTMLElement && event.target.closest('[draggable="true"]')) {
          start3();
        }
      }
    });
  }
  var api = makeFixForAdapter({
    watchForInteractionStart,
    watchForInteractionEnd
  });
  function disableDraggingToCrossOriginIFramesForElement() {
    return api.registerUsage();
  }

  // node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/adapter/external-adapter.js
  init_toConsumableArray();
  var import_bind_event_listener13 = __toESM(require_dist());

  // node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/util/changing-window/is-entering-window.js
  function isEnteringWindow(_ref2) {
    var dragEnter = _ref2.dragEnter;
    var type = dragEnter.type, relatedTarget = dragEnter.relatedTarget;
    if (type !== "dragenter") {
      return false;
    }
    if (isSafari2()) {
      return isEnteringWindowInSafari({
        dragEnter
      });
    }
    if (relatedTarget == null) {
      return true;
    }
    if (isFirefox()) {
      return isFromAnotherWindow(relatedTarget);
    }
    return relatedTarget instanceof HTMLIFrameElement;
  }

  // node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/adapter/external-adapter.js
  function isAnAvailableType(_ref2) {
    var type = _ref2.type, value = _ref2.value;
    if (type === elementAdapterNativeDataKey) {
      return false;
    }
    if (type === textMediaType && value === androidFallbackText) {
      return false;
    }
    return true;
  }
  function getAvailableTypes(transfer) {
    return Array.from(transfer.types).filter(function(type) {
      return isAnAvailableType({
        type,
        value: transfer.getData(type)
      });
    });
  }
  function getAvailableItems(dataTransfer) {
    return Array.from(dataTransfer.items).filter(function(item) {
      return item.kind === "file" || isAnAvailableType({
        type: item.type,
        value: dataTransfer.getData(item.type)
      });
    });
  }
  var didDragStartLocally = false;
  var adapter2 = makeAdapter({
    typeKey: "external",
    // for external drags, we are generally making a copy of something that is being dragged
    defaultDropEffect: "copy",
    mount: function mount2(api4) {
      return (0, import_bind_event_listener13.bind)(window, {
        type: "dragenter",
        listener: function listener(event) {
          if (didDragStartLocally) {
            return;
          }
          if (!event.dataTransfer) {
            if (false) {
              console.warn("\n              It appears as though you have are not testing DragEvents correctly.\n\n              - If you are unit testing, ensure you have polyfilled DragEvent.\n              - If you are browser testing, ensure you are dispatching drag events correctly.\n\n              Please see our testing guides for more information:\n              https://atlassian.design/components/pragmatic-drag-and-drop/core-package/testing\n            ".replace(/ {2}/g, ""));
            }
            return;
          }
          if (!api4.canStart(event)) {
            return;
          }
          if (!isEnteringWindow({
            dragEnter: event
          })) {
            return;
          }
          var types = getAvailableTypes(event.dataTransfer);
          if (!types.length) {
            return;
          }
          var locked = {
            types,
            items: [],
            getStringData: function getStringData() {
              return null;
            }
          };
          api4.start({
            event,
            dragType: {
              type: "external",
              startedFrom: "external",
              payload: locked,
              getDropPayload: function getDropPayload(event2) {
                if (!event2.dataTransfer) {
                  return locked;
                }
                var items = getAvailableItems(event2.dataTransfer);
                var nativeGetData = event2.dataTransfer.getData.bind(event2.dataTransfer);
                return {
                  types,
                  items,
                  // return `null` if there is no result, otherwise string
                  getStringData: function getStringData(mediaType) {
                    if (!types.includes(mediaType)) {
                      return null;
                    }
                    var value = nativeGetData(mediaType);
                    if (!isAnAvailableType({
                      type: mediaType,
                      value
                    })) {
                      return null;
                    }
                    return value;
                  }
                };
              }
            }
          });
        }
      });
    }
  });
  function monitorForExternal(args) {
    return adapter2.monitor(args);
  }
  (function startup() {
    if (typeof window === "undefined") {
      return;
    }
    adapter2.registerUsage();
    var idle = {
      type: "idle"
    };
    var state = idle;
    function clear() {
      if (state.type !== "dragging") {
        return;
      }
      didDragStartLocally = false;
      state.cleanup();
      state = idle;
    }
    function bindEndEvents() {
      return (0, import_bind_event_listener13.bindAll)(
        window,
        [{
          type: "dragend",
          listener: clear
        }].concat(_toConsumableArray(getBindingsForBrokenDrags({
          onDragEnd: clear
        }))),
        // we want to make sure we get all the events,
        // and this helps avoid not seeing events when folks stop
        // them later on the event path
        {
          capture: true
        }
      );
    }
    (0, import_bind_event_listener13.bind)(window, {
      type: "dragstart",
      listener: function listener() {
        if (state.type !== "idle") {
          return;
        }
        didDragStartLocally = true;
        state = {
          type: "dragging",
          cleanup: bindEndEvents()
        };
      },
      // binding in the capture phase so these listeners are called
      // before our listeners in the adapters `mount` function
      options: {
        capture: true
      }
    });
  })();

  // node_modules/@atlaskit/modal-dialog/dist/esm/internal/pragmatic-drag-and-drop/disable-dragging-to-cross-origin-iframes/external.js
  function watchForInteractionStart2(_ref2) {
    var start3 = _ref2.start;
    return monitorForExternal({
      onDragStart: function onDragStart2() {
        start3();
      }
    });
  }
  function watchForInteractionEnd2(_ref2) {
    var stop = _ref2.stop;
    return monitorForExternal({
      onDrop: function onDrop() {
        stop();
      }
    });
  }
  var api2 = makeFixForAdapter({
    watchForInteractionStart: watchForInteractionStart2,
    watchForInteractionEnd: watchForInteractionEnd2
  });
  function disableDraggingToCrossOriginIFramesForExternal() {
    return api2.registerUsage();
  }

  // node_modules/@atlaskit/modal-dialog/dist/esm/internal/pragmatic-drag-and-drop/disable-dragging-to-cross-origin-iframes/text-selection.js
  var import_bind_event_listener15 = __toESM(require_dist());

  // node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/adapter/text-selection-adapter.js
  var import_bind_event_listener14 = __toESM(require_dist());

  // node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/util/media-types/html-media-type.js
  var HTMLMediaType = "text/html";

  // node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/adapter/text-selection-adapter.js
  function findTextNode(event) {
    var _event$dataTransfer;
    if (event.target instanceof Text) {
      return event.target;
    }
    if (!isSafari2()) {
      return null;
    }
    if (!(event.target instanceof HTMLElement)) {
      return null;
    }
    if (event.target.draggable) {
      return null;
    }
    if (!((_event$dataTransfer = event.dataTransfer) !== null && _event$dataTransfer !== void 0 && _event$dataTransfer.getData(textMediaType))) {
      return null;
    }
    var text = Array.from(event.target.childNodes).find(function(node2) {
      return node2.nodeType === Node.TEXT_NODE;
    });
    return text !== null && text !== void 0 ? text : null;
  }
  var honeyPotFix2 = makeHoneyPotFix();
  var adapter3 = makeAdapter({
    typeKey: "text-selection",
    // for text selection, we will usually be making a copy of the text
    defaultDropEffect: "copy",
    mount: function mount3(api4) {
      return combine(honeyPotFix2.bindEvents(), (0, import_bind_event_listener14.bind)(window, {
        type: "dragstart",
        listener: function listener(event) {
          if (event.defaultPrevented) {
            return;
          }
          if (!event.dataTransfer) {
            if (false) {
              console.warn("\n                It appears as though you have are not testing DragEvents correctly.\n\n                - If you are unit testing, ensure you have polyfilled DragEvent.\n                - If you are browser testing, ensure you are dispatching drag events correctly.\n\n                Please see our testing guides for more information:\n                https://atlassian.design/components/pragmatic-drag-and-drop/core-package/testing\n              ".replace(/ {2}/g, ""));
            }
            return;
          }
          if (event.dataTransfer.types.includes(elementAdapterNativeDataKey)) {
            return;
          }
          if (!api4.canStart(event)) {
            return;
          }
          if (!event.dataTransfer.types.includes(textMediaType)) {
            return;
          }
          var target = findTextNode(event);
          if (!target) {
            return;
          }
          var payload = {
            // The `Text` node that is the `target` is the `Text` node
            // that the user started the drag from.
            // The full text being dragged can be looked up from the `dataTransfer`.
            target,
            plain: event.dataTransfer.getData(textMediaType),
            HTML: event.dataTransfer.getData(HTMLMediaType)
          };
          api4.start({
            event,
            dragType: {
              type: "text-selection",
              startedFrom: "internal",
              payload
            }
          });
        }
      }));
    },
    onPostDispatch: honeyPotFix2.getOnPostDispatch()
  });
  (function register3() {
    if (typeof window === "undefined") {
      return;
    }
    adapter3.registerUsage();
  })();
  function monitorForTextSelection(args) {
    return adapter3.monitor(args);
  }

  // node_modules/@atlaskit/modal-dialog/dist/esm/internal/pragmatic-drag-and-drop/disable-dragging-to-cross-origin-iframes/text-selection.js
  function watchForInteractionEnd3(_ref2) {
    var stop = _ref2.stop;
    var isDragging = false;
    function stopIfNotDragging() {
      if (isDragging) {
        return;
      }
      stop();
    }
    var frameId = null;
    var unbindEvents = (0, import_bind_event_listener15.bindAll)(window, [{
      // User is starting another interaction
      type: "pointerdown",
      listener: stop
    }, {
      // User did not start a drag.
      // "pointerdown" won't be fired if a drag started
      type: "pointerup",
      listener: stopIfNotDragging
    }, {
      type: "dragstart",
      listener: function listener() {
        frameId = requestAnimationFrame(function() {
          frameId = null;
          stopIfNotDragging();
        });
      },
      // need to schedule our frame after the text-selection
      // adapter queues it's `onDragStart` frame.
      options: {
        capture: false
      }
    }], {
      // Listening in the capture phase to increase resilience
      // against events being stopped.
      capture: true,
      // being super clear these should only run once
      once: true
    });
    var unbindMonitor = monitorForTextSelection({
      onDragStart: function onDragStart2() {
        isDragging = true;
      },
      onDrop: function onDrop() {
        isDragging = false;
        stop();
      }
    });
    return combine(unbindEvents, unbindMonitor, function abortFrame() {
      if (frameId != null) {
        cancelAnimationFrame(frameId);
      }
    });
  }
  function watchForInteractionStart3(_ref2) {
    var start3 = _ref2.start;
    return (0, import_bind_event_listener15.bind)(window, {
      // Note: Using "mousedown" rather than "pointerdown" due to a Safari bug.
      // Safari not publish a "pointerdown" on the interaction after a drag
      // → https://bugs.webkit.org/show_bug.cgi?id=279749
      type: "mousedown",
      listener: function listener() {
        var selection = window.getSelection();
        if (!selection) {
          return;
        }
        if (selection.isCollapsed) {
          return;
        }
        start3();
      }
    });
  }
  var api3 = makeFixForAdapter({
    watchForInteractionStart: watchForInteractionStart3,
    watchForInteractionEnd: watchForInteractionEnd3
  });
  function disableDraggingToCrossOriginIFramesForTextSelection() {
    return api3.registerUsage();
  }

  // node_modules/@atlaskit/modal-dialog/dist/esm/internal/utils.js
  var width = {
    values: ["small", "medium", "large", "x-large"],
    widths: {
      small: 400,
      medium: 600,
      large: 800,
      "x-large": 968
    },
    defaultValue: "medium"
  };
  var dialogWidth = function dialogWidth2(input) {
    if (!input) {
      return "auto";
    }
    var isWidthName = width.values.indexOf(input.toString()) !== -1;
    var widthName = isWidthName && input;
    if (widthName) {
      return "".concat(width.widths[widthName], "px");
    }
    return typeof input === "number" ? "".concat(input, "px") : input;
  };
  var dialogHeight = function dialogHeight2(input) {
    if (!input) {
      return "auto";
    }
    return typeof input === "number" ? "".concat(input, "px") : input;
  };

  // node_modules/@atlaskit/modal-dialog/dist/esm/internal/components/positioner.js
  var React53 = __toESM(require_react());
  var gutter = 60;
  var maxWidthDimensions = "calc(100vw - ".concat(gutter * 2, "px)");
  var maxHeightDimensions = "calc(100vh - ".concat(gutter * 2 - 1, "px)");
  var scrollStyles = {
    viewport: "_4t3i1wug _kqswh2mm _1sg41wqb _maxs1wug _1jvh1wqb _1uca1wug _eoawglyw",
    body: "_we1i18uh _e8uozwhf _y1k5stnw _5ee41wqb _1urridpf _1juqidpf _yakv1wug _4lht1wug _eoawglyw",
    fullScreen: ""
  };
  function getScrollBehavior(_ref2) {
    var isFullScreen = _ref2.isFullScreen, shouldScrollInViewport = _ref2.shouldScrollInViewport;
    if (isFullScreen) {
      return "fullScreen";
    }
    if (shouldScrollInViewport) {
      return "viewport";
    }
    return "body";
  }
  var Positioner = function Positioner2(props) {
    var children = props.children, stackIndex = props.stackIndex, shouldScrollInViewport = props.shouldScrollInViewport, testId = props.testId, isFullScreen = props.isFullScreen;
    var scrollBehavior = getScrollBehavior({
      isFullScreen,
      shouldScrollInViewport
    });
    return /* @__PURE__ */ React53.createElement("div", {
      style: {
        "--modal-dialog-translate-y": "calc(".concat(stackIndex, "px * ", "var(--ds-space-100, 8px)", ")"),
        // eslint-disable-next-line @atlaskit/ui-styling-standard/no-imported-style-values -- Ignored via go/DSP-18766
        transitionDuration: "".concat(durations.medium, "ms"),
        // eslint-disable-next-line @atlaskit/ui-styling-standard/enforce-style-prop
        transitionTimingFunction: easeInOut
      },
      "data-testid": testId && "".concat(testId, "--positioner"),
      className: ax(["_1e0c1txw _1bsb1osq _p12f1osq _4t3i1osq _kqsw1n9t _1pby16oo _2lx21bp4 _152tidpf _1e02idpf", "_k8m01e03 _1bumglyw _sedtglyw", stackIndex > 0 ? "_t9ec1b95" : "_t9ecglyw", scrollStyles[scrollBehavior]])
    }, children);
  };
  var positioner_default = Positioner;

  // node_modules/@atlaskit/modal-dialog/dist/esm/internal/components/modal-dialog.js
  var dialogStyles = {
    root: "_16jlidpf _1o9zkb7n _i0dl1wug _1e0c1txw _1bsb1osq _p12fauwl _4t3i1osq _1tkeidpf _c71l1kxc _2lx21bp4 _bfhk1bhr _syaz1fxt _1q1l1bhr _lcxv1wug _1mq81kw7 _m01u1kw7 _1dg11kw7 _mizu1p6i _1ah31bk5 _ra3xnqa1 _128m1bk5 _1cvmnqa1 _4davt94y _we1i1kw7 _zg7p1cd0 _yakv1kw7 _4lht1kw7 _1xlt6m9r",
    borderRadius: "_epkx1sit"
  };
  var ModalDialog = function ModalDialog2(props) {
    var _props$width = props.width, width2 = _props$width === void 0 ? "medium" : _props$width, _props$shouldScrollIn = props.shouldScrollInViewport, shouldScrollInViewport = _props$shouldScrollIn === void 0 ? false : _props$shouldScrollIn, shouldCloseOnEscapePress = props.shouldCloseOnEscapePress, autoFocus = props.autoFocus, stackIndex = props.stackIndex, onClose = props.onClose, onCloseComplete = props.onCloseComplete, onOpenComplete = props.onOpenComplete, height = props.height, hasProvidedOnClose = props.hasProvidedOnClose, children = props.children, label = props.label, testId = props.testId, _props$isFullScreen = props.isFullScreen, isFullScreen = _props$isFullScreen === void 0 ? false : _props$isFullScreen;
    var id = useId();
    var titleId = "modal-dialog-title-".concat(id);
    var defaultTestId = testId || "modal-dialog";
    (0, import_react89.useEffect)(function() {
      return combine(disableDraggingToCrossOriginIFramesForElement(), disableDraggingToCrossOriginIFramesForTextSelection(), disableDraggingToCrossOriginIFramesForExternal());
    }, []);
    useAutoFocus(
      _typeof(autoFocus) === "object" ? autoFocus : void 0,
      // When a user supplies  a ref to focus we enable this hook
      _typeof(autoFocus) === "object"
    );
    var _useOnMotionFinish = useOnMotionFinish({
      onOpenComplete,
      onCloseComplete
    }), _useOnMotionFinish2 = _slicedToArray(_useOnMotionFinish, 2), motionRef = _useOnMotionFinish2[0], onMotionFinish = _useOnMotionFinish2[1];
    var modalDialogContext = (0, import_react89.useMemo)(function() {
      return {
        testId: defaultTestId,
        titleId,
        onClose,
        hasProvidedOnClose,
        isFullScreen
      };
    }, [defaultTestId, titleId, onClose, hasProvidedOnClose, isFullScreen]);
    useCloseOnEscapePress2({
      onClose,
      isDisabled: !shouldCloseOnEscapePress
    });
    var _useLayering = useLayering(), currentLevel = _useLayering.currentLevel;
    return /* @__PURE__ */ React54.createElement(positioner_default, {
      stackIndex,
      shouldScrollInViewport,
      testId: defaultTestId,
      isFullScreen
    }, /* @__PURE__ */ React54.createElement(ModalContext.Provider, {
      value: modalDialogContext
    }, /* @__PURE__ */ React54.createElement(ScrollContext.Provider, {
      value: shouldScrollInViewport
    }, /* @__PURE__ */ React54.createElement(
      fade_in_default,
      {
        entranceDirection: isFullScreen ? void 0 : "bottom",
        onFinish: onMotionFinish
      },
      function(bottomFadeInProps) {
        return /* @__PURE__ */ React54.createElement("section", _extends({}, bottomFadeInProps, {
          "aria-label": label,
          ref: mergeRefs([bottomFadeInProps.ref, motionRef]),
          style: {
            // eslint-disable-next-line @atlaskit/ui-styling-standard/no-imported-style-values -- Ignored via go/DSP-18766
            "--modal-dialog-width": dialogWidth(width2),
            // eslint-disable-next-line @atlaskit/ui-styling-standard/no-imported-style-values -- Ignored via go/DSP-18766
            "--modal-dialog-height": dialogHeight(height)
          },
          // eslint-disable-next-line @atlaskit/ui-styling-standard/no-classname-prop
          className: ax([dialogStyles.root, !isFullScreen && dialogStyles.borderRadius, shouldScrollInViewport ? "_1tke1kxc _c71lglyw _8kn617ks" : "_cbiz17ks _bolh1kw7", bottomFadeInProps.className]),
          role: "dialog",
          "aria-labelledby": label ? void 0 : titleId,
          "data-testid": defaultTestId,
          "data-modal-stack": stackIndex,
          tabIndex: -1,
          "aria-modal": true,
          "data-ds--level": currentLevel
        }), children);
      }
    ))));
  };
  var modal_dialog_default = ModalDialog;

  // node_modules/@atlaskit/modal-dialog/dist/esm/internal/components/modal-wrapper.js
  var allowlistElements = function allowlistElements2(element, callback) {
    if (!!document.querySelector(".aui-blanket:not([hidden])")) {
      return false;
    }
    if (typeof callback === "function") {
      return callback(element);
    }
    return true;
  };
  var InternalModalWrapper = function InternalModalWrapper2(props) {
    var _props$autoFocus = props.autoFocus, autoFocus = _props$autoFocus === void 0 ? true : _props$autoFocus, focusLockAllowlist = props.focusLockAllowlist, _props$shouldCloseOnE = props.shouldCloseOnEscapePress, shouldCloseOnEscapePress = _props$shouldCloseOnE === void 0 ? true : _props$shouldCloseOnE, _props$shouldCloseOnO = props.shouldCloseOnOverlayClick, shouldCloseOnOverlayClick = _props$shouldCloseOnO === void 0 ? true : _props$shouldCloseOnO, _props$shouldScrollIn = props.shouldScrollInViewport, shouldScrollInViewport = _props$shouldScrollIn === void 0 ? false : _props$shouldScrollIn, _props$shouldReturnFo = props.shouldReturnFocus, shouldReturnFocus = _props$shouldReturnFo === void 0 ? true : _props$shouldReturnFo, stackIndexOverride = props.stackIndex, providedOnClose = props.onClose, _props$onStackChange = props.onStackChange, onStackChange = _props$onStackChange === void 0 ? noop3 : _props$onStackChange, isBlanketHidden = props.isBlanketHidden, children = props.children, height = props.height, width2 = props.width, onCloseComplete = props.onCloseComplete, onOpenComplete = props.onOpenComplete, label = props.label, testId = props.testId, isFullScreen = props.isFullScreen;
    var calculatedStackIndex = useModalStack({
      onStackChange
    });
    var stackIndex = stackIndexOverride || calculatedStackIndex;
    var isForeground = stackIndex === 0;
    var autoFocusLock = typeof autoFocus === "boolean" ? autoFocus : false;
    var onCloseHandler = usePlatformLeafEventHandler({
      fn: providedOnClose || noop3,
      action: "closed",
      componentName: "modalDialog",
      packageName: "@atlaskit/modal-dialog",
      packageVersion: "14.3.3"
    });
    var onBlanketClicked = (0, import_react90.useCallback)(function(e) {
      if (shouldCloseOnOverlayClick) {
        onCloseHandler(e);
      }
    }, [shouldCloseOnOverlayClick, onCloseHandler]);
    var allowListCallback = (0, import_react90.useCallback)(function(element) {
      return allowlistElements(element, focusLockAllowlist);
    }, [focusLockAllowlist]);
    usePreventProgrammaticScroll();
    var modalDialogWithBlanket = /* @__PURE__ */ React55.createElement(blanket_default, {
      isTinted: !isBlanketHidden,
      onBlanketClicked,
      testId: testId && "".concat(testId, "--blanket")
    }, /* @__PURE__ */ React55.createElement(modal_dialog_default, {
      testId,
      label,
      autoFocus,
      stackIndex,
      onClose: onCloseHandler,
      shouldCloseOnEscapePress: shouldCloseOnEscapePress && isForeground,
      shouldScrollInViewport,
      height,
      width: width2,
      onCloseComplete,
      onOpenComplete,
      hasProvidedOnClose: Boolean(providedOnClose),
      isFullScreen
    }, children));
    var returnFocus = true;
    var onDeactivation;
    if ("boolean" === typeof shouldReturnFocus) {
      returnFocus = shouldReturnFocus;
    } else {
      onDeactivation = function onDeactivation2() {
        window.setTimeout(function() {
          var _shouldReturnFocus$cu;
          (_shouldReturnFocus$cu = shouldReturnFocus.current) === null || _shouldReturnFocus$cu === void 0 || _shouldReturnFocus$cu.focus();
        }, 0);
      };
    }
    return /* @__PURE__ */ React55.createElement(Layering, {
      isDisabled: false
    }, /* @__PURE__ */ React55.createElement(Portal, {
      zIndex: layers.modal()
    }, /* @__PURE__ */ React55.createElement(fade_in_default, null, function(fadeInProps) {
      return /* @__PURE__ */ React55.createElement("div", _extends({}, fadeInProps, {
        // eslint-disable-next-line @atlaskit/ui-styling-standard/no-classname-prop
        className: ax(["_1bsbauwl _4t3i1kxc _kqsw1n9t _152tze3t _1e02ze3t _18m91wug _8am5i4x0", fadeInProps.className]),
        "aria-hidden": !isForeground
      }), /* @__PURE__ */ React55.createElement(es2015_default, {
        autoFocus: autoFocusLock,
        returnFocus,
        onDeactivation,
        whiteList: allowListCallback
      }, /* @__PURE__ */ React55.createElement(import_react_scrolllock.default, null), shouldScrollInViewport ? /* @__PURE__ */ React55.createElement(import_react_scrolllock.TouchScrollable, null, modalDialogWithBlanket) : modalDialogWithBlanket));
    })));
  };
  var modal_wrapper_default = InternalModalWrapper;

  // node_modules/@atlaskit/modal-dialog/dist/esm/modal-dialog.js
  function ModalWrapper(props) {
    return /* @__PURE__ */ import_react91.default.createElement(modal_wrapper_default, _extends({}, props, {
      isFullScreen: false
    }));
  }

  // node_modules/@atlaskit/modal-dialog/dist/esm/modal-transition.js
  var import_react92 = __toESM(require_react());
  var ModalTransition = function ModalTransition2(props) {
    var _props$children;
    return /* @__PURE__ */ import_react92.default.createElement(
      exiting_persistence_default,
      {
        appear: true
      },
      //Checking if children are undefined to prevent potential runtime errors in React 17
      (_props$children = props.children) !== null && _props$children !== void 0 ? _props$children : null
    );
  };
  var modal_transition_default = ModalTransition;

  // node_modules/@atlaskit/modal-dialog/dist/esm/modal-header.js
  var import_react104 = __toESM(require_react());

  // node_modules/@atlaskit/primitives/dist/esm/components/box.js
  var import_react96 = __toESM(require_react());

  // node_modules/@emotion/react/dist/emotion-element-f0de968e.browser.esm.js
  var React59 = __toESM(require_react());
  var import_react93 = __toESM(require_react());

  // node_modules/@emotion/sheet/dist/emotion-sheet.esm.js
  var isDevelopment = false;
  function sheetForTag(tag) {
    if (tag.sheet) {
      return tag.sheet;
    }
    for (var i = 0; i < document.styleSheets.length; i++) {
      if (document.styleSheets[i].ownerNode === tag) {
        return document.styleSheets[i];
      }
    }
    return void 0;
  }
  function createStyleElement(options2) {
    var tag = document.createElement("style");
    tag.setAttribute("data-emotion", options2.key);
    if (options2.nonce !== void 0) {
      tag.setAttribute("nonce", options2.nonce);
    }
    tag.appendChild(document.createTextNode(""));
    tag.setAttribute("data-s", "");
    return tag;
  }
  var StyleSheet = /* @__PURE__ */ (function() {
    function StyleSheet2(options2) {
      var _this = this;
      this._insertTag = function(tag) {
        var before;
        if (_this.tags.length === 0) {
          if (_this.insertionPoint) {
            before = _this.insertionPoint.nextSibling;
          } else if (_this.prepend) {
            before = _this.container.firstChild;
          } else {
            before = _this.before;
          }
        } else {
          before = _this.tags[_this.tags.length - 1].nextSibling;
        }
        _this.container.insertBefore(tag, before);
        _this.tags.push(tag);
      };
      this.isSpeedy = options2.speedy === void 0 ? !isDevelopment : options2.speedy;
      this.tags = [];
      this.ctr = 0;
      this.nonce = options2.nonce;
      this.key = options2.key;
      this.container = options2.container;
      this.prepend = options2.prepend;
      this.insertionPoint = options2.insertionPoint;
      this.before = null;
    }
    var _proto = StyleSheet2.prototype;
    _proto.hydrate = function hydrate(nodes) {
      nodes.forEach(this._insertTag);
    };
    _proto.insert = function insert(rule) {
      if (this.ctr % (this.isSpeedy ? 65e3 : 1) === 0) {
        this._insertTag(createStyleElement(this));
      }
      var tag = this.tags[this.tags.length - 1];
      if (this.isSpeedy) {
        var sheet = sheetForTag(tag);
        try {
          sheet.insertRule(rule, sheet.cssRules.length);
        } catch (e) {
        }
      } else {
        tag.appendChild(document.createTextNode(rule));
      }
      this.ctr++;
    };
    _proto.flush = function flush() {
      this.tags.forEach(function(tag) {
        var _tag$parentNode;
        return (_tag$parentNode = tag.parentNode) == null ? void 0 : _tag$parentNode.removeChild(tag);
      });
      this.tags = [];
      this.ctr = 0;
    };
    return StyleSheet2;
  })();

  // node_modules/stylis/src/Enum.js
  var MS = "-ms-";
  var MOZ = "-moz-";
  var WEBKIT = "-webkit-";
  var COMMENT = "comm";
  var RULESET = "rule";
  var DECLARATION = "decl";
  var IMPORT = "@import";
  var KEYFRAMES = "@keyframes";
  var LAYER = "@layer";

  // node_modules/stylis/src/Utility.js
  var abs = Math.abs;
  var from = String.fromCharCode;
  var assign = Object.assign;
  function hash3(value, length2) {
    return charat(value, 0) ^ 45 ? (((length2 << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3) : 0;
  }
  function trim(value) {
    return value.trim();
  }
  function match(value, pattern) {
    return (value = pattern.exec(value)) ? value[0] : value;
  }
  function replace(value, pattern, replacement) {
    return value.replace(pattern, replacement);
  }
  function indexof(value, search) {
    return value.indexOf(search);
  }
  function charat(value, index2) {
    return value.charCodeAt(index2) | 0;
  }
  function substr(value, begin, end2) {
    return value.slice(begin, end2);
  }
  function strlen(value) {
    return value.length;
  }
  function sizeof(value) {
    return value.length;
  }
  function append(value, array) {
    return array.push(value), value;
  }
  function combine2(array, callback) {
    return array.map(callback).join("");
  }

  // node_modules/stylis/src/Tokenizer.js
  var line = 1;
  var column = 1;
  var length = 0;
  var position = 0;
  var character = 0;
  var characters = "";
  function node(value, root2, parent, type, props, children, length2) {
    return { value, root: root2, parent, type, props, children, line, column, length: length2, return: "" };
  }
  function copy(root2, props) {
    return assign(node("", null, null, "", null, null, 0), root2, { length: -root2.length }, props);
  }
  function char() {
    return character;
  }
  function prev() {
    character = position > 0 ? charat(characters, --position) : 0;
    if (column--, character === 10)
      column = 1, line--;
    return character;
  }
  function next() {
    character = position < length ? charat(characters, position++) : 0;
    if (column++, character === 10)
      column = 1, line++;
    return character;
  }
  function peek() {
    return charat(characters, position);
  }
  function caret() {
    return position;
  }
  function slice(begin, end2) {
    return substr(characters, begin, end2);
  }
  function token(type) {
    switch (type) {
      // \0 \t \n \r \s whitespace token
      case 0:
      case 9:
      case 10:
      case 13:
      case 32:
        return 5;
      // ! + , / > @ ~ isolate token
      case 33:
      case 43:
      case 44:
      case 47:
      case 62:
      case 64:
      case 126:
      // ; { } breakpoint token
      case 59:
      case 123:
      case 125:
        return 4;
      // : accompanied token
      case 58:
        return 3;
      // " ' ( [ opening delimit token
      case 34:
      case 39:
      case 40:
      case 91:
        return 2;
      // ) ] closing delimit token
      case 41:
      case 93:
        return 1;
    }
    return 0;
  }
  function alloc(value) {
    return line = column = 1, length = strlen(characters = value), position = 0, [];
  }
  function dealloc(value) {
    return characters = "", value;
  }
  function delimit(type) {
    return trim(slice(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)));
  }
  function whitespace(type) {
    while (character = peek())
      if (character < 33)
        next();
      else
        break;
    return token(type) > 2 || token(character) > 3 ? "" : " ";
  }
  function escaping(index2, count) {
    while (--count && next())
      if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
        break;
    return slice(index2, caret() + (count < 6 && peek() == 32 && next() == 32));
  }
  function delimiter(type) {
    while (next())
      switch (character) {
        // ] ) " '
        case type:
          return position;
        // " '
        case 34:
        case 39:
          if (type !== 34 && type !== 39)
            delimiter(character);
          break;
        // (
        case 40:
          if (type === 41)
            delimiter(type);
          break;
        // \
        case 92:
          next();
          break;
      }
    return position;
  }
  function commenter(type, index2) {
    while (next())
      if (type + character === 47 + 10)
        break;
      else if (type + character === 42 + 42 && peek() === 47)
        break;
    return "/*" + slice(index2, position - 1) + "*" + from(type === 47 ? type : next());
  }
  function identifier(index2) {
    while (!token(peek()))
      next();
    return slice(index2, position);
  }

  // node_modules/stylis/src/Parser.js
  function compile(value) {
    return dealloc(parse("", null, null, null, [""], value = alloc(value), 0, [0], value));
  }
  function parse(value, root2, parent, rule, rules, rulesets, pseudo, points, declarations) {
    var index2 = 0;
    var offset3 = 0;
    var length2 = pseudo;
    var atrule = 0;
    var property = 0;
    var previous = 0;
    var variable = 1;
    var scanning = 1;
    var ampersand = 1;
    var character2 = 0;
    var type = "";
    var props = rules;
    var children = rulesets;
    var reference2 = rule;
    var characters2 = type;
    while (scanning)
      switch (previous = character2, character2 = next()) {
        // (
        case 40:
          if (previous != 108 && charat(characters2, length2 - 1) == 58) {
            if (indexof(characters2 += replace(delimit(character2), "&", "&\f"), "&\f") != -1)
              ampersand = -1;
            break;
          }
        // " ' [
        case 34:
        case 39:
        case 91:
          characters2 += delimit(character2);
          break;
        // \t \n \r \s
        case 9:
        case 10:
        case 13:
        case 32:
          characters2 += whitespace(previous);
          break;
        // \
        case 92:
          characters2 += escaping(caret() - 1, 7);
          continue;
        // /
        case 47:
          switch (peek()) {
            case 42:
            case 47:
              append(comment(commenter(next(), caret()), root2, parent), declarations);
              break;
            default:
              characters2 += "/";
          }
          break;
        // {
        case 123 * variable:
          points[index2++] = strlen(characters2) * ampersand;
        // } ; \0
        case 125 * variable:
        case 59:
        case 0:
          switch (character2) {
            // \0 }
            case 0:
            case 125:
              scanning = 0;
            // ;
            case 59 + offset3:
              if (ampersand == -1) characters2 = replace(characters2, /\f/g, "");
              if (property > 0 && strlen(characters2) - length2)
                append(property > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1) : declaration(replace(characters2, " ", "") + ";", rule, parent, length2 - 2), declarations);
              break;
            // @ ;
            case 59:
              characters2 += ";";
            // { rule/at-rule
            default:
              append(reference2 = ruleset(characters2, root2, parent, index2, offset3, rules, points, type, props = [], children = [], length2), rulesets);
              if (character2 === 123)
                if (offset3 === 0)
                  parse(characters2, root2, reference2, reference2, props, rulesets, length2, points, children);
                else
                  switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                    // d l m s
                    case 100:
                    case 108:
                    case 109:
                    case 115:
                      parse(value, reference2, reference2, rule && append(ruleset(value, reference2, reference2, 0, 0, rules, points, type, rules, props = [], length2), children), rules, children, length2, points, rule ? props : children);
                      break;
                    default:
                      parse(characters2, reference2, reference2, reference2, [""], children, 0, points, children);
                  }
          }
          index2 = offset3 = property = 0, variable = ampersand = 1, type = characters2 = "", length2 = pseudo;
          break;
        // :
        case 58:
          length2 = 1 + strlen(characters2), property = previous;
        default:
          if (variable < 1) {
            if (character2 == 123)
              --variable;
            else if (character2 == 125 && variable++ == 0 && prev() == 125)
              continue;
          }
          switch (characters2 += from(character2), character2 * variable) {
            // &
            case 38:
              ampersand = offset3 > 0 ? 1 : (characters2 += "\f", -1);
              break;
            // ,
            case 44:
              points[index2++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
              break;
            // @
            case 64:
              if (peek() === 45)
                characters2 += delimit(next());
              atrule = peek(), offset3 = length2 = strlen(type = characters2 += identifier(caret())), character2++;
              break;
            // -
            case 45:
              if (previous === 45 && strlen(characters2) == 2)
                variable = 0;
          }
      }
    return rulesets;
  }
  function ruleset(value, root2, parent, index2, offset3, rules, points, type, props, children, length2) {
    var post = offset3 - 1;
    var rule = offset3 === 0 ? rules : [""];
    var size2 = sizeof(rule);
    for (var i = 0, j = 0, k = 0; i < index2; ++i)
      for (var x = 0, y = substr(value, post + 1, post = abs(j = points[i])), z = value; x < size2; ++x)
        if (z = trim(j > 0 ? rule[x] + " " + y : replace(y, /&\f/g, rule[x])))
          props[k++] = z;
    return node(value, root2, parent, offset3 === 0 ? RULESET : type, props, children, length2);
  }
  function comment(value, root2, parent) {
    return node(value, root2, parent, COMMENT, from(char()), substr(value, 2, -2), 0);
  }
  function declaration(value, root2, parent, length2) {
    return node(value, root2, parent, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2);
  }

  // node_modules/stylis/src/Serializer.js
  function serialize(children, callback) {
    var output = "";
    var length2 = sizeof(children);
    for (var i = 0; i < length2; i++)
      output += callback(children[i], i, children, callback) || "";
    return output;
  }
  function stringify(element, index2, children, callback) {
    switch (element.type) {
      case LAYER:
        if (element.children.length) break;
      case IMPORT:
      case DECLARATION:
        return element.return = element.return || element.value;
      case COMMENT:
        return "";
      case KEYFRAMES:
        return element.return = element.value + "{" + serialize(element.children, callback) + "}";
      case RULESET:
        element.value = element.props.join(",");
    }
    return strlen(children = serialize(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
  }

  // node_modules/stylis/src/Middleware.js
  function middleware(collection) {
    var length2 = sizeof(collection);
    return function(element, index2, children, callback) {
      var output = "";
      for (var i = 0; i < length2; i++)
        output += collection[i](element, index2, children, callback) || "";
      return output;
    };
  }
  function rulesheet(callback) {
    return function(element) {
      if (!element.root) {
        if (element = element.return)
          callback(element);
      }
    };
  }

  // node_modules/@emotion/memoize/dist/emotion-memoize.esm.js
  function memoize(fn2) {
    var cache = /* @__PURE__ */ Object.create(null);
    return function(arg) {
      if (cache[arg] === void 0) cache[arg] = fn2(arg);
      return cache[arg];
    };
  }

  // node_modules/@emotion/cache/dist/emotion-cache.browser.esm.js
  var identifierWithPointTracking = function identifierWithPointTracking2(begin, points, index2) {
    var previous = 0;
    var character2 = 0;
    while (true) {
      previous = character2;
      character2 = peek();
      if (previous === 38 && character2 === 12) {
        points[index2] = 1;
      }
      if (token(character2)) {
        break;
      }
      next();
    }
    return slice(begin, position);
  };
  var toRules = function toRules2(parsed, points) {
    var index2 = -1;
    var character2 = 44;
    do {
      switch (token(character2)) {
        case 0:
          if (character2 === 38 && peek() === 12) {
            points[index2] = 1;
          }
          parsed[index2] += identifierWithPointTracking(position - 1, points, index2);
          break;
        case 2:
          parsed[index2] += delimit(character2);
          break;
        case 4:
          if (character2 === 44) {
            parsed[++index2] = peek() === 58 ? "&\f" : "";
            points[index2] = parsed[index2].length;
            break;
          }
        // fallthrough
        default:
          parsed[index2] += from(character2);
      }
    } while (character2 = next());
    return parsed;
  };
  var getRules = function getRules2(value, points) {
    return dealloc(toRules(alloc(value), points));
  };
  var fixedElements = /* @__PURE__ */ new WeakMap();
  var compat = function compat2(element) {
    if (element.type !== "rule" || !element.parent || // positive .length indicates that this rule contains pseudo
    // negative .length indicates that this rule has been already prefixed
    element.length < 1) {
      return;
    }
    var value = element.value;
    var parent = element.parent;
    var isImplicitRule = element.column === parent.column && element.line === parent.line;
    while (parent.type !== "rule") {
      parent = parent.parent;
      if (!parent) return;
    }
    if (element.props.length === 1 && value.charCodeAt(0) !== 58 && !fixedElements.get(parent)) {
      return;
    }
    if (isImplicitRule) {
      return;
    }
    fixedElements.set(element, true);
    var points = [];
    var rules = getRules(value, points);
    var parentRules = parent.props;
    for (var i = 0, k = 0; i < rules.length; i++) {
      for (var j = 0; j < parentRules.length; j++, k++) {
        element.props[k] = points[i] ? rules[i].replace(/&\f/g, parentRules[j]) : parentRules[j] + " " + rules[i];
      }
    }
  };
  var removeLabel = function removeLabel2(element) {
    if (element.type === "decl") {
      var value = element.value;
      if (
        // charcode for l
        value.charCodeAt(0) === 108 && // charcode for b
        value.charCodeAt(2) === 98
      ) {
        element["return"] = "";
        element.value = "";
      }
    }
  };
  function prefix2(value, length2) {
    switch (hash3(value, length2)) {
      // color-adjust
      case 5103:
        return WEBKIT + "print-" + value + value;
      // animation, animation-(delay|direction|duration|fill-mode|iteration-count|name|play-state|timing-function)
      case 5737:
      case 4201:
      case 3177:
      case 3433:
      case 1641:
      case 4457:
      case 2921:
      // text-decoration, filter, clip-path, backface-visibility, column, box-decoration-break
      case 5572:
      case 6356:
      case 5844:
      case 3191:
      case 6645:
      case 3005:
      // mask, mask-image, mask-(mode|clip|size), mask-(repeat|origin), mask-position, mask-composite,
      case 6391:
      case 5879:
      case 5623:
      case 6135:
      case 4599:
      case 4855:
      // background-clip, columns, column-(count|fill|gap|rule|rule-color|rule-style|rule-width|span|width)
      case 4215:
      case 6389:
      case 5109:
      case 5365:
      case 5621:
      case 3829:
        return WEBKIT + value + value;
      // appearance, user-select, transform, hyphens, text-size-adjust
      case 5349:
      case 4246:
      case 4810:
      case 6968:
      case 2756:
        return WEBKIT + value + MOZ + value + MS + value + value;
      // flex, flex-direction
      case 6828:
      case 4268:
        return WEBKIT + value + MS + value + value;
      // order
      case 6165:
        return WEBKIT + value + MS + "flex-" + value + value;
      // align-items
      case 5187:
        return WEBKIT + value + replace(value, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + value;
      // align-self
      case 5443:
        return WEBKIT + value + MS + "flex-item-" + replace(value, /flex-|-self/, "") + value;
      // align-content
      case 4675:
        return WEBKIT + value + MS + "flex-line-pack" + replace(value, /align-content|flex-|-self/, "") + value;
      // flex-shrink
      case 5548:
        return WEBKIT + value + MS + replace(value, "shrink", "negative") + value;
      // flex-basis
      case 5292:
        return WEBKIT + value + MS + replace(value, "basis", "preferred-size") + value;
      // flex-grow
      case 6060:
        return WEBKIT + "box-" + replace(value, "-grow", "") + WEBKIT + value + MS + replace(value, "grow", "positive") + value;
      // transition
      case 4554:
        return WEBKIT + replace(value, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + value;
      // cursor
      case 6187:
        return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value, "") + value;
      // background, background-image
      case 5495:
      case 3959:
        return replace(value, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
      // justify-content
      case 4968:
        return replace(replace(value, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + value + value;
      // (margin|padding)-inline-(start|end)
      case 4095:
      case 3583:
      case 4068:
      case 2532:
        return replace(value, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value;
      // (min|max)?(width|height|inline-size|block-size)
      case 8116:
      case 7059:
      case 5753:
      case 5535:
      case 5445:
      case 5701:
      case 4933:
      case 4677:
      case 5533:
      case 5789:
      case 5021:
      case 4765:
        if (strlen(value) - 1 - length2 > 6) switch (charat(value, length2 + 1)) {
          // (m)ax-content, (m)in-content
          case 109:
            if (charat(value, length2 + 4) !== 45) break;
          // (f)ill-available, (f)it-content
          case 102:
            return replace(value, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value, length2 + 3) == 108 ? "$3" : "$2-$3")) + value;
          // (s)tretch
          case 115:
            return ~indexof(value, "stretch") ? prefix2(replace(value, "stretch", "fill-available"), length2) + value : value;
        }
        break;
      // position: sticky
      case 4949:
        if (charat(value, length2 + 1) !== 115) break;
      // display: (flex|inline-flex)
      case 6444:
        switch (charat(value, strlen(value) - 3 - (~indexof(value, "!important") && 10))) {
          // stic(k)y
          case 107:
            return replace(value, ":", ":" + WEBKIT) + value;
          // (inline-)?fl(e)x
          case 101:
            return replace(value, /(.+:)([^;!]+)(;|!.+)?/, "$1" + WEBKIT + (charat(value, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + value;
        }
        break;
      // writing-mode
      case 5936:
        switch (charat(value, length2 + 11)) {
          // vertical-l(r)
          case 114:
            return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
          // vertical-r(l)
          case 108:
            return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
          // horizontal(-)tb
          case 45:
            return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
        }
        return WEBKIT + value + MS + value + value;
    }
    return value;
  }
  var prefixer = function prefixer2(element, index2, children, callback) {
    if (element.length > -1) {
      if (!element["return"]) switch (element.type) {
        case DECLARATION:
          element["return"] = prefix2(element.value, element.length);
          break;
        case KEYFRAMES:
          return serialize([copy(element, {
            value: replace(element.value, "@", "@" + WEBKIT)
          })], callback);
        case RULESET:
          if (element.length) return combine2(element.props, function(value) {
            switch (match(value, /(::plac\w+|:read-\w+)/)) {
              // :read-(only|write)
              case ":read-only":
              case ":read-write":
                return serialize([copy(element, {
                  props: [replace(value, /:(read-\w+)/, ":" + MOZ + "$1")]
                })], callback);
              // :placeholder
              case "::placeholder":
                return serialize([copy(element, {
                  props: [replace(value, /:(plac\w+)/, ":" + WEBKIT + "input-$1")]
                }), copy(element, {
                  props: [replace(value, /:(plac\w+)/, ":" + MOZ + "$1")]
                }), copy(element, {
                  props: [replace(value, /:(plac\w+)/, MS + "input-$1")]
                })], callback);
            }
            return "";
          });
      }
    }
  };
  var defaultStylisPlugins = [prefixer];
  var createCache = function createCache2(options2) {
    var key = options2.key;
    if (key === "css") {
      var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])");
      Array.prototype.forEach.call(ssrStyles, function(node2) {
        var dataEmotionAttribute = node2.getAttribute("data-emotion");
        if (dataEmotionAttribute.indexOf(" ") === -1) {
          return;
        }
        document.head.appendChild(node2);
        node2.setAttribute("data-s", "");
      });
    }
    var stylisPlugins = options2.stylisPlugins || defaultStylisPlugins;
    var inserted = {};
    var container;
    var nodesToHydrate = [];
    {
      container = options2.container || document.head;
      Array.prototype.forEach.call(
        // this means we will ignore elements which don't have a space in them which
        // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
        document.querySelectorAll('style[data-emotion^="' + key + ' "]'),
        function(node2) {
          var attrib = node2.getAttribute("data-emotion").split(" ");
          for (var i = 1; i < attrib.length; i++) {
            inserted[attrib[i]] = true;
          }
          nodesToHydrate.push(node2);
        }
      );
    }
    var _insert;
    var omnipresentPlugins = [compat, removeLabel];
    {
      var currentSheet;
      var finalizingPlugins = [stringify, rulesheet(function(rule) {
        currentSheet.insert(rule);
      })];
      var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
      var stylis = function stylis2(styles15) {
        return serialize(compile(styles15), serializer);
      };
      _insert = function insert(selector, serialized, sheet, shouldCache) {
        currentSheet = sheet;
        stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
        if (shouldCache) {
          cache.inserted[serialized.name] = true;
        }
      };
    }
    var cache = {
      key,
      sheet: new StyleSheet({
        key,
        container,
        nonce: options2.nonce,
        speedy: options2.speedy,
        prepend: options2.prepend,
        insertionPoint: options2.insertionPoint
      }),
      nonce: options2.nonce,
      inserted,
      registered: {},
      insert: _insert
    };
    cache.sheet.hydrate(nodesToHydrate);
    return cache;
  };

  // node_modules/@emotion/utils/dist/emotion-utils.browser.esm.js
  var isBrowser = true;
  function getRegisteredStyles(registered, registeredStyles, classNames2) {
    var rawClassName = "";
    classNames2.split(" ").forEach(function(className) {
      if (registered[className] !== void 0) {
        registeredStyles.push(registered[className] + ";");
      } else if (className) {
        rawClassName += className + " ";
      }
    });
    return rawClassName;
  }
  var registerStyles = function registerStyles2(cache, serialized, isStringTag) {
    var className = cache.key + "-" + serialized.name;
    if (
      // we only need to add the styles to the registered cache if the
      // class name could be used further down
      // the tree but if it's a string tag, we know it won't
      // so we don't have to add it to registered cache.
      // this improves memory usage since we can avoid storing the whole style string
      (isStringTag === false || // we need to always store it if we're in compat mode and
      // in node since emotion-server relies on whether a style is in
      // the registered cache to know whether a style is global or not
      // also, note that this check will be dead code eliminated in the browser
      isBrowser === false) && cache.registered[className] === void 0
    ) {
      cache.registered[className] = serialized.styles;
    }
  };
  var insertStyles = function insertStyles2(cache, serialized, isStringTag) {
    registerStyles(cache, serialized, isStringTag);
    var className = cache.key + "-" + serialized.name;
    if (cache.inserted[serialized.name] === void 0) {
      var current = serialized;
      do {
        cache.insert(serialized === current ? "." + className : "", current, cache.sheet, true);
        current = current.next;
      } while (current !== void 0);
    }
  };

  // node_modules/@emotion/hash/dist/emotion-hash.esm.js
  function murmur2(str) {
    var h = 0;
    var k, i = 0, len = str.length;
    for (; len >= 4; ++i, len -= 4) {
      k = str.charCodeAt(i) & 255 | (str.charCodeAt(++i) & 255) << 8 | (str.charCodeAt(++i) & 255) << 16 | (str.charCodeAt(++i) & 255) << 24;
      k = /* Math.imul(k, m): */
      (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16);
      k ^= /* k >>> r: */
      k >>> 24;
      h = /* Math.imul(k, m): */
      (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
      (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
    }
    switch (len) {
      case 3:
        h ^= (str.charCodeAt(i + 2) & 255) << 16;
      case 2:
        h ^= (str.charCodeAt(i + 1) & 255) << 8;
      case 1:
        h ^= str.charCodeAt(i) & 255;
        h = /* Math.imul(h, m): */
        (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
    }
    h ^= h >>> 13;
    h = /* Math.imul(h, m): */
    (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
    return ((h ^ h >>> 15) >>> 0).toString(36);
  }

  // node_modules/@emotion/unitless/dist/emotion-unitless.esm.js
  var unitlessKeys = {
    animationIterationCount: 1,
    aspectRatio: 1,
    borderImageOutset: 1,
    borderImageSlice: 1,
    borderImageWidth: 1,
    boxFlex: 1,
    boxFlexGroup: 1,
    boxOrdinalGroup: 1,
    columnCount: 1,
    columns: 1,
    flex: 1,
    flexGrow: 1,
    flexPositive: 1,
    flexShrink: 1,
    flexNegative: 1,
    flexOrder: 1,
    gridRow: 1,
    gridRowEnd: 1,
    gridRowSpan: 1,
    gridRowStart: 1,
    gridColumn: 1,
    gridColumnEnd: 1,
    gridColumnSpan: 1,
    gridColumnStart: 1,
    msGridRow: 1,
    msGridRowSpan: 1,
    msGridColumn: 1,
    msGridColumnSpan: 1,
    fontWeight: 1,
    lineHeight: 1,
    opacity: 1,
    order: 1,
    orphans: 1,
    scale: 1,
    tabSize: 1,
    widows: 1,
    zIndex: 1,
    zoom: 1,
    WebkitLineClamp: 1,
    // SVG-related properties
    fillOpacity: 1,
    floodOpacity: 1,
    stopOpacity: 1,
    strokeDasharray: 1,
    strokeDashoffset: 1,
    strokeMiterlimit: 1,
    strokeOpacity: 1,
    strokeWidth: 1
  };

  // node_modules/@emotion/serialize/dist/emotion-serialize.esm.js
  var isDevelopment2 = false;
  var hyphenateRegex = /[A-Z]|^ms/g;
  var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
  var isCustomProperty = function isCustomProperty2(property) {
    return property.charCodeAt(1) === 45;
  };
  var isProcessableValue = function isProcessableValue2(value) {
    return value != null && typeof value !== "boolean";
  };
  var processStyleName = /* @__PURE__ */ memoize(function(styleName) {
    return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, "-$&").toLowerCase();
  });
  var processStyleValue = function processStyleValue2(key, value) {
    switch (key) {
      case "animation":
      case "animationName": {
        if (typeof value === "string") {
          return value.replace(animationRegex, function(match3, p1, p2) {
            cursor = {
              name: p1,
              styles: p2,
              next: cursor
            };
            return p1;
          });
        }
      }
    }
    if (unitlessKeys[key] !== 1 && !isCustomProperty(key) && typeof value === "number" && value !== 0) {
      return value + "px";
    }
    return value;
  };
  var noComponentSelectorMessage = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
  function handleInterpolation(mergedProps, registered, interpolation) {
    if (interpolation == null) {
      return "";
    }
    var componentSelector = interpolation;
    if (componentSelector.__emotion_styles !== void 0) {
      return componentSelector;
    }
    switch (typeof interpolation) {
      case "boolean": {
        return "";
      }
      case "object": {
        var keyframes = interpolation;
        if (keyframes.anim === 1) {
          cursor = {
            name: keyframes.name,
            styles: keyframes.styles,
            next: cursor
          };
          return keyframes.name;
        }
        var serializedStyles = interpolation;
        if (serializedStyles.styles !== void 0) {
          var next2 = serializedStyles.next;
          if (next2 !== void 0) {
            while (next2 !== void 0) {
              cursor = {
                name: next2.name,
                styles: next2.styles,
                next: cursor
              };
              next2 = next2.next;
            }
          }
          var styles15 = serializedStyles.styles + ";";
          return styles15;
        }
        return createStringFromObject(mergedProps, registered, interpolation);
      }
      case "function": {
        if (mergedProps !== void 0) {
          var previousCursor = cursor;
          var result2 = interpolation(mergedProps);
          cursor = previousCursor;
          return handleInterpolation(mergedProps, registered, result2);
        }
        break;
      }
    }
    var asString = interpolation;
    if (registered == null) {
      return asString;
    }
    var cached = registered[asString];
    return cached !== void 0 ? cached : asString;
  }
  function createStringFromObject(mergedProps, registered, obj) {
    var string = "";
    if (Array.isArray(obj)) {
      for (var i = 0; i < obj.length; i++) {
        string += handleInterpolation(mergedProps, registered, obj[i]) + ";";
      }
    } else {
      for (var key in obj) {
        var value = obj[key];
        if (typeof value !== "object") {
          var asString = value;
          if (registered != null && registered[asString] !== void 0) {
            string += key + "{" + registered[asString] + "}";
          } else if (isProcessableValue(asString)) {
            string += processStyleName(key) + ":" + processStyleValue(key, asString) + ";";
          }
        } else {
          if (key === "NO_COMPONENT_SELECTOR" && isDevelopment2) {
            throw new Error(noComponentSelectorMessage);
          }
          if (Array.isArray(value) && typeof value[0] === "string" && (registered == null || registered[value[0]] === void 0)) {
            for (var _i = 0; _i < value.length; _i++) {
              if (isProcessableValue(value[_i])) {
                string += processStyleName(key) + ":" + processStyleValue(key, value[_i]) + ";";
              }
            }
          } else {
            var interpolated = handleInterpolation(mergedProps, registered, value);
            switch (key) {
              case "animation":
              case "animationName": {
                string += processStyleName(key) + ":" + interpolated + ";";
                break;
              }
              default: {
                string += key + "{" + interpolated + "}";
              }
            }
          }
        }
      }
    }
    return string;
  }
  var labelPattern = /label:\s*([^\s;{]+)\s*(;|$)/g;
  var cursor;
  function serializeStyles(args, registered, mergedProps) {
    if (args.length === 1 && typeof args[0] === "object" && args[0] !== null && args[0].styles !== void 0) {
      return args[0];
    }
    var stringMode = true;
    var styles15 = "";
    cursor = void 0;
    var strings = args[0];
    if (strings == null || strings.raw === void 0) {
      stringMode = false;
      styles15 += handleInterpolation(mergedProps, registered, strings);
    } else {
      var asTemplateStringsArr = strings;
      styles15 += asTemplateStringsArr[0];
    }
    for (var i = 1; i < args.length; i++) {
      styles15 += handleInterpolation(mergedProps, registered, args[i]);
      if (stringMode) {
        var templateStringsArr = strings;
        styles15 += templateStringsArr[i];
      }
    }
    labelPattern.lastIndex = 0;
    var identifierName = "";
    var match3;
    while ((match3 = labelPattern.exec(styles15)) !== null) {
      identifierName += "-" + match3[1];
    }
    var name = murmur2(styles15) + identifierName;
    return {
      name,
      styles: styles15,
      next: cursor
    };
  }

  // node_modules/@emotion/use-insertion-effect-with-fallbacks/dist/emotion-use-insertion-effect-with-fallbacks.browser.esm.js
  var React58 = __toESM(require_react());
  var syncFallback = function syncFallback2(create) {
    return create();
  };
  var useInsertionEffect2 = React58["useInsertionEffect"] ? React58["useInsertionEffect"] : false;
  var useInsertionEffectAlwaysWithSyncFallback = useInsertionEffect2 || syncFallback;

  // node_modules/@emotion/react/dist/emotion-element-f0de968e.browser.esm.js
  var isDevelopment3 = false;
  var EmotionCacheContext = /* @__PURE__ */ React59.createContext(
    // we're doing this to avoid preconstruct's dead code elimination in this one case
    // because this module is primarily intended for the browser and node
    // but it's also required in react native and similar environments sometimes
    // and we could have a special build just for that
    // but this is much easier and the native packages
    // might use a different theme context in the future anyway
    typeof HTMLElement !== "undefined" ? /* @__PURE__ */ createCache({
      key: "css"
    }) : null
  );
  var CacheProvider = EmotionCacheContext.Provider;
  var withEmotionCache = function withEmotionCache2(func) {
    return /* @__PURE__ */ (0, import_react93.forwardRef)(function(props, ref) {
      var cache = (0, import_react93.useContext)(EmotionCacheContext);
      return func(props, cache, ref);
    });
  };
  var ThemeContext = /* @__PURE__ */ React59.createContext({});
  var hasOwn = {}.hasOwnProperty;
  var typePropName = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__";
  var createEmotionProps = function createEmotionProps2(type, props) {
    var newProps = {};
    for (var _key in props) {
      if (hasOwn.call(props, _key)) {
        newProps[_key] = props[_key];
      }
    }
    newProps[typePropName] = type;
    return newProps;
  };
  var Insertion = function Insertion2(_ref2) {
    var cache = _ref2.cache, serialized = _ref2.serialized, isStringTag = _ref2.isStringTag;
    registerStyles(cache, serialized, isStringTag);
    useInsertionEffectAlwaysWithSyncFallback(function() {
      return insertStyles(cache, serialized, isStringTag);
    });
    return null;
  };
  var Emotion = /* @__PURE__ */ withEmotionCache(function(props, cache, ref) {
    var cssProp = props.css;
    if (typeof cssProp === "string" && cache.registered[cssProp] !== void 0) {
      cssProp = cache.registered[cssProp];
    }
    var WrappedComponent = props[typePropName];
    var registeredStyles = [cssProp];
    var className = "";
    if (typeof props.className === "string") {
      className = getRegisteredStyles(cache.registered, registeredStyles, props.className);
    } else if (props.className != null) {
      className = props.className + " ";
    }
    var serialized = serializeStyles(registeredStyles, void 0, React59.useContext(ThemeContext));
    className += cache.key + "-" + serialized.name;
    var newProps = {};
    for (var _key2 in props) {
      if (hasOwn.call(props, _key2) && _key2 !== "css" && _key2 !== typePropName && !isDevelopment3) {
        newProps[_key2] = props[_key2];
      }
    }
    newProps.className = className;
    if (ref) {
      newProps.ref = ref;
    }
    return /* @__PURE__ */ React59.createElement(React59.Fragment, null, /* @__PURE__ */ React59.createElement(Insertion, {
      cache,
      serialized,
      isStringTag: typeof WrappedComponent === "string"
    }), /* @__PURE__ */ React59.createElement(WrappedComponent, newProps));
  });
  var Emotion$1 = Emotion;

  // node_modules/@emotion/react/dist/emotion-react.browser.esm.js
  var React60 = __toESM(require_react());
  var import_hoist_non_react_statics = __toESM(require_hoist_non_react_statics_cjs());
  var jsx = function jsx2(type, props) {
    var args = arguments;
    if (props == null || !hasOwn.call(props, "css")) {
      return React60.createElement.apply(void 0, args);
    }
    var argsLength = args.length;
    var createElementArgArray = new Array(argsLength);
    createElementArgArray[0] = Emotion$1;
    createElementArgArray[1] = createEmotionProps(type, props);
    for (var i = 2; i < argsLength; i++) {
      createElementArgArray[i] = args[i];
    }
    return React60.createElement.apply(null, createElementArgArray);
  };
  (function(_jsx) {
    var JSX;
    /* @__PURE__ */ (function(_JSX) {
    })(JSX || (JSX = _jsx.JSX || (_jsx.JSX = {})));
  })(jsx || (jsx = {}));
  function css2() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return serializeStyles(args);
  }

  // node_modules/@atlaskit/primitives/dist/esm/xcss/style-maps.partial.js
  init_defineProperty();
  function ownKeys13(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r && (o = o.filter(function(r2) {
        return Object.getOwnPropertyDescriptor(e, r2).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread13(e) {
    for (var r = 1; r < arguments.length; r++) {
      var t = null != arguments[r] ? arguments[r] : {};
      r % 2 ? ownKeys13(Object(t), true).forEach(function(r2) {
        _defineProperty(e, r2, t[r2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys13(Object(t)).forEach(function(r2) {
        Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
      });
    }
    return e;
  }
  var dimensionMap = {
    "100%": "100%",
    "size.100": "1rem",
    "size.200": "1.5rem",
    "size.300": "2rem",
    "size.400": "2.5rem",
    "size.500": "3rem",
    "size.600": "6rem",
    "size.1000": "12rem"
  };
  var positiveSpaceMap = {
    "space.0": "var(--ds-space-0, 0px)",
    "space.025": "var(--ds-space-025, 2px)",
    "space.050": "var(--ds-space-050, 4px)",
    "space.075": "var(--ds-space-075, 6px)",
    "space.100": "var(--ds-space-100, 8px)",
    "space.150": "var(--ds-space-150, 12px)",
    "space.200": "var(--ds-space-200, 16px)",
    "space.250": "var(--ds-space-250, 20px)",
    "space.300": "var(--ds-space-300, 24px)",
    "space.400": "var(--ds-space-400, 32px)",
    "space.500": "var(--ds-space-500, 40px)",
    "space.600": "var(--ds-space-600, 48px)",
    "space.800": "var(--ds-space-800, 64px)",
    "space.1000": "var(--ds-space-1000, 80px)"
  };
  var negativeSpaceMap = {
    "space.negative.025": "var(--ds-space-negative-025, -2px)",
    "space.negative.050": "var(--ds-space-negative-050, -4px)",
    "space.negative.075": "var(--ds-space-negative-075, -6px)",
    "space.negative.100": "var(--ds-space-negative-100, -8px)",
    "space.negative.150": "var(--ds-space-negative-150, -12px)",
    "space.negative.200": "var(--ds-space-negative-200, -16px)",
    "space.negative.250": "var(--ds-space-negative-250, -20px)",
    "space.negative.300": "var(--ds-space-negative-300, -24px)",
    "space.negative.400": "var(--ds-space-negative-400, -32px)"
  };
  var allSpaceMap = _objectSpread13(_objectSpread13({}, positiveSpaceMap), negativeSpaceMap);
  var inverseColorMap2 = {
    "color.background.neutral.bold": "color.text.inverse",
    "color.background.neutral.bold.hovered": "color.text.inverse",
    "color.background.neutral.bold.pressed": "color.text.inverse",
    "color.background.selected.bold": "color.text.inverse",
    "color.background.selected.bold.hovered": "color.text.inverse",
    "color.background.selected.bold.pressed": "color.text.inverse",
    "color.background.brand.bold": "color.text.inverse",
    "color.background.brand.bold.hovered": "color.text.inverse",
    "color.background.brand.bold.pressed": "color.text.inverse",
    "color.background.brand.boldest": "color.text.inverse",
    "color.background.brand.boldest.hovered": "color.text.inverse",
    "color.background.brand.boldest.pressed": "color.text.inverse",
    "color.background.danger.bold": "color.text.inverse",
    "color.background.danger.bold.hovered": "color.text.inverse",
    "color.background.danger.bold.pressed": "color.text.inverse",
    "color.background.warning.bold": "color.text.warning.inverse",
    "color.background.warning.bold.hovered": "color.text.warning.inverse",
    "color.background.warning.bold.pressed": "color.text.warning.inverse",
    "color.background.success.bold": "color.text.inverse",
    "color.background.success.bold.hovered": "color.text.inverse",
    "color.background.success.bold.pressed": "color.text.inverse",
    "color.background.discovery.bold": "color.text.inverse",
    "color.background.discovery.bold.hovered": "color.text.inverse",
    "color.background.discovery.bold.pressed": "color.text.inverse",
    "color.background.information.bold": "color.text.inverse",
    "color.background.information.bold.hovered": "color.text.inverse",
    "color.background.information.bold.pressed": "color.text.inverse"
  };
  var opacityMap = {
    "opacity.disabled": "var(--ds-opacity-disabled, 0.4)",
    "opacity.loading": "var(--ds-opacity-loading, 0.2)"
  };
  var shadowMap = {
    "elevation.shadow.overflow": "var(--ds-shadow-overflow, 0px 0px 8px #091e423f, 0px 0px 1px #091e424f)",
    "elevation.shadow.overflow.perimeter": "var(--ds-shadow-overflow-perimeter, #091e421f)",
    "elevation.shadow.overflow.spread": "var(--ds-shadow-overflow-spread, #091e4229)",
    "elevation.shadow.overlay": "var(--ds-shadow-overlay, 0px 8px 12px #091e423f, 0px 0px 1px #091e424f)",
    "elevation.shadow.raised": "var(--ds-shadow-raised, 0px 1px 1px #091e423f, 0px 0px 1px #091e4221)"
  };
  var surfaceColorMap = {
    "elevation.surface": "var(--ds-surface, #FFFFFF)",
    "elevation.surface.hovered": "var(--ds-surface-hovered, #FAFBFC)",
    "elevation.surface.pressed": "var(--ds-surface-pressed, #F4F5F7)",
    "elevation.surface.overlay": "var(--ds-surface-overlay, #FFFFFF)",
    "elevation.surface.overlay.hovered": "var(--ds-surface-overlay-hovered, #FAFBFC)",
    "elevation.surface.overlay.pressed": "var(--ds-surface-overlay-pressed, #F4F5F7)",
    "elevation.surface.raised": "var(--ds-surface-raised, #FFFFFF)",
    "elevation.surface.raised.hovered": "var(--ds-surface-raised-hovered, #FAFBFC)",
    "elevation.surface.raised.pressed": "var(--ds-surface-raised-pressed, #F4F5F7)",
    "elevation.surface.sunken": "var(--ds-surface-sunken, #F4F5F7)"
  };
  var borderColorMap = {
    "color.border": "var(--ds-border, #091e4221)",
    "color.border.accent.lime": "var(--ds-border-accent-lime, #6A9A23)",
    "color.border.accent.red": "var(--ds-border-accent-red, #FF5630)",
    "color.border.accent.orange": "var(--ds-border-accent-orange, #D94008)",
    "color.border.accent.yellow": "var(--ds-border-accent-yellow, #FFAB00)",
    "color.border.accent.green": "var(--ds-border-accent-green, #36B37E)",
    "color.border.accent.teal": "var(--ds-border-accent-teal, #00B8D9)",
    "color.border.accent.blue": "var(--ds-border-accent-blue, #0065FF)",
    "color.border.accent.purple": "var(--ds-border-accent-purple, #6554C0)",
    "color.border.accent.magenta": "var(--ds-border-accent-magenta, #CD519D)",
    "color.border.accent.gray": "var(--ds-border-accent-gray, #5E6C84)",
    "color.border.disabled": "var(--ds-border-disabled, #FAFBFC)",
    "color.border.focused": "var(--ds-border-focused, #2684FF)",
    "color.border.input": "var(--ds-border-input, #FAFBFC)",
    "color.border.inverse": "var(--ds-border-inverse, #FFFFFF)",
    "color.border.selected": "var(--ds-border-selected, #0052CC)",
    "color.border.brand": "var(--ds-border-brand, #0052CC)",
    "color.border.danger": "var(--ds-border-danger, #FF5630)",
    "color.border.warning": "var(--ds-border-warning, #FFC400)",
    "color.border.success": "var(--ds-border-success, #00875A)",
    "color.border.discovery": "var(--ds-border-discovery, #998DD9)",
    "color.border.information": "var(--ds-border-information, #0065FF)",
    "color.border.bold": "var(--ds-border-bold, #344563)"
  };
  var backgroundColorMap2 = {
    "color.background.accent.lime.subtlest": "var(--ds-background-accent-lime-subtlest, #EEFBDA)",
    "color.background.accent.lime.subtlest.hovered": "var(--ds-background-accent-lime-subtlest-hovered, #D3F1A7)",
    "color.background.accent.lime.subtlest.pressed": "var(--ds-background-accent-lime-subtlest-pressed, #B3DF72)",
    "color.background.accent.lime.subtler": "var(--ds-background-accent-lime-subtler, #D3F1A7)",
    "color.background.accent.lime.subtler.hovered": "var(--ds-background-accent-lime-subtler-hovered, #B3DF72)",
    "color.background.accent.lime.subtler.pressed": "var(--ds-background-accent-lime-subtler-pressed, #94C748)",
    "color.background.accent.lime.subtle": "var(--ds-background-accent-lime-subtle, #94C748)",
    "color.background.accent.lime.subtle.hovered": "var(--ds-background-accent-lime-subtle-hovered, #B3DF72)",
    "color.background.accent.lime.subtle.pressed": "var(--ds-background-accent-lime-subtle-pressed, #D3F1A7)",
    "color.background.accent.lime.bolder": "var(--ds-background-accent-lime-bolder, #5B7F24)",
    "color.background.accent.lime.bolder.hovered": "var(--ds-background-accent-lime-bolder-hovered, #37471F)",
    "color.background.accent.lime.bolder.pressed": "var(--ds-background-accent-lime-bolder-pressed, #37471F)",
    "color.background.accent.red.subtlest": "var(--ds-background-accent-red-subtlest, #FF8F73)",
    "color.background.accent.red.subtlest.hovered": "var(--ds-background-accent-red-subtlest-hovered, #FF7452)",
    "color.background.accent.red.subtlest.pressed": "var(--ds-background-accent-red-subtlest-pressed, #FF5630)",
    "color.background.accent.red.subtler": "var(--ds-background-accent-red-subtler, #FF7452)",
    "color.background.accent.red.subtler.hovered": "var(--ds-background-accent-red-subtler-hovered, #FF5630)",
    "color.background.accent.red.subtler.pressed": "var(--ds-background-accent-red-subtler-pressed, #DE350B)",
    "color.background.accent.red.subtle": "var(--ds-background-accent-red-subtle, #DE350B)",
    "color.background.accent.red.subtle.hovered": "var(--ds-background-accent-red-subtle-hovered, #FF5630)",
    "color.background.accent.red.subtle.pressed": "var(--ds-background-accent-red-subtle-pressed, #FF7452)",
    "color.background.accent.red.bolder": "var(--ds-background-accent-red-bolder, #DE350B)",
    "color.background.accent.red.bolder.hovered": "var(--ds-background-accent-red-bolder-hovered, #FF5630)",
    "color.background.accent.red.bolder.pressed": "var(--ds-background-accent-red-bolder-pressed, #FF7452)",
    "color.background.accent.orange.subtlest": "var(--ds-background-accent-orange-subtlest, #F18D13)",
    "color.background.accent.orange.subtlest.hovered": "var(--ds-background-accent-orange-subtlest-hovered, #FEC57B)",
    "color.background.accent.orange.subtlest.pressed": "var(--ds-background-accent-orange-subtlest-pressed, #FFE2BD)",
    "color.background.accent.orange.subtler": "var(--ds-background-accent-orange-subtler, #B65C02)",
    "color.background.accent.orange.subtler.hovered": "var(--ds-background-accent-orange-subtler-hovered, #F18D13)",
    "color.background.accent.orange.subtler.pressed": "var(--ds-background-accent-orange-subtler-pressed, #FEC57B)",
    "color.background.accent.orange.subtle": "var(--ds-background-accent-orange-subtle, #5F3811)",
    "color.background.accent.orange.subtle.hovered": "var(--ds-background-accent-orange-subtle-hovered, #974F0C)",
    "color.background.accent.orange.subtle.pressed": "var(--ds-background-accent-orange-subtle-pressed, #B65C02)",
    "color.background.accent.orange.bolder": "var(--ds-background-accent-orange-bolder, #43290F)",
    "color.background.accent.orange.bolder.hovered": "var(--ds-background-accent-orange-bolder-hovered, #5F3811)",
    "color.background.accent.orange.bolder.pressed": "var(--ds-background-accent-orange-bolder-pressed, #974F0C)",
    "color.background.accent.yellow.subtlest": "var(--ds-background-accent-yellow-subtlest, #FFE380)",
    "color.background.accent.yellow.subtlest.hovered": "var(--ds-background-accent-yellow-subtlest-hovered, #FFC400)",
    "color.background.accent.yellow.subtlest.pressed": "var(--ds-background-accent-yellow-subtlest-pressed, #FFAB00)",
    "color.background.accent.yellow.subtler": "var(--ds-background-accent-yellow-subtler, #FFC400)",
    "color.background.accent.yellow.subtler.hovered": "var(--ds-background-accent-yellow-subtler-hovered, #FFAB00)",
    "color.background.accent.yellow.subtler.pressed": "var(--ds-background-accent-yellow-subtler-pressed, #FF991F)",
    "color.background.accent.yellow.subtle": "var(--ds-background-accent-yellow-subtle, #FF991F)",
    "color.background.accent.yellow.subtle.hovered": "var(--ds-background-accent-yellow-subtle-hovered, #FFAB00)",
    "color.background.accent.yellow.subtle.pressed": "var(--ds-background-accent-yellow-subtle-pressed, #FFC400)",
    "color.background.accent.yellow.bolder": "var(--ds-background-accent-yellow-bolder, #FF991F)",
    "color.background.accent.yellow.bolder.hovered": "var(--ds-background-accent-yellow-bolder-hovered, #FFAB00)",
    "color.background.accent.yellow.bolder.pressed": "var(--ds-background-accent-yellow-bolder-pressed, #FFC400)",
    "color.background.accent.green.subtlest": "var(--ds-background-accent-green-subtlest, #79F2C0)",
    "color.background.accent.green.subtlest.hovered": "var(--ds-background-accent-green-subtlest-hovered, #57D9A3)",
    "color.background.accent.green.subtlest.pressed": "var(--ds-background-accent-green-subtlest-pressed, #36B37E)",
    "color.background.accent.green.subtler": "var(--ds-background-accent-green-subtler, #57D9A3)",
    "color.background.accent.green.subtler.hovered": "var(--ds-background-accent-green-subtler-hovered, #36B37E)",
    "color.background.accent.green.subtler.pressed": "var(--ds-background-accent-green-subtler-pressed, #00875A)",
    "color.background.accent.green.subtle": "var(--ds-background-accent-green-subtle, #00875A)",
    "color.background.accent.green.subtle.hovered": "var(--ds-background-accent-green-subtle-hovered, #36B37E)",
    "color.background.accent.green.subtle.pressed": "var(--ds-background-accent-green-subtle-pressed, #57D9A3)",
    "color.background.accent.green.bolder": "var(--ds-background-accent-green-bolder, #00875A)",
    "color.background.accent.green.bolder.hovered": "var(--ds-background-accent-green-bolder-hovered, #36B37E)",
    "color.background.accent.green.bolder.pressed": "var(--ds-background-accent-green-bolder-pressed, #57D9A3)",
    "color.background.accent.teal.subtlest": "var(--ds-background-accent-teal-subtlest, #79E2F2)",
    "color.background.accent.teal.subtlest.hovered": "var(--ds-background-accent-teal-subtlest-hovered, #00C7E6)",
    "color.background.accent.teal.subtlest.pressed": "var(--ds-background-accent-teal-subtlest-pressed, #00B8D9)",
    "color.background.accent.teal.subtler": "var(--ds-background-accent-teal-subtler, #00C7E6)",
    "color.background.accent.teal.subtler.hovered": "var(--ds-background-accent-teal-subtler-hovered, #00B8D9)",
    "color.background.accent.teal.subtler.pressed": "var(--ds-background-accent-teal-subtler-pressed, #00A3BF)",
    "color.background.accent.teal.subtle": "var(--ds-background-accent-teal-subtle, #00A3BF)",
    "color.background.accent.teal.subtle.hovered": "var(--ds-background-accent-teal-subtle-hovered, #00B8D9)",
    "color.background.accent.teal.subtle.pressed": "var(--ds-background-accent-teal-subtle-pressed, #00C7E6)",
    "color.background.accent.teal.bolder": "var(--ds-background-accent-teal-bolder, #00A3BF)",
    "color.background.accent.teal.bolder.hovered": "var(--ds-background-accent-teal-bolder-hovered, #00B8D9)",
    "color.background.accent.teal.bolder.pressed": "var(--ds-background-accent-teal-bolder-pressed, #00C7E6)",
    "color.background.accent.blue.subtlest": "var(--ds-background-accent-blue-subtlest, #4C9AFF)",
    "color.background.accent.blue.subtlest.hovered": "var(--ds-background-accent-blue-subtlest-hovered, #2684FF)",
    "color.background.accent.blue.subtlest.pressed": "var(--ds-background-accent-blue-subtlest-pressed, #0065FF)",
    "color.background.accent.blue.subtler": "var(--ds-background-accent-blue-subtler, #2684FF)",
    "color.background.accent.blue.subtler.hovered": "var(--ds-background-accent-blue-subtler-hovered, #0065FF)",
    "color.background.accent.blue.subtler.pressed": "var(--ds-background-accent-blue-subtler-pressed, #0052CC)",
    "color.background.accent.blue.subtle": "var(--ds-background-accent-blue-subtle, #0052CC)",
    "color.background.accent.blue.subtle.hovered": "var(--ds-background-accent-blue-subtle-hovered, #0065FF)",
    "color.background.accent.blue.subtle.pressed": "var(--ds-background-accent-blue-subtle-pressed, #2684FF)",
    "color.background.accent.blue.bolder": "var(--ds-background-accent-blue-bolder, #0052CC)",
    "color.background.accent.blue.bolder.hovered": "var(--ds-background-accent-blue-bolder-hovered, #0065FF)",
    "color.background.accent.blue.bolder.pressed": "var(--ds-background-accent-blue-bolder-pressed, #2684FF)",
    "color.background.accent.purple.subtlest": "var(--ds-background-accent-purple-subtlest, #998DD9)",
    "color.background.accent.purple.subtlest.hovered": "var(--ds-background-accent-purple-subtlest-hovered, #8777D9)",
    "color.background.accent.purple.subtlest.pressed": "var(--ds-background-accent-purple-subtlest-pressed, #6554C0)",
    "color.background.accent.purple.subtler": "var(--ds-background-accent-purple-subtler, #8777D9)",
    "color.background.accent.purple.subtler.hovered": "var(--ds-background-accent-purple-subtler-hovered, #6554C0)",
    "color.background.accent.purple.subtler.pressed": "var(--ds-background-accent-purple-subtler-pressed, #5243AA)",
    "color.background.accent.purple.subtle": "var(--ds-background-accent-purple-subtle, #5243AA)",
    "color.background.accent.purple.subtle.hovered": "var(--ds-background-accent-purple-subtle-hovered, #6554C0)",
    "color.background.accent.purple.subtle.pressed": "var(--ds-background-accent-purple-subtle-pressed, #8777D9)",
    "color.background.accent.purple.bolder": "var(--ds-background-accent-purple-bolder, #5243AA)",
    "color.background.accent.purple.bolder.hovered": "var(--ds-background-accent-purple-bolder-hovered, #6554C0)",
    "color.background.accent.purple.bolder.pressed": "var(--ds-background-accent-purple-bolder-pressed, #8777D9)",
    "color.background.accent.magenta.subtlest": "var(--ds-background-accent-magenta-subtlest, #FFECF8)",
    "color.background.accent.magenta.subtlest.hovered": "var(--ds-background-accent-magenta-subtlest-hovered, #FDD0EC)",
    "color.background.accent.magenta.subtlest.pressed": "var(--ds-background-accent-magenta-subtlest-pressed, #F797D2)",
    "color.background.accent.magenta.subtler": "var(--ds-background-accent-magenta-subtler, #FDD0EC)",
    "color.background.accent.magenta.subtler.hovered": "var(--ds-background-accent-magenta-subtler-hovered, #F797D2)",
    "color.background.accent.magenta.subtler.pressed": "var(--ds-background-accent-magenta-subtler-pressed, #E774BB)",
    "color.background.accent.magenta.subtle": "var(--ds-background-accent-magenta-subtle, #E774BB)",
    "color.background.accent.magenta.subtle.hovered": "var(--ds-background-accent-magenta-subtle-hovered, #F797D2)",
    "color.background.accent.magenta.subtle.pressed": "var(--ds-background-accent-magenta-subtle-pressed, #FDD0EC)",
    "color.background.accent.magenta.bolder": "var(--ds-background-accent-magenta-bolder, #AE4787)",
    "color.background.accent.magenta.bolder.hovered": "var(--ds-background-accent-magenta-bolder-hovered, #943D73)",
    "color.background.accent.magenta.bolder.pressed": "var(--ds-background-accent-magenta-bolder-pressed, #50253F)",
    "color.background.accent.gray.subtlest": "var(--ds-background-accent-gray-subtlest, #6B778C)",
    "color.background.accent.gray.subtlest.hovered": "var(--ds-background-accent-gray-subtlest-hovered, #5E6C84)",
    "color.background.accent.gray.subtlest.pressed": "var(--ds-background-accent-gray-subtlest-pressed, #505F79)",
    "color.background.accent.gray.subtler": "var(--ds-background-accent-gray-subtler, #5E6C84)",
    "color.background.accent.gray.subtler.hovered": "var(--ds-background-accent-gray-subtler-hovered, #505F79)",
    "color.background.accent.gray.subtler.pressed": "var(--ds-background-accent-gray-subtler-pressed, #42526E)",
    "color.background.accent.gray.subtle": "var(--ds-background-accent-gray-subtle, #505F79)",
    "color.background.accent.gray.subtle.hovered": "var(--ds-background-accent-gray-subtle-hovered, #5E6C84)",
    "color.background.accent.gray.subtle.pressed": "var(--ds-background-accent-gray-subtle-pressed, #6B778C)",
    "color.background.accent.gray.bolder": "var(--ds-background-accent-gray-bolder, #42526E)",
    "color.background.accent.gray.bolder.hovered": "var(--ds-background-accent-gray-bolder-hovered, #344563)",
    "color.background.accent.gray.bolder.pressed": "var(--ds-background-accent-gray-bolder-pressed, #253858)",
    "color.background.disabled": "var(--ds-background-disabled, #091e4289)",
    "color.background.input": "var(--ds-background-input, #FAFBFC)",
    "color.background.input.hovered": "var(--ds-background-input-hovered, #EBECF0)",
    "color.background.input.pressed": "var(--ds-background-input-pressed, #FFFFFF)",
    "color.background.inverse.subtle": "var(--ds-background-inverse-subtle, #00000029)",
    "color.background.inverse.subtle.hovered": "var(--ds-background-inverse-subtle-hovered, #0000003D)",
    "color.background.inverse.subtle.pressed": "var(--ds-background-inverse-subtle-pressed, #00000052)",
    "color.background.neutral": "var(--ds-background-neutral, #DFE1E6)",
    "color.background.neutral.hovered": "var(--ds-background-neutral-hovered, #091e4214)",
    "color.background.neutral.pressed": "var(--ds-background-neutral-pressed, #B3D4FF)",
    "color.background.neutral.subtle": "var(--ds-background-neutral-subtle, transparent)",
    "color.background.neutral.subtle.hovered": "var(--ds-background-neutral-subtle-hovered, #091e4214)",
    "color.background.neutral.subtle.pressed": "var(--ds-background-neutral-subtle-pressed, #B3D4FF)",
    "color.background.neutral.bold": "var(--ds-background-neutral-bold, #42526E)",
    "color.background.neutral.bold.hovered": "var(--ds-background-neutral-bold-hovered, #505F79)",
    "color.background.neutral.bold.pressed": "var(--ds-background-neutral-bold-pressed, #344563)",
    "color.background.selected": "var(--ds-background-selected, #DEEBFF)",
    "color.background.selected.hovered": "var(--ds-background-selected-hovered, #B3D4FF)",
    "color.background.selected.pressed": "var(--ds-background-selected-pressed, #4C9AFF)",
    "color.background.selected.bold": "var(--ds-background-selected-bold, #0052CC)",
    "color.background.selected.bold.hovered": "var(--ds-background-selected-bold-hovered, #2684FF)",
    "color.background.selected.bold.pressed": "var(--ds-background-selected-bold-pressed, #0052CC)",
    "color.background.brand.subtlest": "var(--ds-background-brand-subtlest, #B3D4FF)",
    "color.background.brand.subtlest.hovered": "var(--ds-background-brand-subtlest-hovered, #DEEBFF)",
    "color.background.brand.subtlest.pressed": "var(--ds-background-brand-subtlest-pressed, #4C9AFF)",
    "color.background.brand.bold": "var(--ds-background-brand-bold, #0052CC)",
    "color.background.brand.bold.hovered": "var(--ds-background-brand-bold-hovered, #0065FF)",
    "color.background.brand.bold.pressed": "var(--ds-background-brand-bold-pressed, #0747A6)",
    "color.background.brand.boldest": "var(--ds-background-brand-boldest, #0747A6)",
    "color.background.brand.boldest.hovered": "var(--ds-background-brand-boldest-hovered, #0052CC)",
    "color.background.brand.boldest.pressed": "var(--ds-background-brand-boldest-pressed, #0747A6)",
    "color.background.danger": "var(--ds-background-danger, #FFEBE6)",
    "color.background.danger.hovered": "var(--ds-background-danger-hovered, #FFBDAD)",
    "color.background.danger.pressed": "var(--ds-background-danger-pressed, #FF8F73)",
    "color.background.danger.bold": "var(--ds-background-danger-bold, #DE350B)",
    "color.background.danger.bold.hovered": "var(--ds-background-danger-bold-hovered, #FF5630)",
    "color.background.danger.bold.pressed": "var(--ds-background-danger-bold-pressed, #BF2600)",
    "color.background.warning": "var(--ds-background-warning, #FFFAE6)",
    "color.background.warning.hovered": "var(--ds-background-warning-hovered, #FFF0B3)",
    "color.background.warning.pressed": "var(--ds-background-warning-pressed, #FFE380)",
    "color.background.warning.bold": "var(--ds-background-warning-bold, #FFAB00)",
    "color.background.warning.bold.hovered": "var(--ds-background-warning-bold-hovered, #FFC400)",
    "color.background.warning.bold.pressed": "var(--ds-background-warning-bold-pressed, #FF991F)",
    "color.background.success": "var(--ds-background-success, #E3FCEF)",
    "color.background.success.hovered": "var(--ds-background-success-hovered, #ABF5D1)",
    "color.background.success.pressed": "var(--ds-background-success-pressed, #79F2C0)",
    "color.background.success.bold": "var(--ds-background-success-bold, #00875A)",
    "color.background.success.bold.hovered": "var(--ds-background-success-bold-hovered, #57D9A3)",
    "color.background.success.bold.pressed": "var(--ds-background-success-bold-pressed, #00875A)",
    "color.background.discovery": "var(--ds-background-discovery, #EAE6FF)",
    "color.background.discovery.hovered": "var(--ds-background-discovery-hovered, #C0B6F2)",
    "color.background.discovery.pressed": "var(--ds-background-discovery-pressed, #998DD9)",
    "color.background.discovery.bold": "var(--ds-background-discovery-bold, #5243AA)",
    "color.background.discovery.bold.hovered": "var(--ds-background-discovery-bold-hovered, #8777D9)",
    "color.background.discovery.bold.pressed": "var(--ds-background-discovery-bold-pressed, #5243AA)",
    "color.background.information": "var(--ds-background-information, #DEEBFF)",
    "color.background.information.hovered": "var(--ds-background-information-hovered, #B3D4FF)",
    "color.background.information.pressed": "var(--ds-background-information-pressed, #4C9AFF)",
    "color.background.information.bold": "var(--ds-background-information-bold, #0052CC)",
    "color.background.information.bold.hovered": "var(--ds-background-information-bold-hovered, #2684FF)",
    "color.background.information.bold.pressed": "var(--ds-background-information-bold-pressed, #0052CC)",
    "color.blanket": "var(--ds-blanket, #091e4289)",
    "color.blanket.selected": "var(--ds-blanket-selected, #388BFF14)",
    "color.blanket.danger": "var(--ds-blanket-danger, #EF5C4814)",
    "color.skeleton": "var(--ds-skeleton, #F4F5F7)",
    "color.skeleton.subtle": "var(--ds-skeleton-subtle, #091e420a)",
    "elevation.surface": "var(--ds-surface, #FFFFFF)",
    "elevation.surface.hovered": "var(--ds-surface-hovered, #FAFBFC)",
    "elevation.surface.pressed": "var(--ds-surface-pressed, #F4F5F7)",
    "elevation.surface.overlay": "var(--ds-surface-overlay, #FFFFFF)",
    "elevation.surface.overlay.hovered": "var(--ds-surface-overlay-hovered, #FAFBFC)",
    "elevation.surface.overlay.pressed": "var(--ds-surface-overlay-pressed, #F4F5F7)",
    "elevation.surface.raised": "var(--ds-surface-raised, #FFFFFF)",
    "elevation.surface.raised.hovered": "var(--ds-surface-raised-hovered, #FAFBFC)",
    "elevation.surface.raised.pressed": "var(--ds-surface-raised-pressed, #F4F5F7)",
    "elevation.surface.sunken": "var(--ds-surface-sunken, #F4F5F7)",
    "utility.elevation.surface.current": "var(--ds-elevation-surface-current, #FFFFFF)"
  };
  var textColorMap2 = {
    "color.text": "var(--ds-text, #172B4D)",
    "color.text.accent.lime": "var(--ds-text-accent-lime, #4C6B1F)",
    "color.text.accent.lime.bolder": "var(--ds-text-accent-lime-bolder, #37471F)",
    "color.text.accent.red": "var(--ds-text-accent-red, #DE350B)",
    "color.text.accent.red.bolder": "var(--ds-text-accent-red-bolder, #BF2600)",
    "color.text.accent.orange": "var(--ds-text-accent-orange, #F18D13)",
    "color.text.accent.orange.bolder": "var(--ds-text-accent-orange-bolder, #B65C02)",
    "color.text.accent.yellow": "var(--ds-text-accent-yellow, #FF991F)",
    "color.text.accent.yellow.bolder": "var(--ds-text-accent-yellow-bolder, #FF8B00)",
    "color.text.accent.green": "var(--ds-text-accent-green, #00875A)",
    "color.text.accent.green.bolder": "var(--ds-text-accent-green-bolder, #006644)",
    "color.text.accent.teal": "var(--ds-text-accent-teal, #00A3BF)",
    "color.text.accent.teal.bolder": "var(--ds-text-accent-teal-bolder, #008DA6)",
    "color.text.accent.blue": "var(--ds-text-accent-blue, #0052CC)",
    "color.text.accent.blue.bolder": "var(--ds-text-accent-blue-bolder, #0747A6)",
    "color.text.accent.purple": "var(--ds-text-accent-purple, #5243AA)",
    "color.text.accent.purple.bolder": "var(--ds-text-accent-purple-bolder, #403294)",
    "color.text.accent.magenta": "var(--ds-text-accent-magenta, #E774BB)",
    "color.text.accent.magenta.bolder": "var(--ds-text-accent-magenta-bolder, #DA62AC)",
    "color.text.accent.gray": "var(--ds-text-accent-gray, #505F79)",
    "color.text.accent.gray.bolder": "var(--ds-text-accent-gray-bolder, #172B4D)",
    "color.text.disabled": "var(--ds-text-disabled, #A5ADBA)",
    "color.text.inverse": "var(--ds-text-inverse, #FFFFFF)",
    "color.text.selected": "var(--ds-text-selected, #0052CC)",
    "color.text.brand": "var(--ds-text-brand, #0065FF)",
    "color.text.danger": "var(--ds-text-danger, #DE350B)",
    "color.text.warning": "var(--ds-text-warning, #974F0C)",
    "color.text.warning.inverse": "var(--ds-text-warning-inverse, #172B4D)",
    "color.text.success": "var(--ds-text-success, #006644)",
    "color.text.discovery": "var(--ds-text-discovery, #403294)",
    "color.text.information": "var(--ds-text-information, #0052CC)",
    "color.text.subtlest": "var(--ds-text-subtlest, #7A869A)",
    "color.text.subtle": "var(--ds-text-subtle, #42526E)",
    "color.link": "var(--ds-link, #0052CC)",
    "color.link.pressed": "var(--ds-link-pressed, #0747A6)",
    "color.link.visited": "var(--ds-link-visited, #403294)",
    "color.link.visited.pressed": "var(--ds-link-visited-pressed, #403294)"
  };
  var layerMap = {
    "1": 1,
    card: 100,
    navigation: 200,
    dialog: 300,
    layer: 400,
    blanket: 500,
    modal: 510,
    flag: 600,
    spotlight: 700,
    tooltip: 800
  };
  var borderWidthMap = {
    "border.width": "var(--ds-border-width, 1px)",
    "border.width.0": "var(--ds-border-width-0, 0px)",
    "border.width.indicator": "var(--ds-border-width-indicator, 3px)",
    "border.width.outline": "var(--ds-border-width-outline, 2px)"
  };
  var borderRadiusMap = {
    "border.radius.050": "var(--ds-border-radius-050, 2px)",
    "border.radius": "var(--ds-border-radius, 3px)",
    "border.radius.100": "var(--ds-border-radius-100, 3px)",
    "border.radius.200": "var(--ds-border-radius-200, 8px)",
    "border.radius.300": "var(--ds-border-radius-300, 12px)",
    "border.radius.400": "var(--ds-border-radius-400, 16px)",
    "border.radius.circle": "var(--ds-border-radius-circle, 32032px)"
  };
  var fontMap = {
    "font.body": 'var(--ds-font-body, normal 400 14px/20px ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Ubuntu, "Helvetica Neue", sans-serif)',
    "font.body.UNSAFE_small": 'var(--ds-font-body-UNSAFE_small, normal 400 12px/16px ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Ubuntu, "Helvetica Neue", sans-serif)',
    "font.body.large": 'var(--ds-font-body-large, normal 400 16px/24px ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Ubuntu, "Helvetica Neue", sans-serif)',
    "font.body.small": 'var(--ds-font-body-small, normal 400 11px/16px ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Ubuntu, "Helvetica Neue", sans-serif)',
    "font.code": 'var(--ds-font-code, normal 400 0.875em/1 ui-monospace, Menlo, "Segoe UI Mono", "Ubuntu Mono", monospace)',
    "font.heading.large": 'var(--ds-font-heading-large, normal 500 24px/28px ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Ubuntu, "Helvetica Neue", sans-serif)',
    "font.heading.medium": 'var(--ds-font-heading-medium, normal 500 20px/24px ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Ubuntu, "Helvetica Neue", sans-serif)',
    "font.heading.small": 'var(--ds-font-heading-small, normal 600 16px/20px ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Ubuntu, "Helvetica Neue", sans-serif)',
    "font.heading.xlarge": 'var(--ds-font-heading-xlarge, normal 600 29px/32px ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Ubuntu, "Helvetica Neue", sans-serif)',
    "font.heading.xsmall": 'var(--ds-font-heading-xsmall, normal 600 14px/16px ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Ubuntu, "Helvetica Neue", sans-serif)',
    "font.heading.xxlarge": 'var(--ds-font-heading-xxlarge, normal 500 35px/40px ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Ubuntu, "Helvetica Neue", sans-serif)',
    "font.heading.xxsmall": 'var(--ds-font-heading-xxsmall, normal 600 12px/16px ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Ubuntu, "Helvetica Neue", sans-serif)',
    "font.metric.large": 'var(--ds-font-metric-large, normal 653 28px/32px ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Ubuntu, "Helvetica Neue", sans-serif)',
    "font.metric.medium": 'var(--ds-font-metric-medium, normal 653 24px/28px ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Ubuntu, "Helvetica Neue", sans-serif)',
    "font.metric.small": 'var(--ds-font-metric-small, normal 653 16px/20px ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Ubuntu, "Helvetica Neue", sans-serif)'
  };
  var fontWeightMap2 = {
    "font.weight.bold": "var(--ds-font-weight-bold, 700)",
    "font.weight.medium": "var(--ds-font-weight-medium, 500)",
    "font.weight.regular": "var(--ds-font-weight-regular, 400)",
    "font.weight.semibold": "var(--ds-font-weight-semibold, 600)"
  };
  var fontFamilyMap = {
    "font.family.body": 'var(--ds-font-family-body, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Ubuntu, "Helvetica Neue", sans-serif)',
    "font.family.brand.body": 'var(--ds-font-family-brand-body, "Charlie Text", ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Ubuntu, "Helvetica Neue", sans-serif)',
    "font.family.brand.heading": 'var(--ds-font-family-brand-heading, "Charlie Display", ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Ubuntu, "Helvetica Neue", sans-serif)',
    "font.family.code": 'var(--ds-font-family-code, ui-monospace, Menlo, "Segoe UI Mono", "Ubuntu Mono", monospace)',
    "font.family.heading": 'var(--ds-font-family-heading, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Ubuntu, "Helvetica Neue", sans-serif)'
  };
  var textSizeMap = {
    medium: 'var(--ds-font-body, normal 400 14px/20px ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Ubuntu, "Helvetica Neue", sans-serif)',
    UNSAFE_small: 'var(--ds-font-body-UNSAFE_small, normal 400 12px/16px ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Ubuntu, "Helvetica Neue", sans-serif)',
    large: 'var(--ds-font-body-large, normal 400 16px/24px ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Ubuntu, "Helvetica Neue", sans-serif)',
    small: 'var(--ds-font-body-small, normal 400 11px/16px ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Ubuntu, "Helvetica Neue", sans-serif)'
  };
  var textWeightMap = {
    bold: "var(--ds-font-weight-bold, 700)",
    medium: "var(--ds-font-weight-medium, 500)",
    regular: "var(--ds-font-weight-regular, 400)",
    semibold: "var(--ds-font-weight-semibold, 600)"
  };
  var metricTextSizeMap = {
    large: 'var(--ds-font-metric-large, normal 653 28px/32px ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Ubuntu, "Helvetica Neue", sans-serif)',
    medium: 'var(--ds-font-metric-medium, normal 653 24px/28px ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Ubuntu, "Helvetica Neue", sans-serif)',
    small: 'var(--ds-font-metric-small, normal 653 16px/20px ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Ubuntu, "Helvetica Neue", sans-serif)'
  };
  var spacingProperties = [
    // Used by Box
    "padding",
    "paddingBlock",
    "paddingBlockStart",
    "paddingBlockEnd",
    "paddingInline",
    "paddingInlineStart",
    "paddingInlineEnd",
    // Used by Inline and Stack
    "gap",
    "rowGap",
    "columnGap"
  ];
  var getSerializedStylesMap = function getSerializedStylesMap2(cssProperty, tokenMap) {
    return Object.keys(tokenMap).reduce(function(emotionSpacingMap, token2) {
      emotionSpacingMap[token2] = css2(_defineProperty({}, cssProperty, tokenMap[token2]));
      return emotionSpacingMap;
    }, {});
  };
  var paddingStylesMap = spacingProperties.reduce(function(styleMap, spacingProperty) {
    styleMap[spacingProperty] = getSerializedStylesMap(spacingProperty, positiveSpaceMap);
    return styleMap;
  }, {});
  var spaceStylesMap = spacingProperties.reduce(function(styleMap, spacingProperty) {
    styleMap[spacingProperty] = getSerializedStylesMap(spacingProperty, positiveSpaceMap);
    return styleMap;
  }, {});
  var backgroundColorStylesMap = getSerializedStylesMap("backgroundColor", backgroundColorMap2);
  var textColorStylesMap = getSerializedStylesMap("color", textColorMap2);
  var fontWeightStylesMap = getSerializedStylesMap("fontWeight", fontWeightMap2);
  var fontFamilyStylesMap = getSerializedStylesMap("fontFamily", fontFamilyMap);
  var fontStylesMap = getSerializedStylesMap("font", fontMap);
  var textSizeStylesMap = getSerializedStylesMap("font", textSizeMap);
  var textWeightStylesMap = getSerializedStylesMap("fontWeight", textWeightMap);
  var surfaceColorStylesMap = getSerializedStylesMap(CURRENT_SURFACE_CSS_VAR, surfaceColorMap);
  var isSurfaceColorToken = function isSurfaceColorToken2(color) {
    return surfaceColorMap[color] !== void 0;
  };
  var metricTextSizeStylesMap = getSerializedStylesMap("font", metricTextSizeMap);

  // node_modules/@atlaskit/primitives/dist/esm/xcss/xcss.js
  init_toConsumableArray();
  init_defineProperty();
  init_slicedToArray();
  init_typeof();
  function _createForOfIteratorHelper3(r, e) {
    var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
    if (!t) {
      if (Array.isArray(r) || (t = _unsupportedIterableToArray4(r)) || e && r && "number" == typeof r.length) {
        t && (r = t);
        var _n = 0, F = function F2() {
        };
        return { s: F, n: function n() {
          return _n >= r.length ? { done: true } : { done: false, value: r[_n++] };
        }, e: function e2(r2) {
          throw r2;
        }, f: F };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var o, a = true, u = false;
    return { s: function s() {
      t = t.call(r);
    }, n: function n() {
      var r2 = t.next();
      return a = r2.done, r2;
    }, e: function e2(r2) {
      u = true, o = r2;
    }, f: function f() {
      try {
        a || null == t.return || t.return();
      } finally {
        if (u) throw o;
      }
    } };
  }
  function _unsupportedIterableToArray4(r, a) {
    if (r) {
      if ("string" == typeof r) return _arrayLikeToArray4(r, a);
      var t = {}.toString.call(r).slice(8, -1);
      return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray4(r, a) : void 0;
    }
  }
  function _arrayLikeToArray4(r, a) {
    (null == a || a > r.length) && (a = r.length);
    for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
    return n;
  }
  var tokensMap = {
    backgroundColor: backgroundColorMap2,
    blockSize: dimensionMap,
    borderBlockColor: borderColorMap,
    borderBlockEndColor: borderColorMap,
    borderBlockEndWidth: borderWidthMap,
    borderBlockStartColor: borderColorMap,
    borderBlockStartWidth: borderWidthMap,
    borderBlockWidth: borderWidthMap,
    borderBottomColor: borderColorMap,
    borderBottomLeftRadius: borderRadiusMap,
    borderBottomRightRadius: borderRadiusMap,
    borderBottomWidth: borderWidthMap,
    borderColor: borderColorMap,
    borderEndEndRadius: borderRadiusMap,
    borderEndStartRadius: borderRadiusMap,
    borderInlineColor: borderColorMap,
    borderInlineEndColor: borderColorMap,
    borderInlineEndWidth: borderWidthMap,
    borderInlineStartColor: borderColorMap,
    borderInlineStartWidth: borderWidthMap,
    borderInlineWidth: borderWidthMap,
    borderLeftColor: borderColorMap,
    borderLeftWidth: borderWidthMap,
    borderRadius: borderRadiusMap,
    borderRightColor: borderColorMap,
    borderRightWidth: borderWidthMap,
    borderStartEndRadius: borderRadiusMap,
    borderStartStartRadius: borderRadiusMap,
    borderTopColor: borderColorMap,
    borderTopLeftRadius: borderRadiusMap,
    borderTopRightRadius: borderRadiusMap,
    borderTopWidth: borderWidthMap,
    borderWidth: borderWidthMap,
    bottom: allSpaceMap,
    boxShadow: shadowMap,
    color: textColorMap2,
    columnGap: positiveSpaceMap,
    font: fontMap,
    fontFamily: fontFamilyMap,
    fontWeight: fontWeightMap2,
    gap: positiveSpaceMap,
    height: dimensionMap,
    inlineSize: dimensionMap,
    inset: allSpaceMap,
    insetBlock: allSpaceMap,
    insetBlockEnd: allSpaceMap,
    insetBlockStart: allSpaceMap,
    insetInline: allSpaceMap,
    insetInlineEnd: allSpaceMap,
    insetInlineStart: allSpaceMap,
    left: allSpaceMap,
    margin: allSpaceMap,
    marginBlock: allSpaceMap,
    marginBlockEnd: allSpaceMap,
    marginBlockStart: allSpaceMap,
    marginBottom: allSpaceMap,
    marginInline: allSpaceMap,
    marginInlineEnd: allSpaceMap,
    marginInlineStart: allSpaceMap,
    marginLeft: allSpaceMap,
    marginRight: allSpaceMap,
    marginTop: allSpaceMap,
    maxBlockSize: dimensionMap,
    maxHeight: dimensionMap,
    maxInlineSize: dimensionMap,
    maxWidth: dimensionMap,
    minBlockSize: dimensionMap,
    minHeight: dimensionMap,
    minInlineSize: dimensionMap,
    minWidth: dimensionMap,
    opacity: opacityMap,
    outlineColor: borderColorMap,
    outlineOffset: allSpaceMap,
    outlineWidth: borderWidthMap,
    padding: positiveSpaceMap,
    paddingBlock: positiveSpaceMap,
    paddingBlockEnd: positiveSpaceMap,
    paddingBlockStart: positiveSpaceMap,
    paddingBottom: positiveSpaceMap,
    paddingInline: positiveSpaceMap,
    paddingInlineEnd: positiveSpaceMap,
    paddingInlineStart: positiveSpaceMap,
    paddingLeft: positiveSpaceMap,
    paddingRight: positiveSpaceMap,
    paddingTop: positiveSpaceMap,
    right: allSpaceMap,
    rowGap: positiveSpaceMap,
    top: allSpaceMap,
    width: dimensionMap,
    zIndex: layerMap
  };
  var uniqueSymbol = Symbol("UNSAFE_INTERNAL_styles");
  var isSafeEnvToThrow = function isSafeEnvToThrow2() {
    return (typeof process === "undefined" ? "undefined" : _typeof(process)) === "object" && _typeof(process.env) === "object" && false;
  };
  var reNestedSelectors = /(\.|\s|&+|\*\>|#|\[.*\])/;
  var safeSelectors = /^@media .*$|^::?.*$|^@supports .*$/;
  var _transformStyles = function transformStyles(styleObj) {
    if (!styleObj || _typeof(styleObj) !== "object") {
      return styleObj;
    }
    if (Array.isArray(styleObj)) {
      return styleObj.map(_transformStyles);
    }
    Object.entries(styleObj).forEach(function(_ref2) {
      var _ref22 = _slicedToArray(_ref2, 2), key = _ref22[0], value = _ref22[1];
      if (_typeof(value) === "object" && safeSelectors.test(key)) {
        styleObj[key] = _transformStyles(value);
        return;
      }
      if (isSafeEnvToThrow()) {
        if (reNestedSelectors.test(key)) {
          throw new Error("Styles not supported for key '".concat(key, "'."));
        }
      }
      if (!(key in tokensMap)) {
        return;
      }
      var tokenValue = tokensMap[key][value];
      styleObj[key] = tokenValue !== null && tokenValue !== void 0 ? tokenValue : value;
    });
    return styleObj;
  };
  var baseXcss = function baseXcss2(style) {
    var transformedStyles = _transformStyles(style);
    return _defineProperty({}, uniqueSymbol, css2(transformedStyles));
  };
  var _parseXcss = function parseXcss(args) {
    if (Array.isArray(args)) {
      var emotion = [];
      var staticArr = [];
      var _iterator = _createForOfIteratorHelper3(args), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var arg = _step.value;
          var result2 = _parseXcss(arg);
          if (result2.emotion) {
            emotion.push.apply(emotion, _toConsumableArray(result2.emotion));
          }
          if (result2.static) {
            staticArr.push(result2.static);
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return {
        emotion,
        static: staticArr.join(" ")
      };
    }
    var objArgs = args;
    var _ref4 = objArgs || {}, styles15 = _ref4[uniqueSymbol];
    if (styles15) {
      return {
        emotion: [styles15]
      };
    }
    if (args) {
      var stringifiedArgs = "".concat(args);
      if (stringifiedArgs) {
        return {
          static: stringifiedArgs
        };
      }
    }
    return {};
  };
  function xcss(style) {
    return baseXcss(style);
  }

  // node_modules/@atlaskit/primitives/dist/esm/components/box.js
  var _excluded12 = ["as", "children", "backgroundColor", "padding", "paddingBlock", "paddingBlockStart", "paddingBlockEnd", "paddingInline", "paddingInlineStart", "paddingInlineEnd", "style", "testId", "xcss"];
  var _excluded28 = ["className"];
  var Box2 = /* @__PURE__ */ (0, import_react96.forwardRef)(
    function(_ref2, ref) {
      var _ref$as = _ref2.as, Component3 = _ref$as === void 0 ? "div" : _ref$as, children = _ref2.children, backgroundColor = _ref2.backgroundColor, padding = _ref2.padding, paddingBlock = _ref2.paddingBlock, paddingBlockStart = _ref2.paddingBlockStart, paddingBlockEnd = _ref2.paddingBlockEnd, paddingInline = _ref2.paddingInline, paddingInlineStart = _ref2.paddingInlineStart, paddingInlineEnd = _ref2.paddingInlineEnd, style = _ref2.style, testId = _ref2.testId, xcss2 = _ref2.xcss, htmlAttributes = _objectWithoutProperties(_ref2, _excluded12);
      var _spreadClass = htmlAttributes.className, safeHtmlAttributes = _objectWithoutProperties(htmlAttributes, _excluded28);
      var resolvedStyles = _parseXcss(xcss2);
      var node2 = (
        // @ts-expect-error Expression produces a union type that is too complex to represent. I think this is unavoidable
        jsx(
          Component3,
          _extends({
            style,
            ref,
            className: resolvedStyles.static
          }, safeHtmlAttributes, {
            css: [
              baseStyles,
              // eslint-disable-next-line @atlaskit/ui-styling-standard/no-imported-style-values -- Ignored via go/DSP-18766
              backgroundColor && backgroundColorStylesMap[backgroundColor],
              // eslint-disable-next-line @atlaskit/ui-styling-standard/no-imported-style-values -- Ignored via go/DSP-18766
              isSurfaceColorToken(backgroundColor) && surfaceColorStylesMap[backgroundColor],
              // eslint-disable-next-line @atlaskit/ui-styling-standard/no-imported-style-values -- Ignored via go/DSP-18766
              padding && paddingStylesMap.padding[padding],
              // eslint-disable-next-line @atlaskit/ui-styling-standard/no-imported-style-values -- Ignored via go/DSP-18766
              paddingBlock && paddingStylesMap.paddingBlock[paddingBlock],
              // eslint-disable-next-line @atlaskit/ui-styling-standard/no-imported-style-values -- Ignored via go/DSP-18766
              paddingBlockStart && paddingStylesMap.paddingBlockStart[paddingBlockStart],
              // eslint-disable-next-line @atlaskit/ui-styling-standard/no-imported-style-values -- Ignored via go/DSP-18766
              paddingBlockEnd && paddingStylesMap.paddingBlockEnd[paddingBlockEnd],
              // eslint-disable-next-line @atlaskit/ui-styling-standard/no-imported-style-values -- Ignored via go/DSP-18766
              paddingInline && paddingStylesMap.paddingInline[paddingInline],
              // eslint-disable-next-line @atlaskit/ui-styling-standard/no-imported-style-values -- Ignored via go/DSP-18766
              paddingInlineStart && paddingStylesMap.paddingInlineStart[paddingInlineStart],
              // eslint-disable-next-line @atlaskit/ui-styling-standard/no-imported-style-values -- Ignored via go/DSP-18766
              paddingInlineEnd && paddingStylesMap.paddingInlineEnd[paddingInlineEnd],
              resolvedStyles.emotion
            ],
            "data-testid": testId
          }),
          children
        )
      );
      return backgroundColor ? jsx(SurfaceContext.Provider, {
        value: backgroundColor
      }, node2) : node2;
    }
    // @ts-ignore This typescript error has been surpessed while locally enrolling `@atlaskit/primitives` into Jira
    // The return type of `BoxComponent` does not match the return type of `forwardRef` in React 18
  );
  var box_default2 = Box2;
  var baseStyles = css2({
    boxSizing: "border-box",
    appearance: "none",
    border: "none"
  });

  // node_modules/@atlaskit/primitives/dist/esm/components/flex.js
  var import_react98 = __toESM(require_react());
  var justifyContentMap2 = {
    start: css2({
      justifyContent: "start"
    }),
    center: css2({
      justifyContent: "center"
    }),
    end: css2({
      justifyContent: "end"
    }),
    "space-between": css2({
      justifyContent: "space-between"
    }),
    "space-around": css2({
      justifyContent: "space-around"
    }),
    "space-evenly": css2({
      justifyContent: "space-evenly"
    }),
    stretch: css2({
      justifyContent: "stretch"
    })
  };
  var flexDirectionMap2 = {
    column: css2({
      flexDirection: "column"
    }),
    row: css2({
      flexDirection: "row"
    })
  };
  var flexWrapMap2 = {
    wrap: css2({
      flexWrap: "wrap"
    }),
    nowrap: css2({
      flexWrap: "nowrap"
    })
  };
  var alignItemsMap2 = {
    start: css2({
      alignItems: "start"
    }),
    center: css2({
      alignItems: "center"
    }),
    baseline: css2({
      alignItems: "baseline"
    }),
    end: css2({
      alignItems: "end"
    }),
    stretch: css2({
      alignItems: "stretch"
    })
  };
  var baseStyles2 = css2({
    display: "flex",
    boxSizing: "border-box"
  });
  var Flex2 = /* @__PURE__ */ (0, import_react98.memo)(/* @__PURE__ */ (0, import_react98.forwardRef)(function(_ref2, ref) {
    var _ref$as = _ref2.as, Component3 = _ref$as === void 0 ? "div" : _ref$as, role = _ref2.role, alignItems = _ref2.alignItems, justifyContent = _ref2.justifyContent, gap = _ref2.gap, columnGap = _ref2.columnGap, rowGap = _ref2.rowGap, children = _ref2.children, testId = _ref2.testId, direction = _ref2.direction, wrap4 = _ref2.wrap, xcss2 = _ref2.xcss, id = _ref2.id;
    var resolvedStyles = _parseXcss(xcss2);
    return jsx(Component3, {
      id,
      role,
      className: resolvedStyles.static,
      css: [
        baseStyles2,
        // eslint-disable-next-line @atlaskit/ui-styling-standard/no-imported-style-values -- Ignored via go/DSP-18766
        gap && spaceStylesMap.gap[gap],
        // eslint-disable-next-line @atlaskit/ui-styling-standard/no-imported-style-values -- Ignored via go/DSP-18766
        columnGap && spaceStylesMap.columnGap[columnGap],
        // eslint-disable-next-line @atlaskit/ui-styling-standard/no-imported-style-values -- Ignored via go/DSP-18766
        rowGap && spaceStylesMap.rowGap[rowGap],
        alignItems && alignItemsMap2[alignItems],
        direction && flexDirectionMap2[direction],
        justifyContent && justifyContentMap2[justifyContent],
        wrap4 && flexWrapMap2[wrap4],
        resolvedStyles.emotion
      ],
      "data-testid": testId,
      ref
    }, children);
  }));
  Flex2.displayName = "Flex";
  var flex_default2 = Flex2;

  // node_modules/@atlaskit/primitives/dist/esm/components/grid.js
  init_defineProperty();
  var import_react100 = __toESM(require_react());
  var gridTemplateAreasVar = "--ds-grid--grid-template-areas";
  var gridTemplateColumnsVar = "--ds-grid--grid-template-columns";
  var gridTemplateRowsVar = "--ds-grid--grid-template-rows";
  var justifyContentMap3 = {
    start: css2({
      justifyContent: "start"
    }),
    center: css2({
      justifyContent: "center"
    }),
    end: css2({
      justifyContent: "end"
    }),
    "space-between": css2({
      justifyContent: "space-between"
    }),
    "space-around": css2({
      justifyContent: "space-around"
    }),
    "space-evenly": css2({
      justifyContent: "space-evenly"
    }),
    stretch: css2({
      justifyContent: "stretch"
    })
  };
  var justifyItemsMap = {
    start: css2({
      justifyItems: "start"
    }),
    center: css2({
      justifyItems: "center"
    }),
    end: css2({
      justifyItems: "end"
    }),
    stretch: css2({
      justifyItems: "stretch"
    })
  };
  var alignContentMap = {
    start: css2({
      alignContent: "start"
    }),
    center: css2({
      alignContent: "center"
    }),
    end: css2({
      alignContent: "end"
    }),
    "space-between": css2({
      alignContent: "space-between"
    }),
    "space-around": css2({
      alignContent: "space-around"
    }),
    "space-evenly": css2({
      alignContent: "space-evenly"
    }),
    stretch: css2({
      alignContent: "stretch"
    })
  };
  var alignItemsMap3 = {
    start: css2({
      alignItems: "start"
    }),
    center: css2({
      alignItems: "center"
    }),
    baseline: css2({
      alignItems: "baseline"
    }),
    end: css2({
      alignItems: "end"
    })
  };
  var baseStyles3 = css2({
    display: "grid",
    boxSizing: "border-box",
    gridTemplateAreas: "var(".concat(gridTemplateAreasVar, ")"),
    gridTemplateColumns: "var(".concat(gridTemplateColumnsVar, ")"),
    gridTemplateRows: "var(".concat(gridTemplateRowsVar, ")")
  });
  var gridAutoFlowMap = {
    row: css2({
      gridAutoFlow: "row"
    }),
    column: css2({
      gridAutoFlow: "column"
    }),
    dense: css2({
      gridAutoFlow: "dense"
    }),
    "row dense": css2({
      gridAutoFlow: "row dense"
    }),
    "column dense": css2({
      gridAutoFlow: "column dense"
    })
  };
  var Grid = /* @__PURE__ */ (0, import_react100.memo)(/* @__PURE__ */ (0, import_react100.forwardRef)(function(_ref2, ref) {
    var as = _ref2.as, alignItems = _ref2.alignItems, alignContent = _ref2.alignContent, justifyContent = _ref2.justifyContent, gap = _ref2.gap, columnGap = _ref2.columnGap, rowGap = _ref2.rowGap, children = _ref2.children, id = _ref2.id, role = _ref2.role, testId = _ref2.testId, autoFlow = _ref2.autoFlow, gridTemplateAreas = _ref2.templateAreas, gridTemplateRows = _ref2.templateRows, gridTemplateColumns = _ref2.templateColumns, xcss2 = _ref2.xcss;
    var Component3 = as || "div";
    var resolvedStyles = _parseXcss(xcss2);
    var style = (0, import_react100.useMemo)(function() {
      return _defineProperty(_defineProperty(_defineProperty({}, gridTemplateAreasVar, gridTemplateAreas ? gridTemplateAreas.map(function(str) {
        return '"'.concat(str, '"');
      }).join("\n") || "initial" : "initial"), gridTemplateColumnsVar, gridTemplateColumns || "initial"), gridTemplateRowsVar, gridTemplateRows || "initial");
    }, [gridTemplateAreas, gridTemplateColumns, gridTemplateRows]);
    return jsx(Component3, {
      id,
      role,
      style,
      className: resolvedStyles.static,
      css: [
        baseStyles3,
        // eslint-disable-next-line @atlaskit/ui-styling-standard/no-imported-style-values -- Ignored via go/DSP-18766
        gap && spaceStylesMap.gap[gap],
        // eslint-disable-next-line @atlaskit/ui-styling-standard/no-imported-style-values -- Ignored via go/DSP-18766
        columnGap && spaceStylesMap.columnGap[columnGap],
        // eslint-disable-next-line @atlaskit/ui-styling-standard/no-imported-style-values -- Ignored via go/DSP-18766
        rowGap && spaceStylesMap.rowGap[rowGap],
        alignItems && alignItemsMap3[alignItems],
        alignContent && alignContentMap[alignContent],
        justifyContent && justifyContentMap3[justifyContent],
        autoFlow && gridAutoFlowMap[autoFlow],
        resolvedStyles.emotion
      ],
      "data-testid": testId,
      ref
    }, children);
  }));
  Grid.displayName = "Grid";
  var grid_default = Grid;

  // node_modules/@atlaskit/modal-dialog/dist/esm/close-button.js
  var import_react102 = __toESM(require_react());
  var import_cross = __toESM(require_cross3());
  var CloseButton = function CloseButton2(_ref2) {
    var label = _ref2.label, onClick = _ref2.onClick, testId = _ref2.testId;
    return /* @__PURE__ */ import_react102.default.createElement(button_default2, {
      testId: testId && "".concat(testId, "--close-button"),
      appearance: "subtle",
      icon: import_cross.default,
      label: label || "Close Modal",
      onClick
    });
  };

  // node_modules/@atlaskit/modal-dialog/dist/esm/hooks.js
  var import_react103 = __toESM(require_react());
  var useModal = function useModal2() {
    var modalContext = (0, import_react103.useContext)(ModalContext);
    if (modalContext == null) {
      throw Error("@atlaskit/modal-dialog: Modal context unavailable \u2013 this component needs to be a child of ModalDialog.");
    }
    return modalContext;
  };

  // node_modules/@atlaskit/modal-dialog/dist/esm/modal-header.js
  var flexStyles = xcss({
    flexDirection: "row-reverse",
    width: "100%"
  });
  var ModalHeader = function ModalHeader2(props) {
    var children = props.children, userDefinedTestId = props.testId, _props$hasCloseButton = props.hasCloseButton, hasCloseButton = _props$hasCloseButton === void 0 ? false : _props$hasCloseButton;
    var _useModal = useModal(), hasProvidedOnClose = _useModal.hasProvidedOnClose, onClose = _useModal.onClose, modalTestId = _useModal.testId;
    var testId = userDefinedTestId || modalTestId && "".concat(modalTestId, "--header");
    var shouldShowCloseButton = hasCloseButton && hasProvidedOnClose && onClose;
    return /* @__PURE__ */ import_react104.default.createElement("div", {
      "data-testid": testId,
      className: ax(["_18zr1ejb _1e0c1txw _kqswh2mm _4cvr1h6o _1bah1yb4 _6rthmufe _85i5pxbi _1q511ejb"]),
      style: {
        "--_t7lu6v": cssCustomPropertyValue("calc(-1 * ".concat("var(--ds-border-width-outline, 2px)", ")"))
      }
    }, shouldShowCloseButton ? (
      // The reason we are putting the close button first in the DOM and then
      // reordering them is to ensure that users of assistive technology get
      // all the context of a modal when initial focus is placed on the close
      // button, since it's the first interactive element.
      /* @__PURE__ */ import_react104.default.createElement(flex_default2, {
        gap: "space.200",
        justifyContent: "space-between",
        xcss: flexStyles
      }, /* @__PURE__ */ import_react104.default.createElement(flex_default2, {
        justifyContent: "end"
      }, /* @__PURE__ */ import_react104.default.createElement(CloseButton, {
        onClick: onClose,
        testId: modalTestId
      })), /* @__PURE__ */ import_react104.default.createElement(flex_default2, {
        justifyContent: "start",
        alignItems: "center"
      }, children))
    ) : children);
  };
  var modal_header_default = ModalHeader;

  // node_modules/@atlaskit/modal-dialog/dist/esm/modal-title.js
  var React63 = __toESM(require_react());
  var import_status_error_error = __toESM(require_status_error_error());
  var import_status_warning_warning = __toESM(require_status_warning_warning());
  var iconColor = {
    danger: "var(--ds-icon-danger, #C9372C)",
    warning: "var(--ds-icon-warning, #E56910)"
  };
  var TitleIcon = function TitleIcon2(_ref2) {
    var appearance = _ref2.appearance;
    var Icon = appearance === "danger" ? import_status_error_error.default : import_status_warning_warning.default;
    return /* @__PURE__ */ React63.createElement("span", {
      className: ax(["_16jlidpf _1o9zidpf _i0dl1wug _syaz1kw7 _1wyb1kw7 _zg8l1kw7 _k48p1kw7 _1dyz1kw7 _vwz41kw7"])
    }, /* @__PURE__ */ React63.createElement(Icon, {
      label: appearance,
      color: iconColor[appearance],
      spacing: "spacious"
    }));
  };
  var ModalTitle = function ModalTitle2(props) {
    var appearance = props.appearance, children = props.children, _props$isMultiline = props.isMultiline, isMultiline = _props$isMultiline === void 0 ? true : _props$isMultiline, userDefinedTestId = props.testId;
    var _useModal = useModal(), titleId = _useModal.titleId, modalTestId = _useModal.testId;
    var testId = userDefinedTestId || modalTestId && "".concat(modalTestId, "--title");
    return /* @__PURE__ */ React63.createElement("h1", {
      "data-testid": testId,
      className: ax(["_zulpu2gc _11c8lodh _1e0c1txw _1ul9idpf _6rthze3t _1pfhze3t _12l2ze3t _ahbqze3t"])
    }, appearance && /* @__PURE__ */ React63.createElement(TitleIcon, {
      appearance
    }), /* @__PURE__ */ React63.createElement("span", {
      id: titleId,
      "data-testid": testId && "".concat(testId, "-text"),
      className: ax(["_16jlkb7n _1o9zkb7n _i0dl1wug _1ul9idpf _slp31hna", !isMultiline && "_1reo15vq _18m915vq _1bto1l2s _o5721q9c"])
    }, children));
  };
  var modal_title_default = ModalTitle;

  // node_modules/@atlaskit/modal-dialog/dist/esm/modal-body.js
  var import_react107 = __toESM(require_react());
  var import_react_scrolllock2 = __toESM(require_dist2());
  var import_platform_feature_flags13 = __toESM(require_cjs3());

  // node_modules/@atlaskit/modal-dialog/dist/esm/internal/components/scroll-container.js
  init_slicedToArray();
  var import_react105 = __toESM(require_react());
  var import_bind_event_listener16 = __toESM(require_dist());
  var styles9 = {
    base: "_16jlkb7n _1o9zkb7n _i0dl1kw7 _1e0c1kw7 _2lx21kw7 _6rthze3t _1pfhze3t _12l2ze3t _ahbqze3t _1reo15vq _18m91wug _1jykn7od _wzg61wug",
    topKeyline: "_mqm2v2xi",
    bottomKeyline: "_179rv2xi"
  };
  var keylineHeight = 2;
  var ScrollContainer = /* @__PURE__ */ (0, import_react105.forwardRef)(function(_ref2, ref) {
    var testId = _ref2.testId, children = _ref2.children;
    var scrollableRef = (0, import_react105.useRef)(null);
    var _useState = (0, import_react105.useState)(false), _useState2 = _slicedToArray(_useState, 2), showTopKeyline = _useState2[0], setTopKeyline = _useState2[1];
    var _useState3 = (0, import_react105.useState)(false), _useState4 = _slicedToArray(_useState3, 2), showBottomKeyline = _useState4[0], setBottomKeyline = _useState4[1];
    var _useState5 = (0, import_react105.useState)(false), _useState6 = _slicedToArray(_useState5, 2), showContentFocus = _useState6[0], setContentFocus = _useState6[1];
    (0, import_react105.useEffect)(function() {
      var schedule2 = raf_schd_esm_default(function() {
        var target = scrollableRef.current;
        target && setContentFocus(target.scrollHeight > target.clientHeight);
      });
      schedule2();
    }, [scrollableRef]);
    var setLazyKeylines = useLazyCallback(raf_schd_esm_default(function() {
      var target = scrollableRef.current;
      if (target) {
        var scrollableDistance = target.scrollHeight - target.clientHeight;
        if (target.previousElementSibling) {
          setTopKeyline(target.scrollTop > keylineHeight);
        }
        if (target.nextElementSibling) {
          setBottomKeyline(target.scrollTop <= scrollableDistance - keylineHeight);
        }
      }
    }));
    (0, import_react105.useEffect)(function() {
      var target = scrollableRef.current;
      setLazyKeylines();
      var unbindWindowEvent = (0, import_bind_event_listener16.bind)(window, {
        type: "resize",
        listener: setLazyKeylines
      });
      var unbindTargetEvent = target ? (0, import_bind_event_listener16.bind)(target, {
        type: "scroll",
        listener: setLazyKeylines
      }) : noop3;
      return function() {
        unbindWindowEvent();
        unbindTargetEvent();
      };
    }, [setLazyKeylines]);
    return /* @__PURE__ */ import_react105.default.createElement(focusable_default, {
      as: "div",
      isInset: true,
      tabIndex: showContentFocus ? 0 : void 0,
      role: showContentFocus ? "region" : void 0,
      "aria-label": showContentFocus ? "Scrollable content" : void 0,
      testId: testId && "".concat(testId, "--scrollable"),
      ref: mergeRefs([ref, scrollableRef]),
      xcss: cx2(styles9.base, showTopKeyline && styles9.topKeyline, showBottomKeyline && styles9.bottomKeyline)
    }, children);
  });
  ScrollContainer.displayName = "ScrollContainer";
  var scroll_container_default = ScrollContainer;

  // node_modules/@atlaskit/modal-dialog/dist/esm/internal/hooks/use-scroll.js
  var import_react106 = __toESM(require_react());
  function useScroll() {
    var shouldScrollInViewport = (0, import_react106.useContext)(ScrollContext);
    if (shouldScrollInViewport == null) {
      throw Error("@atlaskit/modal-dialog: Scroll context unavailable \u2013 this component needs to be a child of ModalDialog.");
    }
    return shouldScrollInViewport;
  }

  // node_modules/@atlaskit/modal-dialog/dist/esm/modal-body.js
  var styles10 = {
    root: "_16jlkb7n _1o9zkb7n _i0dl1wug",
    font: "_11c82smr",
    paddingBlock: "_1rjc1bk5",
    paddingInline: "_18zr1ejb"
  };
  var ModalBody = function ModalBody2(props) {
    var children = props.children, userDefinedTestId = props.testId, _props$hasInlinePaddi = props.hasInlinePadding, hasInlinePadding = _props$hasInlinePaddi === void 0 ? true : _props$hasInlinePaddi;
    var _useModal = useModal(), modalTestId = _useModal.testId;
    var shouldScrollInViewport = useScroll();
    var testId = userDefinedTestId || modalTestId && "".concat(modalTestId, "--body");
    return shouldScrollInViewport ? /* @__PURE__ */ import_react107.default.createElement("div", {
      "data-testid": testId,
      className: ax([styles10.root, hasInlinePadding && styles10.paddingInline, (0, import_platform_feature_flags13.fg)("platform_ads_explicit_font_styles") && styles10.font])
    }, children) : /* @__PURE__ */ import_react107.default.createElement(import_react_scrolllock2.TouchScrollable, null, /* @__PURE__ */ import_react107.default.createElement(scroll_container_default, {
      testId: userDefinedTestId || modalTestId
    }, /* @__PURE__ */ import_react107.default.createElement("div", {
      "data-testid": testId,
      className: ax([
        styles10.root,
        /**
         * Adding block padding for scroll keylines, which are only shown when the scrolling
         * is on the container.
         */
        styles10.paddingBlock,
        hasInlinePadding && styles10.paddingInline,
        (0, import_platform_feature_flags13.fg)("platform_ads_explicit_font_styles") && styles10.font
      ])
    }, children)));
  };
  var modal_body_default = ModalBody;

  // node_modules/@atlaskit/section-message/dist/esm/section-message.js
  init_slicedToArray();
  var React69 = __toESM(require_react());
  var import_react111 = __toESM(require_react());

  // node_modules/@atlaskit/heading/dist/esm/heading.partial.js
  init_slicedToArray();
  var React67 = __toESM(require_react());
  var import_react109 = __toESM(require_react());

  // node_modules/@atlaskit/heading/dist/esm/heading-context.js
  var import_react108 = __toESM(require_react());
  var HeadingLevelContext = /* @__PURE__ */ (0, import_react108.createContext)(0);
  var useHeadingLevel = function useHeadingLevel2() {
    return (0, import_react108.useContext)(HeadingLevelContext);
  };
  var useHeading = function useHeading2(fallback) {
    var hLevel = useHeadingLevel();
    return [hLevel, hLevel && (hLevel > 6 ? "div" : "h".concat(hLevel)) || fallback];
  };

  // node_modules/@atlaskit/heading/dist/esm/heading.partial.js
  var sizeTagMap = {
    xxlarge: "h1",
    xlarge: "h1",
    large: "h2",
    medium: "h3",
    small: "h4",
    xsmall: "h5",
    xxsmall: "h6"
  };
  var styles11 = {
    reset: "_1mouidpf _1dyz4jg8 _1p1dglyw"
  };
  var headingColorStylesMap = {
    "color.text": "_syaz1fxt",
    "color.text.inverse": "_syaz15cr",
    "color.text.warning.inverse": "_syazal3n"
  };
  var headingSizeStylesMap = {
    xxlarge: "_11c84xcc",
    xlarge: "_11c81c04",
    large: "_11c8nf1z",
    medium: "_11c8lodh",
    small: "_11c8nbxd",
    xsmall: "_11c8140y",
    xxsmall: "_11c81vhk"
  };
  var useColor3 = function useColor4(colorProp) {
    var surface = useSurface();
    if (colorProp) {
      return colorProp;
    }
    if (inverseColorMap2.hasOwnProperty(surface)) {
      return inverseColorMap2[surface];
    }
    return "color.text";
  };
  var Heading = /* @__PURE__ */ (0, import_react109.forwardRef)(function(props, ref) {
    var children = props.children, size2 = props.size, id = props.id, testId = props.testId, as = props.as, colorProp = props.color;
    if (typeof process !== "undefined" && false) {
      throw new Error("`as` prop should be a string.");
    }
    var _useHeading = useHeading(sizeTagMap[size2]), _useHeading2 = _slicedToArray(_useHeading, 2), hLevel = _useHeading2[0], inferredElement = _useHeading2[1];
    var Component3 = as || inferredElement;
    var needsAriaRole = Component3 === "div" && hLevel;
    var color = useColor3(colorProp);
    return /* @__PURE__ */ React67.createElement(Component3, {
      id,
      ref,
      "data-testid": testId,
      role: needsAriaRole ? "heading" : void 0,
      "aria-level": needsAriaRole ? hLevel : void 0,
      className: ax([styles11.reset, size2 && headingSizeStylesMap[size2], headingColorStylesMap[color]])
    }, children);
  });
  var heading_partial_default = Heading;

  // node_modules/@atlaskit/section-message/dist/esm/section-message.js
  var import_cross2 = __toESM(require_cross3());
  var import_platform_feature_flags15 = __toESM(require_cjs3());

  // node_modules/@atlaskit/section-message/dist/esm/internal/appearance-icon.js
  init_defineProperty();
  var import_react110 = __toESM(require_react());
  var import_discovery_editor_note = __toESM(require_discovery_editor_note());
  var import_question_circle = __toESM(require_question_circle3());
  var import_status_error_error2 = __toESM(require_status_error_error());
  var import_status_information_info = __toESM(require_status_information_info());
  var import_status_success_check_circle = __toESM(require_status_success_check_circle());
  var import_status_warning_warning2 = __toESM(require_status_warning_warning());
  var import_platform_feature_flags14 = __toESM(require_cjs3());
  function ownKeys14(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r && (o = o.filter(function(r2) {
        return Object.getOwnPropertyDescriptor(e, r2).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread14(e) {
    for (var r = 1; r < arguments.length; r++) {
      var t = null != arguments[r] ? arguments[r] : {};
      r % 2 ? ownKeys14(Object(t), true).forEach(function(r2) {
        _defineProperty(e, r2, t[r2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys14(Object(t)).forEach(function(r2) {
        Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
      });
    }
    return e;
  }
  var appearanceIconSchema = {
    information: {
      backgroundColor: "var(--ds-background-information, ".concat(B50, ")"),
      Icon: import_status_information_info.default,
      primaryIconColor: "var(--ds-icon-information, ".concat(B500, ")")
    },
    warning: {
      backgroundColor: "var(--ds-background-warning, ".concat(Y50, ")"),
      Icon: import_status_warning_warning2.default,
      primaryIconColor: "var(--ds-icon-warning, ".concat(Y500, ")")
    },
    error: {
      backgroundColor: "var(--ds-background-danger, ".concat(R50, ")"),
      Icon: import_status_error_error2.default,
      primaryIconColor: "var(--ds-icon-danger, ".concat(R500, ")")
    },
    success: {
      backgroundColor: "var(--ds-background-success, ".concat(G50, ")"),
      Icon: import_status_success_check_circle.default,
      primaryIconColor: "var(--ds-icon-success, ".concat(G500, ")")
    },
    discovery: {
      backgroundColor: "var(--ds-background-discovery, ".concat(P50, ")"),
      Icon: import_question_circle.default,
      primaryIconColor: "var(--ds-icon-discovery, ".concat(P500, ")")
    },
    discoveryUpdated: {
      backgroundColor: "var(--ds-background-discovery, ".concat(P50, ")"),
      Icon: import_discovery_editor_note.default,
      primaryIconColor: "var(--ds-icon-discovery, ".concat(P500, ")")
    }
  };
  function getAppearanceIconStyles(appearance, icon) {
    var appearanceIconStyles = appearanceIconSchema[appearance === "discovery" && (0, import_platform_feature_flags14.fg)("platform_dst_section_message_discovery_icon") ? "discoveryUpdated" : appearance] || appearanceIconSchema.information;
    var AppearanceIcon = function AppearanceIcon2(_ref2) {
      var size2 = _ref2.size, primaryColor = _ref2.primaryColor, secondaryColor = _ref2.secondaryColor;
      return /* @__PURE__ */ import_react110.default.createElement(appearanceIconStyles.Icon, {
        LEGACY_size: size2,
        color: primaryColor,
        spacing: "spacious",
        LEGACY_primaryColor: primaryColor,
        LEGACY_secondaryColor: secondaryColor,
        label: appearance
      });
    };
    var Icon = icon || AppearanceIcon;
    return _objectSpread14(_objectSpread14({}, appearanceIconStyles), {}, {
      Icon
    });
  }

  // node_modules/@atlaskit/section-message/dist/esm/section-message.js
  var sectionMessageStyles = {
    container: "_2rkoglpi _1rjcpxbi _18zrpxbi _1nmz1hna",
    iconContainer: "_1mou1i6y _1e0c1txw",
    contentContainer: "_16jlkb7n",
    content: "_11c82smr _syaz1fxt",
    actionsContainer: "_11c82smr",
    dismissButtonContainer: "_19pk1i6y"
  };
  var appearanceStyles = {
    information: "_bfhk33gi",
    warning: "_bfhk1tzq",
    error: "_bfhk1gly",
    success: "_bfhkmv6i",
    discovery: "_bfhk1nvp"
  };
  var SectionMessage = /* @__PURE__ */ (0, import_react111.forwardRef)(function SectionMessage2(_ref2, ref) {
    var children = _ref2.children, _ref$appearance = _ref2.appearance, appearance = _ref$appearance === void 0 ? "information" : _ref$appearance, actions = _ref2.actions, title = _ref2.title, icon = _ref2.icon, isDismissible = _ref2.isDismissible, testId = _ref2.testId;
    var _useState = (0, import_react111.useState)(false), _useState2 = _slicedToArray(_useState, 2), dismissed = _useState2[0], setDismissed = _useState2[1];
    var handleDismiss = (0, import_react111.useCallback)(function() {
      setDismissed(true);
    }, []);
    var _getAppearanceIconSty = getAppearanceIconStyles(appearance, icon), primaryColor = _getAppearanceIconSty.primaryIconColor, secondaryColor = _getAppearanceIconSty.backgroundColor, Icon = _getAppearanceIconSty.Icon;
    var actionElements = actions && actions.type === import_react111.Fragment ? actions.props.children : actions;
    var actionsArray = import_react111.Children.toArray(actionElements);
    return isDismissible && dismissed ? null : /* @__PURE__ */ React69.createElement("section", {
      "data-testid": testId,
      ref,
      className: ax([sectionMessageStyles.container, appearanceStyles[appearance]])
    }, /* @__PURE__ */ React69.createElement(inline_default, {
      space: "space.200",
      alignBlock: "stretch"
    }, /* @__PURE__ */ React69.createElement("div", {
      className: ax([sectionMessageStyles.iconContainer])
    }, /* @__PURE__ */ React69.createElement(Icon, {
      size: "medium",
      primaryColor,
      secondaryColor,
      LEGACY_size: "medium",
      color: primaryColor,
      spacing: "spacious"
    })), /* @__PURE__ */ React69.createElement(stack_default, {
      space: "space.100",
      testId: testId && "".concat(testId, "--content"),
      xcss: sectionMessageStyles.contentContainer
    }, !!title && /* @__PURE__ */ React69.createElement(heading_partial_default, {
      as: "h2",
      size: "small"
    }, title), /* @__PURE__ */ React69.createElement("div", {
      className: ax([sectionMessageStyles.content])
    }, children), actionsArray.length > 0 && /* @__PURE__ */ React69.createElement(inline_default, {
      shouldWrap: true,
      testId: testId && "".concat(testId, "--actions"),
      separator: "\xB7",
      space: "space.100",
      rowSpace: "space.0",
      role: actionsArray.length > 1 ? "list" : void 0,
      xcss: (0, import_platform_feature_flags15.fg)("platform_ads_explicit_font_styles") && sectionMessageStyles.actionsContainer
    }, actionsArray.map(function(action, id) {
      return (
        // Only use a listitem role if more than one action is present
        /* @__PURE__ */ React69.createElement(inline_default, {
          role: actionsArray.length > 1 ? "listitem" : void 0,
          key: id
        }, action)
      );
    }))), isDismissible && /* @__PURE__ */ React69.createElement("div", {
      className: ax([sectionMessageStyles.dismissButtonContainer])
    }, /* @__PURE__ */ React69.createElement(button_default2, {
      testId: testId && "".concat(testId, "--dismiss-button"),
      label: "Dismiss",
      icon: import_cross2.default,
      appearance: "subtle",
      onClick: handleDismiss,
      spacing: "compact"
    }))));
  });
  SectionMessage.displayName = "SectionMessage";
  var section_message_default = SectionMessage;

  // node_modules/@atlaskit/lozenge/dist/esm/lozenge.js
  var React70 = __toESM(require_react());
  var import_react112 = __toESM(require_react());
  var import_platform_feature_flags16 = __toESM(require_cjs3());
  var stylesOld = {
    container: "_2rkoglpi _1reo15vq _18m915vq _18zr1b66 _1e0c116y _1kz6184x _kqswpfqs _vchhusvi",
    "text.bold.default": "_syaz15cr",
    "text.bold.inprogress": "_syaz15cr",
    "text.bold.moved": "_syazal3n",
    "text.bold.new": "_syaz15cr",
    "text.bold.removed": "_syaz15cr",
    "text.bold.success": "_syaz15cr",
    "text.subtle.default": "_syazjjyb",
    "text.subtle.inprogress": "_syaz1lpn",
    "text.subtle.moved": "_syaz1tm6",
    "text.subtle.new": "_syaz1mvf",
    "text.subtle.removed": "_syaz1ick",
    "text.subtle.success": "_syaz17fi"
  };
  var stylesOldUnbounded = {
    text: "_1reo15vq _18m915vq _ect41gqc _1wyb1skh _zg8l4jg8 _k48pmoej _vwz47vkz _1bto1l2s _1p1dangw _o5721q9c",
    customLetterspacing: "_1dyz9vsi"
  };
  var backgroundColorsOld = {
    bold: {
      default: "color.background.neutral.bold",
      inprogress: "color.background.information.bold",
      moved: "color.background.warning.bold",
      new: "color.background.discovery.bold",
      removed: "color.background.danger.bold",
      success: "color.background.success.bold"
    },
    subtle: {
      default: "color.background.neutral",
      inprogress: "color.background.information",
      moved: "color.background.warning",
      new: "color.background.discovery",
      removed: "color.background.danger",
      success: "color.background.success"
    }
  };
  var stylesNew = {
    container: "_2rkosqtm _1reo15vq _18m915vq _1e0c116y _vchhusvi _kqswpfqs _1kz6184x _bozg1b66 _y4ti1b66",
    containerSubtle: "_1cwg1n1a",
    text: "_1reo15vq _18m915vq _ect41gqc _1wyb1skh _zg8l4jg8 _k48pmoej _vwz47vkz _1bto1l2s _1p1dangw _o5721q9c",
    customLetterspacing: "_1dyz9vsi",
    "bg.bold.default": "_bfhk1fkg",
    "bg.bold.inprogress": "_bfhk1ymo",
    "bg.bold.moved": "_bfhkxmjf",
    "bg.bold.new": "_bfhkshej",
    "bg.bold.removed": "_bfhk1366",
    "bg.bold.success": "_bfhk3uhp",
    "bg.subtle.default": "_bfhksm61",
    "bg.subtle.inprogress": "_bfhksm61",
    "bg.subtle.moved": "_bfhksm61",
    "bg.subtle.new": "_bfhksm61",
    "bg.subtle.removed": "_bfhksm61",
    "bg.subtle.success": "_bfhksm61",
    "border.subtle.default": "_19it14mp",
    "border.subtle.inprogress": "_19it1cy7",
    "border.subtle.moved": "_19itzi1n",
    "border.subtle.new": "_19it1apr",
    "border.subtle.removed": "_19itoa5t",
    "border.subtle.success": "_19it1am1",
    "outline.subtle.default": "_12ji14je _1qu2nqa1 _12y3t94y",
    "outline.subtle.inprogress": "_12jiuisw _1qu2nqa1 _12y3t94y",
    "outline.subtle.moved": "_12jih727 _1qu2nqa1 _12y3t94y",
    "outline.subtle.new": "_12ji157s _1qu2nqa1 _12y3t94y",
    "outline.subtle.removed": "_12jia2c0 _1qu2nqa1 _12y3t94y",
    "outline.subtle.success": "_12jin0nx _1qu2nqa1 _12y3t94y",
    "text.subtle": "_syaz1fxt",
    "text.bold": "_syazwwip"
  };
  var appearanceTypes = ["default", "inprogress", "moved", "new", "removed", "success"];
  var Lozenge = /* @__PURE__ */ (0, import_react112.memo)(function(_ref2) {
    var children = _ref2.children, testId = _ref2.testId, _ref$isBold = _ref2.isBold, isBold = _ref$isBold === void 0 ? false : _ref$isBold, _ref$appearance = _ref2.appearance, appearance = _ref$appearance === void 0 ? "default" : _ref$appearance, _ref$maxWidth = _ref2.maxWidth, maxWidth = _ref$maxWidth === void 0 ? 200 : _ref$maxWidth, style = _ref2.style;
    var appearanceStyle = isBold ? "bold" : "subtle";
    var appearanceType = (0, import_react112.useMemo)(function() {
      return appearanceTypes.includes(appearance) ? appearance : "default";
    }, [appearance]);
    var maxWidthValue = typeof maxWidth === "string" ? maxWidth : "".concat(maxWidth, "px");
    var maxWidthIsPc = typeof maxWidth === "string" && /%$/.test(maxWidth);
    if ((0, import_platform_feature_flags16.fg)("platform-component-visual-refresh")) {
      return /* @__PURE__ */ React70.createElement("span", {
        style: {
          backgroundColor: style === null || style === void 0 ? void 0 : style.backgroundColor,
          maxWidth: maxWidthIsPc ? maxWidth : "100%"
        },
        "data-testid": testId,
        className: ax([stylesNew.container, stylesNew["bg.".concat(appearanceStyle, ".").concat(appearanceType)], appearanceStyle === "subtle" && !(0, import_platform_feature_flags16.fg)("visual-refresh_drop_5") && stylesNew["border.subtle.".concat(appearanceType)], appearanceStyle === "subtle" && (0, import_platform_feature_flags16.fg)("visual-refresh_drop_5") && stylesNew["outline.subtle.".concat(appearanceType)], appearanceStyle === "subtle" && (0, import_platform_feature_flags16.fg)("visual-refresh_drop_5") && stylesNew.containerSubtle])
      }, /* @__PURE__ */ React70.createElement("span", {
        style: {
          color: style === null || style === void 0 ? void 0 : style.color,
          // to negate paddingInline specified on Box above
          maxWidth: maxWidthIsPc ? "100%" : "calc(".concat(maxWidthValue, " - ", "var(--ds-space-100, 8px)", ")")
        },
        "data-testid": testId && "".concat(testId, "--text"),
        className: ax([stylesNew.text, (0, import_platform_feature_flags16.fg)("platform-lozenge-custom-letterspacing") && stylesNew.customLetterspacing, stylesNew["text.".concat(appearanceStyle)]])
      }, children));
    }
    return /* @__PURE__ */ React70.createElement(box_default, {
      as: "span",
      backgroundColor: backgroundColorsOld[appearanceStyle][appearanceType],
      style: {
        backgroundColor: style === null || style === void 0 ? void 0 : style.backgroundColor,
        maxWidth: maxWidthIsPc ? maxWidth : "100%"
      },
      paddingInline: "space.050",
      xcss: stylesOld.container,
      testId
    }, /* @__PURE__ */ React70.createElement("span", {
      style: {
        color: style === null || style === void 0 ? void 0 : style.color,
        // to negate paddingInline specified on Box above
        maxWidth: maxWidthIsPc ? "100%" : "calc(".concat(maxWidthValue, " - ", "var(--ds-space-100, 8px)", ")")
      },
      "data-testid": testId && "".concat(testId, "--text"),
      className: ax([stylesOldUnbounded.text, (0, import_platform_feature_flags16.fg)("platform-lozenge-custom-letterspacing") && stylesOldUnbounded.customLetterspacing, stylesOld["text.".concat(appearanceStyle, ".").concat(appearanceType)]])
    }, children));
  });
  Lozenge.displayName = "Lozenge";
  var lozenge_default = Lozenge;

  // node_modules/chrono-node/dist/esm/results.js
  var import_quarterOfYear = __toESM(require_quarterOfYear(), 1);
  var import_dayjs2 = __toESM(require_dayjs_min(), 1);

  // node_modules/chrono-node/dist/esm/types.js
  var Meridiem;
  (function(Meridiem2) {
    Meridiem2[Meridiem2["AM"] = 0] = "AM";
    Meridiem2[Meridiem2["PM"] = 1] = "PM";
  })(Meridiem || (Meridiem = {}));
  var Weekday;
  (function(Weekday2) {
    Weekday2[Weekday2["SUNDAY"] = 0] = "SUNDAY";
    Weekday2[Weekday2["MONDAY"] = 1] = "MONDAY";
    Weekday2[Weekday2["TUESDAY"] = 2] = "TUESDAY";
    Weekday2[Weekday2["WEDNESDAY"] = 3] = "WEDNESDAY";
    Weekday2[Weekday2["THURSDAY"] = 4] = "THURSDAY";
    Weekday2[Weekday2["FRIDAY"] = 5] = "FRIDAY";
    Weekday2[Weekday2["SATURDAY"] = 6] = "SATURDAY";
  })(Weekday || (Weekday = {}));
  var Month;
  (function(Month2) {
    Month2[Month2["JANUARY"] = 1] = "JANUARY";
    Month2[Month2["FEBRUARY"] = 2] = "FEBRUARY";
    Month2[Month2["MARCH"] = 3] = "MARCH";
    Month2[Month2["APRIL"] = 4] = "APRIL";
    Month2[Month2["MAY"] = 5] = "MAY";
    Month2[Month2["JUNE"] = 6] = "JUNE";
    Month2[Month2["JULY"] = 7] = "JULY";
    Month2[Month2["AUGUST"] = 8] = "AUGUST";
    Month2[Month2["SEPTEMBER"] = 9] = "SEPTEMBER";
    Month2[Month2["OCTOBER"] = 10] = "OCTOBER";
    Month2[Month2["NOVEMBER"] = 11] = "NOVEMBER";
    Month2[Month2["DECEMBER"] = 12] = "DECEMBER";
  })(Month || (Month = {}));

  // node_modules/chrono-node/dist/esm/utils/dates.js
  function assignSimilarDate(component, target) {
    component.assign("day", target.getDate());
    component.assign("month", target.getMonth() + 1);
    component.assign("year", target.getFullYear());
  }
  function assignSimilarTime(component, target) {
    component.assign("hour", target.getHours());
    component.assign("minute", target.getMinutes());
    component.assign("second", target.getSeconds());
    component.assign("millisecond", target.getMilliseconds());
    component.assign("meridiem", target.getHours() < 12 ? Meridiem.AM : Meridiem.PM);
  }
  function implySimilarDate(component, target) {
    component.imply("day", target.getDate());
    component.imply("month", target.getMonth() + 1);
    component.imply("year", target.getFullYear());
  }
  function implySimilarTime(component, target) {
    component.imply("hour", target.getHours());
    component.imply("minute", target.getMinutes());
    component.imply("second", target.getSeconds());
    component.imply("millisecond", target.getMilliseconds());
    component.imply("meridiem", target.getHours() < 12 ? Meridiem.AM : Meridiem.PM);
  }

  // node_modules/chrono-node/dist/esm/timezone.js
  var import_dayjs = __toESM(require_dayjs_min(), 1);
  var TIMEZONE_ABBR_MAP = {
    ACDT: 630,
    ACST: 570,
    ADT: -180,
    AEDT: 660,
    AEST: 600,
    AFT: 270,
    AKDT: -480,
    AKST: -540,
    ALMT: 360,
    AMST: -180,
    AMT: -240,
    ANAST: 720,
    ANAT: 720,
    AQTT: 300,
    ART: -180,
    AST: -240,
    AWDT: 540,
    AWST: 480,
    AZOST: 0,
    AZOT: -60,
    AZST: 300,
    AZT: 240,
    BNT: 480,
    BOT: -240,
    BRST: -120,
    BRT: -180,
    BST: 60,
    BTT: 360,
    CAST: 480,
    CAT: 120,
    CCT: 390,
    CDT: -300,
    CEST: 120,
    CET: {
      timezoneOffsetDuringDst: 2 * 60,
      timezoneOffsetNonDst: 60,
      dstStart: (year) => getLastWeekdayOfMonth(year, Month.MARCH, Weekday.SUNDAY, 2),
      dstEnd: (year) => getLastWeekdayOfMonth(year, Month.OCTOBER, Weekday.SUNDAY, 3)
    },
    CHADT: 825,
    CHAST: 765,
    CKT: -600,
    CLST: -180,
    CLT: -240,
    COT: -300,
    CST: -360,
    CT: {
      timezoneOffsetDuringDst: -5 * 60,
      timezoneOffsetNonDst: -6 * 60,
      dstStart: (year) => getNthWeekdayOfMonth(year, Month.MARCH, Weekday.SUNDAY, 2, 2),
      dstEnd: (year) => getNthWeekdayOfMonth(year, Month.NOVEMBER, Weekday.SUNDAY, 1, 2)
    },
    CVT: -60,
    CXT: 420,
    ChST: 600,
    DAVT: 420,
    EASST: -300,
    EAST: -360,
    EAT: 180,
    ECT: -300,
    EDT: -240,
    EEST: 180,
    EET: 120,
    EGST: 0,
    EGT: -60,
    EST: -300,
    ET: {
      timezoneOffsetDuringDst: -4 * 60,
      timezoneOffsetNonDst: -5 * 60,
      dstStart: (year) => getNthWeekdayOfMonth(year, Month.MARCH, Weekday.SUNDAY, 2, 2),
      dstEnd: (year) => getNthWeekdayOfMonth(year, Month.NOVEMBER, Weekday.SUNDAY, 1, 2)
    },
    FJST: 780,
    FJT: 720,
    FKST: -180,
    FKT: -240,
    FNT: -120,
    GALT: -360,
    GAMT: -540,
    GET: 240,
    GFT: -180,
    GILT: 720,
    GMT: 0,
    GST: 240,
    GYT: -240,
    HAA: -180,
    HAC: -300,
    HADT: -540,
    HAE: -240,
    HAP: -420,
    HAR: -360,
    HAST: -600,
    HAT: -90,
    HAY: -480,
    HKT: 480,
    HLV: -210,
    HNA: -240,
    HNC: -360,
    HNE: -300,
    HNP: -480,
    HNR: -420,
    HNT: -150,
    HNY: -540,
    HOVT: 420,
    ICT: 420,
    IDT: 180,
    IOT: 360,
    IRDT: 270,
    IRKST: 540,
    IRKT: 540,
    IRST: 210,
    IST: 330,
    JST: 540,
    KGT: 360,
    KRAST: 480,
    KRAT: 480,
    KST: 540,
    KUYT: 240,
    LHDT: 660,
    LHST: 630,
    LINT: 840,
    MAGST: 720,
    MAGT: 720,
    MART: -510,
    MAWT: 300,
    MDT: -360,
    MESZ: 120,
    MEZ: 60,
    MHT: 720,
    MMT: 390,
    MSD: 240,
    MSK: 180,
    MST: -420,
    MT: {
      timezoneOffsetDuringDst: -6 * 60,
      timezoneOffsetNonDst: -7 * 60,
      dstStart: (year) => getNthWeekdayOfMonth(year, Month.MARCH, Weekday.SUNDAY, 2, 2),
      dstEnd: (year) => getNthWeekdayOfMonth(year, Month.NOVEMBER, Weekday.SUNDAY, 1, 2)
    },
    MUT: 240,
    MVT: 300,
    MYT: 480,
    NCT: 660,
    NDT: -90,
    NFT: 690,
    NOVST: 420,
    NOVT: 360,
    NPT: 345,
    NST: -150,
    NUT: -660,
    NZDT: 780,
    NZST: 720,
    OMSST: 420,
    OMST: 420,
    PDT: -420,
    PET: -300,
    PETST: 720,
    PETT: 720,
    PGT: 600,
    PHOT: 780,
    PHT: 480,
    PKT: 300,
    PMDT: -120,
    PMST: -180,
    PONT: 660,
    PST: -480,
    PT: {
      timezoneOffsetDuringDst: -7 * 60,
      timezoneOffsetNonDst: -8 * 60,
      dstStart: (year) => getNthWeekdayOfMonth(year, Month.MARCH, Weekday.SUNDAY, 2, 2),
      dstEnd: (year) => getNthWeekdayOfMonth(year, Month.NOVEMBER, Weekday.SUNDAY, 1, 2)
    },
    PWT: 540,
    PYST: -180,
    PYT: -240,
    RET: 240,
    SAMT: 240,
    SAST: 120,
    SBT: 660,
    SCT: 240,
    SGT: 480,
    SRT: -180,
    SST: -660,
    TAHT: -600,
    TFT: 300,
    TJT: 300,
    TKT: 780,
    TLT: 540,
    TMT: 300,
    TVT: 720,
    ULAT: 480,
    UTC: 0,
    UYST: -120,
    UYT: -180,
    UZT: 300,
    VET: -210,
    VLAST: 660,
    VLAT: 660,
    VUT: 660,
    WAST: 120,
    WAT: 60,
    WEST: 60,
    WESZ: 60,
    WET: 0,
    WEZ: 0,
    WFT: 720,
    WGST: -120,
    WGT: -180,
    WIB: 420,
    WIT: 540,
    WITA: 480,
    WST: 780,
    WT: 0,
    YAKST: 600,
    YAKT: 600,
    YAPT: 600,
    YEKST: 360,
    YEKT: 360
  };
  function getNthWeekdayOfMonth(year, month, weekday, n, hour = 0) {
    let dayOfMonth = 0;
    let i = 0;
    while (i < n) {
      dayOfMonth++;
      const date = new Date(year, month - 1, dayOfMonth);
      if (date.getDay() === weekday)
        i++;
    }
    return new Date(year, month - 1, dayOfMonth, hour);
  }
  function getLastWeekdayOfMonth(year, month, weekday, hour = 0) {
    const oneIndexedWeekday = weekday === 0 ? 7 : weekday;
    const date = new Date(year, month - 1 + 1, 1, 12);
    const firstWeekdayNextMonth = date.getDay() === 0 ? 7 : date.getDay();
    let dayDiff;
    if (firstWeekdayNextMonth === oneIndexedWeekday)
      dayDiff = 7;
    else if (firstWeekdayNextMonth < oneIndexedWeekday)
      dayDiff = 7 + firstWeekdayNextMonth - oneIndexedWeekday;
    else
      dayDiff = firstWeekdayNextMonth - oneIndexedWeekday;
    date.setDate(date.getDate() - dayDiff);
    return new Date(year, month - 1, date.getDate(), hour);
  }
  function toTimezoneOffset(timezoneInput, date, timezoneOverrides = {}) {
    if (timezoneInput == null) {
      return null;
    }
    if (typeof timezoneInput === "number") {
      return timezoneInput;
    }
    const matchedTimezone = timezoneOverrides[timezoneInput] ?? TIMEZONE_ABBR_MAP[timezoneInput];
    if (matchedTimezone == null) {
      return null;
    }
    if (typeof matchedTimezone == "number") {
      return matchedTimezone;
    }
    if (date == null) {
      return null;
    }
    if ((0, import_dayjs.default)(date).isAfter(matchedTimezone.dstStart(date.getFullYear())) && !(0, import_dayjs.default)(date).isAfter(matchedTimezone.dstEnd(date.getFullYear()))) {
      return matchedTimezone.timezoneOffsetDuringDst;
    }
    return matchedTimezone.timezoneOffsetNonDst;
  }

  // node_modules/chrono-node/dist/esm/calculation/duration.js
  function addDuration(ref, duration) {
    let date = new Date(ref);
    if (duration["y"]) {
      duration["year"] = duration["y"];
      delete duration["y"];
    }
    if (duration["mo"]) {
      duration["month"] = duration["mo"];
      delete duration["mo"];
    }
    if (duration["M"]) {
      duration["month"] = duration["M"];
      delete duration["M"];
    }
    if (duration["w"]) {
      duration["week"] = duration["w"];
      delete duration["w"];
    }
    if (duration["d"]) {
      duration["day"] = duration["d"];
      delete duration["d"];
    }
    if (duration["h"]) {
      duration["hour"] = duration["h"];
      delete duration["h"];
    }
    if (duration["m"]) {
      duration["minute"] = duration["m"];
      delete duration["m"];
    }
    if (duration["s"]) {
      duration["second"] = duration["s"];
      delete duration["s"];
    }
    if (duration["ms"]) {
      duration["millisecond"] = duration["ms"];
      delete duration["ms"];
    }
    if ("year" in duration) {
      const floor2 = Math.floor(duration["year"]);
      date.setFullYear(date.getFullYear() + floor2);
      const remainingFraction = duration["year"] - floor2;
      if (remainingFraction > 0) {
        duration.month = duration?.month ?? 0;
        duration.month += remainingFraction * 12;
      }
    }
    if ("quarter" in duration) {
      const floor2 = Math.floor(duration["quarter"]);
      date.setMonth(date.getMonth() + floor2 * 3);
    }
    if ("month" in duration) {
      const floor2 = Math.floor(duration["month"]);
      date.setMonth(date.getMonth() + floor2);
      const remainingFraction = duration["month"] - floor2;
      if (remainingFraction > 0) {
        duration.week = duration?.week ?? 0;
        duration.week += remainingFraction * 4;
      }
    }
    if ("week" in duration) {
      const floor2 = Math.floor(duration["week"]);
      date.setDate(date.getDate() + floor2 * 7);
      const remainingFraction = duration["week"] - floor2;
      if (remainingFraction > 0) {
        duration.day = duration?.day ?? 0;
        duration.day += Math.round(remainingFraction * 7);
      }
    }
    if ("day" in duration) {
      const floor2 = Math.floor(duration["day"]);
      date.setDate(date.getDate() + floor2);
      const remainingFraction = duration["day"] - floor2;
      if (remainingFraction > 0) {
        duration.hour = duration?.hour ?? 0;
        duration.hour += Math.round(remainingFraction * 24);
      }
    }
    if ("hour" in duration) {
      const floor2 = Math.floor(duration["hour"]);
      date.setHours(date.getHours() + floor2);
      const remainingFraction = duration["hour"] - floor2;
      if (remainingFraction > 0) {
        duration.minute = duration?.minute ?? 0;
        duration.minute += Math.round(remainingFraction * 60);
      }
    }
    if ("minute" in duration) {
      const floor2 = Math.floor(duration["minute"]);
      date.setMinutes(date.getMinutes() + floor2);
      const remainingFraction = duration["minute"] - floor2;
      if (remainingFraction > 0) {
        duration.second = duration?.second ?? 0;
        duration.second += Math.round(remainingFraction * 60);
      }
    }
    if ("second" in duration) {
      const floor2 = Math.floor(duration["second"]);
      date.setSeconds(date.getSeconds() + floor2);
      const remainingFraction = duration["second"] - floor2;
      if (remainingFraction > 0) {
        duration.millisecond = duration?.millisecond ?? 0;
        duration.millisecond += Math.round(remainingFraction * 1e3);
      }
    }
    if ("millisecond" in duration) {
      const floor2 = Math.floor(duration["millisecond"]);
      date.setMilliseconds(date.getMilliseconds() + floor2);
    }
    return date;
  }
  function reverseDuration(duration) {
    const reversed = {};
    for (const key in duration) {
      reversed[key] = -duration[key];
    }
    return reversed;
  }

  // node_modules/chrono-node/dist/esm/results.js
  import_dayjs2.default.extend(import_quarterOfYear.default);
  var ReferenceWithTimezone = class _ReferenceWithTimezone {
    instant;
    timezoneOffset;
    constructor(instant, timezoneOffset) {
      this.instant = instant ?? /* @__PURE__ */ new Date();
      this.timezoneOffset = timezoneOffset ?? null;
    }
    static fromDate(date) {
      return new _ReferenceWithTimezone(date);
    }
    static fromInput(input, timezoneOverrides) {
      if (input instanceof Date) {
        return _ReferenceWithTimezone.fromDate(input);
      }
      const instant = input?.instant ?? /* @__PURE__ */ new Date();
      const timezoneOffset = toTimezoneOffset(input?.timezone, instant, timezoneOverrides);
      return new _ReferenceWithTimezone(instant, timezoneOffset);
    }
    getDateWithAdjustedTimezone() {
      const date = new Date(this.instant);
      if (this.timezoneOffset !== null) {
        date.setMinutes(date.getMinutes() - this.getSystemTimezoneAdjustmentMinute(this.instant));
      }
      return date;
    }
    getSystemTimezoneAdjustmentMinute(date, overrideTimezoneOffset) {
      if (!date || date.getTime() < 0) {
        date = /* @__PURE__ */ new Date();
      }
      const currentTimezoneOffset = -date.getTimezoneOffset();
      const targetTimezoneOffset = overrideTimezoneOffset ?? this.timezoneOffset ?? currentTimezoneOffset;
      return currentTimezoneOffset - targetTimezoneOffset;
    }
    getTimezoneOffset() {
      return this.timezoneOffset ?? -this.instant.getTimezoneOffset();
    }
  };
  var ParsingComponents = class _ParsingComponents {
    knownValues;
    impliedValues;
    reference;
    _tags = /* @__PURE__ */ new Set();
    constructor(reference2, knownComponents) {
      this.reference = reference2;
      this.knownValues = {};
      this.impliedValues = {};
      if (knownComponents) {
        for (const key in knownComponents) {
          this.knownValues[key] = knownComponents[key];
        }
      }
      const refDayJs = reference2.getDateWithAdjustedTimezone();
      this.imply("day", refDayJs.getDate());
      this.imply("month", refDayJs.getMonth() + 1);
      this.imply("year", refDayJs.getFullYear());
      this.imply("hour", 12);
      this.imply("minute", 0);
      this.imply("second", 0);
      this.imply("millisecond", 0);
    }
    get(component) {
      if (component in this.knownValues) {
        return this.knownValues[component];
      }
      if (component in this.impliedValues) {
        return this.impliedValues[component];
      }
      return null;
    }
    isCertain(component) {
      return component in this.knownValues;
    }
    getCertainComponents() {
      return Object.keys(this.knownValues);
    }
    imply(component, value) {
      if (component in this.knownValues) {
        return this;
      }
      this.impliedValues[component] = value;
      return this;
    }
    assign(component, value) {
      this.knownValues[component] = value;
      delete this.impliedValues[component];
      return this;
    }
    delete(component) {
      delete this.knownValues[component];
      delete this.impliedValues[component];
    }
    clone() {
      const component = new _ParsingComponents(this.reference);
      component.knownValues = {};
      component.impliedValues = {};
      for (const key in this.knownValues) {
        component.knownValues[key] = this.knownValues[key];
      }
      for (const key in this.impliedValues) {
        component.impliedValues[key] = this.impliedValues[key];
      }
      return component;
    }
    isOnlyDate() {
      return !this.isCertain("hour") && !this.isCertain("minute") && !this.isCertain("second");
    }
    isOnlyTime() {
      return !this.isCertain("weekday") && !this.isCertain("day") && !this.isCertain("month") && !this.isCertain("year");
    }
    isOnlyWeekdayComponent() {
      return this.isCertain("weekday") && !this.isCertain("day") && !this.isCertain("month");
    }
    isDateWithUnknownYear() {
      return this.isCertain("month") && !this.isCertain("year");
    }
    isValidDate() {
      const date = this.dateWithoutTimezoneAdjustment();
      if (date.getFullYear() !== this.get("year"))
        return false;
      if (date.getMonth() !== this.get("month") - 1)
        return false;
      if (date.getDate() !== this.get("day"))
        return false;
      if (this.get("hour") != null && date.getHours() != this.get("hour"))
        return false;
      if (this.get("minute") != null && date.getMinutes() != this.get("minute"))
        return false;
      return true;
    }
    toString() {
      return `[ParsingComponents {
            tags: ${JSON.stringify(Array.from(this._tags).sort())}, 
            knownValues: ${JSON.stringify(this.knownValues)}, 
            impliedValues: ${JSON.stringify(this.impliedValues)}}, 
            reference: ${JSON.stringify(this.reference)}]`;
    }
    dayjs() {
      return (0, import_dayjs2.default)(this.dateWithoutTimezoneAdjustment());
    }
    date() {
      const date = this.dateWithoutTimezoneAdjustment();
      const timezoneAdjustment = this.reference.getSystemTimezoneAdjustmentMinute(date, this.get("timezoneOffset"));
      return new Date(date.getTime() + timezoneAdjustment * 6e4);
    }
    addTag(tag) {
      this._tags.add(tag);
      return this;
    }
    addTags(tags) {
      for (const tag of tags) {
        this._tags.add(tag);
      }
      return this;
    }
    tags() {
      return new Set(this._tags);
    }
    dateWithoutTimezoneAdjustment() {
      const date = new Date(this.get("year"), this.get("month") - 1, this.get("day"), this.get("hour"), this.get("minute"), this.get("second"), this.get("millisecond"));
      date.setFullYear(this.get("year"));
      return date;
    }
    static createRelativeFromReference(reference2, duration) {
      let date = addDuration(reference2.getDateWithAdjustedTimezone(), duration);
      const components2 = new _ParsingComponents(reference2);
      components2.addTag("result/relativeDate");
      if (duration["hour"] || duration["minute"] || duration["second"]) {
        components2.addTag("result/relativeDateAndTime");
        assignSimilarTime(components2, date);
        assignSimilarDate(components2, date);
        components2.assign("timezoneOffset", reference2.getTimezoneOffset());
      } else {
        implySimilarTime(components2, date);
        components2.imply("timezoneOffset", reference2.getTimezoneOffset());
        if (duration["day"]) {
          components2.assign("day", date.getDate());
          components2.assign("month", date.getMonth() + 1);
          components2.assign("year", date.getFullYear());
          components2.assign("weekday", date.getDay());
        } else if (duration["week"]) {
          components2.assign("day", date.getDate());
          components2.assign("month", date.getMonth() + 1);
          components2.assign("year", date.getFullYear());
          components2.imply("weekday", date.getDay());
        } else {
          components2.imply("day", date.getDate());
          if (duration["month"]) {
            components2.assign("month", date.getMonth() + 1);
            components2.assign("year", date.getFullYear());
          } else {
            components2.imply("month", date.getMonth() + 1);
            if (duration["year"]) {
              components2.assign("year", date.getFullYear());
            } else {
              components2.imply("year", date.getFullYear());
            }
          }
        }
      }
      return components2;
    }
  };
  var ParsingResult = class _ParsingResult {
    refDate;
    index;
    text;
    reference;
    start;
    end;
    constructor(reference2, index2, text, start3, end2) {
      this.reference = reference2;
      this.refDate = reference2.instant;
      this.index = index2;
      this.text = text;
      this.start = start3 || new ParsingComponents(reference2);
      this.end = end2;
    }
    clone() {
      const result2 = new _ParsingResult(this.reference, this.index, this.text);
      result2.start = this.start ? this.start.clone() : null;
      result2.end = this.end ? this.end.clone() : null;
      return result2;
    }
    date() {
      return this.start.date();
    }
    addTag(tag) {
      this.start.addTag(tag);
      if (this.end) {
        this.end.addTag(tag);
      }
      return this;
    }
    addTags(tags) {
      this.start.addTags(tags);
      if (this.end) {
        this.end.addTags(tags);
      }
      return this;
    }
    tags() {
      const combinedTags = new Set(this.start.tags());
      if (this.end) {
        for (const tag of this.end.tags()) {
          combinedTags.add(tag);
        }
      }
      return combinedTags;
    }
    toString() {
      const tags = Array.from(this.tags()).sort();
      return `[ParsingResult {index: ${this.index}, text: '${this.text}', tags: ${JSON.stringify(tags)} ...}]`;
    }
  };

  // node_modules/chrono-node/dist/esm/utils/pattern.js
  function repeatedTimeunitPattern(prefix3, singleTimeunitPattern, connectorPattern = "\\s{0,5},?\\s{0,5}") {
    const singleTimeunitPatternNoCapture = singleTimeunitPattern.replace(/\((?!\?)/g, "(?:");
    return `${prefix3}${singleTimeunitPatternNoCapture}(?:${connectorPattern}${singleTimeunitPatternNoCapture}){0,10}`;
  }
  function extractTerms(dictionary) {
    let keys;
    if (dictionary instanceof Array) {
      keys = [...dictionary];
    } else if (dictionary instanceof Map) {
      keys = Array.from(dictionary.keys());
    } else {
      keys = Object.keys(dictionary);
    }
    return keys;
  }
  function matchAnyPattern(dictionary) {
    const joinedTerms = extractTerms(dictionary).sort((a, b) => b.length - a.length).join("|").replace(/\./g, "\\.");
    return `(?:${joinedTerms})`;
  }

  // node_modules/chrono-node/dist/esm/calculation/years.js
  var import_dayjs3 = __toESM(require_dayjs_min(), 1);
  function findMostLikelyADYear(yearNumber) {
    if (yearNumber < 100) {
      if (yearNumber > 50) {
        yearNumber = yearNumber + 1900;
      } else {
        yearNumber = yearNumber + 2e3;
      }
    }
    return yearNumber;
  }
  function findYearClosestToRef(refDate, day, month) {
    const refMoment = (0, import_dayjs3.default)(refDate);
    let dateMoment = refMoment;
    dateMoment = dateMoment.month(month - 1);
    dateMoment = dateMoment.date(day);
    dateMoment = dateMoment.year(refMoment.year());
    const nextYear = dateMoment.add(1, "y");
    const lastYear = dateMoment.add(-1, "y");
    if (Math.abs(nextYear.diff(refMoment)) < Math.abs(dateMoment.diff(refMoment))) {
      dateMoment = nextYear;
    } else if (Math.abs(lastYear.diff(refMoment)) < Math.abs(dateMoment.diff(refMoment))) {
      dateMoment = lastYear;
    }
    return dateMoment.year();
  }

  // node_modules/chrono-node/dist/esm/locales/en/constants.js
  var WEEKDAY_DICTIONARY = {
    sunday: 0,
    sun: 0,
    "sun.": 0,
    monday: 1,
    mon: 1,
    "mon.": 1,
    tuesday: 2,
    tue: 2,
    "tue.": 2,
    wednesday: 3,
    wed: 3,
    "wed.": 3,
    thursday: 4,
    thurs: 4,
    "thurs.": 4,
    thur: 4,
    "thur.": 4,
    thu: 4,
    "thu.": 4,
    friday: 5,
    fri: 5,
    "fri.": 5,
    saturday: 6,
    sat: 6,
    "sat.": 6
  };
  var FULL_MONTH_NAME_DICTIONARY = {
    january: 1,
    february: 2,
    march: 3,
    april: 4,
    may: 5,
    june: 6,
    july: 7,
    august: 8,
    september: 9,
    october: 10,
    november: 11,
    december: 12
  };
  var MONTH_DICTIONARY = {
    ...FULL_MONTH_NAME_DICTIONARY,
    jan: 1,
    "jan.": 1,
    feb: 2,
    "feb.": 2,
    mar: 3,
    "mar.": 3,
    apr: 4,
    "apr.": 4,
    jun: 6,
    "jun.": 6,
    jul: 7,
    "jul.": 7,
    aug: 8,
    "aug.": 8,
    sep: 9,
    "sep.": 9,
    sept: 9,
    "sept.": 9,
    oct: 10,
    "oct.": 10,
    nov: 11,
    "nov.": 11,
    dec: 12,
    "dec.": 12
  };
  var INTEGER_WORD_DICTIONARY = {
    one: 1,
    two: 2,
    three: 3,
    four: 4,
    five: 5,
    six: 6,
    seven: 7,
    eight: 8,
    nine: 9,
    ten: 10,
    eleven: 11,
    twelve: 12
  };
  var ORDINAL_WORD_DICTIONARY = {
    first: 1,
    second: 2,
    third: 3,
    fourth: 4,
    fifth: 5,
    sixth: 6,
    seventh: 7,
    eighth: 8,
    ninth: 9,
    tenth: 10,
    eleventh: 11,
    twelfth: 12,
    thirteenth: 13,
    fourteenth: 14,
    fifteenth: 15,
    sixteenth: 16,
    seventeenth: 17,
    eighteenth: 18,
    nineteenth: 19,
    twentieth: 20,
    "twenty first": 21,
    "twenty-first": 21,
    "twenty second": 22,
    "twenty-second": 22,
    "twenty third": 23,
    "twenty-third": 23,
    "twenty fourth": 24,
    "twenty-fourth": 24,
    "twenty fifth": 25,
    "twenty-fifth": 25,
    "twenty sixth": 26,
    "twenty-sixth": 26,
    "twenty seventh": 27,
    "twenty-seventh": 27,
    "twenty eighth": 28,
    "twenty-eighth": 28,
    "twenty ninth": 29,
    "twenty-ninth": 29,
    "thirtieth": 30,
    "thirty first": 31,
    "thirty-first": 31
  };
  var TIME_UNIT_DICTIONARY_NO_ABBR = {
    second: "second",
    seconds: "second",
    minute: "minute",
    minutes: "minute",
    hour: "hour",
    hours: "hour",
    day: "d",
    days: "d",
    week: "week",
    weeks: "week",
    month: "month",
    months: "month",
    quarter: "quarter",
    quarters: "quarter",
    year: "year",
    years: "year"
  };
  var TIME_UNIT_DICTIONARY = {
    s: "second",
    sec: "second",
    second: "second",
    seconds: "second",
    m: "minute",
    min: "minute",
    mins: "minute",
    minute: "minute",
    minutes: "minute",
    h: "hour",
    hr: "hour",
    hrs: "hour",
    hour: "hour",
    hours: "hour",
    d: "d",
    day: "d",
    days: "d",
    w: "w",
    week: "week",
    weeks: "week",
    mo: "month",
    mon: "month",
    mos: "month",
    month: "month",
    months: "month",
    qtr: "quarter",
    quarter: "quarter",
    quarters: "quarter",
    y: "year",
    yr: "year",
    year: "year",
    years: "year",
    ...TIME_UNIT_DICTIONARY_NO_ABBR
  };
  var NUMBER_PATTERN = `(?:${matchAnyPattern(INTEGER_WORD_DICTIONARY)}|[0-9]+|[0-9]+\\.[0-9]+|half(?:\\s{0,2}an?)?|an?\\b(?:\\s{0,2}few)?|few|several|the|a?\\s{0,2}couple\\s{0,2}(?:of)?)`;
  function parseNumberPattern(match3) {
    const num = match3.toLowerCase();
    if (INTEGER_WORD_DICTIONARY[num] !== void 0) {
      return INTEGER_WORD_DICTIONARY[num];
    } else if (num === "a" || num === "an" || num == "the") {
      return 1;
    } else if (num.match(/few/)) {
      return 3;
    } else if (num.match(/half/)) {
      return 0.5;
    } else if (num.match(/couple/)) {
      return 2;
    } else if (num.match(/several/)) {
      return 7;
    }
    return parseFloat(num);
  }
  var ORDINAL_NUMBER_PATTERN = `(?:${matchAnyPattern(ORDINAL_WORD_DICTIONARY)}|[0-9]{1,2}(?:st|nd|rd|th)?)`;
  function parseOrdinalNumberPattern(match3) {
    let num = match3.toLowerCase();
    if (ORDINAL_WORD_DICTIONARY[num] !== void 0) {
      return ORDINAL_WORD_DICTIONARY[num];
    }
    num = num.replace(/(?:st|nd|rd|th)$/i, "");
    return parseInt(num);
  }
  var YEAR_PATTERN = `(?:[1-9][0-9]{0,3}\\s{0,2}(?:BE|AD|BC|BCE|CE)|[1-2][0-9]{3}|[5-9][0-9]|2[0-5])`;
  function parseYear(match3) {
    if (/BE/i.test(match3)) {
      match3 = match3.replace(/BE/i, "");
      return parseInt(match3) - 543;
    }
    if (/BCE?/i.test(match3)) {
      match3 = match3.replace(/BCE?/i, "");
      return -parseInt(match3);
    }
    if (/(AD|CE)/i.test(match3)) {
      match3 = match3.replace(/(AD|CE)/i, "");
      return parseInt(match3);
    }
    const rawYearNumber = parseInt(match3);
    return findMostLikelyADYear(rawYearNumber);
  }
  var SINGLE_TIME_UNIT_PATTERN = `(${NUMBER_PATTERN})\\s{0,3}(${matchAnyPattern(TIME_UNIT_DICTIONARY)})`;
  var SINGLE_TIME_UNIT_REGEX = new RegExp(SINGLE_TIME_UNIT_PATTERN, "i");
  var SINGLE_TIME_UNIT_NO_ABBR_PATTERN = `(${NUMBER_PATTERN})\\s{0,3}(${matchAnyPattern(TIME_UNIT_DICTIONARY_NO_ABBR)})`;
  var TIME_UNIT_CONNECTOR_PATTERN = `\\s{0,5},?(?:\\s*and)?\\s{0,5}`;
  var TIME_UNITS_PATTERN = repeatedTimeunitPattern(`(?:(?:about|around)\\s{0,3})?`, SINGLE_TIME_UNIT_PATTERN, TIME_UNIT_CONNECTOR_PATTERN);
  var TIME_UNITS_NO_ABBR_PATTERN = repeatedTimeunitPattern(`(?:(?:about|around)\\s{0,3})?`, SINGLE_TIME_UNIT_NO_ABBR_PATTERN, TIME_UNIT_CONNECTOR_PATTERN);
  function parseTimeUnits(timeunitText) {
    const fragments = {};
    let remainingText = timeunitText;
    let match3 = SINGLE_TIME_UNIT_REGEX.exec(remainingText);
    while (match3) {
      collectDateTimeFragment(fragments, match3);
      remainingText = remainingText.substring(match3[0].length).trim();
      match3 = SINGLE_TIME_UNIT_REGEX.exec(remainingText);
    }
    if (Object.keys(fragments).length == 0) {
      return null;
    }
    return fragments;
  }
  function collectDateTimeFragment(fragments, match3) {
    if (match3[0].match(/^[a-zA-Z]+$/)) {
      return;
    }
    const num = parseNumberPattern(match3[1]);
    const unit = TIME_UNIT_DICTIONARY[match3[2].toLowerCase()];
    fragments[unit] = num;
  }

  // node_modules/chrono-node/dist/esm/common/parsers/AbstractParserWithWordBoundary.js
  var AbstractParserWithWordBoundaryChecking = class {
    innerPatternHasChange(context, currentInnerPattern) {
      return this.innerPattern(context) !== currentInnerPattern;
    }
    patternLeftBoundary() {
      return `(\\W|^)`;
    }
    cachedInnerPattern = null;
    cachedPattern = null;
    pattern(context) {
      if (this.cachedInnerPattern) {
        if (!this.innerPatternHasChange(context, this.cachedInnerPattern)) {
          return this.cachedPattern;
        }
      }
      this.cachedInnerPattern = this.innerPattern(context);
      this.cachedPattern = new RegExp(`${this.patternLeftBoundary()}${this.cachedInnerPattern.source}`, this.cachedInnerPattern.flags);
      return this.cachedPattern;
    }
    extract(context, match3) {
      const header = match3[1] ?? "";
      match3.index = match3.index + header.length;
      match3[0] = match3[0].substring(header.length);
      for (let i = 2; i < match3.length; i++) {
        match3[i - 1] = match3[i];
      }
      return this.innerExtract(context, match3);
    }
  };

  // node_modules/chrono-node/dist/esm/locales/en/parsers/ENTimeUnitWithinFormatParser.js
  var PATTERN_WITH_OPTIONAL_PREFIX = new RegExp(`(?:(?:within|in|for)\\s*)?(?:(?:about|around|roughly|approximately|just)\\s*(?:~\\s*)?)?(${TIME_UNITS_PATTERN})(?=\\W|$)`, "i");
  var PATTERN_WITH_PREFIX = new RegExp(`(?:within|in|for)\\s*(?:(?:about|around|roughly|approximately|just)\\s*(?:~\\s*)?)?(${TIME_UNITS_PATTERN})(?=\\W|$)`, "i");
  var PATTERN_WITH_PREFIX_STRICT = new RegExp(`(?:within|in|for)\\s*(?:(?:about|around|roughly|approximately|just)\\s*(?:~\\s*)?)?(${TIME_UNITS_NO_ABBR_PATTERN})(?=\\W|$)`, "i");
  var ENTimeUnitWithinFormatParser = class extends AbstractParserWithWordBoundaryChecking {
    strictMode;
    constructor(strictMode) {
      super();
      this.strictMode = strictMode;
    }
    innerPattern(context) {
      if (this.strictMode) {
        return PATTERN_WITH_PREFIX_STRICT;
      }
      return context.option.forwardDate ? PATTERN_WITH_OPTIONAL_PREFIX : PATTERN_WITH_PREFIX;
    }
    innerExtract(context, match3) {
      if (match3[0].match(/^for\s*the\s*\w+/)) {
        return null;
      }
      const timeUnits = parseTimeUnits(match3[1]);
      if (!timeUnits) {
        return null;
      }
      context.debug(() => {
        console.log(timeUnits);
        console.log(ParsingComponents.createRelativeFromReference(context.reference, timeUnits));
      });
      return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
    }
  };

  // node_modules/chrono-node/dist/esm/locales/en/parsers/ENMonthNameLittleEndianParser.js
  var PATTERN = new RegExp(`(?:on\\s{0,3})?(${ORDINAL_NUMBER_PATTERN})(?:\\s{0,3}(?:to|\\-|\\\u2013|until|through|till)?\\s{0,3}(${ORDINAL_NUMBER_PATTERN}))?(?:-|/|\\s{0,3}(?:of)?\\s{0,3})(${matchAnyPattern(MONTH_DICTIONARY)})(?:(?:-|/|,?\\s{0,3})(${YEAR_PATTERN}(?!\\w)))?(?=\\W|$)`, "i");
  var DATE_GROUP = 1;
  var DATE_TO_GROUP = 2;
  var MONTH_NAME_GROUP = 3;
  var YEAR_GROUP = 4;
  var ENMonthNameLittleEndianParser = class extends AbstractParserWithWordBoundaryChecking {
    innerPattern() {
      return PATTERN;
    }
    innerExtract(context, match3) {
      const result2 = context.createParsingResult(match3.index, match3[0]);
      const month = MONTH_DICTIONARY[match3[MONTH_NAME_GROUP].toLowerCase()];
      const day = parseOrdinalNumberPattern(match3[DATE_GROUP]);
      if (day > 31) {
        match3.index = match3.index + match3[DATE_GROUP].length;
        return null;
      }
      result2.start.assign("month", month);
      result2.start.assign("day", day);
      if (match3[YEAR_GROUP]) {
        const yearNumber = parseYear(match3[YEAR_GROUP]);
        result2.start.assign("year", yearNumber);
      } else {
        const year = findYearClosestToRef(context.refDate, day, month);
        result2.start.imply("year", year);
      }
      if (match3[DATE_TO_GROUP]) {
        const endDate = parseOrdinalNumberPattern(match3[DATE_TO_GROUP]);
        result2.end = result2.start.clone();
        result2.end.assign("day", endDate);
      }
      return result2;
    }
  };

  // node_modules/chrono-node/dist/esm/locales/en/parsers/ENMonthNameMiddleEndianParser.js
  var PATTERN2 = new RegExp(`(${matchAnyPattern(MONTH_DICTIONARY)})(?:-|/|\\s*,?\\s*)(${ORDINAL_NUMBER_PATTERN})(?!\\s*(?:am|pm))\\s*(?:(?:to|\\-)\\s*(${ORDINAL_NUMBER_PATTERN})\\s*)?(?:(?:-|/|\\s*,\\s*|\\s+)(${YEAR_PATTERN}))?(?=\\W|$)(?!\\:\\d)`, "i");
  var MONTH_NAME_GROUP2 = 1;
  var DATE_GROUP2 = 2;
  var DATE_TO_GROUP2 = 3;
  var YEAR_GROUP2 = 4;
  var ENMonthNameMiddleEndianParser = class extends AbstractParserWithWordBoundaryChecking {
    shouldSkipYearLikeDate;
    constructor(shouldSkipYearLikeDate) {
      super();
      this.shouldSkipYearLikeDate = shouldSkipYearLikeDate;
    }
    innerPattern() {
      return PATTERN2;
    }
    innerExtract(context, match3) {
      const month = MONTH_DICTIONARY[match3[MONTH_NAME_GROUP2].toLowerCase()];
      const day = parseOrdinalNumberPattern(match3[DATE_GROUP2]);
      if (day > 31) {
        return null;
      }
      if (this.shouldSkipYearLikeDate) {
        if (!match3[DATE_TO_GROUP2] && !match3[YEAR_GROUP2] && match3[DATE_GROUP2].match(/^2[0-5]$/)) {
          return null;
        }
      }
      const components2 = context.createParsingComponents({
        day,
        month
      }).addTag("parser/ENMonthNameMiddleEndianParser");
      if (match3[YEAR_GROUP2]) {
        const year = parseYear(match3[YEAR_GROUP2]);
        components2.assign("year", year);
      } else {
        const year = findYearClosestToRef(context.refDate, day, month);
        components2.imply("year", year);
      }
      if (!match3[DATE_TO_GROUP2]) {
        return components2;
      }
      const endDate = parseOrdinalNumberPattern(match3[DATE_TO_GROUP2]);
      const result2 = context.createParsingResult(match3.index, match3[0]);
      result2.start = components2;
      result2.end = components2.clone();
      result2.end.assign("day", endDate);
      return result2;
    }
  };

  // node_modules/chrono-node/dist/esm/locales/en/parsers/ENMonthNameParser.js
  var PATTERN3 = new RegExp(`((?:in)\\s*)?(${matchAnyPattern(MONTH_DICTIONARY)})\\s*(?:(?:,|-|of)?\\s*(${YEAR_PATTERN})?)?(?=[^\\s\\w]|\\s+[^0-9]|\\s+$|$)`, "i");
  var PREFIX_GROUP = 1;
  var MONTH_NAME_GROUP3 = 2;
  var YEAR_GROUP3 = 3;
  var ENMonthNameParser = class extends AbstractParserWithWordBoundaryChecking {
    innerPattern() {
      return PATTERN3;
    }
    innerExtract(context, match3) {
      const monthName = match3[MONTH_NAME_GROUP3].toLowerCase();
      if (match3[0].length <= 3 && !FULL_MONTH_NAME_DICTIONARY[monthName]) {
        return null;
      }
      const result2 = context.createParsingResult(match3.index + (match3[PREFIX_GROUP] || "").length, match3.index + match3[0].length);
      result2.start.imply("day", 1);
      result2.start.addTag("parser/ENMonthNameParser");
      const month = MONTH_DICTIONARY[monthName];
      result2.start.assign("month", month);
      if (match3[YEAR_GROUP3]) {
        const year = parseYear(match3[YEAR_GROUP3]);
        result2.start.assign("year", year);
      } else {
        const year = findYearClosestToRef(context.refDate, 1, month);
        result2.start.imply("year", year);
      }
      return result2;
    }
  };

  // node_modules/chrono-node/dist/esm/locales/en/parsers/ENYearMonthDayParser.js
  var PATTERN4 = new RegExp(`([0-9]{4})[-\\.\\/\\s](?:(${matchAnyPattern(MONTH_DICTIONARY)})|([0-9]{1,2}))[-\\.\\/\\s]([0-9]{1,2})(?=\\W|$)`, "i");
  var YEAR_NUMBER_GROUP = 1;
  var MONTH_NAME_GROUP4 = 2;
  var MONTH_NUMBER_GROUP = 3;
  var DATE_NUMBER_GROUP = 4;
  var ENYearMonthDayParser = class extends AbstractParserWithWordBoundaryChecking {
    strictMonthDateOrder;
    constructor(strictMonthDateOrder) {
      super();
      this.strictMonthDateOrder = strictMonthDateOrder;
    }
    innerPattern() {
      return PATTERN4;
    }
    innerExtract(context, match3) {
      const year = parseInt(match3[YEAR_NUMBER_GROUP]);
      let day = parseInt(match3[DATE_NUMBER_GROUP]);
      let month = match3[MONTH_NUMBER_GROUP] ? parseInt(match3[MONTH_NUMBER_GROUP]) : MONTH_DICTIONARY[match3[MONTH_NAME_GROUP4].toLowerCase()];
      if (month < 1 || month > 12) {
        if (this.strictMonthDateOrder) {
          return null;
        }
        if (day >= 1 && day <= 12) {
          [month, day] = [day, month];
        }
      }
      if (day < 1 || day > 31) {
        return null;
      }
      return {
        day,
        month,
        year
      };
    }
  };

  // node_modules/chrono-node/dist/esm/locales/en/parsers/ENSlashMonthFormatParser.js
  var PATTERN5 = new RegExp("([0-9]|0[1-9]|1[012])/([0-9]{4})", "i");
  var MONTH_GROUP = 1;
  var YEAR_GROUP4 = 2;
  var ENSlashMonthFormatParser = class extends AbstractParserWithWordBoundaryChecking {
    innerPattern() {
      return PATTERN5;
    }
    innerExtract(context, match3) {
      const year = parseInt(match3[YEAR_GROUP4]);
      const month = parseInt(match3[MONTH_GROUP]);
      return context.createParsingComponents().imply("day", 1).assign("month", month).assign("year", year);
    }
  };

  // node_modules/chrono-node/dist/esm/common/parsers/AbstractTimeExpressionParser.js
  function primaryTimePattern(leftBoundary, primaryPrefix, primarySuffix, flags) {
    return new RegExp(`${leftBoundary}${primaryPrefix}(\\d{1,4})(?:(?:\\.|:|\uFF1A)(\\d{1,2})(?:(?::|\uFF1A)(\\d{2})(?:\\.(\\d{1,6}))?)?)?(?:\\s*(a\\.m\\.|p\\.m\\.|am?|pm?))?${primarySuffix}`, flags);
  }
  function followingTimePatten(followingPhase, followingSuffix) {
    return new RegExp(`^(${followingPhase})(\\d{1,4})(?:(?:\\.|\\:|\\\uFF1A)(\\d{1,2})(?:(?:\\.|\\:|\\\uFF1A)(\\d{1,2})(?:\\.(\\d{1,6}))?)?)?(?:\\s*(a\\.m\\.|p\\.m\\.|am?|pm?))?${followingSuffix}`, "i");
  }
  var HOUR_GROUP = 2;
  var MINUTE_GROUP = 3;
  var SECOND_GROUP = 4;
  var MILLI_SECOND_GROUP = 5;
  var AM_PM_HOUR_GROUP = 6;
  var AbstractTimeExpressionParser = class {
    strictMode;
    constructor(strictMode = false) {
      this.strictMode = strictMode;
    }
    patternFlags() {
      return "i";
    }
    primaryPatternLeftBoundary() {
      return `(^|\\s|T|\\b)`;
    }
    primarySuffix() {
      return `(?!/)(?=\\W|$)`;
    }
    followingSuffix() {
      return `(?!/)(?=\\W|$)`;
    }
    pattern(context) {
      return this.getPrimaryTimePatternThroughCache();
    }
    extract(context, match3) {
      const startComponents = this.extractPrimaryTimeComponents(context, match3);
      if (!startComponents) {
        if (match3[0].match(/^\d{4}/)) {
          match3.index += 4;
          return null;
        }
        match3.index += match3[0].length;
        return null;
      }
      const index2 = match3.index + match3[1].length;
      const text = match3[0].substring(match3[1].length);
      const result2 = context.createParsingResult(index2, text, startComponents);
      match3.index += match3[0].length;
      const remainingText = context.text.substring(match3.index);
      const followingPattern = this.getFollowingTimePatternThroughCache();
      const followingMatch = followingPattern.exec(remainingText);
      if (text.match(/^\d{3,4}/) && followingMatch) {
        if (followingMatch[0].match(/^\s*([+-])\s*\d{2,4}$/)) {
          return null;
        }
        if (followingMatch[0].match(/^\s*([+-])\s*\d{2}\W\d{2}/)) {
          return null;
        }
      }
      if (!followingMatch || followingMatch[0].match(/^\s*([+-])\s*\d{3,4}$/)) {
        return this.checkAndReturnWithoutFollowingPattern(result2);
      }
      result2.end = this.extractFollowingTimeComponents(context, followingMatch, result2);
      if (result2.end) {
        result2.text += followingMatch[0];
      }
      return this.checkAndReturnWithFollowingPattern(result2);
    }
    extractPrimaryTimeComponents(context, match3, strict2 = false) {
      const components2 = context.createParsingComponents();
      let minute = 0;
      let meridiem = null;
      let hour = parseInt(match3[HOUR_GROUP]);
      if (hour > 100) {
        if (this.strictMode || match3[MINUTE_GROUP] != null) {
          return null;
        }
        minute = hour % 100;
        hour = Math.floor(hour / 100);
      }
      if (hour > 24) {
        return null;
      }
      if (match3[MINUTE_GROUP] != null) {
        if (match3[MINUTE_GROUP].length == 1 && !match3[AM_PM_HOUR_GROUP]) {
          return null;
        }
        minute = parseInt(match3[MINUTE_GROUP]);
      }
      if (minute >= 60) {
        return null;
      }
      if (hour > 12) {
        meridiem = Meridiem.PM;
      }
      if (match3[AM_PM_HOUR_GROUP] != null) {
        if (hour > 12)
          return null;
        const ampm = match3[AM_PM_HOUR_GROUP][0].toLowerCase();
        if (ampm == "a") {
          meridiem = Meridiem.AM;
          if (hour == 12) {
            hour = 0;
          }
        }
        if (ampm == "p") {
          meridiem = Meridiem.PM;
          if (hour != 12) {
            hour += 12;
          }
        }
      }
      components2.assign("hour", hour);
      components2.assign("minute", minute);
      if (meridiem !== null) {
        components2.assign("meridiem", meridiem);
      } else {
        if (hour < 12) {
          components2.imply("meridiem", Meridiem.AM);
        } else {
          components2.imply("meridiem", Meridiem.PM);
        }
      }
      if (match3[MILLI_SECOND_GROUP] != null) {
        const millisecond = parseInt(match3[MILLI_SECOND_GROUP].substring(0, 3));
        if (millisecond >= 1e3)
          return null;
        components2.assign("millisecond", millisecond);
      }
      if (match3[SECOND_GROUP] != null) {
        const second = parseInt(match3[SECOND_GROUP]);
        if (second >= 60)
          return null;
        components2.assign("second", second);
      }
      return components2;
    }
    extractFollowingTimeComponents(context, match3, result2) {
      const components2 = context.createParsingComponents();
      if (match3[MILLI_SECOND_GROUP] != null) {
        const millisecond = parseInt(match3[MILLI_SECOND_GROUP].substring(0, 3));
        if (millisecond >= 1e3)
          return null;
        components2.assign("millisecond", millisecond);
      }
      if (match3[SECOND_GROUP] != null) {
        const second = parseInt(match3[SECOND_GROUP]);
        if (second >= 60)
          return null;
        components2.assign("second", second);
      }
      let hour = parseInt(match3[HOUR_GROUP]);
      let minute = 0;
      let meridiem = -1;
      if (match3[MINUTE_GROUP] != null) {
        minute = parseInt(match3[MINUTE_GROUP]);
      } else if (hour > 100) {
        minute = hour % 100;
        hour = Math.floor(hour / 100);
      }
      if (minute >= 60 || hour > 24) {
        return null;
      }
      if (hour >= 12) {
        meridiem = Meridiem.PM;
      }
      if (match3[AM_PM_HOUR_GROUP] != null) {
        if (hour > 12) {
          return null;
        }
        const ampm = match3[AM_PM_HOUR_GROUP][0].toLowerCase();
        if (ampm == "a") {
          meridiem = Meridiem.AM;
          if (hour == 12) {
            hour = 0;
            if (!components2.isCertain("day")) {
              components2.imply("day", components2.get("day") + 1);
            }
          }
        }
        if (ampm == "p") {
          meridiem = Meridiem.PM;
          if (hour != 12)
            hour += 12;
        }
        if (!result2.start.isCertain("meridiem")) {
          if (meridiem == Meridiem.AM) {
            result2.start.imply("meridiem", Meridiem.AM);
            if (result2.start.get("hour") == 12) {
              result2.start.assign("hour", 0);
            }
          } else {
            result2.start.imply("meridiem", Meridiem.PM);
            if (result2.start.get("hour") != 12) {
              result2.start.assign("hour", result2.start.get("hour") + 12);
            }
          }
        }
      }
      components2.assign("hour", hour);
      components2.assign("minute", minute);
      if (meridiem >= 0) {
        components2.assign("meridiem", meridiem);
      } else {
        const startAtPM = result2.start.isCertain("meridiem") && result2.start.get("hour") > 12;
        if (startAtPM) {
          if (result2.start.get("hour") - 12 > hour) {
            components2.imply("meridiem", Meridiem.AM);
          } else if (hour <= 12) {
            components2.assign("hour", hour + 12);
            components2.assign("meridiem", Meridiem.PM);
          }
        } else if (hour > 12) {
          components2.imply("meridiem", Meridiem.PM);
        } else if (hour <= 12) {
          components2.imply("meridiem", Meridiem.AM);
        }
      }
      if (components2.date().getTime() < result2.start.date().getTime()) {
        components2.imply("day", components2.get("day") + 1);
      }
      return components2;
    }
    checkAndReturnWithoutFollowingPattern(result2) {
      if (result2.text.match(/^\d$/)) {
        return null;
      }
      if (result2.text.match(/^\d\d\d+$/)) {
        return null;
      }
      if (result2.text.match(/\d[apAP]$/)) {
        return null;
      }
      const endingWithNumbers = result2.text.match(/[^\d:.](\d[\d.]+)$/);
      if (endingWithNumbers) {
        const endingNumbers = endingWithNumbers[1];
        if (this.strictMode) {
          return null;
        }
        if (endingNumbers.includes(".") && !endingNumbers.match(/\d(\.\d{2})+$/)) {
          return null;
        }
        const endingNumberVal = parseInt(endingNumbers);
        if (endingNumberVal > 24) {
          return null;
        }
      }
      return result2;
    }
    checkAndReturnWithFollowingPattern(result2) {
      if (result2.text.match(/^\d+-\d+$/)) {
        return null;
      }
      const endingWithNumbers = result2.text.match(/[^\d:.](\d[\d.]+)\s*-\s*(\d[\d.]+)$/);
      if (endingWithNumbers) {
        if (this.strictMode) {
          return null;
        }
        const startingNumbers = endingWithNumbers[1];
        const endingNumbers = endingWithNumbers[2];
        if (endingNumbers.includes(".") && !endingNumbers.match(/\d(\.\d{2})+$/)) {
          return null;
        }
        const endingNumberVal = parseInt(endingNumbers);
        const startingNumberVal = parseInt(startingNumbers);
        if (endingNumberVal > 24 || startingNumberVal > 24) {
          return null;
        }
      }
      return result2;
    }
    cachedPrimaryPrefix = null;
    cachedPrimarySuffix = null;
    cachedPrimaryTimePattern = null;
    getPrimaryTimePatternThroughCache() {
      const primaryPrefix = this.primaryPrefix();
      const primarySuffix = this.primarySuffix();
      if (this.cachedPrimaryPrefix === primaryPrefix && this.cachedPrimarySuffix === primarySuffix) {
        return this.cachedPrimaryTimePattern;
      }
      this.cachedPrimaryTimePattern = primaryTimePattern(this.primaryPatternLeftBoundary(), primaryPrefix, primarySuffix, this.patternFlags());
      this.cachedPrimaryPrefix = primaryPrefix;
      this.cachedPrimarySuffix = primarySuffix;
      return this.cachedPrimaryTimePattern;
    }
    cachedFollowingPhase = null;
    cachedFollowingSuffix = null;
    cachedFollowingTimePatten = null;
    getFollowingTimePatternThroughCache() {
      const followingPhase = this.followingPhase();
      const followingSuffix = this.followingSuffix();
      if (this.cachedFollowingPhase === followingPhase && this.cachedFollowingSuffix === followingSuffix) {
        return this.cachedFollowingTimePatten;
      }
      this.cachedFollowingTimePatten = followingTimePatten(followingPhase, followingSuffix);
      this.cachedFollowingPhase = followingPhase;
      this.cachedFollowingSuffix = followingSuffix;
      return this.cachedFollowingTimePatten;
    }
  };

  // node_modules/chrono-node/dist/esm/locales/en/parsers/ENTimeExpressionParser.js
  var ENTimeExpressionParser = class extends AbstractTimeExpressionParser {
    constructor(strictMode) {
      super(strictMode);
    }
    followingPhase() {
      return "\\s*(?:\\-|\\\u2013|\\~|\\\u301C|to|until|through|till|\\?)\\s*";
    }
    primaryPrefix() {
      return "(?:(?:at|from)\\s*)??";
    }
    primarySuffix() {
      return "(?:\\s*(?:o\\W*clock|at\\s*night|in\\s*the\\s*(?:morning|afternoon)))?(?!/)(?=\\W|$)";
    }
    extractPrimaryTimeComponents(context, match3) {
      const components2 = super.extractPrimaryTimeComponents(context, match3);
      if (!components2) {
        return components2;
      }
      if (match3[0].endsWith("night")) {
        const hour = components2.get("hour");
        if (hour >= 6 && hour < 12) {
          components2.assign("hour", components2.get("hour") + 12);
          components2.assign("meridiem", Meridiem.PM);
        } else if (hour < 6) {
          components2.assign("meridiem", Meridiem.AM);
        }
      }
      if (match3[0].endsWith("afternoon")) {
        components2.assign("meridiem", Meridiem.PM);
        const hour = components2.get("hour");
        if (hour >= 0 && hour <= 6) {
          components2.assign("hour", components2.get("hour") + 12);
        }
      }
      if (match3[0].endsWith("morning")) {
        components2.assign("meridiem", Meridiem.AM);
        const hour = components2.get("hour");
        if (hour < 12) {
          components2.assign("hour", components2.get("hour"));
        }
      }
      return components2.addTag("parser/ENTimeExpressionParser");
    }
    extractFollowingTimeComponents(context, match3, result2) {
      const followingComponents = super.extractFollowingTimeComponents(context, match3, result2);
      if (followingComponents) {
        followingComponents.addTag("parser/ENTimeExpressionParser");
      }
      return followingComponents;
    }
  };

  // node_modules/chrono-node/dist/esm/locales/en/parsers/ENTimeUnitAgoFormatParser.js
  var PATTERN6 = new RegExp(`(${TIME_UNITS_PATTERN})\\s{0,5}(?:ago|before|earlier)(?=\\W|$)`, "i");
  var STRICT_PATTERN = new RegExp(`(${TIME_UNITS_NO_ABBR_PATTERN})\\s{0,5}(?:ago|before|earlier)(?=\\W|$)`, "i");
  var ENTimeUnitAgoFormatParser = class extends AbstractParserWithWordBoundaryChecking {
    strictMode;
    constructor(strictMode) {
      super();
      this.strictMode = strictMode;
    }
    innerPattern() {
      return this.strictMode ? STRICT_PATTERN : PATTERN6;
    }
    innerExtract(context, match3) {
      const duration = parseTimeUnits(match3[1]);
      if (!duration) {
        return null;
      }
      return ParsingComponents.createRelativeFromReference(context.reference, reverseDuration(duration));
    }
  };

  // node_modules/chrono-node/dist/esm/locales/en/parsers/ENTimeUnitLaterFormatParser.js
  var PATTERN7 = new RegExp(`(${TIME_UNITS_PATTERN})\\s{0,5}(?:later|after|from now|henceforth|forward|out)(?=(?:\\W|$))`, "i");
  var STRICT_PATTERN2 = new RegExp(`(${TIME_UNITS_NO_ABBR_PATTERN})\\s{0,5}(later|after|from now)(?=\\W|$)`, "i");
  var GROUP_NUM_TIMEUNITS = 1;
  var ENTimeUnitLaterFormatParser = class extends AbstractParserWithWordBoundaryChecking {
    strictMode;
    constructor(strictMode) {
      super();
      this.strictMode = strictMode;
    }
    innerPattern() {
      return this.strictMode ? STRICT_PATTERN2 : PATTERN7;
    }
    innerExtract(context, match3) {
      const timeUnits = parseTimeUnits(match3[GROUP_NUM_TIMEUNITS]);
      if (!timeUnits) {
        return null;
      }
      return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
    }
  };

  // node_modules/chrono-node/dist/esm/common/abstractRefiners.js
  var Filter = class {
    refine(context, results) {
      return results.filter((r) => this.isValid(context, r));
    }
  };
  var MergingRefiner = class {
    refine(context, results) {
      if (results.length < 2) {
        return results;
      }
      const mergedResults = [];
      let curResult = results[0];
      let nextResult = null;
      for (let i = 1; i < results.length; i++) {
        nextResult = results[i];
        const textBetween = context.text.substring(curResult.index + curResult.text.length, nextResult.index);
        if (!this.shouldMergeResults(textBetween, curResult, nextResult, context)) {
          mergedResults.push(curResult);
          curResult = nextResult;
        } else {
          const left2 = curResult;
          const right2 = nextResult;
          const mergedResult = this.mergeResults(textBetween, left2, right2, context);
          context.debug(() => {
            console.log(`${this.constructor.name} merged ${left2} and ${right2} into ${mergedResult}`);
          });
          curResult = mergedResult;
        }
      }
      if (curResult != null) {
        mergedResults.push(curResult);
      }
      return mergedResults;
    }
  };

  // node_modules/chrono-node/dist/esm/common/refiners/AbstractMergeDateRangeRefiner.js
  var AbstractMergeDateRangeRefiner = class extends MergingRefiner {
    shouldMergeResults(textBetween, currentResult, nextResult) {
      return !currentResult.end && !nextResult.end && textBetween.match(this.patternBetween()) != null;
    }
    mergeResults(textBetween, fromResult, toResult) {
      if (!fromResult.start.isOnlyWeekdayComponent() && !toResult.start.isOnlyWeekdayComponent()) {
        toResult.start.getCertainComponents().forEach((key) => {
          if (!fromResult.start.isCertain(key)) {
            fromResult.start.imply(key, toResult.start.get(key));
          }
        });
        fromResult.start.getCertainComponents().forEach((key) => {
          if (!toResult.start.isCertain(key)) {
            toResult.start.imply(key, fromResult.start.get(key));
          }
        });
      }
      if (fromResult.start.date().getTime() > toResult.start.date().getTime()) {
        let fromMoment = fromResult.start.dayjs();
        let toMoment = toResult.start.dayjs();
        if (toResult.start.isOnlyWeekdayComponent() && toMoment.add(7, "days").isAfter(fromMoment)) {
          toMoment = toMoment.add(7, "days");
          toResult.start.imply("day", toMoment.date());
          toResult.start.imply("month", toMoment.month() + 1);
          toResult.start.imply("year", toMoment.year());
        } else if (fromResult.start.isOnlyWeekdayComponent() && fromMoment.add(-7, "days").isBefore(toMoment)) {
          fromMoment = fromMoment.add(-7, "days");
          fromResult.start.imply("day", fromMoment.date());
          fromResult.start.imply("month", fromMoment.month() + 1);
          fromResult.start.imply("year", fromMoment.year());
        } else if (toResult.start.isDateWithUnknownYear() && toMoment.add(1, "years").isAfter(fromMoment)) {
          toMoment = toMoment.add(1, "years");
          toResult.start.imply("year", toMoment.year());
        } else if (fromResult.start.isDateWithUnknownYear() && fromMoment.add(-1, "years").isBefore(toMoment)) {
          fromMoment = fromMoment.add(-1, "years");
          fromResult.start.imply("year", fromMoment.year());
        } else {
          [toResult, fromResult] = [fromResult, toResult];
        }
      }
      const result2 = fromResult.clone();
      result2.start = fromResult.start;
      result2.end = toResult.start;
      result2.index = Math.min(fromResult.index, toResult.index);
      if (fromResult.index < toResult.index) {
        result2.text = fromResult.text + textBetween + toResult.text;
      } else {
        result2.text = toResult.text + textBetween + fromResult.text;
      }
      return result2;
    }
  };

  // node_modules/chrono-node/dist/esm/locales/en/refiners/ENMergeDateRangeRefiner.js
  var ENMergeDateRangeRefiner = class extends AbstractMergeDateRangeRefiner {
    patternBetween() {
      return /^\s*(to|-|–|until|through|till)\s*$/i;
    }
  };

  // node_modules/chrono-node/dist/esm/utils/dayjs.js
  function implyTheNextDay(component, targetDayJs) {
    targetDayJs = targetDayJs.add(1, "day");
    implySimilarDate2(component, targetDayJs);
    implySimilarTime2(component, targetDayJs);
  }
  function assignSimilarDate2(component, targetDayJs) {
    component.assign("day", targetDayJs.date());
    component.assign("month", targetDayJs.month() + 1);
    component.assign("year", targetDayJs.year());
  }
  function assignSimilarTime2(component, targetDayJs) {
    component.assign("hour", targetDayJs.hour());
    component.assign("minute", targetDayJs.minute());
    component.assign("second", targetDayJs.second());
    component.assign("millisecond", targetDayJs.millisecond());
    if (component.get("hour") < 12) {
      component.assign("meridiem", Meridiem.AM);
    } else {
      component.assign("meridiem", Meridiem.PM);
    }
  }
  function implySimilarDate2(component, targetDayJs) {
    component.imply("day", targetDayJs.date());
    component.imply("month", targetDayJs.month() + 1);
    component.imply("year", targetDayJs.year());
  }
  function implySimilarTime2(component, targetDayJs) {
    component.imply("hour", targetDayJs.hour());
    component.imply("minute", targetDayJs.minute());
    component.imply("second", targetDayJs.second());
    component.imply("millisecond", targetDayJs.millisecond());
  }

  // node_modules/chrono-node/dist/esm/calculation/mergingCalculation.js
  function mergeDateTimeResult(dateResult, timeResult) {
    const result2 = dateResult.clone();
    const beginDate = dateResult.start;
    const beginTime = timeResult.start;
    result2.start = mergeDateTimeComponent(beginDate, beginTime);
    if (dateResult.end != null || timeResult.end != null) {
      const endDate = dateResult.end == null ? dateResult.start : dateResult.end;
      const endTime = timeResult.end == null ? timeResult.start : timeResult.end;
      const endDateTime = mergeDateTimeComponent(endDate, endTime);
      if (dateResult.end == null && endDateTime.date().getTime() < result2.start.date().getTime()) {
        const nextDayJs = endDateTime.dayjs().add(1, "day");
        if (endDateTime.isCertain("day")) {
          assignSimilarDate2(endDateTime, nextDayJs);
        } else {
          implySimilarDate2(endDateTime, nextDayJs);
        }
      }
      result2.end = endDateTime;
    }
    return result2;
  }
  function mergeDateTimeComponent(dateComponent, timeComponent) {
    const dateTimeComponent = dateComponent.clone();
    if (timeComponent.isCertain("hour")) {
      dateTimeComponent.assign("hour", timeComponent.get("hour"));
      dateTimeComponent.assign("minute", timeComponent.get("minute"));
      if (timeComponent.isCertain("second")) {
        dateTimeComponent.assign("second", timeComponent.get("second"));
        if (timeComponent.isCertain("millisecond")) {
          dateTimeComponent.assign("millisecond", timeComponent.get("millisecond"));
        } else {
          dateTimeComponent.imply("millisecond", timeComponent.get("millisecond"));
        }
      } else {
        dateTimeComponent.imply("second", timeComponent.get("second"));
        dateTimeComponent.imply("millisecond", timeComponent.get("millisecond"));
      }
    } else {
      dateTimeComponent.imply("hour", timeComponent.get("hour"));
      dateTimeComponent.imply("minute", timeComponent.get("minute"));
      dateTimeComponent.imply("second", timeComponent.get("second"));
      dateTimeComponent.imply("millisecond", timeComponent.get("millisecond"));
    }
    if (timeComponent.isCertain("timezoneOffset")) {
      dateTimeComponent.assign("timezoneOffset", timeComponent.get("timezoneOffset"));
    }
    if (timeComponent.isCertain("meridiem")) {
      dateTimeComponent.assign("meridiem", timeComponent.get("meridiem"));
    } else if (timeComponent.get("meridiem") != null && dateTimeComponent.get("meridiem") == null) {
      dateTimeComponent.imply("meridiem", timeComponent.get("meridiem"));
    }
    if (dateTimeComponent.get("meridiem") == Meridiem.PM && dateTimeComponent.get("hour") < 12) {
      if (timeComponent.isCertain("hour")) {
        dateTimeComponent.assign("hour", dateTimeComponent.get("hour") + 12);
      } else {
        dateTimeComponent.imply("hour", dateTimeComponent.get("hour") + 12);
      }
    }
    dateTimeComponent.addTags(dateComponent.tags());
    dateTimeComponent.addTags(timeComponent.tags());
    return dateTimeComponent;
  }

  // node_modules/chrono-node/dist/esm/common/refiners/AbstractMergeDateTimeRefiner.js
  var AbstractMergeDateTimeRefiner = class extends MergingRefiner {
    shouldMergeResults(textBetween, currentResult, nextResult) {
      return (currentResult.start.isOnlyDate() && nextResult.start.isOnlyTime() || nextResult.start.isOnlyDate() && currentResult.start.isOnlyTime()) && textBetween.match(this.patternBetween()) != null;
    }
    mergeResults(textBetween, currentResult, nextResult) {
      const result2 = currentResult.start.isOnlyDate() ? mergeDateTimeResult(currentResult, nextResult) : mergeDateTimeResult(nextResult, currentResult);
      result2.index = currentResult.index;
      result2.text = currentResult.text + textBetween + nextResult.text;
      return result2;
    }
  };

  // node_modules/chrono-node/dist/esm/locales/en/refiners/ENMergeDateTimeRefiner.js
  var ENMergeDateTimeRefiner = class extends AbstractMergeDateTimeRefiner {
    patternBetween() {
      return new RegExp("^\\s*(T|at|after|before|on|of|,|-|\\.|\u2219|:)?\\s*$");
    }
  };

  // node_modules/chrono-node/dist/esm/common/refiners/ExtractTimezoneAbbrRefiner.js
  var TIMEZONE_NAME_PATTERN = new RegExp("^\\s*,?\\s*\\(?([A-Z]{2,4})\\)?(?=\\W|$)", "i");
  var ExtractTimezoneAbbrRefiner = class {
    timezoneOverrides;
    constructor(timezoneOverrides) {
      this.timezoneOverrides = timezoneOverrides;
    }
    refine(context, results) {
      const timezoneOverrides = context.option.timezones ?? {};
      results.forEach((result2) => {
        const suffix = context.text.substring(result2.index + result2.text.length);
        const match3 = TIMEZONE_NAME_PATTERN.exec(suffix);
        if (!match3) {
          return;
        }
        const timezoneAbbr = match3[1].toUpperCase();
        const refDate = result2.start.date() ?? result2.refDate ?? /* @__PURE__ */ new Date();
        const tzOverrides = { ...this.timezoneOverrides, ...timezoneOverrides };
        const extractedTimezoneOffset = toTimezoneOffset(timezoneAbbr, refDate, tzOverrides);
        if (extractedTimezoneOffset == null) {
          return;
        }
        context.debug(() => {
          console.log(`Extracting timezone: '${timezoneAbbr}' into: ${extractedTimezoneOffset} for: ${result2.start}`);
        });
        const currentTimezoneOffset = result2.start.get("timezoneOffset");
        if (currentTimezoneOffset !== null && extractedTimezoneOffset != currentTimezoneOffset) {
          if (result2.start.isCertain("timezoneOffset")) {
            return;
          }
          if (timezoneAbbr != match3[1]) {
            return;
          }
        }
        if (result2.start.isOnlyDate()) {
          if (timezoneAbbr != match3[1]) {
            return;
          }
        }
        result2.text += match3[0];
        if (!result2.start.isCertain("timezoneOffset")) {
          result2.start.assign("timezoneOffset", extractedTimezoneOffset);
        }
        if (result2.end != null && !result2.end.isCertain("timezoneOffset")) {
          result2.end.assign("timezoneOffset", extractedTimezoneOffset);
        }
      });
      return results;
    }
  };

  // node_modules/chrono-node/dist/esm/common/refiners/ExtractTimezoneOffsetRefiner.js
  var TIMEZONE_OFFSET_PATTERN = new RegExp("^\\s*(?:\\(?(?:GMT|UTC)\\s?)?([+-])(\\d{1,2})(?::?(\\d{2}))?\\)?", "i");
  var TIMEZONE_OFFSET_SIGN_GROUP = 1;
  var TIMEZONE_OFFSET_HOUR_OFFSET_GROUP = 2;
  var TIMEZONE_OFFSET_MINUTE_OFFSET_GROUP = 3;
  var ExtractTimezoneOffsetRefiner = class {
    refine(context, results) {
      results.forEach(function(result2) {
        if (result2.start.isCertain("timezoneOffset")) {
          return;
        }
        const suffix = context.text.substring(result2.index + result2.text.length);
        const match3 = TIMEZONE_OFFSET_PATTERN.exec(suffix);
        if (!match3) {
          return;
        }
        context.debug(() => {
          console.log(`Extracting timezone: '${match3[0]}' into : ${result2}`);
        });
        const hourOffset = parseInt(match3[TIMEZONE_OFFSET_HOUR_OFFSET_GROUP]);
        const minuteOffset = parseInt(match3[TIMEZONE_OFFSET_MINUTE_OFFSET_GROUP] || "0");
        let timezoneOffset = hourOffset * 60 + minuteOffset;
        if (timezoneOffset > 14 * 60) {
          return;
        }
        if (match3[TIMEZONE_OFFSET_SIGN_GROUP] === "-") {
          timezoneOffset = -timezoneOffset;
        }
        if (result2.end != null) {
          result2.end.assign("timezoneOffset", timezoneOffset);
        }
        result2.start.assign("timezoneOffset", timezoneOffset);
        result2.text += match3[0];
      });
      return results;
    }
  };

  // node_modules/chrono-node/dist/esm/common/refiners/OverlapRemovalRefiner.js
  var OverlapRemovalRefiner = class {
    refine(context, results) {
      if (results.length < 2) {
        return results;
      }
      const filteredResults = [];
      let prevResult = results[0];
      for (let i = 1; i < results.length; i++) {
        const result2 = results[i];
        if (result2.index >= prevResult.index + prevResult.text.length) {
          filteredResults.push(prevResult);
          prevResult = result2;
          continue;
        }
        let kept = null;
        let removed = null;
        if (result2.text.length > prevResult.text.length) {
          kept = result2;
          removed = prevResult;
        } else {
          kept = prevResult;
          removed = result2;
        }
        context.debug(() => {
          console.log(`${this.constructor.name} remove ${removed} by ${kept}`);
        });
        prevResult = kept;
      }
      if (prevResult != null) {
        filteredResults.push(prevResult);
      }
      return filteredResults;
    }
  };

  // node_modules/chrono-node/dist/esm/common/refiners/ForwardDateRefiner.js
  var import_dayjs5 = __toESM(require_dayjs_min(), 1);
  var ForwardDateRefiner = class {
    refine(context, results) {
      if (!context.option.forwardDate) {
        return results;
      }
      results.forEach((result2) => {
        let refMoment = (0, import_dayjs5.default)(context.reference.getDateWithAdjustedTimezone());
        if (result2.start.isOnlyTime() && context.reference.instant > result2.start.date()) {
          const refDate = context.reference.getDateWithAdjustedTimezone();
          const refFollowingDay = new Date(refDate);
          refFollowingDay.setDate(refFollowingDay.getDate() + 1);
          implySimilarDate(result2.start, refFollowingDay);
          context.debug(() => {
            console.log(`${this.constructor.name} adjusted ${result2} time from the ref date (${refDate}) to the following day (${refFollowingDay})`);
          });
          if (result2.end && result2.end.isOnlyTime()) {
            implySimilarDate(result2.end, refFollowingDay);
            if (result2.start.date() > result2.end.date()) {
              refFollowingDay.setDate(refFollowingDay.getDate() + 1);
              implySimilarDate(result2.end, refFollowingDay);
            }
          }
        }
        if (result2.start.isOnlyWeekdayComponent() && refMoment.isAfter(result2.start.dayjs())) {
          if (refMoment.day() >= result2.start.get("weekday")) {
            refMoment = refMoment.day(result2.start.get("weekday") + 7);
          } else {
            refMoment = refMoment.day(result2.start.get("weekday"));
          }
          result2.start.imply("day", refMoment.date());
          result2.start.imply("month", refMoment.month() + 1);
          result2.start.imply("year", refMoment.year());
          context.debug(() => {
            console.log(`${this.constructor.name} adjusted ${result2} weekday (${result2.start})`);
          });
          if (result2.end && result2.end.isOnlyWeekdayComponent()) {
            if (refMoment.day() > result2.end.get("weekday")) {
              refMoment = refMoment.day(result2.end.get("weekday") + 7);
            } else {
              refMoment = refMoment.day(result2.end.get("weekday"));
            }
            result2.end.imply("day", refMoment.date());
            result2.end.imply("month", refMoment.month() + 1);
            result2.end.imply("year", refMoment.year());
            context.debug(() => {
              console.log(`${this.constructor.name} adjusted ${result2} weekday (${result2.end})`);
            });
          }
        }
        if (result2.start.isDateWithUnknownYear() && refMoment.isAfter(result2.start.dayjs())) {
          for (let i = 0; i < 3 && refMoment.isAfter(result2.start.dayjs()); i++) {
            result2.start.imply("year", result2.start.get("year") + 1);
            context.debug(() => {
              console.log(`${this.constructor.name} adjusted ${result2} year (${result2.start})`);
            });
            if (result2.end && !result2.end.isCertain("year")) {
              result2.end.imply("year", result2.end.get("year") + 1);
              context.debug(() => {
                console.log(`${this.constructor.name} adjusted ${result2} month (${result2.start})`);
              });
            }
          }
        }
      });
      return results;
    }
  };

  // node_modules/chrono-node/dist/esm/common/refiners/UnlikelyFormatFilter.js
  var UnlikelyFormatFilter = class extends Filter {
    strictMode;
    constructor(strictMode) {
      super();
      this.strictMode = strictMode;
    }
    isValid(context, result2) {
      if (result2.text.replace(" ", "").match(/^\d*(\.\d*)?$/)) {
        context.debug(() => {
          console.log(`Removing unlikely result '${result2.text}'`);
        });
        return false;
      }
      if (!result2.start.isValidDate()) {
        context.debug(() => {
          console.log(`Removing invalid result: ${result2} (${result2.start})`);
        });
        return false;
      }
      if (result2.end && !result2.end.isValidDate()) {
        context.debug(() => {
          console.log(`Removing invalid result: ${result2} (${result2.end})`);
        });
        return false;
      }
      if (this.strictMode) {
        return this.isStrictModeValid(context, result2);
      }
      return true;
    }
    isStrictModeValid(context, result2) {
      if (result2.start.isOnlyWeekdayComponent()) {
        context.debug(() => {
          console.log(`(Strict) Removing weekday only component: ${result2} (${result2.end})`);
        });
        return false;
      }
      return true;
    }
  };

  // node_modules/chrono-node/dist/esm/common/parsers/ISOFormatParser.js
  var PATTERN8 = new RegExp("([0-9]{4})\\-([0-9]{1,2})\\-([0-9]{1,2})(?:T([0-9]{1,2}):([0-9]{1,2})(?::([0-9]{1,2})(?:\\.(\\d{1,4}))?)?(Z|([+-]\\d{2}):?(\\d{2})?)?)?(?=\\W|$)", "i");
  var YEAR_NUMBER_GROUP2 = 1;
  var MONTH_NUMBER_GROUP2 = 2;
  var DATE_NUMBER_GROUP2 = 3;
  var HOUR_NUMBER_GROUP = 4;
  var MINUTE_NUMBER_GROUP = 5;
  var SECOND_NUMBER_GROUP = 6;
  var MILLISECOND_NUMBER_GROUP = 7;
  var TZD_GROUP = 8;
  var TZD_HOUR_OFFSET_GROUP = 9;
  var TZD_MINUTE_OFFSET_GROUP = 10;
  var ISOFormatParser = class extends AbstractParserWithWordBoundaryChecking {
    innerPattern() {
      return PATTERN8;
    }
    innerExtract(context, match3) {
      const components2 = context.createParsingComponents({
        "year": parseInt(match3[YEAR_NUMBER_GROUP2]),
        "month": parseInt(match3[MONTH_NUMBER_GROUP2]),
        "day": parseInt(match3[DATE_NUMBER_GROUP2])
      });
      if (match3[HOUR_NUMBER_GROUP] != null) {
        components2.assign("hour", parseInt(match3[HOUR_NUMBER_GROUP]));
        components2.assign("minute", parseInt(match3[MINUTE_NUMBER_GROUP]));
        if (match3[SECOND_NUMBER_GROUP] != null) {
          components2.assign("second", parseInt(match3[SECOND_NUMBER_GROUP]));
        }
        if (match3[MILLISECOND_NUMBER_GROUP] != null) {
          components2.assign("millisecond", parseInt(match3[MILLISECOND_NUMBER_GROUP]));
        }
        if (match3[TZD_GROUP] != null) {
          let offset3 = 0;
          if (match3[TZD_HOUR_OFFSET_GROUP]) {
            const hourOffset = parseInt(match3[TZD_HOUR_OFFSET_GROUP]);
            let minuteOffset = 0;
            if (match3[TZD_MINUTE_OFFSET_GROUP] != null) {
              minuteOffset = parseInt(match3[TZD_MINUTE_OFFSET_GROUP]);
            }
            offset3 = hourOffset * 60;
            if (offset3 < 0) {
              offset3 -= minuteOffset;
            } else {
              offset3 += minuteOffset;
            }
          }
          components2.assign("timezoneOffset", offset3);
        }
      }
      return components2.addTag("parser/ISOFormatParser");
    }
  };

  // node_modules/chrono-node/dist/esm/common/refiners/MergeWeekdayComponentRefiner.js
  var MergeWeekdayComponentRefiner = class extends MergingRefiner {
    mergeResults(textBetween, currentResult, nextResult) {
      const newResult = nextResult.clone();
      newResult.index = currentResult.index;
      newResult.text = currentResult.text + textBetween + newResult.text;
      newResult.start.assign("weekday", currentResult.start.get("weekday"));
      if (newResult.end) {
        newResult.end.assign("weekday", currentResult.start.get("weekday"));
      }
      return newResult;
    }
    shouldMergeResults(textBetween, currentResult, nextResult) {
      const weekdayThenNormalDate = currentResult.start.isOnlyWeekdayComponent() && !currentResult.start.isCertain("hour") && nextResult.start.isCertain("day");
      return weekdayThenNormalDate && textBetween.match(/^,?\s*$/) != null;
    }
  };

  // node_modules/chrono-node/dist/esm/configurations.js
  function includeCommonConfiguration(configuration2, strictMode = false) {
    configuration2.parsers.unshift(new ISOFormatParser());
    configuration2.refiners.unshift(new MergeWeekdayComponentRefiner());
    configuration2.refiners.unshift(new ExtractTimezoneOffsetRefiner());
    configuration2.refiners.unshift(new OverlapRemovalRefiner());
    configuration2.refiners.push(new ExtractTimezoneAbbrRefiner());
    configuration2.refiners.push(new OverlapRemovalRefiner());
    configuration2.refiners.push(new ForwardDateRefiner());
    configuration2.refiners.push(new UnlikelyFormatFilter(strictMode));
    return configuration2;
  }

  // node_modules/chrono-node/dist/esm/locales/en/parsers/ENCasualDateParser.js
  var import_dayjs8 = __toESM(require_dayjs_min(), 1);

  // node_modules/chrono-node/dist/esm/common/casualReferences.js
  var import_dayjs6 = __toESM(require_dayjs_min(), 1);
  function now(reference2) {
    const targetDate = (0, import_dayjs6.default)(reference2.getDateWithAdjustedTimezone());
    const component = new ParsingComponents(reference2, {});
    assignSimilarDate2(component, targetDate);
    assignSimilarTime2(component, targetDate);
    component.assign("timezoneOffset", reference2.getTimezoneOffset());
    component.addTag("casualReference/now");
    return component;
  }
  function today(reference2) {
    const targetDate = (0, import_dayjs6.default)(reference2.getDateWithAdjustedTimezone());
    const component = new ParsingComponents(reference2, {});
    assignSimilarDate2(component, targetDate);
    implySimilarTime2(component, targetDate);
    component.addTag("casualReference/today");
    return component;
  }
  function yesterday(reference2) {
    return theDayBefore(reference2, 1).addTag("casualReference/yesterday");
  }
  function theDayBefore(reference2, numDay) {
    return theDayAfter(reference2, -numDay);
  }
  function tomorrow(reference2) {
    return theDayAfter(reference2, 1).addTag("casualReference/tomorrow");
  }
  function theDayAfter(reference2, nDays) {
    let targetDate = (0, import_dayjs6.default)(reference2.getDateWithAdjustedTimezone());
    const component = new ParsingComponents(reference2, {});
    targetDate = targetDate.add(nDays, "day");
    assignSimilarDate2(component, targetDate);
    implySimilarTime2(component, targetDate);
    return component;
  }
  function tonight(reference2, implyHour = 22) {
    const targetDate = (0, import_dayjs6.default)(reference2.getDateWithAdjustedTimezone());
    const component = new ParsingComponents(reference2, {});
    assignSimilarDate2(component, targetDate);
    component.imply("hour", implyHour);
    component.imply("meridiem", Meridiem.PM);
    component.addTag("casualReference/tonight");
    return component;
  }
  function evening(reference2, implyHour = 20) {
    const component = new ParsingComponents(reference2, {});
    component.imply("meridiem", Meridiem.PM);
    component.imply("hour", implyHour);
    component.addTag("casualReference/evening");
    return component;
  }
  function midnight(reference2) {
    const component = new ParsingComponents(reference2, {});
    const targetDate = (0, import_dayjs6.default)(reference2.getDateWithAdjustedTimezone());
    if (targetDate.hour() > 2) {
      implyTheNextDay(component, targetDate);
    }
    component.assign("hour", 0);
    component.imply("minute", 0);
    component.imply("second", 0);
    component.imply("millisecond", 0);
    component.addTag("casualReference/midnight");
    return component;
  }
  function morning(reference2, implyHour = 6) {
    const component = new ParsingComponents(reference2, {});
    component.imply("meridiem", Meridiem.AM);
    component.imply("hour", implyHour);
    component.imply("minute", 0);
    component.imply("second", 0);
    component.imply("millisecond", 0);
    component.addTag("casualReference/morning");
    return component;
  }
  function afternoon(reference2, implyHour = 15) {
    const component = new ParsingComponents(reference2, {});
    component.imply("meridiem", Meridiem.PM);
    component.imply("hour", implyHour);
    component.imply("minute", 0);
    component.imply("second", 0);
    component.imply("millisecond", 0);
    component.addTag("casualReference/afternoon");
    return component;
  }
  function noon(reference2) {
    const component = new ParsingComponents(reference2, {});
    component.imply("meridiem", Meridiem.AM);
    component.assign("hour", 12);
    component.imply("minute", 0);
    component.imply("second", 0);
    component.imply("millisecond", 0);
    component.addTag("casualReference/noon");
    return component;
  }

  // node_modules/chrono-node/dist/esm/locales/en/parsers/ENCasualDateParser.js
  var PATTERN9 = /(now|today|tonight|tomorrow|overmorrow|tmr|tmrw|yesterday|last\s*night)(?=\W|$)/i;
  var ENCasualDateParser = class extends AbstractParserWithWordBoundaryChecking {
    innerPattern(context) {
      return PATTERN9;
    }
    innerExtract(context, match3) {
      let targetDate = (0, import_dayjs8.default)(context.refDate);
      const lowerText = match3[0].toLowerCase();
      let component = context.createParsingComponents();
      switch (lowerText) {
        case "now":
          component = now(context.reference);
          break;
        case "today":
          component = today(context.reference);
          break;
        case "yesterday":
          component = yesterday(context.reference);
          break;
        case "tomorrow":
        case "tmr":
        case "tmrw":
          component = tomorrow(context.reference);
          break;
        case "tonight":
          component = tonight(context.reference);
          break;
        case "overmorrow":
          component = theDayAfter(context.reference, 2);
          break;
        default:
          if (lowerText.match(/last\s*night/)) {
            if (targetDate.hour() > 6) {
              targetDate = targetDate.add(-1, "day");
            }
            assignSimilarDate2(component, targetDate);
            component.imply("hour", 0);
          }
          break;
      }
      component.addTag("parser/ENCasualDateParser");
      return component;
    }
  };

  // node_modules/chrono-node/dist/esm/locales/en/parsers/ENCasualTimeParser.js
  var PATTERN10 = /(?:this)?\s{0,3}(morning|afternoon|evening|night|midnight|midday|noon)(?=\W|$)/i;
  var ENCasualTimeParser = class extends AbstractParserWithWordBoundaryChecking {
    innerPattern() {
      return PATTERN10;
    }
    innerExtract(context, match3) {
      let component = null;
      switch (match3[1].toLowerCase()) {
        case "afternoon":
          component = afternoon(context.reference);
          break;
        case "evening":
        case "night":
          component = evening(context.reference);
          break;
        case "midnight":
          component = midnight(context.reference);
          break;
        case "morning":
          component = morning(context.reference);
          break;
        case "noon":
        case "midday":
          component = noon(context.reference);
          break;
      }
      if (component) {
        component.addTag("parser/ENCasualTimeParser");
      }
      return component;
    }
  };

  // node_modules/chrono-node/dist/esm/utils/timeunits.js
  function reverseTimeUnits(timeUnits) {
    const reversed = {};
    for (const key in timeUnits) {
      reversed[key] = -timeUnits[key];
    }
    return reversed;
  }
  function addImpliedTimeUnits(components2, timeUnits) {
    const output = components2.clone();
    let date = components2.dayjs();
    for (const key in timeUnits) {
      date = date.add(timeUnits[key], key);
    }
    if ("day" in timeUnits || "d" in timeUnits || "week" in timeUnits || "month" in timeUnits || "year" in timeUnits) {
      output.imply("day", date.date());
      output.imply("month", date.month() + 1);
      output.imply("year", date.year());
    }
    if ("second" in timeUnits || "minute" in timeUnits || "hour" in timeUnits) {
      output.imply("second", date.second());
      output.imply("minute", date.minute());
      output.imply("hour", date.hour());
    }
    return output;
  }

  // node_modules/chrono-node/dist/esm/calculation/weekdays.js
  function createParsingComponentsAtWeekday(reference2, weekday, modifier) {
    const refDate = reference2.getDateWithAdjustedTimezone();
    const daysToWeekday = getDaysToWeekday(refDate, weekday, modifier);
    let components2 = new ParsingComponents(reference2);
    components2 = addImpliedTimeUnits(components2, { "day": daysToWeekday });
    components2.assign("weekday", weekday);
    return components2;
  }
  function getDaysToWeekday(refDate, weekday, modifier) {
    const refWeekday = refDate.getDay();
    switch (modifier) {
      case "this":
        return getDaysForwardToWeekday(refDate, weekday);
      case "last":
        return getBackwardDaysToWeekday(refDate, weekday);
      case "next":
        if (refWeekday == Weekday.SUNDAY) {
          return weekday == Weekday.SUNDAY ? 7 : weekday;
        }
        if (refWeekday == Weekday.SATURDAY) {
          if (weekday == Weekday.SATURDAY)
            return 7;
          if (weekday == Weekday.SUNDAY)
            return 8;
          return 1 + weekday;
        }
        if (weekday < refWeekday && weekday != Weekday.SUNDAY) {
          return getDaysForwardToWeekday(refDate, weekday);
        } else {
          return getDaysForwardToWeekday(refDate, weekday) + 7;
        }
    }
    return getDaysToWeekdayClosest(refDate, weekday);
  }
  function getDaysToWeekdayClosest(refDate, weekday) {
    const backward = getBackwardDaysToWeekday(refDate, weekday);
    const forward = getDaysForwardToWeekday(refDate, weekday);
    return forward < -backward ? forward : backward;
  }
  function getDaysForwardToWeekday(refDate, weekday) {
    const refWeekday = refDate.getDay();
    let forwardCount = weekday - refWeekday;
    if (forwardCount < 0) {
      forwardCount += 7;
    }
    return forwardCount;
  }
  function getBackwardDaysToWeekday(refDate, weekday) {
    const refWeekday = refDate.getDay();
    let backwardCount = weekday - refWeekday;
    if (backwardCount >= 0) {
      backwardCount -= 7;
    }
    return backwardCount;
  }

  // node_modules/chrono-node/dist/esm/locales/en/parsers/ENWeekdayParser.js
  var PATTERN11 = new RegExp(`(?:(?:\\,|\\(|\\\uFF08)\\s*)?(?:on\\s*?)?(?:(this|last|past|next)\\s*)?(${matchAnyPattern(WEEKDAY_DICTIONARY)}|weekend|weekday)(?:\\s*(?:\\,|\\)|\\\uFF09))?(?:\\s*(this|last|past|next)\\s*week)?(?=\\W|$)`, "i");
  var PREFIX_GROUP2 = 1;
  var WEEKDAY_GROUP = 2;
  var POSTFIX_GROUP = 3;
  var ENWeekdayParser = class extends AbstractParserWithWordBoundaryChecking {
    innerPattern() {
      return PATTERN11;
    }
    innerExtract(context, match3) {
      const prefix3 = match3[PREFIX_GROUP2];
      const postfix = match3[POSTFIX_GROUP];
      let modifierWord = prefix3 || postfix;
      modifierWord = modifierWord || "";
      modifierWord = modifierWord.toLowerCase();
      let modifier = null;
      if (modifierWord == "last" || modifierWord == "past") {
        modifier = "last";
      } else if (modifierWord == "next") {
        modifier = "next";
      } else if (modifierWord == "this") {
        modifier = "this";
      }
      const weekday_word = match3[WEEKDAY_GROUP].toLowerCase();
      let weekday;
      if (WEEKDAY_DICTIONARY[weekday_word] !== void 0) {
        weekday = WEEKDAY_DICTIONARY[weekday_word];
      } else if (weekday_word == "weekend") {
        weekday = modifier == "last" ? Weekday.SUNDAY : Weekday.SATURDAY;
      } else if (weekday_word == "weekday") {
        const refWeekday = context.reference.getDateWithAdjustedTimezone().getDay();
        if (refWeekday == Weekday.SUNDAY || refWeekday == Weekday.SATURDAY) {
          weekday = modifier == "last" ? Weekday.FRIDAY : Weekday.MONDAY;
        } else {
          weekday = refWeekday - 1;
          weekday = modifier == "last" ? weekday - 1 : weekday + 1;
          weekday = weekday % 5 + 1;
        }
      } else {
        return null;
      }
      return createParsingComponentsAtWeekday(context.reference, weekday, modifier);
    }
  };

  // node_modules/chrono-node/dist/esm/locales/en/parsers/ENRelativeDateFormatParser.js
  var import_dayjs10 = __toESM(require_dayjs_min(), 1);
  var PATTERN12 = new RegExp(`(this|last|past|next|after\\s*this)\\s*(${matchAnyPattern(TIME_UNIT_DICTIONARY)})(?=\\s*)(?=\\W|$)`, "i");
  var MODIFIER_WORD_GROUP = 1;
  var RELATIVE_WORD_GROUP = 2;
  var ENRelativeDateFormatParser = class extends AbstractParserWithWordBoundaryChecking {
    innerPattern() {
      return PATTERN12;
    }
    innerExtract(context, match3) {
      const modifier = match3[MODIFIER_WORD_GROUP].toLowerCase();
      const unitWord = match3[RELATIVE_WORD_GROUP].toLowerCase();
      const timeunit = TIME_UNIT_DICTIONARY[unitWord];
      if (modifier == "next" || modifier.startsWith("after")) {
        const timeUnits = {};
        timeUnits[timeunit] = 1;
        return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
      }
      if (modifier == "last" || modifier == "past") {
        const timeUnits = {};
        timeUnits[timeunit] = -1;
        return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
      }
      const components2 = context.createParsingComponents();
      let date = (0, import_dayjs10.default)(context.reference.instant);
      if (unitWord.match(/week/i)) {
        date = date.add(-date.get("d"), "d");
        components2.imply("day", date.date());
        components2.imply("month", date.month() + 1);
        components2.imply("year", date.year());
      } else if (unitWord.match(/month/i)) {
        date = date.add(-date.date() + 1, "d");
        components2.imply("day", date.date());
        components2.assign("year", date.year());
        components2.assign("month", date.month() + 1);
      } else if (unitWord.match(/year/i)) {
        date = date.add(-date.date() + 1, "d");
        date = date.add(-date.month(), "month");
        components2.imply("day", date.date());
        components2.imply("month", date.month() + 1);
        components2.assign("year", date.year());
      }
      return components2;
    }
  };

  // node_modules/chrono-node/dist/esm/common/parsers/SlashDateFormatParser.js
  var PATTERN13 = new RegExp("([^\\d]|^)([0-3]{0,1}[0-9]{1})[\\/\\.\\-]([0-3]{0,1}[0-9]{1})(?:[\\/\\.\\-]([0-9]{4}|[0-9]{2}))?(\\W|$)", "i");
  var OPENING_GROUP = 1;
  var ENDING_GROUP = 5;
  var FIRST_NUMBERS_GROUP = 2;
  var SECOND_NUMBERS_GROUP = 3;
  var YEAR_GROUP5 = 4;
  var SlashDateFormatParser = class {
    groupNumberMonth;
    groupNumberDay;
    constructor(littleEndian) {
      this.groupNumberMonth = littleEndian ? SECOND_NUMBERS_GROUP : FIRST_NUMBERS_GROUP;
      this.groupNumberDay = littleEndian ? FIRST_NUMBERS_GROUP : SECOND_NUMBERS_GROUP;
    }
    pattern() {
      return PATTERN13;
    }
    extract(context, match3) {
      const index2 = match3.index + match3[OPENING_GROUP].length;
      const indexEnd = match3.index + match3[0].length - match3[ENDING_GROUP].length;
      if (index2 > 0) {
        const textBefore = context.text.substring(0, index2);
        if (textBefore.match("\\d/?$")) {
          return;
        }
      }
      if (indexEnd < context.text.length) {
        const textAfter = context.text.substring(indexEnd);
        if (textAfter.match("^/?\\d")) {
          return;
        }
      }
      const text = context.text.substring(index2, indexEnd);
      if (text.match(/^\d\.\d$/) || text.match(/^\d\.\d{1,2}\.\d{1,2}\s*$/)) {
        return;
      }
      if (!match3[YEAR_GROUP5] && text.indexOf("/") < 0) {
        return;
      }
      const result2 = context.createParsingResult(index2, text);
      let month = parseInt(match3[this.groupNumberMonth]);
      let day = parseInt(match3[this.groupNumberDay]);
      if (month < 1 || month > 12) {
        if (month > 12) {
          if (day >= 1 && day <= 12 && month <= 31) {
            [day, month] = [month, day];
          } else {
            return null;
          }
        }
      }
      if (day < 1 || day > 31) {
        return null;
      }
      result2.start.assign("day", day);
      result2.start.assign("month", month);
      if (match3[YEAR_GROUP5]) {
        const rawYearNumber = parseInt(match3[YEAR_GROUP5]);
        const year = findMostLikelyADYear(rawYearNumber);
        result2.start.assign("year", year);
      } else {
        const year = findYearClosestToRef(context.refDate, day, month);
        result2.start.imply("year", year);
      }
      return result2.addTag("parser/SlashDateFormatParser");
    }
  };

  // node_modules/chrono-node/dist/esm/locales/en/parsers/ENTimeUnitCasualRelativeFormatParser.js
  var PATTERN14 = new RegExp(`(this|last|past|next|after|\\+|-)\\s*(${TIME_UNITS_PATTERN})(?=\\W|$)`, "i");
  var PATTERN_NO_ABBR = new RegExp(`(this|last|past|next|after|\\+|-)\\s*(${TIME_UNITS_NO_ABBR_PATTERN})(?=\\W|$)`, "i");
  var ENTimeUnitCasualRelativeFormatParser = class extends AbstractParserWithWordBoundaryChecking {
    allowAbbreviations;
    constructor(allowAbbreviations = true) {
      super();
      this.allowAbbreviations = allowAbbreviations;
    }
    innerPattern() {
      return this.allowAbbreviations ? PATTERN14 : PATTERN_NO_ABBR;
    }
    innerExtract(context, match3) {
      const prefix3 = match3[1].toLowerCase();
      let duration = parseTimeUnits(match3[2]);
      if (!duration) {
        return null;
      }
      switch (prefix3) {
        case "last":
        case "past":
        case "-":
          duration = reverseDuration(duration);
          break;
      }
      return ParsingComponents.createRelativeFromReference(context.reference, duration);
    }
  };

  // node_modules/chrono-node/dist/esm/locales/en/refiners/ENMergeRelativeAfterDateRefiner.js
  function IsPositiveFollowingReference(result2) {
    return result2.text.match(/^[+-]/i) != null;
  }
  function IsNegativeFollowingReference(result2) {
    return result2.text.match(/^-/i) != null;
  }
  var ENMergeRelativeAfterDateRefiner = class extends MergingRefiner {
    shouldMergeResults(textBetween, currentResult, nextResult) {
      if (!textBetween.match(/^\s*$/i)) {
        return false;
      }
      return IsPositiveFollowingReference(nextResult) || IsNegativeFollowingReference(nextResult);
    }
    mergeResults(textBetween, currentResult, nextResult, context) {
      let timeUnits = parseTimeUnits(nextResult.text);
      if (IsNegativeFollowingReference(nextResult)) {
        timeUnits = reverseTimeUnits(timeUnits);
      }
      const components2 = ParsingComponents.createRelativeFromReference(ReferenceWithTimezone.fromDate(currentResult.start.date()), timeUnits);
      return new ParsingResult(currentResult.reference, currentResult.index, `${currentResult.text}${textBetween}${nextResult.text}`, components2);
    }
  };

  // node_modules/chrono-node/dist/esm/locales/en/refiners/ENMergeRelativeFollowByDateRefiner.js
  function hasImpliedEarlierReferenceDate(result2) {
    return result2.text.match(/\s+(before|from)$/i) != null;
  }
  function hasImpliedLaterReferenceDate(result2) {
    return result2.text.match(/\s+(after|since)$/i) != null;
  }
  var ENMergeRelativeFollowByDateRefiner = class extends MergingRefiner {
    patternBetween() {
      return /^\s*$/i;
    }
    shouldMergeResults(textBetween, currentResult, nextResult) {
      if (!textBetween.match(this.patternBetween())) {
        return false;
      }
      if (!hasImpliedEarlierReferenceDate(currentResult) && !hasImpliedLaterReferenceDate(currentResult)) {
        return false;
      }
      return !!nextResult.start.get("day") && !!nextResult.start.get("month") && !!nextResult.start.get("year");
    }
    mergeResults(textBetween, currentResult, nextResult) {
      let duration = parseTimeUnits(currentResult.text);
      if (hasImpliedEarlierReferenceDate(currentResult)) {
        duration = reverseDuration(duration);
      }
      const components2 = ParsingComponents.createRelativeFromReference(ReferenceWithTimezone.fromDate(nextResult.start.date()), duration);
      return new ParsingResult(nextResult.reference, currentResult.index, `${currentResult.text}${textBetween}${nextResult.text}`, components2);
    }
  };

  // node_modules/chrono-node/dist/esm/locales/en/refiners/ENExtractYearSuffixRefiner.js
  var YEAR_SUFFIX_PATTERN = new RegExp(`^\\s*(${YEAR_PATTERN})`, "i");
  var YEAR_GROUP6 = 1;
  var ENExtractYearSuffixRefiner = class {
    refine(context, results) {
      results.forEach(function(result2) {
        if (!result2.start.isDateWithUnknownYear()) {
          return;
        }
        const suffix = context.text.substring(result2.index + result2.text.length);
        const match3 = YEAR_SUFFIX_PATTERN.exec(suffix);
        if (!match3) {
          return;
        }
        if (match3[0].trim().length <= 3) {
          return;
        }
        context.debug(() => {
          console.log(`Extracting year: '${match3[0]}' into : ${result2}`);
        });
        const year = parseYear(match3[YEAR_GROUP6]);
        if (result2.end != null) {
          result2.end.assign("year", year);
        }
        result2.start.assign("year", year);
        result2.text += match3[0];
      });
      return results;
    }
  };

  // node_modules/chrono-node/dist/esm/locales/en/refiners/ENUnlikelyFormatFilter.js
  var ENUnlikelyFormatFilter = class extends Filter {
    constructor() {
      super();
    }
    isValid(context, result2) {
      const text = result2.text.trim();
      if (text === context.text.trim()) {
        return true;
      }
      if (text.toLowerCase() === "may") {
        const textBefore = context.text.substring(0, result2.index).trim();
        if (!textBefore.match(/\b(in)$/i)) {
          context.debug(() => {
            console.log(`Removing unlikely result: ${result2}`);
          });
          return false;
        }
      }
      if (text.toLowerCase().endsWith("the second")) {
        const textAfter = context.text.substring(result2.index + result2.text.length).trim();
        if (textAfter.length > 0) {
          context.debug(() => {
            console.log(`Removing unlikely result: ${result2}`);
          });
        }
        return false;
      }
      return true;
    }
  };

  // node_modules/chrono-node/dist/esm/locales/en/configuration.js
  var ENDefaultConfiguration = class {
    createCasualConfiguration(littleEndian = false) {
      const option = this.createConfiguration(false, littleEndian);
      option.parsers.push(new ENCasualDateParser());
      option.parsers.push(new ENCasualTimeParser());
      option.parsers.push(new ENMonthNameParser());
      option.parsers.push(new ENRelativeDateFormatParser());
      option.parsers.push(new ENTimeUnitCasualRelativeFormatParser());
      option.refiners.push(new ENUnlikelyFormatFilter());
      return option;
    }
    createConfiguration(strictMode = true, littleEndian = false) {
      const options2 = includeCommonConfiguration({
        parsers: [
          new SlashDateFormatParser(littleEndian),
          new ENTimeUnitWithinFormatParser(strictMode),
          new ENMonthNameLittleEndianParser(),
          new ENMonthNameMiddleEndianParser(littleEndian),
          new ENWeekdayParser(),
          new ENSlashMonthFormatParser(),
          new ENTimeExpressionParser(strictMode),
          new ENTimeUnitAgoFormatParser(strictMode),
          new ENTimeUnitLaterFormatParser(strictMode)
        ],
        refiners: [new ENMergeDateTimeRefiner()]
      }, strictMode);
      options2.parsers.unshift(new ENYearMonthDayParser(strictMode));
      options2.refiners.unshift(new ENMergeRelativeFollowByDateRefiner());
      options2.refiners.unshift(new ENMergeRelativeAfterDateRefiner());
      options2.refiners.unshift(new OverlapRemovalRefiner());
      options2.refiners.push(new ENMergeDateTimeRefiner());
      options2.refiners.push(new ENExtractYearSuffixRefiner());
      options2.refiners.push(new ENMergeDateRangeRefiner());
      return options2;
    }
  };

  // node_modules/chrono-node/dist/esm/chrono.js
  var Chrono = class _Chrono {
    parsers;
    refiners;
    defaultConfig = new ENDefaultConfiguration();
    constructor(configuration2) {
      configuration2 = configuration2 || this.defaultConfig.createCasualConfiguration();
      this.parsers = [...configuration2.parsers];
      this.refiners = [...configuration2.refiners];
    }
    clone() {
      return new _Chrono({
        parsers: [...this.parsers],
        refiners: [...this.refiners]
      });
    }
    parseDate(text, referenceDate, option) {
      const results = this.parse(text, referenceDate, option);
      return results.length > 0 ? results[0].start.date() : null;
    }
    parse(text, referenceDate, option) {
      const context = new ParsingContext(text, referenceDate, option);
      let results = [];
      this.parsers.forEach((parser) => {
        const parsedResults = _Chrono.executeParser(context, parser);
        results = results.concat(parsedResults);
      });
      results.sort((a, b) => {
        return a.index - b.index;
      });
      this.refiners.forEach(function(refiner) {
        results = refiner.refine(context, results);
      });
      return results;
    }
    static executeParser(context, parser) {
      const results = [];
      const pattern = parser.pattern(context);
      const originalText = context.text;
      let remainingText = context.text;
      let match3 = pattern.exec(remainingText);
      while (match3) {
        const index2 = match3.index + originalText.length - remainingText.length;
        match3.index = index2;
        const result2 = parser.extract(context, match3);
        if (!result2) {
          remainingText = originalText.substring(match3.index + 1);
          match3 = pattern.exec(remainingText);
          continue;
        }
        let parsedResult = null;
        if (result2 instanceof ParsingResult) {
          parsedResult = result2;
        } else if (result2 instanceof ParsingComponents) {
          parsedResult = context.createParsingResult(match3.index, match3[0]);
          parsedResult.start = result2;
        } else {
          parsedResult = context.createParsingResult(match3.index, match3[0], result2);
        }
        const parsedIndex = parsedResult.index;
        const parsedText = parsedResult.text;
        context.debug(() => console.log(`${parser.constructor.name} extracted (at index=${parsedIndex}) '${parsedText}'`));
        results.push(parsedResult);
        remainingText = originalText.substring(parsedIndex + parsedText.length);
        match3 = pattern.exec(remainingText);
      }
      return results;
    }
  };
  var ParsingContext = class {
    text;
    option;
    reference;
    refDate;
    constructor(text, refDate, option) {
      this.text = text;
      this.option = option ?? {};
      this.reference = ReferenceWithTimezone.fromInput(refDate, this.option.timezones);
      this.refDate = this.reference.instant;
    }
    createParsingComponents(components2) {
      if (components2 instanceof ParsingComponents) {
        return components2;
      }
      return new ParsingComponents(this.reference, components2);
    }
    createParsingResult(index2, textOrEndIndex, startComponents, endComponents) {
      const text = typeof textOrEndIndex === "string" ? textOrEndIndex : this.text.substring(index2, textOrEndIndex);
      const start3 = startComponents ? this.createParsingComponents(startComponents) : null;
      const end2 = endComponents ? this.createParsingComponents(endComponents) : null;
      return new ParsingResult(this.reference, index2, text, start3, end2);
    }
    debug(block2) {
      if (this.option.debug) {
        if (this.option.debug instanceof Function) {
          this.option.debug(block2);
        } else {
          const handler = this.option.debug;
          handler.debug(block2);
        }
      }
    }
  };

  // node_modules/chrono-node/dist/esm/locales/en/index.js
  var configuration = new ENDefaultConfiguration();
  var casual = new Chrono(configuration.createCasualConfiguration(false));
  var strict = new Chrono(configuration.createConfiguration(true, false));
  var GB = new Chrono(configuration.createCasualConfiguration(true));

  // node_modules/chrono-node/dist/esm/index.js
  var casual2 = casual;
  function parse2(text, ref, option) {
    return casual2.parse(text, ref, option);
  }

  // node_modules/date-fns/constants.js
  var daysInYear = 365.2425;
  var maxTime = Math.pow(10, 8) * 24 * 60 * 60 * 1e3;
  var minTime = -maxTime;
  var millisecondsInWeek = 6048e5;
  var millisecondsInDay = 864e5;
  var millisecondsInMinute = 6e4;
  var millisecondsInHour = 36e5;
  var secondsInHour = 3600;
  var secondsInDay = secondsInHour * 24;
  var secondsInWeek = secondsInDay * 7;
  var secondsInYear = secondsInDay * daysInYear;
  var secondsInMonth = secondsInYear / 12;
  var secondsInQuarter = secondsInMonth * 3;
  var constructFromSymbol = Symbol.for("constructDateFrom");

  // node_modules/date-fns/constructFrom.js
  function constructFrom(date, value) {
    if (typeof date === "function") return date(value);
    if (date && typeof date === "object" && constructFromSymbol in date)
      return date[constructFromSymbol](value);
    if (date instanceof Date) return new date.constructor(value);
    return new Date(value);
  }

  // node_modules/date-fns/toDate.js
  function toDate(argument, context) {
    return constructFrom(context || argument, argument);
  }

  // node_modules/date-fns/addDays.js
  function addDays(date, amount, options2) {
    const _date = toDate(date, options2?.in);
    if (isNaN(amount)) return constructFrom(options2?.in || date, NaN);
    if (!amount) return _date;
    _date.setDate(_date.getDate() + amount);
    return _date;
  }

  // node_modules/date-fns/_lib/defaultOptions.js
  var defaultOptions2 = {};
  function getDefaultOptions() {
    return defaultOptions2;
  }

  // node_modules/date-fns/startOfWeek.js
  function startOfWeek(date, options2) {
    const defaultOptions4 = getDefaultOptions();
    const weekStartsOn = options2?.weekStartsOn ?? options2?.locale?.options?.weekStartsOn ?? defaultOptions4.weekStartsOn ?? defaultOptions4.locale?.options?.weekStartsOn ?? 0;
    const _date = toDate(date, options2?.in);
    const day = _date.getDay();
    const diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
    _date.setDate(_date.getDate() - diff);
    _date.setHours(0, 0, 0, 0);
    return _date;
  }

  // node_modules/date-fns/startOfISOWeek.js
  function startOfISOWeek(date, options2) {
    return startOfWeek(date, { ...options2, weekStartsOn: 1 });
  }

  // node_modules/date-fns/getISOWeekYear.js
  function getISOWeekYear(date, options2) {
    const _date = toDate(date, options2?.in);
    const year = _date.getFullYear();
    const fourthOfJanuaryOfNextYear = constructFrom(_date, 0);
    fourthOfJanuaryOfNextYear.setFullYear(year + 1, 0, 4);
    fourthOfJanuaryOfNextYear.setHours(0, 0, 0, 0);
    const startOfNextYear = startOfISOWeek(fourthOfJanuaryOfNextYear);
    const fourthOfJanuaryOfThisYear = constructFrom(_date, 0);
    fourthOfJanuaryOfThisYear.setFullYear(year, 0, 4);
    fourthOfJanuaryOfThisYear.setHours(0, 0, 0, 0);
    const startOfThisYear = startOfISOWeek(fourthOfJanuaryOfThisYear);
    if (_date.getTime() >= startOfNextYear.getTime()) {
      return year + 1;
    } else if (_date.getTime() >= startOfThisYear.getTime()) {
      return year;
    } else {
      return year - 1;
    }
  }

  // node_modules/date-fns/_lib/getTimezoneOffsetInMilliseconds.js
  function getTimezoneOffsetInMilliseconds(date) {
    const _date = toDate(date);
    const utcDate = new Date(
      Date.UTC(
        _date.getFullYear(),
        _date.getMonth(),
        _date.getDate(),
        _date.getHours(),
        _date.getMinutes(),
        _date.getSeconds(),
        _date.getMilliseconds()
      )
    );
    utcDate.setUTCFullYear(_date.getFullYear());
    return +date - +utcDate;
  }

  // node_modules/date-fns/_lib/normalizeDates.js
  function normalizeDates(context, ...dates) {
    const normalize3 = constructFrom.bind(
      null,
      context || dates.find((date) => typeof date === "object")
    );
    return dates.map(normalize3);
  }

  // node_modules/date-fns/startOfDay.js
  function startOfDay(date, options2) {
    const _date = toDate(date, options2?.in);
    _date.setHours(0, 0, 0, 0);
    return _date;
  }

  // node_modules/date-fns/differenceInCalendarDays.js
  function differenceInCalendarDays(laterDate, earlierDate, options2) {
    const [laterDate_, earlierDate_] = normalizeDates(
      options2?.in,
      laterDate,
      earlierDate
    );
    const laterStartOfDay = startOfDay(laterDate_);
    const earlierStartOfDay = startOfDay(earlierDate_);
    const laterTimestamp = +laterStartOfDay - getTimezoneOffsetInMilliseconds(laterStartOfDay);
    const earlierTimestamp = +earlierStartOfDay - getTimezoneOffsetInMilliseconds(earlierStartOfDay);
    return Math.round((laterTimestamp - earlierTimestamp) / millisecondsInDay);
  }

  // node_modules/date-fns/startOfISOWeekYear.js
  function startOfISOWeekYear(date, options2) {
    const year = getISOWeekYear(date, options2);
    const fourthOfJanuary = constructFrom(options2?.in || date, 0);
    fourthOfJanuary.setFullYear(year, 0, 4);
    fourthOfJanuary.setHours(0, 0, 0, 0);
    return startOfISOWeek(fourthOfJanuary);
  }

  // node_modules/date-fns/addWeeks.js
  function addWeeks(date, amount, options2) {
    return addDays(date, amount * 7, options2);
  }

  // node_modules/date-fns/isDate.js
  function isDate(value) {
    return value instanceof Date || typeof value === "object" && Object.prototype.toString.call(value) === "[object Date]";
  }

  // node_modules/date-fns/isValid.js
  function isValid(date) {
    return !(!isDate(date) && typeof date !== "number" || isNaN(+toDate(date)));
  }

  // node_modules/date-fns/startOfYear.js
  function startOfYear(date, options2) {
    const date_ = toDate(date, options2?.in);
    date_.setFullYear(date_.getFullYear(), 0, 1);
    date_.setHours(0, 0, 0, 0);
    return date_;
  }

  // node_modules/date-fns/locale/en-US/_lib/formatDistance.js
  var formatDistanceLocale = {
    lessThanXSeconds: {
      one: "less than a second",
      other: "less than {{count}} seconds"
    },
    xSeconds: {
      one: "1 second",
      other: "{{count}} seconds"
    },
    halfAMinute: "half a minute",
    lessThanXMinutes: {
      one: "less than a minute",
      other: "less than {{count}} minutes"
    },
    xMinutes: {
      one: "1 minute",
      other: "{{count}} minutes"
    },
    aboutXHours: {
      one: "about 1 hour",
      other: "about {{count}} hours"
    },
    xHours: {
      one: "1 hour",
      other: "{{count}} hours"
    },
    xDays: {
      one: "1 day",
      other: "{{count}} days"
    },
    aboutXWeeks: {
      one: "about 1 week",
      other: "about {{count}} weeks"
    },
    xWeeks: {
      one: "1 week",
      other: "{{count}} weeks"
    },
    aboutXMonths: {
      one: "about 1 month",
      other: "about {{count}} months"
    },
    xMonths: {
      one: "1 month",
      other: "{{count}} months"
    },
    aboutXYears: {
      one: "about 1 year",
      other: "about {{count}} years"
    },
    xYears: {
      one: "1 year",
      other: "{{count}} years"
    },
    overXYears: {
      one: "over 1 year",
      other: "over {{count}} years"
    },
    almostXYears: {
      one: "almost 1 year",
      other: "almost {{count}} years"
    }
  };
  var formatDistance = (token2, count, options2) => {
    let result2;
    const tokenValue = formatDistanceLocale[token2];
    if (typeof tokenValue === "string") {
      result2 = tokenValue;
    } else if (count === 1) {
      result2 = tokenValue.one;
    } else {
      result2 = tokenValue.other.replace("{{count}}", count.toString());
    }
    if (options2?.addSuffix) {
      if (options2.comparison && options2.comparison > 0) {
        return "in " + result2;
      } else {
        return result2 + " ago";
      }
    }
    return result2;
  };

  // node_modules/date-fns/locale/_lib/buildFormatLongFn.js
  function buildFormatLongFn(args) {
    return (options2 = {}) => {
      const width2 = options2.width ? String(options2.width) : args.defaultWidth;
      const format2 = args.formats[width2] || args.formats[args.defaultWidth];
      return format2;
    };
  }

  // node_modules/date-fns/locale/en-US/_lib/formatLong.js
  var dateFormats = {
    full: "EEEE, MMMM do, y",
    long: "MMMM do, y",
    medium: "MMM d, y",
    short: "MM/dd/yyyy"
  };
  var timeFormats = {
    full: "h:mm:ss a zzzz",
    long: "h:mm:ss a z",
    medium: "h:mm:ss a",
    short: "h:mm a"
  };
  var dateTimeFormats = {
    full: "{{date}} 'at' {{time}}",
    long: "{{date}} 'at' {{time}}",
    medium: "{{date}}, {{time}}",
    short: "{{date}}, {{time}}"
  };
  var formatLong = {
    date: buildFormatLongFn({
      formats: dateFormats,
      defaultWidth: "full"
    }),
    time: buildFormatLongFn({
      formats: timeFormats,
      defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
      formats: dateTimeFormats,
      defaultWidth: "full"
    })
  };

  // node_modules/date-fns/locale/en-US/_lib/formatRelative.js
  var formatRelativeLocale = {
    lastWeek: "'last' eeee 'at' p",
    yesterday: "'yesterday at' p",
    today: "'today at' p",
    tomorrow: "'tomorrow at' p",
    nextWeek: "eeee 'at' p",
    other: "P"
  };
  var formatRelative = (token2, _date, _baseDate, _options) => formatRelativeLocale[token2];

  // node_modules/date-fns/locale/_lib/buildLocalizeFn.js
  function buildLocalizeFn(args) {
    return (value, options2) => {
      const context = options2?.context ? String(options2.context) : "standalone";
      let valuesArray;
      if (context === "formatting" && args.formattingValues) {
        const defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
        const width2 = options2?.width ? String(options2.width) : defaultWidth;
        valuesArray = args.formattingValues[width2] || args.formattingValues[defaultWidth];
      } else {
        const defaultWidth = args.defaultWidth;
        const width2 = options2?.width ? String(options2.width) : args.defaultWidth;
        valuesArray = args.values[width2] || args.values[defaultWidth];
      }
      const index2 = args.argumentCallback ? args.argumentCallback(value) : value;
      return valuesArray[index2];
    };
  }

  // node_modules/date-fns/locale/en-US/_lib/localize.js
  var eraValues = {
    narrow: ["B", "A"],
    abbreviated: ["BC", "AD"],
    wide: ["Before Christ", "Anno Domini"]
  };
  var quarterValues = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["Q1", "Q2", "Q3", "Q4"],
    wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
  };
  var monthValues = {
    narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
    abbreviated: [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ],
    wide: [
      "January",
      "February",
      "March",
      "April",
      "May",
      "June",
      "July",
      "August",
      "September",
      "October",
      "November",
      "December"
    ]
  };
  var dayValues = {
    narrow: ["S", "M", "T", "W", "T", "F", "S"],
    short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
    abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    wide: [
      "Sunday",
      "Monday",
      "Tuesday",
      "Wednesday",
      "Thursday",
      "Friday",
      "Saturday"
    ]
  };
  var dayPeriodValues = {
    narrow: {
      am: "a",
      pm: "p",
      midnight: "mi",
      noon: "n",
      morning: "morning",
      afternoon: "afternoon",
      evening: "evening",
      night: "night"
    },
    abbreviated: {
      am: "AM",
      pm: "PM",
      midnight: "midnight",
      noon: "noon",
      morning: "morning",
      afternoon: "afternoon",
      evening: "evening",
      night: "night"
    },
    wide: {
      am: "a.m.",
      pm: "p.m.",
      midnight: "midnight",
      noon: "noon",
      morning: "morning",
      afternoon: "afternoon",
      evening: "evening",
      night: "night"
    }
  };
  var formattingDayPeriodValues = {
    narrow: {
      am: "a",
      pm: "p",
      midnight: "mi",
      noon: "n",
      morning: "in the morning",
      afternoon: "in the afternoon",
      evening: "in the evening",
      night: "at night"
    },
    abbreviated: {
      am: "AM",
      pm: "PM",
      midnight: "midnight",
      noon: "noon",
      morning: "in the morning",
      afternoon: "in the afternoon",
      evening: "in the evening",
      night: "at night"
    },
    wide: {
      am: "a.m.",
      pm: "p.m.",
      midnight: "midnight",
      noon: "noon",
      morning: "in the morning",
      afternoon: "in the afternoon",
      evening: "in the evening",
      night: "at night"
    }
  };
  var ordinalNumber = (dirtyNumber, _options) => {
    const number = Number(dirtyNumber);
    const rem100 = number % 100;
    if (rem100 > 20 || rem100 < 10) {
      switch (rem100 % 10) {
        case 1:
          return number + "st";
        case 2:
          return number + "nd";
        case 3:
          return number + "rd";
      }
    }
    return number + "th";
  };
  var localize = {
    ordinalNumber,
    era: buildLocalizeFn({
      values: eraValues,
      defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
      values: quarterValues,
      defaultWidth: "wide",
      argumentCallback: (quarter) => quarter - 1
    }),
    month: buildLocalizeFn({
      values: monthValues,
      defaultWidth: "wide"
    }),
    day: buildLocalizeFn({
      values: dayValues,
      defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
      values: dayPeriodValues,
      defaultWidth: "wide",
      formattingValues: formattingDayPeriodValues,
      defaultFormattingWidth: "wide"
    })
  };

  // node_modules/date-fns/locale/_lib/buildMatchFn.js
  function buildMatchFn(args) {
    return (string, options2 = {}) => {
      const width2 = options2.width;
      const matchPattern = width2 && args.matchPatterns[width2] || args.matchPatterns[args.defaultMatchWidth];
      const matchResult = string.match(matchPattern);
      if (!matchResult) {
        return null;
      }
      const matchedString = matchResult[0];
      const parsePatterns = width2 && args.parsePatterns[width2] || args.parsePatterns[args.defaultParseWidth];
      const key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, (pattern) => pattern.test(matchedString)) : (
        // [TODO] -- I challenge you to fix the type
        findKey(parsePatterns, (pattern) => pattern.test(matchedString))
      );
      let value;
      value = args.valueCallback ? args.valueCallback(key) : key;
      value = options2.valueCallback ? (
        // [TODO] -- I challenge you to fix the type
        options2.valueCallback(value)
      ) : value;
      const rest = string.slice(matchedString.length);
      return { value, rest };
    };
  }
  function findKey(object, predicate) {
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key) && predicate(object[key])) {
        return key;
      }
    }
    return void 0;
  }
  function findIndex(array, predicate) {
    for (let key = 0; key < array.length; key++) {
      if (predicate(array[key])) {
        return key;
      }
    }
    return void 0;
  }

  // node_modules/date-fns/locale/_lib/buildMatchPatternFn.js
  function buildMatchPatternFn(args) {
    return (string, options2 = {}) => {
      const matchResult = string.match(args.matchPattern);
      if (!matchResult) return null;
      const matchedString = matchResult[0];
      const parseResult = string.match(args.parsePattern);
      if (!parseResult) return null;
      let value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
      value = options2.valueCallback ? options2.valueCallback(value) : value;
      const rest = string.slice(matchedString.length);
      return { value, rest };
    };
  }

  // node_modules/date-fns/locale/en-US/_lib/match.js
  var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
  var parseOrdinalNumberPattern2 = /\d+/i;
  var matchEraPatterns = {
    narrow: /^(b|a)/i,
    abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
    wide: /^(before christ|before common era|anno domini|common era)/i
  };
  var parseEraPatterns = {
    any: [/^b/i, /^(a|c)/i]
  };
  var matchQuarterPatterns = {
    narrow: /^[1234]/i,
    abbreviated: /^q[1234]/i,
    wide: /^[1234](th|st|nd|rd)? quarter/i
  };
  var parseQuarterPatterns = {
    any: [/1/i, /2/i, /3/i, /4/i]
  };
  var matchMonthPatterns = {
    narrow: /^[jfmasond]/i,
    abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
    wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
  };
  var parseMonthPatterns = {
    narrow: [
      /^j/i,
      /^f/i,
      /^m/i,
      /^a/i,
      /^m/i,
      /^j/i,
      /^j/i,
      /^a/i,
      /^s/i,
      /^o/i,
      /^n/i,
      /^d/i
    ],
    any: [
      /^ja/i,
      /^f/i,
      /^mar/i,
      /^ap/i,
      /^may/i,
      /^jun/i,
      /^jul/i,
      /^au/i,
      /^s/i,
      /^o/i,
      /^n/i,
      /^d/i
    ]
  };
  var matchDayPatterns = {
    narrow: /^[smtwf]/i,
    short: /^(su|mo|tu|we|th|fr|sa)/i,
    abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
    wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
  };
  var parseDayPatterns = {
    narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
    any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
  };
  var matchDayPeriodPatterns = {
    narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
    any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
  };
  var parseDayPeriodPatterns = {
    any: {
      am: /^a/i,
      pm: /^p/i,
      midnight: /^mi/i,
      noon: /^no/i,
      morning: /morning/i,
      afternoon: /afternoon/i,
      evening: /evening/i,
      night: /night/i
    }
  };
  var match2 = {
    ordinalNumber: buildMatchPatternFn({
      matchPattern: matchOrdinalNumberPattern,
      parsePattern: parseOrdinalNumberPattern2,
      valueCallback: (value) => parseInt(value, 10)
    }),
    era: buildMatchFn({
      matchPatterns: matchEraPatterns,
      defaultMatchWidth: "wide",
      parsePatterns: parseEraPatterns,
      defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
      matchPatterns: matchQuarterPatterns,
      defaultMatchWidth: "wide",
      parsePatterns: parseQuarterPatterns,
      defaultParseWidth: "any",
      valueCallback: (index2) => index2 + 1
    }),
    month: buildMatchFn({
      matchPatterns: matchMonthPatterns,
      defaultMatchWidth: "wide",
      parsePatterns: parseMonthPatterns,
      defaultParseWidth: "any"
    }),
    day: buildMatchFn({
      matchPatterns: matchDayPatterns,
      defaultMatchWidth: "wide",
      parsePatterns: parseDayPatterns,
      defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
      matchPatterns: matchDayPeriodPatterns,
      defaultMatchWidth: "any",
      parsePatterns: parseDayPeriodPatterns,
      defaultParseWidth: "any"
    })
  };

  // node_modules/date-fns/locale/en-US.js
  var enUS = {
    code: "en-US",
    formatDistance,
    formatLong,
    formatRelative,
    localize,
    match: match2,
    options: {
      weekStartsOn: 0,
      firstWeekContainsDate: 1
    }
  };

  // node_modules/date-fns/getDayOfYear.js
  function getDayOfYear(date, options2) {
    const _date = toDate(date, options2?.in);
    const diff = differenceInCalendarDays(_date, startOfYear(_date));
    const dayOfYear = diff + 1;
    return dayOfYear;
  }

  // node_modules/date-fns/getISOWeek.js
  function getISOWeek(date, options2) {
    const _date = toDate(date, options2?.in);
    const diff = +startOfISOWeek(_date) - +startOfISOWeekYear(_date);
    return Math.round(diff / millisecondsInWeek) + 1;
  }

  // node_modules/date-fns/getWeekYear.js
  function getWeekYear(date, options2) {
    const _date = toDate(date, options2?.in);
    const year = _date.getFullYear();
    const defaultOptions4 = getDefaultOptions();
    const firstWeekContainsDate = options2?.firstWeekContainsDate ?? options2?.locale?.options?.firstWeekContainsDate ?? defaultOptions4.firstWeekContainsDate ?? defaultOptions4.locale?.options?.firstWeekContainsDate ?? 1;
    const firstWeekOfNextYear = constructFrom(options2?.in || date, 0);
    firstWeekOfNextYear.setFullYear(year + 1, 0, firstWeekContainsDate);
    firstWeekOfNextYear.setHours(0, 0, 0, 0);
    const startOfNextYear = startOfWeek(firstWeekOfNextYear, options2);
    const firstWeekOfThisYear = constructFrom(options2?.in || date, 0);
    firstWeekOfThisYear.setFullYear(year, 0, firstWeekContainsDate);
    firstWeekOfThisYear.setHours(0, 0, 0, 0);
    const startOfThisYear = startOfWeek(firstWeekOfThisYear, options2);
    if (+_date >= +startOfNextYear) {
      return year + 1;
    } else if (+_date >= +startOfThisYear) {
      return year;
    } else {
      return year - 1;
    }
  }

  // node_modules/date-fns/startOfWeekYear.js
  function startOfWeekYear(date, options2) {
    const defaultOptions4 = getDefaultOptions();
    const firstWeekContainsDate = options2?.firstWeekContainsDate ?? options2?.locale?.options?.firstWeekContainsDate ?? defaultOptions4.firstWeekContainsDate ?? defaultOptions4.locale?.options?.firstWeekContainsDate ?? 1;
    const year = getWeekYear(date, options2);
    const firstWeek = constructFrom(options2?.in || date, 0);
    firstWeek.setFullYear(year, 0, firstWeekContainsDate);
    firstWeek.setHours(0, 0, 0, 0);
    const _date = startOfWeek(firstWeek, options2);
    return _date;
  }

  // node_modules/date-fns/getWeek.js
  function getWeek(date, options2) {
    const _date = toDate(date, options2?.in);
    const diff = +startOfWeek(_date, options2) - +startOfWeekYear(_date, options2);
    return Math.round(diff / millisecondsInWeek) + 1;
  }

  // node_modules/date-fns/_lib/addLeadingZeros.js
  function addLeadingZeros(number, targetLength) {
    const sign = number < 0 ? "-" : "";
    const output = Math.abs(number).toString().padStart(targetLength, "0");
    return sign + output;
  }

  // node_modules/date-fns/_lib/format/lightFormatters.js
  var lightFormatters = {
    // Year
    y(date, token2) {
      const signedYear = date.getFullYear();
      const year = signedYear > 0 ? signedYear : 1 - signedYear;
      return addLeadingZeros(token2 === "yy" ? year % 100 : year, token2.length);
    },
    // Month
    M(date, token2) {
      const month = date.getMonth();
      return token2 === "M" ? String(month + 1) : addLeadingZeros(month + 1, 2);
    },
    // Day of the month
    d(date, token2) {
      return addLeadingZeros(date.getDate(), token2.length);
    },
    // AM or PM
    a(date, token2) {
      const dayPeriodEnumValue = date.getHours() / 12 >= 1 ? "pm" : "am";
      switch (token2) {
        case "a":
        case "aa":
          return dayPeriodEnumValue.toUpperCase();
        case "aaa":
          return dayPeriodEnumValue;
        case "aaaaa":
          return dayPeriodEnumValue[0];
        case "aaaa":
        default:
          return dayPeriodEnumValue === "am" ? "a.m." : "p.m.";
      }
    },
    // Hour [1-12]
    h(date, token2) {
      return addLeadingZeros(date.getHours() % 12 || 12, token2.length);
    },
    // Hour [0-23]
    H(date, token2) {
      return addLeadingZeros(date.getHours(), token2.length);
    },
    // Minute
    m(date, token2) {
      return addLeadingZeros(date.getMinutes(), token2.length);
    },
    // Second
    s(date, token2) {
      return addLeadingZeros(date.getSeconds(), token2.length);
    },
    // Fraction of second
    S(date, token2) {
      const numberOfDigits = token2.length;
      const milliseconds = date.getMilliseconds();
      const fractionalSeconds = Math.trunc(
        milliseconds * Math.pow(10, numberOfDigits - 3)
      );
      return addLeadingZeros(fractionalSeconds, token2.length);
    }
  };

  // node_modules/date-fns/_lib/format/formatters.js
  var dayPeriodEnum = {
    am: "am",
    pm: "pm",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  };
  var formatters = {
    // Era
    G: function(date, token2, localize2) {
      const era = date.getFullYear() > 0 ? 1 : 0;
      switch (token2) {
        // AD, BC
        case "G":
        case "GG":
        case "GGG":
          return localize2.era(era, { width: "abbreviated" });
        // A, B
        case "GGGGG":
          return localize2.era(era, { width: "narrow" });
        // Anno Domini, Before Christ
        case "GGGG":
        default:
          return localize2.era(era, { width: "wide" });
      }
    },
    // Year
    y: function(date, token2, localize2) {
      if (token2 === "yo") {
        const signedYear = date.getFullYear();
        const year = signedYear > 0 ? signedYear : 1 - signedYear;
        return localize2.ordinalNumber(year, { unit: "year" });
      }
      return lightFormatters.y(date, token2);
    },
    // Local week-numbering year
    Y: function(date, token2, localize2, options2) {
      const signedWeekYear = getWeekYear(date, options2);
      const weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;
      if (token2 === "YY") {
        const twoDigitYear = weekYear % 100;
        return addLeadingZeros(twoDigitYear, 2);
      }
      if (token2 === "Yo") {
        return localize2.ordinalNumber(weekYear, { unit: "year" });
      }
      return addLeadingZeros(weekYear, token2.length);
    },
    // ISO week-numbering year
    R: function(date, token2) {
      const isoWeekYear = getISOWeekYear(date);
      return addLeadingZeros(isoWeekYear, token2.length);
    },
    // Extended year. This is a single number designating the year of this calendar system.
    // The main difference between `y` and `u` localizers are B.C. years:
    // | Year | `y` | `u` |
    // |------|-----|-----|
    // | AC 1 |   1 |   1 |
    // | BC 1 |   1 |   0 |
    // | BC 2 |   2 |  -1 |
    // Also `yy` always returns the last two digits of a year,
    // while `uu` pads single digit years to 2 characters and returns other years unchanged.
    u: function(date, token2) {
      const year = date.getFullYear();
      return addLeadingZeros(year, token2.length);
    },
    // Quarter
    Q: function(date, token2, localize2) {
      const quarter = Math.ceil((date.getMonth() + 1) / 3);
      switch (token2) {
        // 1, 2, 3, 4
        case "Q":
          return String(quarter);
        // 01, 02, 03, 04
        case "QQ":
          return addLeadingZeros(quarter, 2);
        // 1st, 2nd, 3rd, 4th
        case "Qo":
          return localize2.ordinalNumber(quarter, { unit: "quarter" });
        // Q1, Q2, Q3, Q4
        case "QQQ":
          return localize2.quarter(quarter, {
            width: "abbreviated",
            context: "formatting"
          });
        // 1, 2, 3, 4 (narrow quarter; could be not numerical)
        case "QQQQQ":
          return localize2.quarter(quarter, {
            width: "narrow",
            context: "formatting"
          });
        // 1st quarter, 2nd quarter, ...
        case "QQQQ":
        default:
          return localize2.quarter(quarter, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    // Stand-alone quarter
    q: function(date, token2, localize2) {
      const quarter = Math.ceil((date.getMonth() + 1) / 3);
      switch (token2) {
        // 1, 2, 3, 4
        case "q":
          return String(quarter);
        // 01, 02, 03, 04
        case "qq":
          return addLeadingZeros(quarter, 2);
        // 1st, 2nd, 3rd, 4th
        case "qo":
          return localize2.ordinalNumber(quarter, { unit: "quarter" });
        // Q1, Q2, Q3, Q4
        case "qqq":
          return localize2.quarter(quarter, {
            width: "abbreviated",
            context: "standalone"
          });
        // 1, 2, 3, 4 (narrow quarter; could be not numerical)
        case "qqqqq":
          return localize2.quarter(quarter, {
            width: "narrow",
            context: "standalone"
          });
        // 1st quarter, 2nd quarter, ...
        case "qqqq":
        default:
          return localize2.quarter(quarter, {
            width: "wide",
            context: "standalone"
          });
      }
    },
    // Month
    M: function(date, token2, localize2) {
      const month = date.getMonth();
      switch (token2) {
        case "M":
        case "MM":
          return lightFormatters.M(date, token2);
        // 1st, 2nd, ..., 12th
        case "Mo":
          return localize2.ordinalNumber(month + 1, { unit: "month" });
        // Jan, Feb, ..., Dec
        case "MMM":
          return localize2.month(month, {
            width: "abbreviated",
            context: "formatting"
          });
        // J, F, ..., D
        case "MMMMM":
          return localize2.month(month, {
            width: "narrow",
            context: "formatting"
          });
        // January, February, ..., December
        case "MMMM":
        default:
          return localize2.month(month, { width: "wide", context: "formatting" });
      }
    },
    // Stand-alone month
    L: function(date, token2, localize2) {
      const month = date.getMonth();
      switch (token2) {
        // 1, 2, ..., 12
        case "L":
          return String(month + 1);
        // 01, 02, ..., 12
        case "LL":
          return addLeadingZeros(month + 1, 2);
        // 1st, 2nd, ..., 12th
        case "Lo":
          return localize2.ordinalNumber(month + 1, { unit: "month" });
        // Jan, Feb, ..., Dec
        case "LLL":
          return localize2.month(month, {
            width: "abbreviated",
            context: "standalone"
          });
        // J, F, ..., D
        case "LLLLL":
          return localize2.month(month, {
            width: "narrow",
            context: "standalone"
          });
        // January, February, ..., December
        case "LLLL":
        default:
          return localize2.month(month, { width: "wide", context: "standalone" });
      }
    },
    // Local week of year
    w: function(date, token2, localize2, options2) {
      const week = getWeek(date, options2);
      if (token2 === "wo") {
        return localize2.ordinalNumber(week, { unit: "week" });
      }
      return addLeadingZeros(week, token2.length);
    },
    // ISO week of year
    I: function(date, token2, localize2) {
      const isoWeek = getISOWeek(date);
      if (token2 === "Io") {
        return localize2.ordinalNumber(isoWeek, { unit: "week" });
      }
      return addLeadingZeros(isoWeek, token2.length);
    },
    // Day of the month
    d: function(date, token2, localize2) {
      if (token2 === "do") {
        return localize2.ordinalNumber(date.getDate(), { unit: "date" });
      }
      return lightFormatters.d(date, token2);
    },
    // Day of year
    D: function(date, token2, localize2) {
      const dayOfYear = getDayOfYear(date);
      if (token2 === "Do") {
        return localize2.ordinalNumber(dayOfYear, { unit: "dayOfYear" });
      }
      return addLeadingZeros(dayOfYear, token2.length);
    },
    // Day of week
    E: function(date, token2, localize2) {
      const dayOfWeek = date.getDay();
      switch (token2) {
        // Tue
        case "E":
        case "EE":
        case "EEE":
          return localize2.day(dayOfWeek, {
            width: "abbreviated",
            context: "formatting"
          });
        // T
        case "EEEEE":
          return localize2.day(dayOfWeek, {
            width: "narrow",
            context: "formatting"
          });
        // Tu
        case "EEEEEE":
          return localize2.day(dayOfWeek, {
            width: "short",
            context: "formatting"
          });
        // Tuesday
        case "EEEE":
        default:
          return localize2.day(dayOfWeek, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    // Local day of week
    e: function(date, token2, localize2, options2) {
      const dayOfWeek = date.getDay();
      const localDayOfWeek = (dayOfWeek - options2.weekStartsOn + 8) % 7 || 7;
      switch (token2) {
        // Numerical value (Nth day of week with current locale or weekStartsOn)
        case "e":
          return String(localDayOfWeek);
        // Padded numerical value
        case "ee":
          return addLeadingZeros(localDayOfWeek, 2);
        // 1st, 2nd, ..., 7th
        case "eo":
          return localize2.ordinalNumber(localDayOfWeek, { unit: "day" });
        case "eee":
          return localize2.day(dayOfWeek, {
            width: "abbreviated",
            context: "formatting"
          });
        // T
        case "eeeee":
          return localize2.day(dayOfWeek, {
            width: "narrow",
            context: "formatting"
          });
        // Tu
        case "eeeeee":
          return localize2.day(dayOfWeek, {
            width: "short",
            context: "formatting"
          });
        // Tuesday
        case "eeee":
        default:
          return localize2.day(dayOfWeek, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    // Stand-alone local day of week
    c: function(date, token2, localize2, options2) {
      const dayOfWeek = date.getDay();
      const localDayOfWeek = (dayOfWeek - options2.weekStartsOn + 8) % 7 || 7;
      switch (token2) {
        // Numerical value (same as in `e`)
        case "c":
          return String(localDayOfWeek);
        // Padded numerical value
        case "cc":
          return addLeadingZeros(localDayOfWeek, token2.length);
        // 1st, 2nd, ..., 7th
        case "co":
          return localize2.ordinalNumber(localDayOfWeek, { unit: "day" });
        case "ccc":
          return localize2.day(dayOfWeek, {
            width: "abbreviated",
            context: "standalone"
          });
        // T
        case "ccccc":
          return localize2.day(dayOfWeek, {
            width: "narrow",
            context: "standalone"
          });
        // Tu
        case "cccccc":
          return localize2.day(dayOfWeek, {
            width: "short",
            context: "standalone"
          });
        // Tuesday
        case "cccc":
        default:
          return localize2.day(dayOfWeek, {
            width: "wide",
            context: "standalone"
          });
      }
    },
    // ISO day of week
    i: function(date, token2, localize2) {
      const dayOfWeek = date.getDay();
      const isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;
      switch (token2) {
        // 2
        case "i":
          return String(isoDayOfWeek);
        // 02
        case "ii":
          return addLeadingZeros(isoDayOfWeek, token2.length);
        // 2nd
        case "io":
          return localize2.ordinalNumber(isoDayOfWeek, { unit: "day" });
        // Tue
        case "iii":
          return localize2.day(dayOfWeek, {
            width: "abbreviated",
            context: "formatting"
          });
        // T
        case "iiiii":
          return localize2.day(dayOfWeek, {
            width: "narrow",
            context: "formatting"
          });
        // Tu
        case "iiiiii":
          return localize2.day(dayOfWeek, {
            width: "short",
            context: "formatting"
          });
        // Tuesday
        case "iiii":
        default:
          return localize2.day(dayOfWeek, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    // AM or PM
    a: function(date, token2, localize2) {
      const hours = date.getHours();
      const dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
      switch (token2) {
        case "a":
        case "aa":
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "abbreviated",
            context: "formatting"
          });
        case "aaa":
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "abbreviated",
            context: "formatting"
          }).toLowerCase();
        case "aaaaa":
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "narrow",
            context: "formatting"
          });
        case "aaaa":
        default:
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    // AM, PM, midnight, noon
    b: function(date, token2, localize2) {
      const hours = date.getHours();
      let dayPeriodEnumValue;
      if (hours === 12) {
        dayPeriodEnumValue = dayPeriodEnum.noon;
      } else if (hours === 0) {
        dayPeriodEnumValue = dayPeriodEnum.midnight;
      } else {
        dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
      }
      switch (token2) {
        case "b":
        case "bb":
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "abbreviated",
            context: "formatting"
          });
        case "bbb":
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "abbreviated",
            context: "formatting"
          }).toLowerCase();
        case "bbbbb":
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "narrow",
            context: "formatting"
          });
        case "bbbb":
        default:
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    // in the morning, in the afternoon, in the evening, at night
    B: function(date, token2, localize2) {
      const hours = date.getHours();
      let dayPeriodEnumValue;
      if (hours >= 17) {
        dayPeriodEnumValue = dayPeriodEnum.evening;
      } else if (hours >= 12) {
        dayPeriodEnumValue = dayPeriodEnum.afternoon;
      } else if (hours >= 4) {
        dayPeriodEnumValue = dayPeriodEnum.morning;
      } else {
        dayPeriodEnumValue = dayPeriodEnum.night;
      }
      switch (token2) {
        case "B":
        case "BB":
        case "BBB":
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "abbreviated",
            context: "formatting"
          });
        case "BBBBB":
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "narrow",
            context: "formatting"
          });
        case "BBBB":
        default:
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    // Hour [1-12]
    h: function(date, token2, localize2) {
      if (token2 === "ho") {
        let hours = date.getHours() % 12;
        if (hours === 0) hours = 12;
        return localize2.ordinalNumber(hours, { unit: "hour" });
      }
      return lightFormatters.h(date, token2);
    },
    // Hour [0-23]
    H: function(date, token2, localize2) {
      if (token2 === "Ho") {
        return localize2.ordinalNumber(date.getHours(), { unit: "hour" });
      }
      return lightFormatters.H(date, token2);
    },
    // Hour [0-11]
    K: function(date, token2, localize2) {
      const hours = date.getHours() % 12;
      if (token2 === "Ko") {
        return localize2.ordinalNumber(hours, { unit: "hour" });
      }
      return addLeadingZeros(hours, token2.length);
    },
    // Hour [1-24]
    k: function(date, token2, localize2) {
      let hours = date.getHours();
      if (hours === 0) hours = 24;
      if (token2 === "ko") {
        return localize2.ordinalNumber(hours, { unit: "hour" });
      }
      return addLeadingZeros(hours, token2.length);
    },
    // Minute
    m: function(date, token2, localize2) {
      if (token2 === "mo") {
        return localize2.ordinalNumber(date.getMinutes(), { unit: "minute" });
      }
      return lightFormatters.m(date, token2);
    },
    // Second
    s: function(date, token2, localize2) {
      if (token2 === "so") {
        return localize2.ordinalNumber(date.getSeconds(), { unit: "second" });
      }
      return lightFormatters.s(date, token2);
    },
    // Fraction of second
    S: function(date, token2) {
      return lightFormatters.S(date, token2);
    },
    // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
    X: function(date, token2, _localize) {
      const timezoneOffset = date.getTimezoneOffset();
      if (timezoneOffset === 0) {
        return "Z";
      }
      switch (token2) {
        // Hours and optional minutes
        case "X":
          return formatTimezoneWithOptionalMinutes(timezoneOffset);
        // Hours, minutes and optional seconds without `:` delimiter
        // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
        // so this token always has the same output as `XX`
        case "XXXX":
        case "XX":
          return formatTimezone(timezoneOffset);
        // Hours, minutes and optional seconds with `:` delimiter
        // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
        // so this token always has the same output as `XXX`
        case "XXXXX":
        case "XXX":
        // Hours and minutes with `:` delimiter
        default:
          return formatTimezone(timezoneOffset, ":");
      }
    },
    // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
    x: function(date, token2, _localize) {
      const timezoneOffset = date.getTimezoneOffset();
      switch (token2) {
        // Hours and optional minutes
        case "x":
          return formatTimezoneWithOptionalMinutes(timezoneOffset);
        // Hours, minutes and optional seconds without `:` delimiter
        // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
        // so this token always has the same output as `xx`
        case "xxxx":
        case "xx":
          return formatTimezone(timezoneOffset);
        // Hours, minutes and optional seconds with `:` delimiter
        // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
        // so this token always has the same output as `xxx`
        case "xxxxx":
        case "xxx":
        // Hours and minutes with `:` delimiter
        default:
          return formatTimezone(timezoneOffset, ":");
      }
    },
    // Timezone (GMT)
    O: function(date, token2, _localize) {
      const timezoneOffset = date.getTimezoneOffset();
      switch (token2) {
        // Short
        case "O":
        case "OO":
        case "OOO":
          return "GMT" + formatTimezoneShort(timezoneOffset, ":");
        // Long
        case "OOOO":
        default:
          return "GMT" + formatTimezone(timezoneOffset, ":");
      }
    },
    // Timezone (specific non-location)
    z: function(date, token2, _localize) {
      const timezoneOffset = date.getTimezoneOffset();
      switch (token2) {
        // Short
        case "z":
        case "zz":
        case "zzz":
          return "GMT" + formatTimezoneShort(timezoneOffset, ":");
        // Long
        case "zzzz":
        default:
          return "GMT" + formatTimezone(timezoneOffset, ":");
      }
    },
    // Seconds timestamp
    t: function(date, token2, _localize) {
      const timestamp = Math.trunc(+date / 1e3);
      return addLeadingZeros(timestamp, token2.length);
    },
    // Milliseconds timestamp
    T: function(date, token2, _localize) {
      return addLeadingZeros(+date, token2.length);
    }
  };
  function formatTimezoneShort(offset3, delimiter2 = "") {
    const sign = offset3 > 0 ? "-" : "+";
    const absOffset = Math.abs(offset3);
    const hours = Math.trunc(absOffset / 60);
    const minutes = absOffset % 60;
    if (minutes === 0) {
      return sign + String(hours);
    }
    return sign + String(hours) + delimiter2 + addLeadingZeros(minutes, 2);
  }
  function formatTimezoneWithOptionalMinutes(offset3, delimiter2) {
    if (offset3 % 60 === 0) {
      const sign = offset3 > 0 ? "-" : "+";
      return sign + addLeadingZeros(Math.abs(offset3) / 60, 2);
    }
    return formatTimezone(offset3, delimiter2);
  }
  function formatTimezone(offset3, delimiter2 = "") {
    const sign = offset3 > 0 ? "-" : "+";
    const absOffset = Math.abs(offset3);
    const hours = addLeadingZeros(Math.trunc(absOffset / 60), 2);
    const minutes = addLeadingZeros(absOffset % 60, 2);
    return sign + hours + delimiter2 + minutes;
  }

  // node_modules/date-fns/_lib/format/longFormatters.js
  var dateLongFormatter = (pattern, formatLong2) => {
    switch (pattern) {
      case "P":
        return formatLong2.date({ width: "short" });
      case "PP":
        return formatLong2.date({ width: "medium" });
      case "PPP":
        return formatLong2.date({ width: "long" });
      case "PPPP":
      default:
        return formatLong2.date({ width: "full" });
    }
  };
  var timeLongFormatter = (pattern, formatLong2) => {
    switch (pattern) {
      case "p":
        return formatLong2.time({ width: "short" });
      case "pp":
        return formatLong2.time({ width: "medium" });
      case "ppp":
        return formatLong2.time({ width: "long" });
      case "pppp":
      default:
        return formatLong2.time({ width: "full" });
    }
  };
  var dateTimeLongFormatter = (pattern, formatLong2) => {
    const matchResult = pattern.match(/(P+)(p+)?/) || [];
    const datePattern = matchResult[1];
    const timePattern = matchResult[2];
    if (!timePattern) {
      return dateLongFormatter(pattern, formatLong2);
    }
    let dateTimeFormat;
    switch (datePattern) {
      case "P":
        dateTimeFormat = formatLong2.dateTime({ width: "short" });
        break;
      case "PP":
        dateTimeFormat = formatLong2.dateTime({ width: "medium" });
        break;
      case "PPP":
        dateTimeFormat = formatLong2.dateTime({ width: "long" });
        break;
      case "PPPP":
      default:
        dateTimeFormat = formatLong2.dateTime({ width: "full" });
        break;
    }
    return dateTimeFormat.replace("{{date}}", dateLongFormatter(datePattern, formatLong2)).replace("{{time}}", timeLongFormatter(timePattern, formatLong2));
  };
  var longFormatters = {
    p: timeLongFormatter,
    P: dateTimeLongFormatter
  };

  // node_modules/date-fns/_lib/protectedTokens.js
  var dayOfYearTokenRE = /^D+$/;
  var weekYearTokenRE = /^Y+$/;
  var throwTokens = ["D", "DD", "YY", "YYYY"];
  function isProtectedDayOfYearToken(token2) {
    return dayOfYearTokenRE.test(token2);
  }
  function isProtectedWeekYearToken(token2) {
    return weekYearTokenRE.test(token2);
  }
  function warnOrThrowProtectedError(token2, format2, input) {
    const _message = message(token2, format2, input);
    console.warn(_message);
    if (throwTokens.includes(token2)) throw new RangeError(_message);
  }
  function message(token2, format2, input) {
    const subject = token2[0] === "Y" ? "years" : "days of the month";
    return `Use \`${token2.toLowerCase()}\` instead of \`${token2}\` (in \`${format2}\`) for formatting ${subject} to the input \`${input}\`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md`;
  }

  // node_modules/date-fns/format.js
  var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
  var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
  var escapedStringRegExp = /^'([^]*?)'?$/;
  var doubleQuoteRegExp = /''/g;
  var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
  function format(date, formatStr, options2) {
    const defaultOptions4 = getDefaultOptions();
    const locale = options2?.locale ?? defaultOptions4.locale ?? enUS;
    const firstWeekContainsDate = options2?.firstWeekContainsDate ?? options2?.locale?.options?.firstWeekContainsDate ?? defaultOptions4.firstWeekContainsDate ?? defaultOptions4.locale?.options?.firstWeekContainsDate ?? 1;
    const weekStartsOn = options2?.weekStartsOn ?? options2?.locale?.options?.weekStartsOn ?? defaultOptions4.weekStartsOn ?? defaultOptions4.locale?.options?.weekStartsOn ?? 0;
    const originalDate = toDate(date, options2?.in);
    if (!isValid(originalDate)) {
      throw new RangeError("Invalid time value");
    }
    let parts = formatStr.match(longFormattingTokensRegExp).map((substring) => {
      const firstCharacter = substring[0];
      if (firstCharacter === "p" || firstCharacter === "P") {
        const longFormatter = longFormatters[firstCharacter];
        return longFormatter(substring, locale.formatLong);
      }
      return substring;
    }).join("").match(formattingTokensRegExp).map((substring) => {
      if (substring === "''") {
        return { isToken: false, value: "'" };
      }
      const firstCharacter = substring[0];
      if (firstCharacter === "'") {
        return { isToken: false, value: cleanEscapedString(substring) };
      }
      if (formatters[firstCharacter]) {
        return { isToken: true, value: substring };
      }
      if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
        throw new RangeError(
          "Format string contains an unescaped latin alphabet character `" + firstCharacter + "`"
        );
      }
      return { isToken: false, value: substring };
    });
    if (locale.localize.preprocessor) {
      parts = locale.localize.preprocessor(originalDate, parts);
    }
    const formatterOptions = {
      firstWeekContainsDate,
      weekStartsOn,
      locale
    };
    return parts.map((part) => {
      if (!part.isToken) return part.value;
      const token2 = part.value;
      if (!options2?.useAdditionalWeekYearTokens && isProtectedWeekYearToken(token2) || !options2?.useAdditionalDayOfYearTokens && isProtectedDayOfYearToken(token2)) {
        warnOrThrowProtectedError(token2, formatStr, String(date));
      }
      const formatter = formatters[token2[0]];
      return formatter(originalDate, token2, locale.localize, formatterOptions);
    }).join("");
  }
  function cleanEscapedString(input) {
    const matched = input.match(escapedStringRegExp);
    if (!matched) {
      return input;
    }
    return matched[1].replace(doubleQuoteRegExp, "'");
  }

  // node_modules/date-fns/lastDayOfMonth.js
  function lastDayOfMonth(date, options2) {
    const _date = toDate(date, options2?.in);
    const month = _date.getMonth();
    _date.setFullYear(_date.getFullYear(), month + 1, 0);
    _date.setHours(0, 0, 0, 0);
    return toDate(_date, options2?.in);
  }

  // node_modules/date-fns/isAfter.js
  function isAfter(date, dateToCompare) {
    return +toDate(date) > +toDate(dateToCompare);
  }

  // node_modules/date-fns/isBefore.js
  function isBefore(date, dateToCompare) {
    return +toDate(date) < +toDate(dateToCompare);
  }

  // node_modules/date-fns/isSameWeek.js
  function isSameWeek(laterDate, earlierDate, options2) {
    const [laterDate_, earlierDate_] = normalizeDates(
      options2?.in,
      laterDate,
      earlierDate
    );
    return +startOfWeek(laterDate_, options2) === +startOfWeek(earlierDate_, options2);
  }

  // node_modules/date-fns/subDays.js
  function subDays(date, amount, options2) {
    return addDays(date, -amount, options2);
  }

  // node_modules/date-fns/parseISO.js
  function parseISO(argument, options2) {
    const invalidDate = () => constructFrom(options2?.in, NaN);
    const additionalDigits = options2?.additionalDigits ?? 2;
    const dateStrings = splitDateString(argument);
    let date;
    if (dateStrings.date) {
      const parseYearResult = parseYear2(dateStrings.date, additionalDigits);
      date = parseDate(parseYearResult.restDateString, parseYearResult.year);
    }
    if (!date || isNaN(+date)) return invalidDate();
    const timestamp = +date;
    let time = 0;
    let offset3;
    if (dateStrings.time) {
      time = parseTime(dateStrings.time);
      if (isNaN(time)) return invalidDate();
    }
    if (dateStrings.timezone) {
      offset3 = parseTimezone(dateStrings.timezone);
      if (isNaN(offset3)) return invalidDate();
    } else {
      const tmpDate = new Date(timestamp + time);
      const result2 = toDate(0, options2?.in);
      result2.setFullYear(
        tmpDate.getUTCFullYear(),
        tmpDate.getUTCMonth(),
        tmpDate.getUTCDate()
      );
      result2.setHours(
        tmpDate.getUTCHours(),
        tmpDate.getUTCMinutes(),
        tmpDate.getUTCSeconds(),
        tmpDate.getUTCMilliseconds()
      );
      return result2;
    }
    return toDate(timestamp + time + offset3, options2?.in);
  }
  var patterns = {
    dateTimeDelimiter: /[T ]/,
    timeZoneDelimiter: /[Z ]/i,
    timezone: /([Z+-].*)$/
  };
  var dateRegex = /^-?(?:(\d{3})|(\d{2})(?:-?(\d{2}))?|W(\d{2})(?:-?(\d{1}))?|)$/;
  var timeRegex = /^(\d{2}(?:[.,]\d*)?)(?::?(\d{2}(?:[.,]\d*)?))?(?::?(\d{2}(?:[.,]\d*)?))?$/;
  var timezoneRegex = /^([+-])(\d{2})(?::?(\d{2}))?$/;
  function splitDateString(dateString) {
    const dateStrings = {};
    const array = dateString.split(patterns.dateTimeDelimiter);
    let timeString;
    if (array.length > 2) {
      return dateStrings;
    }
    if (/:/.test(array[0])) {
      timeString = array[0];
    } else {
      dateStrings.date = array[0];
      timeString = array[1];
      if (patterns.timeZoneDelimiter.test(dateStrings.date)) {
        dateStrings.date = dateString.split(patterns.timeZoneDelimiter)[0];
        timeString = dateString.substr(
          dateStrings.date.length,
          dateString.length
        );
      }
    }
    if (timeString) {
      const token2 = patterns.timezone.exec(timeString);
      if (token2) {
        dateStrings.time = timeString.replace(token2[1], "");
        dateStrings.timezone = token2[1];
      } else {
        dateStrings.time = timeString;
      }
    }
    return dateStrings;
  }
  function parseYear2(dateString, additionalDigits) {
    const regex = new RegExp(
      "^(?:(\\d{4}|[+-]\\d{" + (4 + additionalDigits) + "})|(\\d{2}|[+-]\\d{" + (2 + additionalDigits) + "})$)"
    );
    const captures = dateString.match(regex);
    if (!captures) return { year: NaN, restDateString: "" };
    const year = captures[1] ? parseInt(captures[1]) : null;
    const century = captures[2] ? parseInt(captures[2]) : null;
    return {
      year: century === null ? year : century * 100,
      restDateString: dateString.slice((captures[1] || captures[2]).length)
    };
  }
  function parseDate(dateString, year) {
    if (year === null) return /* @__PURE__ */ new Date(NaN);
    const captures = dateString.match(dateRegex);
    if (!captures) return /* @__PURE__ */ new Date(NaN);
    const isWeekDate = !!captures[4];
    const dayOfYear = parseDateUnit(captures[1]);
    const month = parseDateUnit(captures[2]) - 1;
    const day = parseDateUnit(captures[3]);
    const week = parseDateUnit(captures[4]);
    const dayOfWeek = parseDateUnit(captures[5]) - 1;
    if (isWeekDate) {
      if (!validateWeekDate(year, week, dayOfWeek)) {
        return /* @__PURE__ */ new Date(NaN);
      }
      return dayOfISOWeekYear(year, week, dayOfWeek);
    } else {
      const date = /* @__PURE__ */ new Date(0);
      if (!validateDate(year, month, day) || !validateDayOfYearDate(year, dayOfYear)) {
        return /* @__PURE__ */ new Date(NaN);
      }
      date.setUTCFullYear(year, month, Math.max(dayOfYear, day));
      return date;
    }
  }
  function parseDateUnit(value) {
    return value ? parseInt(value) : 1;
  }
  function parseTime(timeString) {
    const captures = timeString.match(timeRegex);
    if (!captures) return NaN;
    const hours = parseTimeUnit(captures[1]);
    const minutes = parseTimeUnit(captures[2]);
    const seconds = parseTimeUnit(captures[3]);
    if (!validateTime(hours, minutes, seconds)) {
      return NaN;
    }
    return hours * millisecondsInHour + minutes * millisecondsInMinute + seconds * 1e3;
  }
  function parseTimeUnit(value) {
    return value && parseFloat(value.replace(",", ".")) || 0;
  }
  function parseTimezone(timezoneString) {
    if (timezoneString === "Z") return 0;
    const captures = timezoneString.match(timezoneRegex);
    if (!captures) return 0;
    const sign = captures[1] === "+" ? -1 : 1;
    const hours = parseInt(captures[2]);
    const minutes = captures[3] && parseInt(captures[3]) || 0;
    if (!validateTimezone(hours, minutes)) {
      return NaN;
    }
    return sign * (hours * millisecondsInHour + minutes * millisecondsInMinute);
  }
  function dayOfISOWeekYear(isoWeekYear, week, day) {
    const date = /* @__PURE__ */ new Date(0);
    date.setUTCFullYear(isoWeekYear, 0, 4);
    const fourthOfJanuaryDay = date.getUTCDay() || 7;
    const diff = (week - 1) * 7 + day + 1 - fourthOfJanuaryDay;
    date.setUTCDate(date.getUTCDate() + diff);
    return date;
  }
  var daysInMonths = [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  function isLeapYearIndex(year) {
    return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
  }
  function validateDate(year, month, date) {
    return month >= 0 && month <= 11 && date >= 1 && date <= (daysInMonths[month] || (isLeapYearIndex(year) ? 29 : 28));
  }
  function validateDayOfYearDate(year, dayOfYear) {
    return dayOfYear >= 1 && dayOfYear <= (isLeapYearIndex(year) ? 366 : 365);
  }
  function validateWeekDate(_year, week, day) {
    return week >= 1 && week <= 53 && day >= 0 && day <= 6;
  }
  function validateTime(hours, minutes, seconds) {
    if (hours === 24) {
      return minutes === 0 && seconds === 0;
    }
    return seconds >= 0 && seconds < 60 && minutes >= 0 && minutes < 60 && hours >= 0 && hours < 25;
  }
  function validateTimezone(_hours, minutes) {
    return minutes >= 0 && minutes <= 59;
  }

  // node_modules/date-fns/subWeeks.js
  function subWeeks(date, amount, options2) {
    return addWeeks(date, -amount, options2);
  }

  // src/utils/globalState.ts
  var cloudId = null;
  var sectionId = null;
  function setGlobalCloudAndSection({ newCloudId, newSectionId }) {
    cloudId = newCloudId;
    sectionId = newSectionId;
  }
  function getGlobalCloudId() {
    return cloudId;
  }
  function getGlobalSectionId() {
    return sectionId;
  }

  // src/utils/timelineUtils/timeline.ts
  var MONTHS = [
    "jan",
    "feb",
    "mar",
    "apr",
    "may",
    "jun",
    "jul",
    "aug",
    "sep",
    "oct",
    "nov",
    "dec"
  ];
  function safeParseDate(dateStr) {
    if (!dateStr) return /* @__PURE__ */ new Date("Invalid Date");
    let d = parseISO(dateStr);
    if (!isValid(d)) d = new Date(dateStr);
    return d;
  }
  function getWeekRanges(startDate, endDate) {
    const weeks = [];
    let current = startOfWeek(startDate, { weekStartsOn: 1 });
    let last = startOfWeek(endDate, { weekStartsOn: 1 });
    const now2 = /* @__PURE__ */ new Date();
    const thisWeek = startOfWeek(now2, { weekStartsOn: 1 });
    if (isAfter(thisWeek, last)) {
      last = thisWeek;
    }
    while (!isAfter(current, last)) {
      const weekStart = current;
      const weekEnd = addWeeks(weekStart, 1);
      const weekEndLabel = subDays(weekEnd, 1);
      let label;
      if (isSameWeek(weekStart, now2, { weekStartsOn: 1 })) {
        label = "This week";
      } else if (isSameWeek(weekStart, startOfWeek(subWeeks(now2, 1), { weekStartsOn: 1 }), { weekStartsOn: 1 })) {
        label = "Last week";
      } else {
        const startDay = format(weekStart, "d");
        const startMonth = format(weekStart, "MMM");
        const endDay = format(weekEndLabel, "d");
        const endMonth = format(weekEndLabel, "MMM");
        if (startMonth === endMonth) {
          label = `${startDay}-${endDay} ${startMonth}`;
        } else {
          label = `${startDay} ${startMonth}-${endDay} ${endMonth}`;
        }
      }
      weeks.push({
        label,
        start: weekStart,
        end: weekEnd
      });
      current = addWeeks(current, 1);
    }
    return weeks;
  }
  function getAllProjectDates(projects, updatesByProject) {
    let minDate = null;
    let maxDate = null;
    (projects || []).forEach((proj) => {
      const updates = updatesByProject[proj.projectKey] || [];
      updates.forEach((u) => {
        if (u && u.creationDate) {
          const date = safeParseDate(u.creationDate);
          if (date && !isNaN(date.getTime())) {
            if (!minDate || isBefore(date, minDate)) minDate = date;
            if (!maxDate || isAfter(date, maxDate)) maxDate = date;
          }
        }
      });
    });
    return { minDate, maxDate };
  }
  function buildProjectUrlFromKey(projectKey) {
    const cloudId2 = getGlobalCloudId();
    const sectionId2 = getGlobalSectionId();
    if (!cloudId2 || !sectionId2 || !projectKey) return void 0;
    return `https://home.atlassian.com/o/${cloudId2}/s/${sectionId2}/project/${projectKey}/updates`;
  }
  function parseFlexibleDateChrono(dateStr, year = (/* @__PURE__ */ new Date()).getFullYear(), isEnd = false) {
    if (!dateStr || typeof dateStr !== "string") return null;
    if (dateStr.includes("-")) {
      const [start3, end2] = dateStr.split("-").map((s) => s.trim());
      return parseFlexibleDateChrono(end2, year, true);
    }
    const monthIdx = MONTHS.findIndex((m) => dateStr.toLowerCase().startsWith(m));
    if (monthIdx !== -1) {
      if (isEnd) {
        return lastDayOfMonth(new Date(year, monthIdx, 1));
      } else {
        return new Date(year, monthIdx, 1);
      }
    }
    const dayMonthMatch = dateStr.match(/^(\d{1,2})\s+([A-Za-z]{3,})$/);
    if (dayMonthMatch) {
      const day = parseInt(dayMonthMatch[1], 10);
      const monthStr = dayMonthMatch[2].toLowerCase();
      const idx = MONTHS.findIndex((m) => monthStr.startsWith(m));
      if (idx !== -1) {
        return new Date(year, idx, day);
      }
    }
    const refDate = /* @__PURE__ */ new Date(`${year}-01-01`);
    const results = parse2(dateStr, refDate);
    if (results.length > 0) {
      return results[0].start.date();
    }
    return null;
  }
  function daysBetweenFlexibleDates(dateStr1, dateStr2, year) {
    if (!dateStr1 || !dateStr2 || typeof dateStr1 !== "string" || typeof dateStr2 !== "string") {
      return null;
    }
    const d1 = parseFlexibleDateChrono(dateStr1, year, dateStr1.includes("-") ? true : false);
    const d2 = parseFlexibleDateChrono(dateStr2, year, true);
    if (!d1 || !d2) return null;
    const diff = differenceInCalendarDays(d2, d1);
    if (diff === 0) return 1;
    return diff > 0 ? diff + 1 : diff - 1;
  }
  function getTargetDateDisplay(dateStr) {
    if (!dateStr || typeof dateStr !== "string") {
      return "No date";
    }
    const d = safeParseDate(dateStr);
    if (d && !isNaN(d.getTime())) {
      return format(d, "d MMM yyyy");
    }
    return dateStr;
  }
  function getTimelineWeekCells(weekRanges, updates) {
    if (!updates || !Array.isArray(updates)) {
      return weekRanges.map(() => ({
        cellClass: "timeline-cell state-none",
        weekUpdates: []
      }));
    }
    const validUpdates = updates.filter((u) => {
      if (!u) return false;
      const creationDate = u.creationDate || u.raw?.creationDate;
      return creationDate && typeof creationDate === "string";
    });
    return weekRanges.map((w2) => {
      const weekStart = w2.start;
      const weekEnd = w2.end;
      const weekUpdates = validUpdates.filter((u) => {
        const creationDate = u.creationDate || u.raw?.creationDate;
        const d = safeParseDate(creationDate);
        return d && d >= weekStart && d < weekEnd;
      });
      const lastUpdate = weekUpdates.length > 0 ? weekUpdates[weekUpdates.length - 1] : void 0;
      let stateClass = "state-none";
      if (lastUpdate) {
        if (lastUpdate.missedUpdate) stateClass = "state-missed-update";
        else if (lastUpdate.state && typeof lastUpdate.state === "string") {
          stateClass = `state-${lastUpdate.state.replace(/_/g, "-").toLowerCase()}`;
        }
      }
      let oldStateClass = "";
      if (lastUpdate && lastUpdate.oldState && typeof lastUpdate.oldState === "string") {
        oldStateClass = `old-state-${lastUpdate.oldState.replace(/_/g, "-").toLowerCase()}`;
      }
      const cellClass = [
        "timeline-cell",
        weekUpdates.length > 0 ? "has-update" : "",
        stateClass,
        oldStateClass
      ].filter(Boolean).join(" ");
      return {
        cellClass,
        weekUpdates
      };
    });
  }
  function getDueDateTooltip(u) {
    if (u && u.oldDueDate && u.newDueDate) {
      return `${u.oldDueDate} \u2192 ${u.newDueDate}`;
    }
    return null;
  }
  function getDueDateDiff(u) {
    if (u && u.oldDueDate && u.newDueDate) {
      return daysBetweenFlexibleDates(u.oldDueDate, u.newDueDate, (/* @__PURE__ */ new Date()).getFullYear());
    }
    return null;
  }

  // src/utils/proseMirrorRenderer.ts
  function renderProseMirror(summary) {
    if (!summary) return "No summary available";
    let parsedSummary = summary;
    if (typeof summary === "string") {
      if (summary.startsWith("{") && summary.endsWith("}")) {
        try {
          parsedSummary = JSON.parse(summary);
        } catch (error) {
          return summary;
        }
      } else {
        return summary;
      }
    }
    if (parsedSummary && typeof parsedSummary === "object" && parsedSummary.content) {
      try {
        const rendered = renderProseMirrorManually(parsedSummary);
        return rendered;
      } catch (error) {
        console.error("Error rendering ProseMirror content:", error);
        return `Summary rendering error: ${error instanceof Error ? error.message : String(error)}`;
      }
    }
    return "No summary available";
  }
  function renderProseMirrorManually(doc) {
    if (!doc.content || !Array.isArray(doc.content)) {
      return "Invalid document structure";
    }
    let html = "";
    for (const node2 of doc.content) {
      html += renderNode(node2);
    }
    return html;
  }
  function renderNode(node2) {
    if (!node2) return "";
    switch (node2.type) {
      case "paragraph":
        return `<p>${renderNodeContent(node2.content)}</p>`;
      case "text":
        let text = node2.text || "";
        if (node2.marks) {
          for (const mark of node2.marks) {
            switch (mark.type) {
              case "strong":
              case "bold":
                text = `<strong>${text}</strong>`;
                break;
              case "em":
              case "italic":
                text = `<em>${text}</em>`;
                break;
              case "code":
                text = `<code>${text}</code>`;
                break;
            }
          }
        }
        return text;
      case "emoji":
        return node2.attrs?.text || "\u{1F60A}";
      case "bullet_list":
      case "bulletList":
        return `<ul>${renderNodeContent(node2.content)}</ul>`;
      case "ordered_list":
      case "orderedList":
        return `<ol>${renderNodeContent(node2.content)}</ol>`;
      case "list_item":
      case "listItem":
        return `<li>${renderNodeContent(node2.content)}</li>`;
      case "heading":
        const level = node2.attrs?.level || 1;
        return `<h${level}>${renderNodeContent(node2.content)}</h${level}>`;
      case "inlineCard":
        const url = node2.attrs?.url || "#";
        return `<a href="${url}" target="_blank" style="color: #0052CC; text-decoration: underline;">${url}</a>`;
      case "hardBreak":
        return "<br>";
      case "date":
        const timestamp = node2.attrs?.timestamp;
        if (timestamp) {
          try {
            const date = new Date(parseInt(timestamp));
            const formattedDate = date.toLocaleDateString("en-US", {
              year: "numeric",
              month: "short",
              day: "numeric"
            });
            return `<span class="date-node" style="background-color: #F4F5F7; padding: 2px 4px; border-radius: 3px; font-size: 12px; color: #172B4D;">\u{1F4C5} ${formattedDate}</span>`;
          } catch (error) {
            return `<span class="date-node" style="background-color: #F4F5F7; padding: 2px 4px; border-radius: 3px; font-size: 12px; color: #172B4D;">\u{1F4C5} Date</span>`;
          }
        }
        return `<span class="date-node" style="background-color: #F4F5F7; padding: 2px 4px; border-radius: 3px; font-size: 12px; color: #172B4D;">\u{1F4C5} Date</span>`;
      case "status":
        const statusText = node2.attrs?.text || "Status";
        const statusColor = node2.attrs?.color || "neutral";
        const colorMap = {
          "blue": "#0052CC",
          "green": "#36B37E",
          "yellow": "#FFAB00",
          "red": "#DE350B",
          "purple": "#6554C0",
          "neutral": "#6B778C"
        };
        const bgColor = colorMap[statusColor] || colorMap["neutral"];
        return `<span style="background-color: ${bgColor}; color: white; padding: 2px 6px; border-radius: 3px; font-size: 11px; font-weight: bold;">${statusText}</span>`;
      case "mediaSingle":
        if (node2.content && Array.isArray(node2.content)) {
          return `<div class="media-container">${renderNodeContent(node2.content)}</div>`;
        }
        return "";
      case "media":
        const mediaType = node2.attrs?.type || "file";
        const mediaId = node2.attrs?.id || "";
        const mediaCollection = node2.attrs?.collection || "";
        if (mediaType === "file" && mediaId) {
          return `<div class="media-file" style="padding: 8px; border: 1px solid #ddd; border-radius: 4px; margin: 4px 0;">
          <span style="color: #6B778C;">\u{1F4CE} Media file (${mediaId})</span>
        </div>`;
        }
        if (mediaType === "image" && mediaId) {
          return `<div class="media-image" data-media-id="${mediaId}" style="padding: 8px; border: 1px solid #ddd; border-radius: 4px; margin: 4px 0;">
          <span style="color: #6B778C;">\u{1F5BC}\uFE0F Image (${mediaId})</span>
        </div>`;
        }
        return `<div class="media-placeholder" style="padding: 8px; border: 1px solid #ddd; border-radius: 4px; margin: 4px 0; color: #6B778C;">
        \u{1F4CE} Media content
      </div>`;
      default:
        if (node2.type) {
          console.warn(`Unknown ProseMirror node type: ${node2.type}`, node2);
        }
        if (node2.content) {
          return renderNodeContent(node2.content);
        }
        return "";
    }
  }
  function renderNodeContent(content) {
    if (!content || !Array.isArray(content)) return "";
    let html = "";
    for (const node2 of content) {
      html += renderNode(node2);
    }
    return html;
  }

  // src/components/ImageRenderer/ImageRenderer.tsx
  var import_react113 = __toESM(require_react());

  // src/utils/imageUtils.ts
  async function fetchImageFromBlobUrl(blobUrl) {
    try {
      const response = await fetch(blobUrl);
      if (!response.ok) {
        console.warn("[AtlasXray] Failed to fetch image from blob URL:", response.statusText);
        return null;
      }
      const blob = await response.blob();
      const mimeType = blob.type || "image/png";
      const imageData = await blobToBase64(blob);
      return { imageData, mimeType };
    } catch (error) {
      console.error("[AtlasXray] Error fetching image from blob URL:", error);
      return null;
    }
  }
  function blobToBase64(blob) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => {
        const result2 = reader.result;
        const base64Data = result2.split(",")[1];
        resolve(base64Data);
      };
      reader.onerror = reject;
      reader.readAsDataURL(blob);
    });
  }
  function base64ToDataUrl(imageData, mimeType) {
    return `data:${mimeType};base64,${imageData}`;
  }

  // src/components/ImageRenderer/ImageRenderer.tsx
  var import_jsx_runtime = __toESM(require_jsx_runtime());
  function ImageRenderer({ projectKey, mediaId, fallbackText }) {
    const [imageUrl, setImageUrl] = (0, import_react113.useState)(null);
    const [loading, setLoading] = (0, import_react113.useState)(true);
    const [error, setError] = (0, import_react113.useState)(false);
    (0, import_react113.useEffect)(() => {
      async function loadImage() {
        try {
          setLoading(true);
          const imageData = await getProjectImage(projectKey, mediaId);
          if (imageData) {
            const dataUrl = base64ToDataUrl(imageData.imageData, imageData.mimeType);
            setImageUrl(dataUrl);
          } else {
            setError(true);
          }
        } catch (err) {
          console.error("[AtlasXray] Error loading image:", err);
          setError(true);
        } finally {
          setLoading(false);
        }
      }
      if (projectKey && mediaId) {
        loadImage();
      }
    }, [projectKey, mediaId]);
    if (loading) {
      return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", { className: "image-loading", style: { padding: "8px", color: "#6B778C", fontStyle: "italic" }, children: "Loading image..." });
    }
    if (error || !imageUrl) {
      return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", { className: "image-error", style: { padding: "8px", border: "1px solid #ddd", borderRadius: "4px", margin: "4px 0", color: "#6B778C" }, children: fallbackText || `\u{1F5BC}\uFE0F Image (${mediaId})` });
    }
    return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", { className: "stored-image", style: { margin: "8px 0" }, children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
      "img",
      {
        src: imageUrl,
        alt: `Project update image ${mediaId}`,
        style: {
          maxWidth: "100%",
          height: "auto",
          borderRadius: "4px",
          border: "1px solid #ddd"
        },
        onError: () => setError(true)
      }
    ) });
  }

  // src/components/ProjectUpdateModal/ProjectUpdateModal.tsx
  var import_jsx_runtime2 = __toESM(require_jsx_runtime());
  function extractMediaNodes(content) {
    const mediaNodes = [];
    function traverse(nodes) {
      for (const node2 of nodes) {
        if (node2.type === "media" && node2.attrs?.id) {
          mediaNodes.push(node2);
        }
        if (node2.content && Array.isArray(node2.content)) {
          traverse(node2.content);
        }
      }
    }
    if (content && Array.isArray(content)) {
      traverse(content);
    }
    return mediaNodes;
  }
  function ProjectUpdateModal({
    selectedUpdate,
    project,
    onClose
  }) {
    const getLozengeAppearance = (status) => {
      if (!status) return "new";
      const normalizedStatus = status.toLowerCase().replace(/_/g, "-");
      switch (normalizedStatus) {
        case "on-track":
          return "success";
        case "off-track":
          return "removed-bold";
        case "none":
          return "new";
        case "at-risk":
          return "moved";
        case "pending":
          return "inprogress";
        case "paused":
          return "default";
        case "cancelled":
          return "default-bold";
        case "done":
          return "success-bold";
        default:
          return "default";
      }
    };
    if (!selectedUpdate) return null;
    return /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(modal_transition_default, { children: selectedUpdate && /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)(
      ModalWrapper,
      {
        onClose,
        width: "full",
        shouldScrollInViewport: true,
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(modal_header_default, { children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(modal_title_default, { children: "Date Change Details" }) }),
          /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(modal_body_default, { children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(box_default2, { style: { maxWidth: "1128px", margin: "0 auto", width: "100%" }, children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(grid_default, { children: /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { className: "date-change-modal-body", children: [
            /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("h3", { className: "project-name", children: project?.name }),
            /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { className: "project-key", children: [
              /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("small", { children: "Project Key:" }),
              " ",
              project?.projectKey
            ] }),
            selectedUpdate.oldDueDate && /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)(
              section_message_default,
              {
                appearance: "error",
                title: "Date Change Detected",
                children: [
                  /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("div", { className: "change-section", children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("strong", { children: "Date Change:" }) }),
                  /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { className: "date-change-display", children: [
                    /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("span", { className: "old-date", children: selectedUpdate.oldDueDate }),
                    /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("span", { className: "arrow", children: "\u2192" }),
                    /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("span", { className: "new-date", children: selectedUpdate.newDueDate })
                  ] }),
                  /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { className: "change-difference", children: [
                    /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("strong", { children: "Difference:" }),
                    " ",
                    getDueDateDiff(selectedUpdate),
                    " days"
                  ] })
                ]
              }
            ),
            selectedUpdate.oldState && /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)(
              section_message_default,
              {
                appearance: "error",
                title: "Status Change Detected",
                children: [
                  /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("div", { className: "change-section", children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("strong", { children: "Status Change:" }) }),
                  /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { className: "status-change-display", children: [
                    /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(lozenge_default, { appearance: getLozengeAppearance(selectedUpdate.oldState), children: selectedUpdate.oldState }),
                    /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("span", { className: "arrow", children: "\u2192" }),
                    /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(lozenge_default, { appearance: getLozengeAppearance(selectedUpdate.state), children: selectedUpdate.state })
                  ] })
                ]
              }
            ),
            selectedUpdate.summary && /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { className: "summary-section", children: [
              /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("h3", { children: "Update Summary:" }),
              /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { className: "summary-content", children: [
                /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("div", { dangerouslySetInnerHTML: { __html: renderProseMirror(selectedUpdate.summary) } }),
                (() => {
                  try {
                    const summaryContent = JSON.parse(selectedUpdate.summary);
                    const mediaNodes = extractMediaNodes(summaryContent.content);
                    return mediaNodes.map((mediaNode, idx) => /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
                      ImageRenderer,
                      {
                        projectKey: project?.projectKey || "",
                        mediaId: mediaNode.attrs?.id || "",
                        fallbackText: `\u{1F5BC}\uFE0F Image (${mediaNode.attrs?.id || ""})`
                      },
                      `summary-${idx}`
                    ));
                  } catch (e) {
                    return null;
                  }
                })()
              ] })
            ] }),
            selectedUpdate.details && /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { className: "details-section", children: [
              /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("h3", { children: "Update Details:" }),
              /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("div", { className: "details-content", children: (() => {
                try {
                  const parsedDetails = JSON.parse(selectedUpdate.details);
                  if (Array.isArray(parsedDetails) && parsedDetails.length > 0) {
                    return parsedDetails.map((note, idx) => /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { className: "note-item", children: [
                      /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("strong", { children: [
                        note.title || "Note",
                        ":"
                      ] }),
                      /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("div", { dangerouslySetInnerHTML: { __html: renderProseMirror(note.summary) } })
                    ] }, idx));
                  }
                } catch (e) {
                  console.error("Error parsing details:", e);
                }
                return /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("div", { className: "no-details", children: "No detailed update provided" });
              })() })
            ] })
          ] }) }) }) })
        ]
      }
    ) });
  }

  // src/components/StatusTimelineHeatmap/StatusTimelineHeatmapRow.tsx
  var import_jsx_runtime3 = __toESM(require_jsx_runtime());
  function StatusTimelineHeatmapRow({
    project,
    weekRanges,
    updates
  }) {
    const [isOpen, setIsOpen] = (0, import_react114.useState)(false);
    const [selectedUpdate, setSelectedUpdate] = (0, import_react114.useState)(null);
    if (!project) {
      console.warn("ProjectTimelineRow received undefined project");
      return null;
    }
    const weekCells = getTimelineWeekCells(weekRanges, updates);
    const targetDateRaw = updates.find((u) => u.targetDate)?.targetDate || updates.find((u) => u.newDueDate)?.newDueDate || null;
    const targetDateDisplay = getTargetDateDisplay(targetDateRaw);
    return /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)("div", { className: "timeline-row", children: [
      /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)("div", { className: "timeline-y-label", children: [
        /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(tooltip_default, { content: project.name, position: "top-start", children: /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("h3", { className: "project-title-ellipsis", children: project.name }) }),
        /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(
          "a",
          {
            href: buildProjectUrlFromKey(project.projectKey),
            target: "_blank",
            rel: "noopener noreferrer",
            children: project.projectKey
          }
        )
      ] }),
      weekCells.map((cell, i) => /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("div", { className: cell.cellClass, children: cell.weekUpdates.map((u, idx) => /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)(
        "div",
        {
          className: `timeline-cell-content ${u.oldDueDate ? "has-old-due-date" : ""}`,
          onClick: () => setSelectedUpdate(u),
          style: { cursor: "pointer" },
          children: [
            u.oldDueDate && u.newDueDate && /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(tooltip_default, { content: getDueDateTooltip(u), position: "top", children: /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("span", { className: "date-difference", children: (() => {
              const diff = getDueDateDiff(u);
              return diff !== null ? diff > 0 ? `+${diff}` : `${diff}` : "";
            })() }) }),
            !u.oldDueDate && /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(tooltip_default, { content: "Click to view update details", position: "top", children: /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("span", { className: "update-indicator", children: "\u2022" }) })
          ]
        },
        idx
      )) }, i)),
      /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("div", { className: "timeline-target-date", children: targetDateRaw ? /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(
        esm_default3,
        {
          isOpen,
          onClose: () => setIsOpen(false),
          content: () => /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)("div", { style: { padding: "16px", maxWidth: "300px" }, children: [
            /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("h3", { children: "Target Date" }),
            /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("p", { children: targetDateRaw })
          ] }),
          trigger: (triggerProps) => /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(
            button_default,
            {
              ...triggerProps,
              appearance: "default",
              spacing: "compact",
              onClick: () => setIsOpen(!isOpen),
              children: targetDateDisplay
            }
          ),
          placement: "bottom-start",
          zIndex: 1e3
        }
      ) : /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("span", { style: { color: "#6b7280", fontSize: "12px" }, children: "No target date" }) }),
      /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(
        ProjectUpdateModal,
        {
          selectedUpdate,
          project,
          onClose: () => setSelectedUpdate(null)
        }
      )
    ] });
  }

  // src/components/StatusTimelineHeatmap/StatusTimelineHeatmapHeader.tsx
  var import_jsx_runtime4 = __toESM(require_jsx_runtime());
  function StatusTimelineHeatmapHeader({ weekRanges }) {
    return /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)("div", { className: "timeline-row timeline-labels", children: [
      /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("div", { className: "timeline-y-label" }),
      " ",
      weekRanges.map((w2, i) => /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("div", { className: "timeline-x-label", children: /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(tooltip_default, { content: w2.label, children: w2.label }) }, i)),
      /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("div", { className: "timeline-target-date", children: "Target Date" }),
      " "
    ] });
  }

  // src/hooks/useTimelineData.ts
  var import_react115 = __toESM(require_react());
  function useTimeline(weekLimit = 12) {
    const projects = useLiveQuery(() => db.projectView.toArray(), []);
    const allUpdates = useLiveQuery(() => db.projectUpdates.toArray(), []);
    const allStatusHistory = useLiveQuery(() => db.projectStatusHistory.toArray(), []);
    return (0, import_react115.useMemo)(() => {
      if (!projects || !allUpdates || !allStatusHistory) {
        return {
          weekRanges: [],
          projectViewModels: [],
          updatesByProject: {},
          statusByProject: {},
          isLoading: true
        };
      }
      const updatesByProject = {};
      allUpdates.forEach((update) => {
        const key = update.projectKey;
        if (key) {
          if (!updatesByProject[key]) {
            updatesByProject[key] = [];
          }
          updatesByProject[key].push(update);
        }
      });
      console.log("=== UPDATE DATA DEBUG ===");
      console.log("Total updates found:", allUpdates.length);
      console.log("All updates array:", allUpdates);
      if (allUpdates.length > 0) {
        console.log("First update object:", allUpdates[0]);
        console.log("First update raw:", allUpdates[0]?.raw);
        console.log("First update keys:", Object.keys(allUpdates[0] || {}));
        if (allUpdates[0]?.raw) {
          console.log("First update raw keys:", Object.keys(allUpdates[0].raw || {}));
        }
        if (allUpdates[0]?.projectUpdates?.edges) {
          console.log("Found GraphQL edges structure");
          console.log("First edge:", allUpdates[0].projectUpdates.edges[0]);
        }
      }
      console.log("=== END UPDATE DEBUG ===");
      const statusByProject = {};
      allStatusHistory.forEach((status) => {
        const key = status.projectKey;
        if (key) {
          if (!statusByProject[key]) {
            statusByProject[key] = [];
          }
          statusByProject[key].push(status);
        }
      });
      const projectViewModels = projects.map((project) => {
        console.log("Project data:", project);
        console.log("Project raw:", project.raw);
        const projectName = project.raw?.project?.name || project.raw?.name || project.project?.name || "Unknown Project";
        return {
          projectKey: project.projectKey,
          name: projectName,
          rawProject: project
        };
      });
      const allDates = getAllProjectDates(projectViewModels, updatesByProject);
      if (!allDates.minDate || !allDates.maxDate) {
        return {
          weekRanges: [],
          projectViewModels,
          updatesByProject,
          statusByProject,
          isLoading: false
        };
      }
      const weekRanges = getWeekRanges(allDates.minDate, allDates.maxDate);
      const limitedWeekRanges = weekRanges.slice(-weekLimit);
      return {
        weekRanges: limitedWeekRanges,
        projectViewModels,
        updatesByProject,
        statusByProject,
        isLoading: false
      };
    }, [projects, allUpdates, allStatusHistory, weekLimit]);
  }

  // src/components/StatusTimelineHeatmap/StatusTimelineHeatmap.tsx
  var import_jsx_runtime5 = __toESM(require_jsx_runtime());
  function StatusTimelineHeatmap({ weekLimit = 12 }) {
    const { projectViewModels, weekRanges, updatesByProject, isLoading } = useTimeline(weekLimit);
    if (isLoading) {
      return /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("div", { children: "Loading timeline data..." });
    }
    return /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("div", { className: "project-timeline", children: [
      /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(StatusTimelineHeatmapHeader, { weekRanges }),
      projectViewModels.filter(Boolean).map((project, idx) => /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
        StatusTimelineHeatmapRow,
        {
          project,
          weekRanges,
          updates: updatesByProject[project.projectKey] || []
        },
        project.projectKey || idx
      ))
    ] });
  }

  // src/components/ProjectStatusHistoryModal/ProjectStatusHistoryModal.tsx
  var import_react138 = __toESM(require_react());

  // node_modules/@atlaskit/modal-dialog/dist/esm/full-screen.js
  var import_react116 = __toESM(require_react());
  function FullScreenModalDialog(props) {
    return /* @__PURE__ */ import_react116.default.createElement(
      modal_wrapper_default,
      _extends({}, props, {
        /**
         * Making this an internal-only prop and exposing it through a facade
         * component so that we can keep public types simple.
         *
         * Otherwise we need complex conditional types that are harder to
         * understand / maintain and aren't actually any better for consumers.
         */
        isFullScreen: true,
        width: "100%",
        height: "100%",
        shouldScrollInViewport: false,
        shouldCloseOnOverlayClick: false,
        isBlanketHidden: false
      })
    );
  }

  // src/components/ProjectStatusHistoryModal/ProjectStatusHistoryModal.tsx
  var import_cross4 = __toESM(require_cross2());

  // node_modules/@atlaskit/react-select/dist/esm/use-state-manager.js
  init_defineProperty();
  init_slicedToArray();
  var import_react117 = __toESM(require_react());
  var _excluded13 = ["defaultInputValue", "defaultMenuIsOpen", "defaultValue", "inputValue", "menuIsOpen", "onChange", "onInputChange", "onMenuClose", "onMenuOpen", "value"];
  function ownKeys15(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r && (o = o.filter(function(r2) {
        return Object.getOwnPropertyDescriptor(e, r2).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread15(e) {
    for (var r = 1; r < arguments.length; r++) {
      var t = null != arguments[r] ? arguments[r] : {};
      r % 2 ? ownKeys15(Object(t), true).forEach(function(r2) {
        _defineProperty(e, r2, t[r2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys15(Object(t)).forEach(function(r2) {
        Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
      });
    }
    return e;
  }
  function useStateManager(_ref2) {
    var _ref$defaultInputValu = _ref2.defaultInputValue, defaultInputValue = _ref$defaultInputValu === void 0 ? "" : _ref$defaultInputValu, _ref$defaultMenuIsOpe = _ref2.defaultMenuIsOpen, defaultMenuIsOpen = _ref$defaultMenuIsOpe === void 0 ? false : _ref$defaultMenuIsOpe, _ref$defaultValue = _ref2.defaultValue, defaultValue = _ref$defaultValue === void 0 ? null : _ref$defaultValue, propsInputValue = _ref2.inputValue, propsMenuIsOpen = _ref2.menuIsOpen, propsOnChange = _ref2.onChange, propsOnInputChange = _ref2.onInputChange, propsOnMenuClose = _ref2.onMenuClose, propsOnMenuOpen = _ref2.onMenuOpen, propsValue = _ref2.value, restSelectProps = _objectWithoutProperties(_ref2, _excluded13);
    var _useState = (0, import_react117.useState)(propsInputValue !== void 0 ? propsInputValue : defaultInputValue), _useState2 = _slicedToArray(_useState, 2), stateInputValue = _useState2[0], setStateInputValue = _useState2[1];
    var _useState3 = (0, import_react117.useState)(propsMenuIsOpen !== void 0 ? propsMenuIsOpen : defaultMenuIsOpen), _useState4 = _slicedToArray(_useState3, 2), stateMenuIsOpen = _useState4[0], setStateMenuIsOpen = _useState4[1];
    var _useState5 = (0, import_react117.useState)(propsValue !== void 0 ? propsValue : defaultValue), _useState6 = _slicedToArray(_useState5, 2), stateValue = _useState6[0], setStateValue = _useState6[1];
    var onChange2 = (0, import_react117.useCallback)(function(value2, actionMeta) {
      if (typeof propsOnChange === "function") {
        propsOnChange(value2, actionMeta);
      }
      setStateValue(value2);
    }, [propsOnChange]);
    var onInputChange = (0, import_react117.useCallback)(function(value2, actionMeta) {
      var newValue;
      if (typeof propsOnInputChange === "function") {
        newValue = propsOnInputChange(value2, actionMeta);
      }
      setStateInputValue(newValue !== void 0 ? newValue : value2);
    }, [propsOnInputChange]);
    var onMenuOpen = (0, import_react117.useCallback)(function() {
      if (typeof propsOnMenuOpen === "function") {
        propsOnMenuOpen();
      }
      setStateMenuIsOpen(true);
    }, [propsOnMenuOpen]);
    var onMenuClose = (0, import_react117.useCallback)(function() {
      if (typeof propsOnMenuClose === "function") {
        propsOnMenuClose();
      }
      setStateMenuIsOpen(false);
    }, [propsOnMenuClose]);
    var inputValue = propsInputValue !== void 0 ? propsInputValue : stateInputValue;
    var menuIsOpen = propsMenuIsOpen !== void 0 ? propsMenuIsOpen : stateMenuIsOpen;
    var value = propsValue !== void 0 ? propsValue : stateValue;
    return _objectSpread15(_objectSpread15({}, restSelectProps), {}, {
      inputValue,
      menuIsOpen,
      onChange: onChange2,
      onInputChange,
      onMenuClose,
      onMenuOpen,
      value
    });
  }

  // node_modules/@atlaskit/react-select/dist/esm/select.js
  init_typeof();
  init_classCallCheck();
  init_createClass();
  init_defineProperty();
  init_toConsumableArray();
  var import_react134 = __toESM(require_react());
  var import_platform_feature_flags20 = __toESM(require_cjs3());

  // node_modules/@atlaskit/react-select/dist/esm/builtins.js
  var formatGroupLabel = function formatGroupLabel2(group) {
    return group.label;
  };
  var getOptionLabel = function getOptionLabel2(option) {
    return option.label;
  };
  var getOptionValue = function getOptionValue2(option) {
    return option.value;
  };
  var isOptionDisabled = function isOptionDisabled2(option) {
    return !!option.isDisabled;
  };

  // node_modules/@atlaskit/react-select/dist/esm/components/index.js
  init_defineProperty();

  // node_modules/@atlaskit/react-select/dist/esm/components/containers.js
  var React74 = __toESM(require_react());
  var import_platform_feature_flags17 = __toESM(require_cjs3());

  // node_modules/@atlaskit/react-select/dist/esm/utils.js
  init_slicedToArray();
  init_defineProperty();
  init_typeof();
  var _excluded14 = ["className", "clearValue", "cx", "xcss", "getStyles", "getClassNames", "getValue", "hasValue", "isMulti", "isRtl", "options", "selectOption", "selectProps", "setValue"];
  function ownKeys16(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r && (o = o.filter(function(r2) {
        return Object.getOwnPropertyDescriptor(e, r2).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread16(e) {
    for (var r = 1; r < arguments.length; r++) {
      var t = null != arguments[r] ? arguments[r] : {};
      r % 2 ? ownKeys16(Object(t), true).forEach(function(r2) {
        _defineProperty(e, r2, t[r2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys16(Object(t)).forEach(function(r2) {
        Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
      });
    }
    return e;
  }
  var noop4 = function noop5() {
  };
  function applyPrefixToName(prefix3, name) {
    if (!name) {
      return prefix3;
    } else if (name[0] === "-") {
      return prefix3 + name;
    } else {
      return prefix3 + "__" + name;
    }
  }
  function classNames(prefix3, state) {
    for (var _len = arguments.length, classNameList = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      classNameList[_key - 2] = arguments[_key];
    }
    var arr = [].concat(classNameList);
    if (state && prefix3) {
      for (var key in state) {
        if (state.hasOwnProperty(key) && state[key]) {
          arr.push("".concat(applyPrefixToName(prefix3, key)));
        }
      }
    }
    return arr.filter(function(i) {
      return i;
    }).map(function(i) {
      return String(i).trim();
    }).join(" ");
  }
  var cleanValue = function cleanValue2(value) {
    if (isArray(value)) {
      return value.filter(Boolean);
    }
    if (_typeof(value) === "object" && value !== null) {
      return [value];
    }
    return [];
  };
  var cleanCommonProps = function cleanCommonProps2(props) {
    var className = props.className, clearValue = props.clearValue, cx3 = props.cx, xcss2 = props.xcss, getStyles = props.getStyles, getClassNames = props.getClassNames, getValue = props.getValue, hasValue = props.hasValue, isMulti = props.isMulti, isRtl = props.isRtl, options2 = props.options, selectOption = props.selectOption, selectProps = props.selectProps, setValue = props.setValue, innerProps = _objectWithoutProperties(props, _excluded14);
    return _objectSpread16({}, innerProps);
  };
  var getStyleProps = function getStyleProps2(props, name, classNamesState) {
    var cx3 = props.cx, getStyles = props.getStyles, getClassNames = props.getClassNames, className = props.className;
    return {
      css: getStyles(name, props),
      className: cx3(classNamesState !== null && classNamesState !== void 0 ? classNamesState : {}, getClassNames(name, props), className)
    };
  };
  function handleInputChange(inputValue, actionMeta, onInputChange) {
    if (onInputChange) {
      var newValue = onInputChange(inputValue, actionMeta);
      if (typeof newValue === "string") {
        return newValue;
      }
    }
    return inputValue;
  }
  function isDocumentElement(el) {
    return [document.documentElement, document.body, window].indexOf(el) > -1;
  }
  function normalizedHeight(el) {
    if (isDocumentElement(el)) {
      return window.innerHeight;
    }
    return el.clientHeight;
  }
  function getScrollTop(el) {
    if (isDocumentElement(el)) {
      return window.pageYOffset;
    }
    return el.scrollTop;
  }
  function scrollTo(el, top2) {
    if (isDocumentElement(el)) {
      window.scrollTo(0, top2);
      return;
    }
    el.scrollTop = top2;
  }
  function getScrollParent2(element) {
    var style = getComputedStyle(element);
    var excludeStaticParent = style.position === "absolute";
    var overflowRx = /(auto|scroll)/;
    if (style.position === "fixed") {
      return document.documentElement;
    }
    for (var parent = element; parent = parent.parentElement; ) {
      style = getComputedStyle(parent);
      if (excludeStaticParent && style.position === "static") {
        continue;
      }
      if (overflowRx.test(style.overflow + style.overflowY + style.overflowX)) {
        return parent;
      }
    }
    return document.documentElement;
  }
  function easeOutCubic(t, b, c, d) {
    return c * ((t = t / d - 1) * t * t + 1) + b;
  }
  function animatedScrollTo(element, to) {
    var duration = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 200;
    var callback = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : noop4;
    var start3 = getScrollTop(element);
    var change = to - start3;
    var increment = 10;
    var currentTime = 0;
    function animateScroll() {
      currentTime += increment;
      var val = easeOutCubic(currentTime, start3, change, duration);
      scrollTo(element, val);
      if (currentTime < duration) {
        window.requestAnimationFrame(animateScroll);
      } else {
        callback(element);
      }
    }
    animateScroll();
  }
  function scrollIntoView(menuEl, focusedEl) {
    var menuRect = menuEl.getBoundingClientRect();
    var focusedRect = focusedEl.getBoundingClientRect();
    var overScroll = focusedEl.offsetHeight / 3;
    if (focusedRect.bottom + overScroll > menuRect.bottom) {
      scrollTo(menuEl, Math.min(focusedEl.offsetTop + focusedEl.clientHeight - menuEl.offsetHeight + overScroll, menuEl.scrollHeight));
    } else if (focusedRect.top - overScroll < menuRect.top) {
      scrollTo(menuEl, Math.max(focusedEl.offsetTop - overScroll, 0));
    }
  }
  function getBoundingClientObj(element) {
    var rect = element.getBoundingClientRect();
    return {
      bottom: rect.bottom,
      height: rect.height,
      left: rect.left,
      right: rect.right,
      top: rect.top,
      width: rect.width
    };
  }
  function isTouchCapable() {
    try {
      document.createEvent("TouchEvent");
      return true;
    } catch (e) {
      return false;
    }
  }
  function isMobileDevice() {
    try {
      return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    } catch (e) {
      return false;
    }
  }
  var passiveOptionAccessed = false;
  var options = {
    get passive() {
      return passiveOptionAccessed = true;
    }
  };
  var w = typeof window !== "undefined" ? window : {};
  if (w.addEventListener && w.removeEventListener) {
    w.addEventListener("p", noop4, options);
    w.removeEventListener("p", noop4, false);
  }
  var supportsPassiveEvents = passiveOptionAccessed;
  function notNullish(item) {
    return item != null;
  }
  function isArray(arg) {
    return Array.isArray(arg);
  }
  function valueTernary(isMulti, multiValue, singleValue) {
    return isMulti ? multiValue : singleValue;
  }
  function singleValueAsValue(singleValue) {
    return singleValue;
  }
  function multiValueAsValue(multiValue) {
    return multiValue;
  }
  var removeProps = function removeProps2(propsObj) {
    for (var _len2 = arguments.length, properties = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      properties[_key2 - 1] = arguments[_key2];
    }
    var propsMap = Object.entries(propsObj).filter(function(_ref2) {
      var _ref22 = _slicedToArray(_ref2, 1), key = _ref22[0];
      return !properties.includes(key);
    });
    return propsMap.reduce(function(newProps, _ref3) {
      var _ref4 = _slicedToArray(_ref3, 2), key = _ref4[0], val = _ref4[1];
      newProps[key] = val;
      return newProps;
    }, {});
  };
  var filterUnsupportedSelectors = function filterUnsupportedSelectors2(styles15) {
    var unsupportedSelectors = [
      ":",
      // pseudo-classes/elements
      "[",
      // attribute selectors
      ">",
      // child combinator
      "+",
      // adjacent sibling combinator
      "~",
      // general sibling combinator
      " ",
      // descendant combinator
      "*",
      // universal selector
      "#",
      // ID selector
      ".",
      // class selector
      "@",
      // at-rules
      "&",
      // parent selector
      "|",
      // namespace separator
      "^",
      // starts with
      "$",
      // ends with
      "="
      // equals
    ];
    return Object.keys(styles15).reduce(function(filteredStyles, key) {
      if (!unsupportedSelectors.some(function(selector) {
        return key.includes(selector);
      })) {
        filteredStyles[key] = styles15[key];
      }
      return filteredStyles;
    }, {});
  };

  // node_modules/@atlaskit/react-select/dist/esm/components/containers.js
  var containerCSS = function containerCSS2() {
    return {};
  };
  var containerStyles = {
    default: "_11c82smr _kqswh2mm _lcxv1rj4",
    rtl: "_1eim1xrj",
    disabled: "_80om13gf",
    ff_safari_input_fix: "_11c81ixg _1tn22smr"
  };
  var SelectContainer = function SelectContainer2(props) {
    var children = props.children, innerProps = props.innerProps, isDisabled = props.isDisabled, isRtl = props.isRtl, xcss2 = props.xcss;
    var _getStyleProps = getStyleProps(props, "container", {
      "--is-disabled": isDisabled,
      "--is-rtl": isRtl
    }), className = _getStyleProps.className, css7 = _getStyleProps.css;
    return /* @__PURE__ */ React74.createElement("div", _extends({
      // eslint-disable-next-line @atlaskit/ui-styling-standard/no-classname-prop, @atlaskit/ui-styling-standard/local-cx-xcss, @compiled/local-cx-xcss
      className: ax([containerStyles.default, isRtl && containerStyles.rtl, isDisabled && containerStyles.disabled, (0, import_platform_feature_flags17.fg)("platform_design_system_team_safari_input_fix") && containerStyles.ff_safari_input_fix, cx(className, xcss2, "-container")]),
      style: css7
    }, innerProps), children);
  };
  var valueContainerCSS = function valueContainerCSS2() {
    return {};
  };
  var valueContainerStyles = {
    default: "_16jlkb7n _1o9zkb7n _i0dlf1ug _1reo15vq _18m915vq _4cvr1h6o _1e0c11p5 _1n261g80 _8am5i4x0 _kqswh2mm _ca0qv77o _u5f312x7 _n3tdv77o _19bv12x7",
    flex: "_1e0c1txw",
    compact: "_ca0qze3t _u5f312x7 _n3tdze3t _19bv12x7"
  };
  var ValueContainer = function ValueContainer2(props) {
    var children = props.children, innerProps = props.innerProps, isMulti = props.isMulti, hasValue = props.hasValue, isCompact = props.isCompact, xcss2 = props.xcss, controlShouldRenderValue = props.selectProps.controlShouldRenderValue;
    var _getStyleProps2 = getStyleProps(props, "valueContainer", {
      "value-container": true,
      "value-container--is-multi": isMulti,
      "value-container--has-value": hasValue
    }), css7 = _getStyleProps2.css, className = _getStyleProps2.className;
    return /* @__PURE__ */ React74.createElement("div", _extends({
      // eslint-disable-next-line @atlaskit/ui-styling-standard/no-classname-prop, @atlaskit/ui-styling-standard/local-cx-xcss, @compiled/local-cx-xcss
      className: ax([valueContainerStyles.default, isMulti && hasValue && controlShouldRenderValue && valueContainerStyles.flex, isCompact && valueContainerStyles.compact, cx(className, xcss2, "-ValueContainer")]),
      style: css7
    }, innerProps), children);
  };
  var indicatorsContainerCSS = function indicatorsContainerCSS2() {
    return {};
  };
  var IndicatorsContainer = function IndicatorsContainer2(props) {
    var children = props.children, innerProps = props.innerProps, xcss2 = props.xcss;
    var _getStyleProps3 = getStyleProps(props, "indicatorsContainer", {
      indicators: true
    }), css7 = _getStyleProps3.css, className = _getStyleProps3.className;
    return /* @__PURE__ */ React74.createElement("div", _extends({
      // eslint-disable-next-line @atlaskit/ui-styling-standard/enforce-style-prop
      style: css7,
      className: ax(["_1e0c1txw _4cvr1h6o _1o9zidpf _1wpz1fhb _y4ti1b66", cx(className, xcss2, "-IndicatorsContainer")])
    }, innerProps), children);
  };

  // node_modules/@atlaskit/react-select/dist/esm/components/control.js
  var React75 = __toESM(require_react());
  var styles12 = {
    default: "_12ji1r31 _1qu2glyw _12y3idpf _2rkosqtm _v564r5cv _1h6d1elr _1dqonqa1 _189ee4h9 _4cvr1h6o _80om73ad _1e0c1txw _1n261g80 _1bah1yb4 _kqswh2mm _bfhk1j9a _1tke1ylp _ca0qze3t _u5f3ze3t _n3tdze3t _19bvze3t _15peftgi _1ke8ftgi _jaboglyw _1u6l1bml _4cvx1elr _123byq51 _d0altlke _irr31d5g _1ogl1caj",
    compact: "_1tkezwfg",
    invalid: "_1h6d1bqt _16qsizbr _1u6lizbr _4cvx1bqt",
    focusedInvalid: "_16qsq049",
    disabled: "_1h6dsyzs _lcxvglyw _bfhksyzs _1u6llkwx",
    focused: "_1h6d1p6i _bfhkr01l _16qsq049 _1u6lq049 _4cvx1p6i _irr3r01l",
    subtle: "_1h6d1j28 _bfhk1j28 _1u6l3sij",
    subtleFocused: "_bfhkvuon",
    none: "_1h6d1j28 _bfhk1j28 _1u6l3sij _4cvx1j28 _irr31j28"
  };
  var css3 = function css4() {
    return {};
  };
  var Control = function Control2(props) {
    var children = props.children, appearance = props.appearance, isCompact = props.isCompact, isDisabled = props.isDisabled, isFocused = props.isFocused, isInvalid = props.isInvalid, innerRef = props.innerRef, innerProps = props.innerProps, menuIsOpen = props.menuIsOpen, xcss2 = props.xcss;
    var _getStyleProps = getStyleProps(props, "control", {
      control: true,
      "control--is-disabled": isDisabled,
      "control--is-focused": isFocused,
      "control--menu-is-open": menuIsOpen
    }), css7 = _getStyleProps.css, className = _getStyleProps.className;
    return /* @__PURE__ */ React75.createElement("div", _extends({
      ref: innerRef,
      className: ax([styles12.default, isDisabled && styles12.disabled, isInvalid && styles12.invalid, isCompact && styles12.compact, appearance === "subtle" && styles12.subtle, appearance === "subtle" && isFocused && styles12.subtleFocused, isFocused && styles12.focused, appearance === "none" && styles12.none, cx(className, xcss2, "-control")]),
      style: css7
    }, innerProps, {
      "aria-disabled": isDisabled || void 0
    }), children);
  };
  var control_default = Control;

  // node_modules/@atlaskit/react-select/dist/esm/components/group.js
  var React76 = __toESM(require_react());
  var _excluded15 = ["data"];
  var styles13 = {
    root: "_n3tdu2gc _ca0qu2gc"
  };
  var groupCSS = function groupCSS2() {
    return {};
  };
  var Group = function Group2(props) {
    var children = props.children, builtinCX = props.cx, getStyles = props.getStyles, getClassNames = props.getClassNames, Heading2 = props.Heading, headingProps = props.headingProps, innerProps = props.innerProps, label = props.label, selectProps = props.selectProps, xcss2 = props.xcss;
    var _getStyleProps = getStyleProps(props, "group", {
      group: true
    }), css7 = _getStyleProps.css, className = _getStyleProps.className;
    return /* @__PURE__ */ React76.createElement("div", _extends({
      // eslint-disable-next-line @atlaskit/ui-styling-standard/enforce-style-prop
      style: css7
    }, innerProps, {
      // eslint-disable-next-line @atlaskit/ui-styling-standard/no-classname-prop, @atlaskit/ui-styling-standard/local-cx-xcss, @compiled/local-cx-xcss
      className: ax([styles13.root, cx(className, xcss2, innerProps === null || innerProps === void 0 ? void 0 : innerProps.className, "-Group")])
    }), label && /* @__PURE__ */ React76.createElement(Heading2, _extends({}, headingProps, {
      selectProps,
      getStyles,
      getClassNames,
      cx: builtinCX
    }), label), /* @__PURE__ */ React76.createElement("div", null, children));
  };
  var groupHeadingCSS = function groupHeadingCSS2() {
    return {};
  };
  var GroupHeading = function GroupHeading2(props) {
    var xcss2 = props.xcss;
    var _cleanCommonProps = cleanCommonProps(props), data = _cleanCommonProps.data, innerProps = _objectWithoutProperties(_cleanCommonProps, _excluded15);
    var _getStyleProps2 = getStyleProps(props, "groupHeading", {
      "group-heading": true
    }), css7 = _getStyleProps2.css, className = _getStyleProps2.className;
    return /* @__PURE__ */ React76.createElement("div", _extends({
      // eslint-disable-next-line @atlaskit/ui-styling-standard/no-classname-prop, @atlaskit/ui-styling-standard/local-cx-xcss, @compiled/local-cx-xcss
      className: ax(["_11c81o8v _1e0c1ule _syaz1gjq _80om73ad _k48pmoej _6rthpd1z _y4tiutpp _bozgutpp _1p1dglyw", cx(className, xcss2, "-group")]),
      style: css7
    }, innerProps));
  };
  var group_default = Group;

  // node_modules/@atlaskit/react-select/dist/esm/components/indicators.js
  init_defineProperty();
  var React77 = __toESM(require_react());
  var import_chevron_down = __toESM(require_chevron_down3());
  var import_cross_circle_select_clear = __toESM(require_cross_circle_select_clear());
  var _excluded16 = ["innerProps", "isRtl", "size", "isCompact", "xcss"];
  function ownKeys17(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r && (o = o.filter(function(r2) {
        return Object.getOwnPropertyDescriptor(e, r2).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread17(e) {
    for (var r = 1; r < arguments.length; r++) {
      var t = null != arguments[r] ? arguments[r] : {};
      r % 2 ? ownKeys17(Object(t), true).forEach(function(r2) {
        _defineProperty(e, r2, t[r2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys17(Object(t)).forEach(function(r2) {
        Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
      });
    }
    return e;
  }
  var iconContainerStyles = {
    root: "_kkk2n7od _12ji1r31 _1qu219ly _12y31o36 _1e0c1txw _4cvr1h6o _1bah1h6o _ca0qv77o _u5f3v77o _n3tdv77o _19bvv77o"
  };
  var dropdownWrapperStyles = {
    root: "_ca0q12x7 _u5f312x7 _n3td12x7 _19bv12x7"
  };
  var dropdownStyles = {
    default: "_v564vrg3 _1e0c1txw _syaz1gjq _ca0q12x7 _u5f3v77o _n3td12x7 _19bvv77o _30l31gjq",
    compact: "_ca0qidpf _n3tdidpf",
    disabled: "_syaz1lh4"
  };
  var dropdownIndicatorCSS = function dropdownIndicatorCSS2() {
    return {};
  };
  var DropdownIndicator = function DropdownIndicator2(props) {
    var innerProps = props.innerProps, children = props.children, isDisabled = props.isDisabled, isCompact = props.isCompact, xcss2 = props.xcss;
    var _getStyleProps = getStyleProps(props, "dropdownIndicator", {
      indicator: true,
      "dropdown-indicator": true
    }), css7 = _getStyleProps.css, className = _getStyleProps.className;
    return /* @__PURE__ */ React77.createElement("div", _extends({
      // eslint-disable-next-line @atlaskit/ui-styling-standard/enforce-style-prop
      style: css7,
      className: ax([dropdownStyles.default, isDisabled && dropdownStyles.disabled, isCompact && dropdownStyles.compact, cx(className, xcss2, "-indicatorContainer")])
    }, innerProps), children ? children : /* @__PURE__ */ React77.createElement(inline_default, {
      as: "span",
      xcss: dropdownWrapperStyles.root
    }, /* @__PURE__ */ React77.createElement(import_chevron_down.default, {
      color: "currentColor",
      label: "open",
      LEGACY_margin: "var(--ds-space-negative-075, -0.375rem)",
      size: "small"
    })));
  };
  var clearIndicatorCSS = function clearIndicatorCSS2() {
    return {};
  };
  var clearIndicatorStyles = {
    default: "_v564vrg3 _1e0c1txw _syaz131l _ca0q12x7 _u5f3v77o _n3td12x7 _19bvv77o _30l31gjq",
    compact: "_ca0qidpf _n3tdidpf"
  };
  var ClearIndicator = function ClearIndicator2(props) {
    var innerProps = props.innerProps, _props$clearControlLa = props.clearControlLabel, clearControlLabel = _props$clearControlLa === void 0 ? "clear" : _props$clearControlLa, isCompact = props.isCompact, xcss2 = props.xcss;
    var _getStyleProps2 = getStyleProps(props, "clearIndicator", {
      indicator: true,
      "clear-indicator": true
    }), css7 = _getStyleProps2.css, className = _getStyleProps2.className;
    return /* @__PURE__ */ React77.createElement("div", _extends({
      // eslint-disable-next-line @atlaskit/ui-styling-standard/enforce-style-prop
      style: css7,
      className: ax([clearIndicatorStyles.default, isCompact && clearIndicatorStyles.compact, cx(className, xcss2, "-indicatorContainer")])
    }, innerProps), /* @__PURE__ */ React77.createElement(pressable_default, {
      xcss: iconContainerStyles.root,
      tabIndex: -1,
      "aria-label": clearControlLabel
    }, /* @__PURE__ */ React77.createElement(import_cross_circle_select_clear.default, {
      label: "",
      color: "currentColor",
      LEGACY_size: "small",
      LEGACY_margin: "var(--ds-space-negative-025, -0.125rem)",
      size: "small"
    })));
  };
  var loadingIndicatorCSS = function loadingIndicatorCSS2() {
    return {};
  };
  var loadingIndicatorStyles = {
    default: "_ca0q12x7 _u5f3u2gc _n3td12x7 _19bvu2gc",
    compact: "_ca0qidpf _n3tdidpf"
  };
  var LoadingIndicator = function LoadingIndicator2(_ref2) {
    var innerProps = _ref2.innerProps, isRtl = _ref2.isRtl, _ref$size = _ref2.size, size2 = _ref$size === void 0 ? 4 : _ref$size, isCompact = _ref2.isCompact, xcss2 = _ref2.xcss, restProps = _objectWithoutProperties(_ref2, _excluded16);
    var _getStyleProps3 = getStyleProps(_objectSpread17(_objectSpread17({}, restProps), {}, {
      innerProps,
      isRtl,
      size: size2
    }), "loadingIndicator", {
      indicator: true,
      "loading-indicator": true
    }), css7 = _getStyleProps3.css, className = _getStyleProps3.className;
    return /* @__PURE__ */ React77.createElement("div", _extends({
      // eslint-disable-next-line @atlaskit/ui-styling-standard/enforce-style-prop
      style: css7,
      className: ax([loadingIndicatorStyles.default, isCompact && loadingIndicatorStyles.compact, cx(className, xcss2, "-loadingIndicator")])
    }, innerProps), /* @__PURE__ */ React77.createElement(spinner_default, {
      size: "small"
    }));
  };

  // node_modules/@atlaskit/react-select/dist/esm/components/input.js
  var React78 = __toESM(require_react());
  var import_platform_feature_flags18 = __toESM(require_cjs3());
  var _excluded17 = ["innerRef", "isDisabled", "isHidden", "inputClassName", "testId"];
  var inputCSS = function inputCSS2() {
    return {};
  };
  var inputStylesOld = {
    root: "_16jlkb7n _1o9zkb7n _i0dl1wug _nd5l1sux _1mouv77o _195gv77o _1rjcv77o _1e0c1n7u _yv0e12qd _syaz1fxt _j8d6idpf _1av2idpf _1doyidpf _pfztidpf _uoe3idpf _1recidpf _70xridpf _1k96idpf _eq43idpf _1h9u1kw7 _ckog1yjy _1x651r31 _1nn4glyw _1rzeidpf _1yd8yh40 _aetr11ps _uy7x15vq _1qjlqvpr",
    disabled: "_3um015vq"
  };
  var inputStyles = {
    root: "_16jlkb7n _1o9zkb7n _i0dl1wug _nd5l1sux _1mouv77o _195gv77o _1rjcv77o _kqswh2mm _1e0c1txw _yv0e12qd _syaz1fxt _j8d6idpf _1av2idpf _1doyidpf _pfztidpf _uoe3idpf _1recidpf _70xridpf _1k96idpf _eq43idpf _1h9u1kw7 _ckog1yjy _1x651r31 _1nn4glyw _1rzeidpf _1yd8yh40 _aetr11ps _uy7x15vq _1qjlqvpr",
    disabled: "_3um015vq"
  };
  var Input = function Input2(props) {
    var builtinCX = props.cx, value = props.value, xcss2 = props.xcss;
    var _cleanCommonProps = cleanCommonProps(props), innerRef = _cleanCommonProps.innerRef, isDisabled = _cleanCommonProps.isDisabled, isHidden = _cleanCommonProps.isHidden, inputClassName = _cleanCommonProps.inputClassName, testId = _cleanCommonProps.testId, innerProps = _objectWithoutProperties(_cleanCommonProps, _excluded17);
    var dataId = testId ? "".concat(testId, "-select--input") : null;
    var _getStyleProps = getStyleProps(props, "input", {
      "input-container": true
    }), css7 = _getStyleProps.css, className = _getStyleProps.className;
    if ((0, import_platform_feature_flags18.fg)("platform_do_not_clear_input_for_multiselect")) {
      return /* @__PURE__ */ React78.createElement("div", {
        // eslint-disable-next-line @atlaskit/ui-styling-standard/enforce-style-prop
        style: css7,
        className: ax([inputStyles.root, isDisabled && inputStyles.disabled, cx(className, xcss2, "-Input")]),
        "data-value": value || "",
        "data-testid": dataId && "".concat(dataId, "-container")
      }, /* @__PURE__ */ React78.createElement("input", _extends({
        // eslint-disable-next-line @atlaskit/ui-styling-standard/no-classname-prop
        className: ax(["_19pkidpf _2hwxidpf _otyridpf _18u0idpf _ca0qidpf _u5f3idpf _n3tdidpf _19bvidpf _1r04idpf _11q7idpf _19itidpf _11c81kw7 _nd5l1yjy _12ji1r31 _1qu2glyw _12y3idpf _1bsb1osq _1ul9yh40 _kqswstnw _syaz1kw7 _tzy4kb7n", isHidden && "_tzy4idpf", builtinCX({
          input: true
        }, inputClassName, "-input")]),
        ref: innerRef,
        disabled: isDisabled,
        "data-testid": dataId
      }, innerProps)));
    }
    return /* @__PURE__ */ React78.createElement("div", {
      // eslint-disable-next-line @atlaskit/ui-styling-standard/enforce-style-prop
      style: css7,
      className: ax([inputStylesOld.root, isDisabled && inputStylesOld.disabled, cx(className, xcss2, "-Input")]),
      "data-value": value || "",
      "data-testid": dataId && "".concat(dataId, "-container")
    }, /* @__PURE__ */ React78.createElement("input", _extends({
      // eslint-disable-next-line @atlaskit/ui-styling-standard/no-classname-prop
      className: ax(["_19pkidpf _2hwxidpf _otyridpf _18u0idpf _ca0qidpf _u5f3idpf _n3tdidpf _19bvidpf _11q7idpf _19itidpf _11c81kw7 _nd5l1yjy _12ji1r31 _1qu2glyw _12y3idpf _1bsb1osq _1ul9yh40 _syaz1kw7 _tzy4kb7n", isHidden && "_tzy4idpf", builtinCX({
        input: true
      }, inputClassName, "-input")]),
      ref: innerRef,
      disabled: isDisabled,
      "data-testid": dataId
    }, innerProps)));
  };
  var input_default = Input;

  // node_modules/@atlaskit/react-select/dist/esm/components/menu.js
  init_defineProperty();
  init_slicedToArray();
  var React79 = __toESM(require_react());
  var import_react124 = __toESM(require_react());

  // node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
  var min2 = Math.min;
  var max2 = Math.max;
  var round2 = Math.round;
  var floor = Math.floor;
  var createCoords = (v) => ({
    x: v,
    y: v
  });
  function rectToClientRect2(rect) {
    const {
      x,
      y,
      width: width2,
      height
    } = rect;
    return {
      width: width2,
      height,
      top: y,
      left: x,
      right: x + width2,
      bottom: y + height,
      x,
      y
    };
  }

  // node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs
  function hasWindow() {
    return typeof window !== "undefined";
  }
  function getNodeName2(node2) {
    if (isNode(node2)) {
      return (node2.nodeName || "").toLowerCase();
    }
    return "#document";
  }
  function getWindow2(node2) {
    var _node$ownerDocument;
    return (node2 == null || (_node$ownerDocument = node2.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
  }
  function getDocumentElement2(node2) {
    var _ref2;
    return (_ref2 = (isNode(node2) ? node2.ownerDocument : node2.document) || window.document) == null ? void 0 : _ref2.documentElement;
  }
  function isNode(value) {
    if (!hasWindow()) {
      return false;
    }
    return value instanceof Node || value instanceof getWindow2(value).Node;
  }
  function isElement2(value) {
    if (!hasWindow()) {
      return false;
    }
    return value instanceof Element || value instanceof getWindow2(value).Element;
  }
  function isHTMLElement2(value) {
    if (!hasWindow()) {
      return false;
    }
    return value instanceof HTMLElement || value instanceof getWindow2(value).HTMLElement;
  }
  function isShadowRoot2(value) {
    if (!hasWindow() || typeof ShadowRoot === "undefined") {
      return false;
    }
    return value instanceof ShadowRoot || value instanceof getWindow2(value).ShadowRoot;
  }
  var invalidOverflowDisplayValues = /* @__PURE__ */ new Set(["inline", "contents"]);
  function isOverflowElement(element) {
    const {
      overflow,
      overflowX,
      overflowY,
      display
    } = getComputedStyle3(element);
    return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !invalidOverflowDisplayValues.has(display);
  }
  function isWebKit() {
    if (typeof CSS === "undefined" || !CSS.supports) return false;
    return CSS.supports("-webkit-backdrop-filter", "none");
  }
  var lastTraversableNodeNames = /* @__PURE__ */ new Set(["html", "body", "#document"]);
  function isLastTraversableNode(node2) {
    return lastTraversableNodeNames.has(getNodeName2(node2));
  }
  function getComputedStyle3(element) {
    return getWindow2(element).getComputedStyle(element);
  }
  function getParentNode3(node2) {
    if (getNodeName2(node2) === "html") {
      return node2;
    }
    const result2 = (
      // Step into the shadow DOM of the parent of a slotted node.
      node2.assignedSlot || // DOM Element detected.
      node2.parentNode || // ShadowRoot detected.
      isShadowRoot2(node2) && node2.host || // Fallback.
      getDocumentElement2(node2)
    );
    return isShadowRoot2(result2) ? result2.host : result2;
  }
  function getNearestOverflowAncestor(node2) {
    const parentNode = getParentNode3(node2);
    if (isLastTraversableNode(parentNode)) {
      return node2.ownerDocument ? node2.ownerDocument.body : node2.body;
    }
    if (isHTMLElement2(parentNode) && isOverflowElement(parentNode)) {
      return parentNode;
    }
    return getNearestOverflowAncestor(parentNode);
  }
  function getOverflowAncestors(node2, list, traverseIframes) {
    var _node$ownerDocument2;
    if (list === void 0) {
      list = [];
    }
    if (traverseIframes === void 0) {
      traverseIframes = true;
    }
    const scrollableAncestor = getNearestOverflowAncestor(node2);
    const isBody = scrollableAncestor === ((_node$ownerDocument2 = node2.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
    const win = getWindow2(scrollableAncestor);
    if (isBody) {
      const frameElement = getFrameElement(win);
      return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
    }
    return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
  }
  function getFrameElement(win) {
    return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
  }

  // node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
  function getCssDimensions(element) {
    const css7 = getComputedStyle3(element);
    let width2 = parseFloat(css7.width) || 0;
    let height = parseFloat(css7.height) || 0;
    const hasOffset = isHTMLElement2(element);
    const offsetWidth = hasOffset ? element.offsetWidth : width2;
    const offsetHeight = hasOffset ? element.offsetHeight : height;
    const shouldFallback = round2(width2) !== offsetWidth || round2(height) !== offsetHeight;
    if (shouldFallback) {
      width2 = offsetWidth;
      height = offsetHeight;
    }
    return {
      width: width2,
      height,
      $: shouldFallback
    };
  }
  function unwrapElement(element) {
    return !isElement2(element) ? element.contextElement : element;
  }
  function getScale(element) {
    const domElement = unwrapElement(element);
    if (!isHTMLElement2(domElement)) {
      return createCoords(1);
    }
    const rect = domElement.getBoundingClientRect();
    const {
      width: width2,
      height,
      $
    } = getCssDimensions(domElement);
    let x = ($ ? round2(rect.width) : rect.width) / width2;
    let y = ($ ? round2(rect.height) : rect.height) / height;
    if (!x || !Number.isFinite(x)) {
      x = 1;
    }
    if (!y || !Number.isFinite(y)) {
      y = 1;
    }
    return {
      x,
      y
    };
  }
  var noOffsets = /* @__PURE__ */ createCoords(0);
  function getVisualOffsets(element) {
    const win = getWindow2(element);
    if (!isWebKit() || !win.visualViewport) {
      return noOffsets;
    }
    return {
      x: win.visualViewport.offsetLeft,
      y: win.visualViewport.offsetTop
    };
  }
  function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
    if (isFixed === void 0) {
      isFixed = false;
    }
    if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow2(element)) {
      return false;
    }
    return isFixed;
  }
  function getBoundingClientRect2(element, includeScale, isFixedStrategy, offsetParent) {
    if (includeScale === void 0) {
      includeScale = false;
    }
    if (isFixedStrategy === void 0) {
      isFixedStrategy = false;
    }
    const clientRect = element.getBoundingClientRect();
    const domElement = unwrapElement(element);
    let scale = createCoords(1);
    if (includeScale) {
      if (offsetParent) {
        if (isElement2(offsetParent)) {
          scale = getScale(offsetParent);
        }
      } else {
        scale = getScale(element);
      }
    }
    const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
    let x = (clientRect.left + visualOffsets.x) / scale.x;
    let y = (clientRect.top + visualOffsets.y) / scale.y;
    let width2 = clientRect.width / scale.x;
    let height = clientRect.height / scale.y;
    if (domElement) {
      const win = getWindow2(domElement);
      const offsetWin = offsetParent && isElement2(offsetParent) ? getWindow2(offsetParent) : offsetParent;
      let currentWin = win;
      let currentIFrame = getFrameElement(currentWin);
      while (currentIFrame && offsetParent && offsetWin !== currentWin) {
        const iframeScale = getScale(currentIFrame);
        const iframeRect = currentIFrame.getBoundingClientRect();
        const css7 = getComputedStyle3(currentIFrame);
        const left2 = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css7.paddingLeft)) * iframeScale.x;
        const top2 = iframeRect.top + (currentIFrame.clientTop + parseFloat(css7.paddingTop)) * iframeScale.y;
        x *= iframeScale.x;
        y *= iframeScale.y;
        width2 *= iframeScale.x;
        height *= iframeScale.y;
        x += left2;
        y += top2;
        currentWin = getWindow2(currentIFrame);
        currentIFrame = getFrameElement(currentWin);
      }
    }
    return rectToClientRect2({
      width: width2,
      height,
      x,
      y
    });
  }
  function rectsAreEqual(a, b) {
    return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;
  }
  function observeMove(element, onMove) {
    let io = null;
    let timeoutId;
    const root2 = getDocumentElement2(element);
    function cleanup() {
      var _io;
      clearTimeout(timeoutId);
      (_io = io) == null || _io.disconnect();
      io = null;
    }
    function refresh(skip, threshold) {
      if (skip === void 0) {
        skip = false;
      }
      if (threshold === void 0) {
        threshold = 1;
      }
      cleanup();
      const elementRectForRootMargin = element.getBoundingClientRect();
      const {
        left: left2,
        top: top2,
        width: width2,
        height
      } = elementRectForRootMargin;
      if (!skip) {
        onMove();
      }
      if (!width2 || !height) {
        return;
      }
      const insetTop = floor(top2);
      const insetRight = floor(root2.clientWidth - (left2 + width2));
      const insetBottom = floor(root2.clientHeight - (top2 + height));
      const insetLeft = floor(left2);
      const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
      const options2 = {
        rootMargin,
        threshold: max2(0, min2(1, threshold)) || 1
      };
      let isFirstUpdate = true;
      function handleObserve(entries) {
        const ratio = entries[0].intersectionRatio;
        if (ratio !== threshold) {
          if (!isFirstUpdate) {
            return refresh();
          }
          if (!ratio) {
            timeoutId = setTimeout(() => {
              refresh(false, 1e-7);
            }, 1e3);
          } else {
            refresh(false, ratio);
          }
        }
        if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {
          refresh();
        }
        isFirstUpdate = false;
      }
      try {
        io = new IntersectionObserver(handleObserve, {
          ...options2,
          // Handle <iframe>s
          root: root2.ownerDocument
        });
      } catch (_e) {
        io = new IntersectionObserver(handleObserve, options2);
      }
      io.observe(element);
    }
    refresh(true);
    return cleanup;
  }
  function autoUpdate(reference2, floating, update, options2) {
    if (options2 === void 0) {
      options2 = {};
    }
    const {
      ancestorScroll = true,
      ancestorResize = true,
      elementResize = typeof ResizeObserver === "function",
      layoutShift = typeof IntersectionObserver === "function",
      animationFrame = false
    } = options2;
    const referenceEl = unwrapElement(reference2);
    const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.addEventListener("scroll", update, {
        passive: true
      });
      ancestorResize && ancestor.addEventListener("resize", update);
    });
    const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
    let reobserveFrame = -1;
    let resizeObserver = null;
    if (elementResize) {
      resizeObserver = new ResizeObserver((_ref2) => {
        let [firstEntry] = _ref2;
        if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
          resizeObserver.unobserve(floating);
          cancelAnimationFrame(reobserveFrame);
          reobserveFrame = requestAnimationFrame(() => {
            var _resizeObserver;
            (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
          });
        }
        update();
      });
      if (referenceEl && !animationFrame) {
        resizeObserver.observe(referenceEl);
      }
      resizeObserver.observe(floating);
    }
    let frameId;
    let prevRefRect = animationFrame ? getBoundingClientRect2(reference2) : null;
    if (animationFrame) {
      frameLoop();
    }
    function frameLoop() {
      const nextRefRect = getBoundingClientRect2(reference2);
      if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
        update();
      }
      prevRefRect = nextRefRect;
      frameId = requestAnimationFrame(frameLoop);
    }
    update();
    return () => {
      var _resizeObserver2;
      ancestors.forEach((ancestor) => {
        ancestorScroll && ancestor.removeEventListener("scroll", update);
        ancestorResize && ancestor.removeEventListener("resize", update);
      });
      cleanupIo == null || cleanupIo();
      (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
      resizeObserver = null;
      if (animationFrame) {
        cancelAnimationFrame(frameId);
      }
    };
  }

  // node_modules/@atlaskit/react-select/dist/esm/components/menu.js
  var import_react_dom3 = __toESM(require_react_dom());

  // node_modules/use-isomorphic-layout-effect/dist/use-isomorphic-layout-effect.browser.esm.js
  var import_react123 = __toESM(require_react());
  var index = import_react123.useLayoutEffect;

  // node_modules/@atlaskit/react-select/dist/esm/components/menu.js
  var _excluded18 = ["children", "innerProps", "xcss"];
  var _excluded29 = ["children", "innerProps", "xcss"];
  function ownKeys18(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r && (o = o.filter(function(r2) {
        return Object.getOwnPropertyDescriptor(e, r2).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread18(e) {
    for (var r = 1; r < arguments.length; r++) {
      var t = null != arguments[r] ? arguments[r] : {};
      r % 2 ? ownKeys18(Object(t), true).forEach(function(r2) {
        _defineProperty(e, r2, t[r2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys18(Object(t)).forEach(function(r2) {
        Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
      });
    }
    return e;
  }
  function getMenuPlacement(_ref2) {
    var preferredMaxHeight = _ref2.maxHeight, menuEl = _ref2.menuEl, minHeight = _ref2.minHeight, preferredPlacement = _ref2.placement, shouldScroll = _ref2.shouldScroll, isFixedPosition = _ref2.isFixedPosition, controlHeight = _ref2.controlHeight;
    var scrollParent = getScrollParent2(menuEl);
    var defaultState = {
      placement: "bottom",
      maxHeight: preferredMaxHeight
    };
    if (!menuEl || !menuEl.offsetParent) {
      return defaultState;
    }
    var _scrollParent$getBoun = scrollParent.getBoundingClientRect(), scrollHeight = _scrollParent$getBoun.height;
    var _menuEl$getBoundingCl = menuEl.getBoundingClientRect(), menuBottom = _menuEl$getBoundingCl.bottom, menuHeight = _menuEl$getBoundingCl.height, menuTop = _menuEl$getBoundingCl.top;
    var _menuEl$offsetParent$ = menuEl.offsetParent.getBoundingClientRect(), containerTop = _menuEl$offsetParent$.top;
    var viewHeight = isFixedPosition ? window.innerHeight : normalizedHeight(scrollParent);
    var scrollTop = getScrollTop(scrollParent);
    var menuTopFromParent = menuTop;
    var marginBottom = parseInt(getComputedStyle(menuEl).marginBottom, 10);
    var marginTop = parseInt(getComputedStyle(menuEl).marginTop, 10);
    var viewSpaceAbove = containerTop - marginTop;
    var viewSpaceBelow = viewHeight - menuTopFromParent;
    var scrollSpaceAbove = viewSpaceAbove + scrollTop;
    var scrollSpaceBelow = scrollHeight - scrollTop - menuTopFromParent;
    var scrollDown = menuBottom - viewHeight + scrollTop + marginBottom;
    var scrollUp = scrollTop + menuTop - marginTop;
    var scrollDuration = 160;
    switch (preferredPlacement) {
      case "auto":
      case "bottom":
        if (viewSpaceBelow >= menuHeight) {
          return {
            placement: "bottom",
            maxHeight: preferredMaxHeight
          };
        }
        if (scrollSpaceBelow >= menuHeight && !isFixedPosition) {
          if (shouldScroll) {
            animatedScrollTo(scrollParent, scrollDown, scrollDuration);
          }
          return {
            placement: "bottom",
            maxHeight: preferredMaxHeight
          };
        }
        if (!isFixedPosition && scrollSpaceBelow >= minHeight || isFixedPosition && viewSpaceBelow >= minHeight) {
          if (shouldScroll) {
            animatedScrollTo(scrollParent, scrollDown, scrollDuration);
          }
          var constrainedHeight = isFixedPosition ? viewSpaceBelow - marginBottom : scrollSpaceBelow - marginBottom;
          return {
            placement: "bottom",
            maxHeight: constrainedHeight
          };
        }
        if (preferredPlacement === "auto" || isFixedPosition) {
          var _constrainedHeight = preferredMaxHeight;
          var spaceAbove = isFixedPosition ? viewSpaceAbove : scrollSpaceAbove;
          if (spaceAbove >= minHeight) {
            _constrainedHeight = Math.min(spaceAbove - marginBottom - controlHeight, preferredMaxHeight);
          }
          return {
            placement: "top",
            maxHeight: _constrainedHeight
          };
        }
        if (preferredPlacement === "bottom") {
          if (shouldScroll) {
            scrollTo(scrollParent, scrollDown);
          }
          return {
            placement: "bottom",
            maxHeight: preferredMaxHeight
          };
        }
        break;
      case "top":
        if (viewSpaceAbove >= menuHeight) {
          return {
            placement: "top",
            maxHeight: preferredMaxHeight
          };
        }
        if (scrollSpaceAbove >= menuHeight && !isFixedPosition) {
          if (shouldScroll) {
            animatedScrollTo(scrollParent, scrollUp, scrollDuration);
          }
          return {
            placement: "top",
            maxHeight: preferredMaxHeight
          };
        }
        if (!isFixedPosition && scrollSpaceAbove >= minHeight || isFixedPosition && viewSpaceAbove >= minHeight) {
          var _constrainedHeight2 = preferredMaxHeight;
          if (!isFixedPosition && scrollSpaceAbove >= minHeight || isFixedPosition && viewSpaceAbove >= minHeight) {
            _constrainedHeight2 = isFixedPosition ? viewSpaceAbove - marginTop : scrollSpaceAbove - marginTop;
          }
          if (shouldScroll) {
            animatedScrollTo(scrollParent, scrollUp, scrollDuration);
          }
          return {
            placement: "top",
            maxHeight: _constrainedHeight2
          };
        }
        return {
          placement: "bottom",
          maxHeight: preferredMaxHeight
        };
      default:
        throw new Error('Invalid placement provided "'.concat(preferredPlacement, '".'));
    }
    return defaultState;
  }
  var coercePlacement = function coercePlacement2(p) {
    return p === "auto" ? "bottom" : p;
  };
  var menuStyles = {
    root: "_2rkoglpi _kqswstnw _1bsb1osq _1pbykb7n _otyru2gc _19pku2gc _bfhk1bhr _16qsd0yg",
    bottom: "_154i1osq",
    top: "_94n51osq"
  };
  var menuCSS = function menuCSS2() {
    return {};
  };
  var PortalPlacementContext = /* @__PURE__ */ (0, import_react124.createContext)(null);
  var MenuPlacer = function MenuPlacer2(props) {
    var children = props.children, minMenuHeight = props.minMenuHeight, maxMenuHeight = props.maxMenuHeight, menuPlacement = props.menuPlacement, menuPosition = props.menuPosition, menuShouldScrollIntoView = props.menuShouldScrollIntoView;
    var _ref2 = (0, import_react124.useContext)(PortalPlacementContext) || {}, setPortalPlacement = _ref2.setPortalPlacement;
    var ref = (0, import_react124.useRef)(null);
    var _useState = (0, import_react124.useState)(maxMenuHeight), _useState2 = _slicedToArray(_useState, 2), maxHeight = _useState2[0], setMaxHeight = _useState2[1];
    var _useState3 = (0, import_react124.useState)(null), _useState4 = _slicedToArray(_useState3, 2), placement = _useState4[0], setPlacement = _useState4[1];
    var controlHeight = 38;
    index(function() {
      var menuEl = ref.current;
      if (!menuEl) {
        return;
      }
      var isFixedPosition = menuPosition === "fixed";
      var shouldScroll = menuShouldScrollIntoView && !isFixedPosition;
      var state = getMenuPlacement({
        maxHeight: maxMenuHeight,
        menuEl,
        minHeight: minMenuHeight,
        placement: menuPlacement,
        shouldScroll,
        isFixedPosition,
        controlHeight
      });
      setMaxHeight(state.maxHeight);
      setPlacement(state.placement);
      setPortalPlacement === null || setPortalPlacement === void 0 || setPortalPlacement(state.placement);
    }, [maxMenuHeight, menuPlacement, menuPosition, menuShouldScrollIntoView, minMenuHeight, setPortalPlacement, controlHeight]);
    return children({
      ref,
      placerProps: _objectSpread18(_objectSpread18({}, props), {}, {
        placement: placement || coercePlacement(menuPlacement),
        maxHeight
      })
    });
  };
  var Menu = function Menu2(props) {
    var children = props.children, innerRef = props.innerRef, innerProps = props.innerProps, _props$placement = props.placement, placement = _props$placement === void 0 ? "bottom" : _props$placement, xcss2 = props.xcss;
    var _getStyleProps = getStyleProps(props, "menu", {
      menu: true
    }), css7 = _getStyleProps.css, className = _getStyleProps.className;
    return /* @__PURE__ */ React79.createElement("div", _extends({
      // eslint-disable-next-line @atlaskit/ui-styling-standard/no-classname-prop, @atlaskit/ui-styling-standard/local-cx-xcss, @compiled/local-cx-xcss
      className: ax([menuStyles.root, menuStyles[placement], cx(xcss2, className, "-menu")]),
      style: css7,
      ref: innerRef
    }, innerProps), children);
  };
  var menu_default = Menu;
  var menuListCSS = function menuListCSS2() {
    return {};
  };
  var MenuList = function MenuList2(props) {
    var children = props.children, innerProps = props.innerProps, innerRef = props.innerRef, isMulti = props.isMulti, maxHeight = props.maxHeight, xcss2 = props.xcss;
    var _getStyleProps2 = getStyleProps(props, "menuList", {
      "menu-list": true,
      "menu-list--is-multi": isMulti
    }), css7 = _getStyleProps2.css, className = _getStyleProps2.className;
    return /* @__PURE__ */ React79.createElement("div", _extends({
      // eslint-disable-next-line @atlaskit/ui-styling-standard/no-classname-prop, @atlaskit/ui-styling-standard/local-cx-xcss, @compiled/local-cx-xcss
      className: ax(["_kqswh2mm _18m91wug _85i5u2gc _1q51u2gc _8am5i4x0", cx(className, xcss2, "-MenuList")]),
      style: _objectSpread18(_objectSpread18({}, css7), {}, {
        maxHeight
      }),
      ref: innerRef
    }, innerProps, {
      tabIndex: -1
    }), children);
  };
  var noticeCSS = function noticeCSS2() {
    return {};
  };
  var noOptionsMessageCSS = noticeCSS;
  var loadingMessageCSS = noticeCSS;
  var NoOptionsMessage = function NoOptionsMessage2(_ref3) {
    var _ref3$children = _ref3.children, children = _ref3$children === void 0 ? "No options" : _ref3$children, innerProps = _ref3.innerProps, xcss2 = _ref3.xcss, restProps = _objectWithoutProperties(_ref3, _excluded18);
    var _getStyleProps3 = getStyleProps(_objectSpread18(_objectSpread18({}, restProps), {}, {
      children,
      innerProps
    }), "noOptionsMessage", {
      "menu-notice": true,
      "menu-notice--no-options": true
    }), css7 = _getStyleProps3.css, className = _getStyleProps3.className;
    return /* @__PURE__ */ React79.createElement("div", _extends({
      // eslint-disable-next-line @atlaskit/ui-styling-standard/no-classname-prop, @atlaskit/ui-styling-standard/local-cx-xcss, @compiled/local-cx-xcss
      className: ax(["_85i5u2gc _1q51u2gc _y4tiutpp _bozgutpp _y3gn1h6o", cx(className, xcss2, "-NoOptionsMessage")]),
      style: css7,
      role: "option"
    }, innerProps), /* @__PURE__ */ React79.createElement(text_default, {
      color: "color.text.subtle"
    }, children));
  };
  var LoadingMessage = function LoadingMessage2(_ref4) {
    var _ref4$children = _ref4.children, children = _ref4$children === void 0 ? "Loading..." : _ref4$children, innerProps = _ref4.innerProps, xcss2 = _ref4.xcss, restProps = _objectWithoutProperties(_ref4, _excluded29);
    var _getStyleProps4 = getStyleProps(_objectSpread18(_objectSpread18({}, restProps), {}, {
      children,
      innerProps
    }), "loadingMessage", {
      "menu-notice": true,
      "menu-notice--loading": true
    }), css7 = _getStyleProps4.css, className = _getStyleProps4.className;
    return /* @__PURE__ */ React79.createElement("div", _extends({
      // eslint-disable-next-line @atlaskit/ui-styling-standard/no-classname-prop, @atlaskit/ui-styling-standard/local-cx-xcss, @compiled/local-cx-xcss
      className: ax(["_85i5u2gc _1q51u2gc _y4tiutpp _bozgutpp _y3gn1h6o", cx(className, xcss2, "-LoadingMessage")]),
      style: css7
    }, innerProps, {
      // eslint-disable-next-line jsx-a11y/role-has-required-aria-props
      role: "option"
    }), /* @__PURE__ */ React79.createElement(text_default, {
      color: "color.text.subtle"
    }, children));
  };
  var menuPortalCSS = function menuPortalCSS2() {
    return {};
  };
  var menuPortalStyles = {
    root: "_1pbykb7n _1ltva1vk _kqswcp1v _154i1nmo _1bsb1qxj"
  };
  var MenuPortal = function MenuPortal2(props) {
    var appendTo = props.appendTo, children = props.children, controlElement = props.controlElement, innerProps = props.innerProps, menuPlacement = props.menuPlacement, menuPosition = props.menuPosition, xcss2 = props.xcss;
    var menuPortalRef = (0, import_react124.useRef)(null);
    var cleanupRef = (0, import_react124.useRef)(null);
    var _useState5 = (0, import_react124.useState)(coercePlacement(menuPlacement)), _useState6 = _slicedToArray(_useState5, 2), placement = _useState6[0], setPortalPlacement = _useState6[1];
    var portalPlacementContext = (0, import_react124.useMemo)(function() {
      return {
        setPortalPlacement
      };
    }, []);
    var _useState7 = (0, import_react124.useState)(null), _useState8 = _slicedToArray(_useState7, 2), computedPosition = _useState8[0], setComputedPosition = _useState8[1];
    var updateComputedPosition = (0, import_react124.useCallback)(function() {
      if (!controlElement) {
        return;
      }
      var rect = getBoundingClientObj(controlElement);
      var scrollDistance = menuPosition === "fixed" ? 0 : window.pageYOffset;
      var offset3 = rect[placement] + scrollDistance;
      if (offset3 !== (computedPosition === null || computedPosition === void 0 ? void 0 : computedPosition.offset) || rect.left !== (computedPosition === null || computedPosition === void 0 ? void 0 : computedPosition.rect.left) || rect.width !== (computedPosition === null || computedPosition === void 0 ? void 0 : computedPosition.rect.width)) {
        setComputedPosition({
          offset: offset3,
          rect
        });
      }
    }, [controlElement, menuPosition, placement, computedPosition === null || computedPosition === void 0 ? void 0 : computedPosition.offset, computedPosition === null || computedPosition === void 0 ? void 0 : computedPosition.rect.left, computedPosition === null || computedPosition === void 0 ? void 0 : computedPosition.rect.width]);
    index(function() {
      updateComputedPosition();
    }, [updateComputedPosition]);
    var runAutoUpdate = (0, import_react124.useCallback)(function() {
      if (typeof cleanupRef.current === "function") {
        cleanupRef.current();
        cleanupRef.current = null;
      }
      if (controlElement && menuPortalRef.current) {
        cleanupRef.current = autoUpdate(controlElement, menuPortalRef.current, updateComputedPosition, {
          elementResize: "ResizeObserver" in window
        });
      }
    }, [controlElement, updateComputedPosition]);
    index(function() {
      runAutoUpdate();
    }, [runAutoUpdate]);
    var setMenuPortalElement = (0, import_react124.useCallback)(function(menuPortalElement) {
      menuPortalRef.current = menuPortalElement;
      runAutoUpdate();
    }, [runAutoUpdate]);
    if (!appendTo && menuPosition !== "fixed" || !computedPosition) {
      return null;
    }
    var _getStyleProps5 = getStyleProps(_objectSpread18(_objectSpread18({}, props), {}, {
      offset: computedPosition.offset,
      position: menuPosition,
      rect: computedPosition.rect
    }), "menuPortal", {
      "menu-portal": true
    }), css7 = _getStyleProps5.css, className = _getStyleProps5.className;
    var menuWrapper = /* @__PURE__ */ React79.createElement("div", _extends({
      // eslint-disable-next-line @atlaskit/ui-styling-standard/no-classname-prop, @atlaskit/ui-styling-standard/local-cx-xcss, @compiled/local-cx-xcss
      className: ax([menuPortalStyles.root, cx(className, xcss2, "-MenuPortal")]),
      ref: setMenuPortalElement,
      style: _objectSpread18({
        // eslint-disable-next-line @atlaskit/ui-styling-standard/enforce-style-prop
        "--menu-left": "".concat(computedPosition.rect.left, "px"),
        "--menu-position": menuPosition,
        "--menu-top": "".concat(computedPosition.offset, "px"),
        "--menu-width": "".concat(computedPosition.rect.width, "px")
      }, css7)
    }, innerProps), children);
    return /* @__PURE__ */ React79.createElement(PortalPlacementContext.Provider, {
      value: portalPlacementContext
    }, appendTo ? /* @__PURE__ */ (0, import_react_dom3.createPortal)(menuWrapper, appendTo) : menuWrapper);
  };

  // node_modules/@atlaskit/react-select/dist/esm/components/multi-value.js
  init_defineProperty();
  var React80 = __toESM(require_react());
  var import_cross3 = __toESM(require_cross());
  var import_select_clear = __toESM(require_select_clear());
  var import_platform_feature_flags19 = __toESM(require_cjs3());
  function ownKeys19(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r && (o = o.filter(function(r2) {
        return Object.getOwnPropertyDescriptor(e, r2).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread19(e) {
    for (var r = 1; r < arguments.length; r++) {
      var t = null != arguments[r] ? arguments[r] : {};
      r % 2 ? ownKeys19(Object(t), true).forEach(function(r2) {
        _defineProperty(e, r2, t[r2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys19(Object(t)).forEach(function(r2) {
        Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
      });
    }
    return e;
  }
  var multiValueStyles = {
    root: "_2rkogqwt _1e0c1txw _1ul9ze3t _19pkv77o _2hwxv77o _otyrv77o _18u0v77o _bfhkm7j4 _p12f1osq _syazjpor _3yq3glyw",
    disabled: "_syaz1lh4 _bfhkm7j4",
    focused: "_syaz1wum _bfhkfg4m _16qs7ex6 _1aewe4h9 _6up51j28 _1xdnnqa1",
    refresh: "_2rkoiti9 _1h6d14je _1dqonqa1 _189ee4h9 _bfhk1j9a"
  };
  var multiValueCSS = function multiValueCSS2() {
    return {};
  };
  var multiValueLabelCSS = function multiValueLabelCSS2() {
    return {};
  };
  var multiValueLabelStyles = {
    root: "_1reo15vq _18m915vq _2rkogqwt _11c8dcr7 _o5721q9c _ca0qv77o _u5f3v77o _n3tdv77o _19bv12x7 _syaz1kw7",
    disabled: "_syaz1lh4",
    ellipsis: "_1bto1l2s",
    refresh: "_11c82smr _ca0qidpf _n3tdidpf _19bv1b66"
  };
  var multiValueRemoveCSS = function multiValueRemoveCSS2() {
    return {};
  };
  var multiValueRemoveStyles = {
    focused: "_bfhkb1q9 _lswu1rrc",
    root: "_2rkovtp2 _4cvr1h6o _1e0c1txw _lswu1dx5 _19bvv77o _u5f3v77o _irr31yvi _13br1jjn _1di61io2 _i5f81jjn",
    refresh: "_19itglyw _2rkoglpi _bfhksm61 _4cvr1h6o _1bah1h6o _1wpz1h6o _r06hglyw _syaz1fxt _ca0qv77o _u5f3v77o _n3tdv77o _19bvv77o _2hwxv77o _1ah312gs _irr3166n _1di61dty"
  };
  var MultiValueContainer = function MultiValueContainer2(_ref2) {
    var children = _ref2.children, innerProps = _ref2.innerProps, isFocused = _ref2.isFocused, isDisabled = _ref2.isDisabled, className = _ref2.className, xcss2 = _ref2.xcss;
    return /* @__PURE__ */ React80.createElement("div", _extends({}, innerProps, {
      // eslint-disable-next-line @atlaskit/ui-styling-standard/no-classname-prop, @atlaskit/ui-styling-standard/local-cx-xcss, @compiled/local-cx-xcss
      className: ax([multiValueStyles.root, isDisabled && multiValueStyles.disabled, isFocused && multiValueStyles.focused, (0, import_platform_feature_flags19.fg)("platform-component-visual-refresh") && multiValueStyles.refresh, cx(className, xcss2, "-multiValue")])
    }), children);
  };
  var MultiValueLabel = function MultiValueLabel2(_ref2) {
    var children = _ref2.children, innerProps = _ref2.innerProps, isDisabled = _ref2.isDisabled, hasEllipsis = _ref2.hasEllipsis, className = _ref2.className, xcss2 = _ref2.xcss;
    return /* @__PURE__ */ React80.createElement("div", _extends({}, innerProps, {
      // eslint-disable-next-line @atlaskit/ui-styling-standard/no-classname-prop, @atlaskit/ui-styling-standard/local-cx-xcss, @compiled/local-cx-xcss
      className: ax([multiValueLabelStyles.root, isDisabled && multiValueLabelStyles.disabled, hasEllipsis && multiValueLabelStyles.ellipsis, (0, import_platform_feature_flags19.fg)("platform-component-visual-refresh") && multiValueLabelStyles.refresh, cx(className, xcss2, "-MultiValueLabel")])
    }), children);
  };
  function MultiValueRemove(_ref3) {
    var isDisabled = _ref3.isDisabled, isFocused = _ref3.isFocused, innerProps = _ref3.innerProps, className = _ref3.className, xcss2 = _ref3.xcss;
    return /* @__PURE__ */ React80.createElement("div", _extends({}, innerProps, {
      // eslint-disable-next-line @atlaskit/ui-styling-standard/no-classname-prop, @atlaskit/ui-styling-standard/local-cx-xcss, @compiled/local-cx-xcss
      className: ax([multiValueRemoveStyles.root, isFocused && multiValueRemoveStyles.focused, (0, import_platform_feature_flags19.fg)("platform-component-visual-refresh") && multiValueRemoveStyles.refresh, cx(className, xcss2, "-MultiValueRemove")])
    }), /* @__PURE__ */ React80.createElement("div", {
      "data-testid": isDisabled ? "hide-clear-icon" : "show-clear-icon",
      className: ax([isDisabled && "_1e0cglyw", !isDisabled && "_1e0c1kw7"])
    }, /* @__PURE__ */ React80.createElement(import_cross3.default, {
      label: "",
      color: "currentColor",
      LEGACY_fallbackIcon: import_select_clear.default,
      LEGACY_primaryColor: "transparent",
      LEGACY_secondaryColor: "inherit",
      LEGACY_size: "small",
      size: "small"
    })));
  }
  var MultiValue = function MultiValue2(props) {
    var children = props.children, components2 = props.components, data = props.data, innerProps = props.innerProps, isDisabled = props.isDisabled, isFocused = props.isFocused, removeProps3 = props.removeProps, selectProps = props.selectProps, cropWithEllipsis = props.cropWithEllipsis;
    var Container = components2.Container, Label = components2.Label, Remove = components2.Remove;
    var ariaLabel = typeof children === "string" ? children : data.label;
    var _getStyleProps = getStyleProps(props, "multiValue", {
      "multi-value": true,
      "multi-value--is-disabled": isDisabled
    }), containerCss = _getStyleProps.css, containerClassName = _getStyleProps.className;
    var _getStyleProps2 = getStyleProps(props, "multiValueLabel", {
      "multi-value__label": true
    }), labelCss = _getStyleProps2.css, labelClassName = _getStyleProps2.className;
    var _getStyleProps3 = getStyleProps(props, "multiValueRemove", {
      "multi-value__remove": true
    }), removeCss = _getStyleProps3.css, removeClassName = _getStyleProps3.className;
    return /* @__PURE__ */ React80.createElement(Container, {
      data,
      innerProps: _objectSpread19({
        style: containerCss,
        className: containerClassName
      }, innerProps),
      className: containerClassName,
      isFocused,
      isDisabled,
      selectProps
    }, /* @__PURE__ */ React80.createElement(Label, {
      data,
      innerProps: {
        style: labelCss,
        className: labelClassName
      },
      className: labelClassName,
      hasEllipsis: cropWithEllipsis || cropWithEllipsis === void 0,
      selectProps
    }, children), /* @__PURE__ */ React80.createElement(Remove, {
      data,
      innerProps: _objectSpread19({
        style: removeCss,
        className: removeClassName,
        role: "button",
        tabIndex: -1,
        "aria-label": "".concat(ariaLabel || "option", ", remove")
      }, removeProps3),
      className: removeClassName,
      isDisabled,
      selectProps
    }));
  };
  var multi_value_default = MultiValue;

  // node_modules/@atlaskit/react-select/dist/esm/components/option.js
  var React81 = __toESM(require_react());
  var optionCSS = function optionCSS2() {
    return {};
  };
  var optionStyles = {
    root: "_1rjc12x7 _18zrutpp _syaz1fxt _80om73ad _1e0c1ule _1wyb1kw7 _1bsb1osq _uiztglyw _18ql1j7p _1di61dty",
    disabled: "_syaz1lh4 _80om13gf _bfhk1j28 _16qsglyw _1di61j28 _1pknglyw",
    focused: "_bfhk166n _16qsu4to _1pkn1vrj",
    selected: "_syazaqb7 _bfhkfg4m _16qsu4to _1di619ru _1pkn1vrj",
    focusedSelected: "_bfhki1yw"
  };
  var Option = function Option2(props) {
    var children = props.children, isDisabled = props.isDisabled, isFocused = props.isFocused, isSelected = props.isSelected, innerRef = props.innerRef, innerProps = props.innerProps, xcss2 = props.xcss;
    var _getStyleProps = getStyleProps(props, "option", {
      option: true,
      "option--is-disabled": isDisabled,
      "option--is-focused": isFocused,
      "option--is-selected": isSelected
    }), css7 = _getStyleProps.css, className = _getStyleProps.className;
    return /* @__PURE__ */ React81.createElement("div", _extends({
      // eslint-disable-next-line @atlaskit/ui-styling-standard/enforce-style-prop
      style: css7,
      className: ax([optionStyles.root, isFocused && optionStyles.focused, isSelected && optionStyles.selected, isFocused && isSelected && optionStyles.focusedSelected, isDisabled && optionStyles.disabled, cx(className, xcss2, "-option")]),
      ref: innerRef
    }, innerProps, {
      tabIndex: -1
    }), children);
  };
  var option_default = Option;

  // node_modules/@atlaskit/react-select/dist/esm/components/placeholder.js
  var React82 = __toESM(require_react());
  var placeholderCSS = function placeholderCSS2() {
    return {};
  };
  var placeholderStyles = {
    root: "_nd5l1sux _19pkidpf _2hwxv77o _otyridpf _18u0v77o _syaz131l",
    disabled: "_syaz1lh4"
  };
  var Placeholder = function Placeholder2(props) {
    var children = props.children, innerProps = props.innerProps, isDisabled = props.isDisabled, xcss2 = props.xcss;
    var _getStyleProps = getStyleProps(props, "placeholder", {
      placeholder: true
    }), css7 = _getStyleProps.css, className = _getStyleProps.className;
    return /* @__PURE__ */ React82.createElement("div", _extends({
      // eslint-disable-next-line @atlaskit/ui-styling-standard/enforce-style-prop
      style: css7,
      className: ax([placeholderStyles.root, isDisabled && placeholderStyles.disabled, cx(className, xcss2, "-placeholder")])
    }, innerProps), children);
  };
  var placeholder_default = Placeholder;

  // node_modules/@atlaskit/react-select/dist/esm/components/single-value.js
  var React83 = __toESM(require_react());
  var css5 = function css6() {
    return {};
  };
  var styles14 = {
    root: "_nd5l1sux _1reo15vq _18m915vq _p12f1osq _1bto1l2s _o5721q9c _19pkidpf _2hwxv77o _otyridpf _18u0v77o _syaz1fxt",
    disalbed: "_syaz1lh4"
  };
  var SingleValue = function SingleValue2(props) {
    var children = props.children, isDisabled = props.isDisabled, innerProps = props.innerProps, xcss2 = props.xcss;
    var _getStyleProps = getStyleProps(props, "singleValue", {
      "single-value": true,
      "single-value--is-disabled": isDisabled
    }), css7 = _getStyleProps.css, className = _getStyleProps.className;
    return /* @__PURE__ */ React83.createElement("div", _extends({
      // eslint-disable-next-line @atlaskit/ui-styling-standard/enforce-style-prop
      style: css7,
      className: ax([styles14.root, isDisabled && styles14.disalbed, cx(className, xcss2, "-singleValue")])
    }, innerProps), children);
  };
  var single_value_default = SingleValue;

  // node_modules/@atlaskit/react-select/dist/esm/components/index.js
  function ownKeys20(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r && (o = o.filter(function(r2) {
        return Object.getOwnPropertyDescriptor(e, r2).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread20(e) {
    for (var r = 1; r < arguments.length; r++) {
      var t = null != arguments[r] ? arguments[r] : {};
      r % 2 ? ownKeys20(Object(t), true).forEach(function(r2) {
        _defineProperty(e, r2, t[r2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys20(Object(t)).forEach(function(r2) {
        Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
      });
    }
    return e;
  }
  var components = {
    ClearIndicator,
    Control: control_default,
    DropdownIndicator,
    Group: group_default,
    GroupHeading,
    IndicatorsContainer,
    Input: input_default,
    LoadingIndicator,
    Menu: menu_default,
    MenuList,
    MenuPortal,
    LoadingMessage,
    NoOptionsMessage,
    MultiValue: multi_value_default,
    MultiValueContainer,
    MultiValueLabel,
    MultiValueRemove,
    Option: option_default,
    Placeholder: placeholder_default,
    SelectContainer,
    SingleValue: single_value_default,
    ValueContainer
  };
  var defaultComponents = function defaultComponents2(props) {
    return _objectSpread20(_objectSpread20({}, components), props.components);
  };

  // node_modules/@atlaskit/react-select/dist/esm/components/internal/a11y-text.js
  var React84 = __toESM(require_react());
  var A11yText = function A11yText2(props) {
    return /* @__PURE__ */ React84.createElement("span", _extends({
      // eslint-disable-next-line  @atlaskit/ui-styling-standard/no-classname-prop
      className: ax(["_ca0qidpf _u5f3idpf _n3tdidpf _19bvidpf _19itidpf _1reo15vq _18m915vq _1bsbt94y _4t3it94y _kqswstnw _1pbydx66 _ogto7mnp _uiztglyw _o5721q9c", "-a11yText"])
      // eslint-disable-next-line @repo/internal/react/no-unsafe-spread-props
    }, props));
  };
  var a11y_text_default = A11yText;

  // node_modules/@atlaskit/react-select/dist/esm/components/internal/dummy-input.js
  var React85 = __toESM(require_react());
  var _excluded19 = ["innerRef"];
  function DummyInput(_ref2) {
    var innerRef = _ref2.innerRef, props = _objectWithoutProperties(_ref2, _excluded19);
    var filteredProps = removeProps(props, "onExited", "in", "enter", "exit", "appear");
    return /* @__PURE__ */ React85.createElement("input", _extends({
      ref: innerRef,
      className: ax(["_ca0qidpf _u5f3idpf _n3tdidpf _19bvidpf _11q7idpf _19itidpf _nd5l1sux _12ji1r31 _1qu2glyw _12y3idpf _1bsbt94y _kqswh2mm _1n5d1j28 _syaz1j28 _1e02p1rm _tzy4idpf _t9ec1kuz", "-dummyInput"])
    }, filteredProps));
  }

  // node_modules/@atlaskit/react-select/dist/esm/components/internal/scroll-manager.js
  var import_react132 = __toESM(require_react());

  // node_modules/@atlaskit/react-select/dist/esm/components/internal/use-scroll-capture.js
  var import_react130 = __toESM(require_react());
  var cancelScroll = function cancelScroll2(event) {
    if (event.cancelable) {
      event.preventDefault();
    }
    event.stopPropagation();
  };
  function useScrollCapture(_ref2) {
    var isEnabled = _ref2.isEnabled, onBottomArrive = _ref2.onBottomArrive, onBottomLeave = _ref2.onBottomLeave, onTopArrive = _ref2.onTopArrive, onTopLeave = _ref2.onTopLeave;
    var isBottom = (0, import_react130.useRef)(false);
    var isTop = (0, import_react130.useRef)(false);
    var touchStart = (0, import_react130.useRef)(0);
    var scrollTarget = (0, import_react130.useRef)(null);
    var handleEventDelta = (0, import_react130.useCallback)(function(event, delta) {
      if (scrollTarget.current === null) {
        return;
      }
      var _scrollTarget$current = scrollTarget.current, scrollTop = _scrollTarget$current.scrollTop, scrollHeight = _scrollTarget$current.scrollHeight, clientHeight = _scrollTarget$current.clientHeight;
      var target = scrollTarget.current;
      var isDeltaPositive = delta > 0;
      var availableScroll = scrollHeight - clientHeight - scrollTop;
      var shouldCancelScroll = false;
      if (availableScroll > delta && isBottom.current) {
        if (onBottomLeave) {
          onBottomLeave(event);
        }
        isBottom.current = false;
      }
      if (isDeltaPositive && isTop.current) {
        if (onTopLeave) {
          onTopLeave(event);
        }
        isTop.current = false;
      }
      if (isDeltaPositive && delta > availableScroll) {
        if (onBottomArrive && !isBottom.current) {
          onBottomArrive(event);
        }
        target.scrollTop = scrollHeight;
        shouldCancelScroll = true;
        isBottom.current = true;
      } else if (!isDeltaPositive && -delta > scrollTop) {
        if (onTopArrive && !isTop.current) {
          onTopArrive(event);
        }
        target.scrollTop = 0;
        shouldCancelScroll = true;
        isTop.current = true;
      }
      if (shouldCancelScroll) {
        cancelScroll(event);
      }
    }, [onBottomArrive, onBottomLeave, onTopArrive, onTopLeave]);
    var onWheel = (0, import_react130.useCallback)(function(event) {
      handleEventDelta(event, event.deltaY);
    }, [handleEventDelta]);
    var onTouchStart = (0, import_react130.useCallback)(function(event) {
      touchStart.current = event.changedTouches[0].clientY;
    }, []);
    var onTouchMove = (0, import_react130.useCallback)(function(event) {
      var deltaY = touchStart.current - event.changedTouches[0].clientY;
      handleEventDelta(event, deltaY);
    }, [handleEventDelta]);
    var startListening = (0, import_react130.useCallback)(function(el) {
      if (!el) {
        return;
      }
      var notPassive = supportsPassiveEvents ? {
        passive: false
      } : false;
      el.addEventListener("wheel", onWheel, notPassive);
      el.addEventListener("touchstart", onTouchStart, notPassive);
      el.addEventListener("touchmove", onTouchMove, notPassive);
    }, [onTouchMove, onTouchStart, onWheel]);
    var stopListening = (0, import_react130.useCallback)(function(el) {
      if (!el) {
        return;
      }
      el.removeEventListener("wheel", onWheel, false);
      el.removeEventListener("touchstart", onTouchStart, false);
      el.removeEventListener("touchmove", onTouchMove, false);
    }, [onTouchMove, onTouchStart, onWheel]);
    (0, import_react130.useEffect)(function() {
      if (!isEnabled) {
        return;
      }
      var element = scrollTarget.current;
      startListening(element);
      return function() {
        stopListening(element);
      };
    }, [isEnabled, startListening, stopListening]);
    return function(element) {
      scrollTarget.current = element;
    };
  }

  // node_modules/@atlaskit/react-select/dist/esm/components/internal/use-scroll-lock.js
  var import_react131 = __toESM(require_react());
  var STYLE_KEYS = ["boxSizing", "height", "overflow", "paddingRight", "position"];
  var LOCK_STYLES = {
    boxSizing: "border-box",
    // account for possible declaration `width: 100%;` on body
    overflow: "hidden",
    position: "relative",
    height: "100%"
  };
  function preventTouchMove(e) {
    e.preventDefault();
  }
  function allowTouchMove(e) {
    e.stopPropagation();
  }
  function preventInertiaScroll() {
    var top2 = this.scrollTop;
    var totalScroll = this.scrollHeight;
    var currentScroll = top2 + this.offsetHeight;
    if (top2 === 0) {
      this.scrollTop = 1;
    } else if (currentScroll === totalScroll) {
      this.scrollTop = top2 - 1;
    }
  }
  function isTouchDevice() {
    return "ontouchstart" in window || navigator.maxTouchPoints;
  }
  var canUseDOM = !!(typeof window !== "undefined" && window.document && window.document.createElement);
  var activeScrollLocks = 0;
  var listenerOptions = {
    capture: false,
    passive: false
  };
  function useScrollLock(_ref2) {
    var isEnabled = _ref2.isEnabled, _ref$accountForScroll = _ref2.accountForScrollbars, accountForScrollbars = _ref$accountForScroll === void 0 ? true : _ref$accountForScroll;
    var originalStyles = (0, import_react131.useRef)({});
    var scrollTarget = (0, import_react131.useRef)(null);
    var addScrollLock = (0, import_react131.useCallback)(function(touchScrollTarget) {
      if (!canUseDOM) {
        return;
      }
      var target = document.body;
      var targetStyle = target && target.style;
      if (accountForScrollbars) {
        STYLE_KEYS.forEach(function(key) {
          var val = targetStyle && targetStyle[key];
          originalStyles.current[key] = val;
        });
      }
      if (accountForScrollbars && activeScrollLocks < 1) {
        var currentPadding = parseInt(originalStyles.current.paddingRight, 10) || 0;
        var clientWidth = document.body ? document.body.clientWidth : 0;
        var adjustedPadding = window.innerWidth - clientWidth + currentPadding || 0;
        Object.keys(LOCK_STYLES).forEach(function(key) {
          var val = LOCK_STYLES[key];
          if (targetStyle) {
            targetStyle[key] = val;
          }
        });
        if (targetStyle) {
          targetStyle.paddingRight = "".concat(adjustedPadding, "px");
        }
      }
      if (target && isTouchDevice()) {
        target.addEventListener("touchmove", preventTouchMove, listenerOptions);
        if (touchScrollTarget) {
          touchScrollTarget.addEventListener("touchstart", preventInertiaScroll, listenerOptions);
          touchScrollTarget.addEventListener("touchmove", allowTouchMove, listenerOptions);
        }
      }
      activeScrollLocks += 1;
    }, [accountForScrollbars]);
    var removeScrollLock = (0, import_react131.useCallback)(function(touchScrollTarget) {
      if (!canUseDOM) {
        return;
      }
      var target = document.body;
      var targetStyle = target && target.style;
      activeScrollLocks = Math.max(activeScrollLocks - 1, 0);
      if (accountForScrollbars && activeScrollLocks < 1) {
        STYLE_KEYS.forEach(function(key) {
          var val = originalStyles.current[key];
          if (targetStyle) {
            targetStyle[key] = val;
          }
        });
      }
      if (target && isTouchDevice()) {
        target.removeEventListener("touchmove", preventTouchMove, listenerOptions);
        if (touchScrollTarget) {
          touchScrollTarget.removeEventListener("touchstart", preventInertiaScroll, listenerOptions);
          touchScrollTarget.removeEventListener("touchmove", allowTouchMove, listenerOptions);
        }
      }
    }, [accountForScrollbars]);
    (0, import_react131.useEffect)(function() {
      if (!isEnabled) {
        return;
      }
      var element = scrollTarget.current;
      addScrollLock(element);
      return function() {
        removeScrollLock(element);
      };
    }, [isEnabled, addScrollLock, removeScrollLock]);
    return function(element) {
      scrollTarget.current = element;
    };
  }

  // node_modules/@atlaskit/react-select/dist/esm/components/internal/scroll-manager.js
  var blurSelectInput = function blurSelectInput2(event) {
    var element = event.target;
    return element.ownerDocument.activeElement && element.ownerDocument.activeElement.blur();
  };
  function ScrollManager(_ref2) {
    var children = _ref2.children, lockEnabled = _ref2.lockEnabled, _ref$captureEnabled = _ref2.captureEnabled, captureEnabled = _ref$captureEnabled === void 0 ? true : _ref$captureEnabled, onBottomArrive = _ref2.onBottomArrive, onBottomLeave = _ref2.onBottomLeave, onTopArrive = _ref2.onTopArrive, onTopLeave = _ref2.onTopLeave;
    var setScrollCaptureTarget = useScrollCapture({
      isEnabled: captureEnabled,
      onBottomArrive,
      onBottomLeave,
      onTopArrive,
      onTopLeave
    });
    var setScrollLockTarget = useScrollLock({
      isEnabled: lockEnabled
    });
    var targetRef = function targetRef2(element) {
      setScrollCaptureTarget(element);
      setScrollLockTarget(element);
    };
    return /* @__PURE__ */ import_react132.default.createElement(import_react132.Fragment, null, lockEnabled && // eslint-disable-next-line jsx-a11y/click-events-have-key-events, jsx-a11y/no-static-element-interactions, @atlassian/a11y/interactive-element-not-keyboard-focusable
    /* @__PURE__ */ import_react132.default.createElement("div", {
      onClick: blurSelectInput,
      style: {
        // eslint-disable-next-line @atlaskit/ui-styling-standard/enforce-style-prop
        position: "fixed",
        // eslint-disable-next-line @atlaskit/ui-styling-standard/enforce-style-prop
        insetBlockEnd: 0,
        // eslint-disable-next-line @atlaskit/ui-styling-standard/enforce-style-prop
        insetBlockStart: 0,
        // eslint-disable-next-line @atlaskit/ui-styling-standard/enforce-style-prop
        insetInlineEnd: 0,
        // eslint-disable-next-line @atlaskit/ui-styling-standard/enforce-style-prop
        insetInlineStart: 0
      }
    }), children(targetRef));
  }

  // node_modules/@atlaskit/react-select/dist/esm/components/internal/required-input.js
  var React87 = __toESM(require_react());
  var RequiredInput = function RequiredInput2(_ref2) {
    var name = _ref2.name, onFocus3 = _ref2.onFocus;
    return /* @__PURE__ */ React87.createElement("input", {
      required: true,
      name,
      tabIndex: -1,
      "aria-hidden": "true",
      className: ax(["_1bsb1osq _kqswstnw _u7coidpf _rjxpidpf _1e02idpf _tzy4idpf _lcxvglyw", "-requiredInput"]),
      onFocus: onFocus3,
      // Prevent `Switching from uncontrolled to controlled` error
      value: "",
      onChange: noop3
    });
  };
  var required_input_default = RequiredInput;

  // node_modules/@atlaskit/react-select/dist/esm/components/internal/notify-open-layer-observer.js
  function NotifyOpenLayerObserver(_ref2) {
    var isOpen = _ref2.isOpen, onClose = _ref2.onClose;
    useNotifyOpenLayerObserver({
      isOpen,
      onClose
    });
    return null;
  }

  // node_modules/@atlaskit/react-select/dist/esm/components/live-region.js
  init_defineProperty();
  var import_react133 = __toESM(require_react());

  // node_modules/@atlaskit/react-select/dist/esm/accessibility/index.js
  var defaultAriaLiveMessages = {
    onChange: function onChange(props) {
      var action = props.action, _props$label = props.label, label = _props$label === void 0 ? "" : _props$label, isDisabled = props.isDisabled;
      switch (action) {
        case "deselect-option":
        case "pop-value":
        case "remove-value":
          return label.length ? "option ".concat(label, ", deselected") : "";
        case "clear":
          return "All selected options have been cleared.";
        case "select-option":
          return label.length && !isDisabled ? "option ".concat(label, ", selected.") : "";
        default:
          return "";
      }
    },
    onFilter: function onFilter(props) {
      var inputValue = props.inputValue, resultsMessage = props.resultsMessage;
      return inputValue ? "".concat(resultsMessage, " for search term ").concat(inputValue, ".") : "";
    }
  };

  // node_modules/@atlaskit/react-select/dist/esm/components/live-region.js
  function ownKeys21(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r && (o = o.filter(function(r2) {
        return Object.getOwnPropertyDescriptor(e, r2).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread21(e) {
    for (var r = 1; r < arguments.length; r++) {
      var t = null != arguments[r] ? arguments[r] : {};
      r % 2 ? ownKeys21(Object(t), true).forEach(function(r2) {
        _defineProperty(e, r2, t[r2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys21(Object(t)).forEach(function(r2) {
        Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
      });
    }
    return e;
  }
  var LiveRegion = function LiveRegion2(props) {
    var ariaSelection = props.ariaSelection, focusableOptions = props.focusableOptions, isFocused = props.isFocused, selectValue = props.selectValue, selectProps = props.selectProps, id = props.id;
    var ariaLiveMessages = selectProps.ariaLiveMessages, getOptionLabel5 = selectProps.getOptionLabel, inputValue = selectProps.inputValue, isOptionDisabled3 = selectProps.isOptionDisabled, menuIsOpen = selectProps.menuIsOpen, options2 = selectProps.options, screenReaderStatus2 = selectProps.screenReaderStatus, isLoading = selectProps.isLoading;
    var ariaLive = selectProps["aria-live"];
    var messages = (0, import_react133.useMemo)(function() {
      return _objectSpread21(_objectSpread21({}, defaultAriaLiveMessages), ariaLiveMessages || {});
    }, [ariaLiveMessages]);
    var ariaSelected = (0, import_react133.useMemo)(function() {
      var message2 = "";
      if (menuIsOpen) {
        return "";
      }
      if (ariaSelection && messages.onChange) {
        var option = ariaSelection.option, selectedOptions = ariaSelection.options, removedValue = ariaSelection.removedValue, removedValues = ariaSelection.removedValues, value = ariaSelection.value;
        var asOption = function asOption2(val) {
          return !Array.isArray(val) ? val : null;
        };
        var selected = removedValue || option || asOption(value);
        var label = selected ? getOptionLabel5(selected) : "";
        var multiSelected = selectedOptions || removedValues || void 0;
        var labels = multiSelected ? multiSelected.map(getOptionLabel5) : [];
        if (!label && !labels.length) {
          return "";
        }
        var onChangeProps = _objectSpread21({
          // multiSelected items are usually items that have already been selected
          // or set by the user as a default value so we assume they are not disabled
          isDisabled: selected && isOptionDisabled3(selected, selectValue),
          label,
          labels
        }, ariaSelection);
        message2 = messages.onChange(onChangeProps);
      }
      return message2;
    }, [ariaSelection, messages, isOptionDisabled3, selectValue, getOptionLabel5, menuIsOpen]);
    var ariaResults = (0, import_react133.useMemo)(function() {
      var resultsMsg = "";
      if (isLoading) {
        resultsMsg = "Loading. ";
      }
      if (menuIsOpen && options2.length && !isLoading && messages.onFilter) {
        var resultsMessage = screenReaderStatus2({
          count: focusableOptions.length
        });
        resultsMsg = messages.onFilter({
          inputValue,
          resultsMessage
        });
      }
      if (options2 && options2.length === 0) {
        resultsMsg = "No options. ";
      }
      return resultsMsg;
    }, [focusableOptions, inputValue, menuIsOpen, messages, options2, screenReaderStatus2, isLoading]);
    var isInitialFocus = (ariaSelection === null || ariaSelection === void 0 ? void 0 : ariaSelection.action) === "initial-input-focus";
    var ScreenReaderText = /* @__PURE__ */ import_react133.default.createElement(import_react133.Fragment, null, /* @__PURE__ */ import_react133.default.createElement("span", {
      id: "aria-selection"
    }, ariaSelected), /* @__PURE__ */ import_react133.default.createElement("span", {
      id: "aria-results"
    }, ariaResults));
    return /* @__PURE__ */ import_react133.default.createElement(import_react133.Fragment, null, /* @__PURE__ */ import_react133.default.createElement(a11y_text_default, {
      id
    }, isInitialFocus && ScreenReaderText), /* @__PURE__ */ import_react133.default.createElement(a11y_text_default, {
      "aria-live": ariaLive,
      role: "status"
    }, isFocused && !isInitialFocus && ScreenReaderText));
  };
  var live_region_default = LiveRegion;

  // node_modules/@atlaskit/react-select/dist/esm/filters.js
  init_defineProperty();

  // node_modules/@atlaskit/react-select/dist/esm/diacritics.js
  var diacritics = [{
    base: "A",
    letters: "A\u24B6\uFF21\xC0\xC1\xC2\u1EA6\u1EA4\u1EAA\u1EA8\xC3\u0100\u0102\u1EB0\u1EAE\u1EB4\u1EB2\u0226\u01E0\xC4\u01DE\u1EA2\xC5\u01FA\u01CD\u0200\u0202\u1EA0\u1EAC\u1EB6\u1E00\u0104\u023A\u2C6F"
  }, {
    base: "AA",
    letters: "\uA732"
  }, {
    base: "AE",
    letters: "\xC6\u01FC\u01E2"
  }, {
    base: "AO",
    letters: "\uA734"
  }, {
    base: "AU",
    letters: "\uA736"
  }, {
    base: "AV",
    letters: "\uA738\uA73A"
  }, {
    base: "AY",
    letters: "\uA73C"
  }, {
    base: "B",
    letters: "B\u24B7\uFF22\u1E02\u1E04\u1E06\u0243\u0182\u0181"
  }, {
    base: "C",
    letters: "C\u24B8\uFF23\u0106\u0108\u010A\u010C\xC7\u1E08\u0187\u023B\uA73E"
  }, {
    base: "D",
    letters: "D\u24B9\uFF24\u1E0A\u010E\u1E0C\u1E10\u1E12\u1E0E\u0110\u018B\u018A\u0189\uA779"
  }, {
    base: "DZ",
    letters: "\u01F1\u01C4"
  }, {
    base: "Dz",
    letters: "\u01F2\u01C5"
  }, {
    base: "E",
    letters: "E\u24BA\uFF25\xC8\xC9\xCA\u1EC0\u1EBE\u1EC4\u1EC2\u1EBC\u0112\u1E14\u1E16\u0114\u0116\xCB\u1EBA\u011A\u0204\u0206\u1EB8\u1EC6\u0228\u1E1C\u0118\u1E18\u1E1A\u0190\u018E"
  }, {
    base: "F",
    letters: "F\u24BB\uFF26\u1E1E\u0191\uA77B"
  }, {
    base: "G",
    letters: "G\u24BC\uFF27\u01F4\u011C\u1E20\u011E\u0120\u01E6\u0122\u01E4\u0193\uA7A0\uA77D\uA77E"
  }, {
    base: "H",
    letters: "H\u24BD\uFF28\u0124\u1E22\u1E26\u021E\u1E24\u1E28\u1E2A\u0126\u2C67\u2C75\uA78D"
  }, {
    base: "I",
    letters: "I\u24BE\uFF29\xCC\xCD\xCE\u0128\u012A\u012C\u0130\xCF\u1E2E\u1EC8\u01CF\u0208\u020A\u1ECA\u012E\u1E2C\u0197"
  }, {
    base: "J",
    letters: "J\u24BF\uFF2A\u0134\u0248"
  }, {
    base: "K",
    letters: "K\u24C0\uFF2B\u1E30\u01E8\u1E32\u0136\u1E34\u0198\u2C69\uA740\uA742\uA744\uA7A2"
  }, {
    base: "L",
    letters: "L\u24C1\uFF2C\u013F\u0139\u013D\u1E36\u1E38\u013B\u1E3C\u1E3A\u0141\u023D\u2C62\u2C60\uA748\uA746\uA780"
  }, {
    base: "LJ",
    letters: "\u01C7"
  }, {
    base: "Lj",
    letters: "\u01C8"
  }, {
    base: "M",
    letters: "M\u24C2\uFF2D\u1E3E\u1E40\u1E42\u2C6E\u019C"
  }, {
    base: "N",
    letters: "N\u24C3\uFF2E\u01F8\u0143\xD1\u1E44\u0147\u1E46\u0145\u1E4A\u1E48\u0220\u019D\uA790\uA7A4"
  }, {
    base: "NJ",
    letters: "\u01CA"
  }, {
    base: "Nj",
    letters: "\u01CB"
  }, {
    base: "O",
    letters: "O\u24C4\uFF2F\xD2\xD3\xD4\u1ED2\u1ED0\u1ED6\u1ED4\xD5\u1E4C\u022C\u1E4E\u014C\u1E50\u1E52\u014E\u022E\u0230\xD6\u022A\u1ECE\u0150\u01D1\u020C\u020E\u01A0\u1EDC\u1EDA\u1EE0\u1EDE\u1EE2\u1ECC\u1ED8\u01EA\u01EC\xD8\u01FE\u0186\u019F\uA74A\uA74C"
  }, {
    base: "OI",
    letters: "\u01A2"
  }, {
    base: "OO",
    letters: "\uA74E"
  }, {
    base: "OU",
    letters: "\u0222"
  }, {
    base: "P",
    letters: "P\u24C5\uFF30\u1E54\u1E56\u01A4\u2C63\uA750\uA752\uA754"
  }, {
    base: "Q",
    letters: "Q\u24C6\uFF31\uA756\uA758\u024A"
  }, {
    base: "R",
    letters: "R\u24C7\uFF32\u0154\u1E58\u0158\u0210\u0212\u1E5A\u1E5C\u0156\u1E5E\u024C\u2C64\uA75A\uA7A6\uA782"
  }, {
    base: "S",
    letters: "S\u24C8\uFF33\u1E9E\u015A\u1E64\u015C\u1E60\u0160\u1E66\u1E62\u1E68\u0218\u015E\u2C7E\uA7A8\uA784"
  }, {
    base: "T",
    letters: "T\u24C9\uFF34\u1E6A\u0164\u1E6C\u021A\u0162\u1E70\u1E6E\u0166\u01AC\u01AE\u023E\uA786"
  }, {
    base: "TZ",
    letters: "\uA728"
  }, {
    base: "U",
    letters: "U\u24CA\uFF35\xD9\xDA\xDB\u0168\u1E78\u016A\u1E7A\u016C\xDC\u01DB\u01D7\u01D5\u01D9\u1EE6\u016E\u0170\u01D3\u0214\u0216\u01AF\u1EEA\u1EE8\u1EEE\u1EEC\u1EF0\u1EE4\u1E72\u0172\u1E76\u1E74\u0244"
  }, {
    base: "V",
    letters: "V\u24CB\uFF36\u1E7C\u1E7E\u01B2\uA75E\u0245"
  }, {
    base: "VY",
    letters: "\uA760"
  }, {
    base: "W",
    letters: "W\u24CC\uFF37\u1E80\u1E82\u0174\u1E86\u1E84\u1E88\u2C72"
  }, {
    base: "X",
    letters: "X\u24CD\uFF38\u1E8A\u1E8C"
  }, {
    base: "Y",
    letters: "Y\u24CE\uFF39\u1EF2\xDD\u0176\u1EF8\u0232\u1E8E\u0178\u1EF6\u1EF4\u01B3\u024E\u1EFE"
  }, {
    base: "Z",
    letters: "Z\u24CF\uFF3A\u0179\u1E90\u017B\u017D\u1E92\u1E94\u01B5\u0224\u2C7F\u2C6B\uA762"
  }, {
    base: "a",
    letters: "a\u24D0\uFF41\u1E9A\xE0\xE1\xE2\u1EA7\u1EA5\u1EAB\u1EA9\xE3\u0101\u0103\u1EB1\u1EAF\u1EB5\u1EB3\u0227\u01E1\xE4\u01DF\u1EA3\xE5\u01FB\u01CE\u0201\u0203\u1EA1\u1EAD\u1EB7\u1E01\u0105\u2C65\u0250"
  }, {
    base: "aa",
    letters: "\uA733"
  }, {
    base: "ae",
    letters: "\xE6\u01FD\u01E3"
  }, {
    base: "ao",
    letters: "\uA735"
  }, {
    base: "au",
    letters: "\uA737"
  }, {
    base: "av",
    letters: "\uA739\uA73B"
  }, {
    base: "ay",
    letters: "\uA73D"
  }, {
    base: "b",
    letters: "b\u24D1\uFF42\u1E03\u1E05\u1E07\u0180\u0183\u0253"
  }, {
    base: "c",
    letters: "c\u24D2\uFF43\u0107\u0109\u010B\u010D\xE7\u1E09\u0188\u023C\uA73F\u2184"
  }, {
    base: "d",
    letters: "d\u24D3\uFF44\u1E0B\u010F\u1E0D\u1E11\u1E13\u1E0F\u0111\u018C\u0256\u0257\uA77A"
  }, {
    base: "dz",
    letters: "\u01F3\u01C6"
  }, {
    base: "e",
    letters: "e\u24D4\uFF45\xE8\xE9\xEA\u1EC1\u1EBF\u1EC5\u1EC3\u1EBD\u0113\u1E15\u1E17\u0115\u0117\xEB\u1EBB\u011B\u0205\u0207\u1EB9\u1EC7\u0229\u1E1D\u0119\u1E19\u1E1B\u0247\u025B\u01DD"
  }, {
    base: "f",
    letters: "f\u24D5\uFF46\u1E1F\u0192\uA77C"
  }, {
    base: "g",
    letters: "g\u24D6\uFF47\u01F5\u011D\u1E21\u011F\u0121\u01E7\u0123\u01E5\u0260\uA7A1\u1D79\uA77F"
  }, {
    base: "h",
    letters: "h\u24D7\uFF48\u0125\u1E23\u1E27\u021F\u1E25\u1E29\u1E2B\u1E96\u0127\u2C68\u2C76\u0265"
  }, {
    base: "hv",
    letters: "\u0195"
  }, {
    base: "i",
    letters: "i\u24D8\uFF49\xEC\xED\xEE\u0129\u012B\u012D\xEF\u1E2F\u1EC9\u01D0\u0209\u020B\u1ECB\u012F\u1E2D\u0268\u0131"
  }, {
    base: "j",
    letters: "j\u24D9\uFF4A\u0135\u01F0\u0249"
  }, {
    base: "k",
    letters: "k\u24DA\uFF4B\u1E31\u01E9\u1E33\u0137\u1E35\u0199\u2C6A\uA741\uA743\uA745\uA7A3"
  }, {
    base: "l",
    letters: "l\u24DB\uFF4C\u0140\u013A\u013E\u1E37\u1E39\u013C\u1E3D\u1E3B\u017F\u0142\u019A\u026B\u2C61\uA749\uA781\uA747"
  }, {
    base: "lj",
    letters: "\u01C9"
  }, {
    base: "m",
    letters: "m\u24DC\uFF4D\u1E3F\u1E41\u1E43\u0271\u026F"
  }, {
    base: "n",
    letters: "n\u24DD\uFF4E\u01F9\u0144\xF1\u1E45\u0148\u1E47\u0146\u1E4B\u1E49\u019E\u0272\u0149\uA791\uA7A5"
  }, {
    base: "nj",
    letters: "\u01CC"
  }, {
    base: "o",
    letters: "o\u24DE\uFF4F\xF2\xF3\xF4\u1ED3\u1ED1\u1ED7\u1ED5\xF5\u1E4D\u022D\u1E4F\u014D\u1E51\u1E53\u014F\u022F\u0231\xF6\u022B\u1ECF\u0151\u01D2\u020D\u020F\u01A1\u1EDD\u1EDB\u1EE1\u1EDF\u1EE3\u1ECD\u1ED9\u01EB\u01ED\xF8\u01FF\u0254\uA74B\uA74D\u0275"
  }, {
    base: "oi",
    letters: "\u01A3"
  }, {
    base: "ou",
    letters: "\u0223"
  }, {
    base: "oo",
    letters: "\uA74F"
  }, {
    base: "p",
    letters: "p\u24DF\uFF50\u1E55\u1E57\u01A5\u1D7D\uA751\uA753\uA755"
  }, {
    base: "q",
    letters: "q\u24E0\uFF51\u024B\uA757\uA759"
  }, {
    base: "r",
    letters: "r\u24E1\uFF52\u0155\u1E59\u0159\u0211\u0213\u1E5B\u1E5D\u0157\u1E5F\u024D\u027D\uA75B\uA7A7\uA783"
  }, {
    base: "s",
    letters: "s\u24E2\uFF53\xDF\u015B\u1E65\u015D\u1E61\u0161\u1E67\u1E63\u1E69\u0219\u015F\u023F\uA7A9\uA785\u1E9B"
  }, {
    base: "t",
    letters: "t\u24E3\uFF54\u1E6B\u1E97\u0165\u1E6D\u021B\u0163\u1E71\u1E6F\u0167\u01AD\u0288\u2C66\uA787"
  }, {
    base: "tz",
    letters: "\uA729"
  }, {
    base: "u",
    letters: "u\u24E4\uFF55\xF9\xFA\xFB\u0169\u1E79\u016B\u1E7B\u016D\xFC\u01DC\u01D8\u01D6\u01DA\u1EE7\u016F\u0171\u01D4\u0215\u0217\u01B0\u1EEB\u1EE9\u1EEF\u1EED\u1EF1\u1EE5\u1E73\u0173\u1E77\u1E75\u0289"
  }, {
    base: "v",
    letters: "v\u24E5\uFF56\u1E7D\u1E7F\u028B\uA75F\u028C"
  }, {
    base: "vy",
    letters: "\uA761"
  }, {
    base: "w",
    letters: "w\u24E6\uFF57\u1E81\u1E83\u0175\u1E87\u1E85\u1E98\u1E89\u2C73"
  }, {
    base: "x",
    letters: "x\u24E7\uFF58\u1E8B\u1E8D"
  }, {
    base: "y",
    letters: "y\u24E8\uFF59\u1EF3\xFD\u0177\u1EF9\u0233\u1E8F\xFF\u1EF7\u1E99\u1EF5\u01B4\u024F\u1EFF"
  }, {
    base: "z",
    letters: "z\u24E9\uFF5A\u017A\u1E91\u017C\u017E\u1E93\u1E95\u01B6\u0225\u0240\u2C6C\uA763"
  }];
  var anyDiacritic = new RegExp("[" + diacritics.map(function(d) {
    return d.letters;
  }).join("") + "]", "g");
  var diacriticToBase = {};
  for (i = 0; i < diacritics.length; i++) {
    diacritic = diacritics[i];
    for (j = 0; j < diacritic.letters.length; j++) {
      diacriticToBase[diacritic.letters[j]] = diacritic.base;
    }
  }
  var diacritic;
  var j;
  var i;
  var stripDiacritics = function stripDiacritics2(str) {
    return str.replace(anyDiacritic, function(match3) {
      return diacriticToBase[match3];
    });
  };

  // node_modules/@atlaskit/react-select/dist/esm/filters.js
  function ownKeys22(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r && (o = o.filter(function(r2) {
        return Object.getOwnPropertyDescriptor(e, r2).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread22(e) {
    for (var r = 1; r < arguments.length; r++) {
      var t = null != arguments[r] ? arguments[r] : {};
      r % 2 ? ownKeys22(Object(t), true).forEach(function(r2) {
        _defineProperty(e, r2, t[r2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys22(Object(t)).forEach(function(r2) {
        Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
      });
    }
    return e;
  }
  var memoizedStripDiacriticsForInput = memoizeOne(stripDiacritics);
  var trimString = function trimString2(str) {
    return str.replace(/^\s+|\s+$/g, "");
  };
  var defaultStringify = function defaultStringify2(option) {
    return "".concat(option.label, " ").concat(option.value);
  };
  var createFilter = function createFilter2(config) {
    return function(option, rawInput) {
      if (option.data.__isNew__) {
        return true;
      }
      var _ignoreCase$ignoreAcc = _objectSpread22({
        ignoreCase: true,
        ignoreAccents: true,
        stringify: defaultStringify,
        trim: true,
        matchFrom: "any"
      }, config), ignoreCase = _ignoreCase$ignoreAcc.ignoreCase, ignoreAccents = _ignoreCase$ignoreAcc.ignoreAccents, stringify3 = _ignoreCase$ignoreAcc.stringify, trim2 = _ignoreCase$ignoreAcc.trim, matchFrom = _ignoreCase$ignoreAcc.matchFrom;
      var input = trim2 ? trimString(rawInput) : rawInput;
      var candidate = trim2 ? trimString(stringify3(option)) : stringify3(option);
      if (ignoreCase) {
        input = input.toLowerCase();
        candidate = candidate.toLowerCase();
      }
      if (ignoreAccents) {
        input = memoizedStripDiacriticsForInput(input);
        candidate = stripDiacritics(candidate);
      }
      return matchFrom === "start" ? candidate.substr(0, input.length) === input : candidate.indexOf(input) > -1;
    };
  };

  // node_modules/@atlaskit/react-select/dist/esm/styles.js
  init_defineProperty();
  var defaultStyles2 = {
    clearIndicator: clearIndicatorCSS,
    container: containerCSS,
    control: css3,
    dropdownIndicator: dropdownIndicatorCSS,
    group: groupCSS,
    groupHeading: groupHeadingCSS,
    indicatorsContainer: indicatorsContainerCSS,
    input: inputCSS,
    loadingIndicator: loadingIndicatorCSS,
    loadingMessage: loadingMessageCSS,
    menu: menuCSS,
    menuList: menuListCSS,
    menuPortal: menuPortalCSS,
    multiValue: multiValueCSS,
    multiValueLabel: multiValueLabelCSS,
    multiValueRemove: multiValueRemoveCSS,
    noOptionsMessage: noOptionsMessageCSS,
    option: optionCSS,
    placeholder: placeholderCSS,
    singleValue: css5,
    valueContainer: valueContainerCSS
  };

  // node_modules/@atlaskit/react-select/dist/esm/select.js
  function ownKeys23(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r && (o = o.filter(function(r2) {
        return Object.getOwnPropertyDescriptor(e, r2).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread23(e) {
    for (var r = 1; r < arguments.length; r++) {
      var t = null != arguments[r] ? arguments[r] : {};
      r % 2 ? ownKeys23(Object(t), true).forEach(function(r2) {
        _defineProperty(e, r2, t[r2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys23(Object(t)).forEach(function(r2) {
        Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
      });
    }
    return e;
  }
  function _callSuper3(t, o, e) {
    return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct3() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
  }
  function _isNativeReflectConstruct3() {
    try {
      var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
    } catch (t2) {
    }
    return (_isNativeReflectConstruct3 = function _isNativeReflectConstruct4() {
      return !!t;
    })();
  }
  var defaultProps = {
    backspaceRemovesValue: true,
    blurInputOnSelect: isTouchCapable(),
    captureMenuScroll: !isTouchCapable(),
    classNames: {},
    closeMenuOnSelect: true,
    closeMenuOnScroll: false,
    components: {},
    controlShouldRenderValue: true,
    escapeClearsValue: false,
    filterOption: createFilter(),
    formatGroupLabel,
    getOptionLabel,
    getOptionValue,
    isDisabled: false,
    isLoading: false,
    isMulti: false,
    isRtl: false,
    isSearchable: true,
    isOptionDisabled,
    loadingMessage: function loadingMessage() {
      return "Loading...";
    },
    maxMenuHeight: 300,
    minMenuHeight: 140,
    menuIsOpen: false,
    menuPlacement: "bottom",
    menuPosition: "absolute",
    menuShouldBlockScroll: false,
    menuShouldScrollIntoView: !isMobileDevice(),
    noOptionsMessage: function noOptionsMessage() {
      return "No options";
    },
    openMenuOnFocus: false,
    openMenuOnClick: true,
    options: [],
    pageSize: 5,
    placeholder: "Select...",
    screenReaderStatus: function screenReaderStatus(_ref2) {
      var count = _ref2.count;
      return "".concat(count, " result").concat(count !== 1 ? "s" : "", " available");
    },
    styles: {},
    tabIndex: 0,
    tabSelectsValue: true,
    UNSAFE_is_experimental_generic: false
  };
  function toCategorizedOption(props, option, selectValue, index2) {
    var isDisabled = _isOptionDisabled(props, option, selectValue);
    var isSelected = _isOptionSelected(props, option, selectValue);
    var label = getOptionLabel3(props, option);
    var value = getOptionValue3(props, option);
    return {
      type: "option",
      data: option,
      isDisabled,
      isSelected,
      label,
      value,
      index: index2
    };
  }
  function buildCategorizedOptions(props, selectValue) {
    return props.options.map(function(groupOrOption, groupOrOptionIndex) {
      if ("options" in groupOrOption) {
        var categorizedOptions = groupOrOption.options.map(function(option, optionIndex) {
          return toCategorizedOption(props, option, selectValue, optionIndex);
        }).filter(function(categorizedOption2) {
          return isFocusable(props, categorizedOption2);
        });
        return categorizedOptions.length > 0 ? {
          type: "group",
          data: groupOrOption,
          options: categorizedOptions,
          index: groupOrOptionIndex
        } : void 0;
      }
      var categorizedOption = toCategorizedOption(props, groupOrOption, selectValue, groupOrOptionIndex);
      return isFocusable(props, categorizedOption) ? categorizedOption : void 0;
    }).filter(notNullish);
  }
  function buildFocusableOptionsFromCategorizedOptions(categorizedOptions) {
    return categorizedOptions.reduce(function(optionsAccumulator, categorizedOption) {
      if (categorizedOption.type === "group") {
        optionsAccumulator.push.apply(optionsAccumulator, _toConsumableArray(categorizedOption.options.map(function(option) {
          return option.data;
        })));
      } else {
        optionsAccumulator.push(categorizedOption.data);
      }
      return optionsAccumulator;
    }, []);
  }
  function buildFocusableOptionsWithIds(categorizedOptions, optionId) {
    return categorizedOptions.reduce(function(optionsAccumulator, categorizedOption) {
      if (categorizedOption.type === "group") {
        optionsAccumulator.push.apply(optionsAccumulator, _toConsumableArray(categorizedOption.options.map(function(option) {
          return {
            data: option.data,
            id: "".concat(optionId, "-").concat(categorizedOption.index, "-").concat(option.index)
          };
        })));
      } else {
        optionsAccumulator.push({
          data: categorizedOption.data,
          id: "".concat(optionId, "-").concat(categorizedOption.index)
        });
      }
      return optionsAccumulator;
    }, []);
  }
  function buildFocusableOptions(props, selectValue) {
    return buildFocusableOptionsFromCategorizedOptions(buildCategorizedOptions(props, selectValue));
  }
  function isFocusable(props, categorizedOption) {
    var _props$inputValue = props.inputValue, inputValue = _props$inputValue === void 0 ? "" : _props$inputValue;
    var data = categorizedOption.data, isSelected = categorizedOption.isSelected, label = categorizedOption.label, value = categorizedOption.value;
    return (!shouldHideSelectedOptions(props) || !isSelected) && _filterOption(props, {
      label,
      value,
      data
    }, inputValue);
  }
  function getNextFocusedValue(state, nextSelectValue) {
    var focusedValue = state.focusedValue, lastSelectValue = state.selectValue;
    var lastFocusedIndex = lastSelectValue.indexOf(focusedValue);
    if (lastFocusedIndex > -1) {
      var nextFocusedIndex = nextSelectValue.indexOf(focusedValue);
      if (nextFocusedIndex > -1) {
        return focusedValue;
      } else if (lastFocusedIndex < nextSelectValue.length) {
        return nextSelectValue[lastFocusedIndex];
      }
    }
    return null;
  }
  function getNextFocusedOption(state, options2) {
    var lastFocusedOption = state.focusedOption;
    return lastFocusedOption && options2.indexOf(lastFocusedOption) > -1 ? lastFocusedOption : options2[0];
  }
  var getFocusedOptionId = function getFocusedOptionId2(focusableOptionsWithIds, focusedOption) {
    var _focusableOptionsWith;
    var focusedOptionId = (_focusableOptionsWith = focusableOptionsWithIds.find(function(option) {
      return option.data === focusedOption;
    })) === null || _focusableOptionsWith === void 0 ? void 0 : _focusableOptionsWith.id;
    return focusedOptionId || null;
  };
  var getOptionLabel3 = function getOptionLabel4(props, data) {
    return props.getOptionLabel(data);
  };
  var getOptionValue3 = function getOptionValue4(props, data) {
    return props.getOptionValue(data);
  };
  function _isOptionDisabled(props, option, selectValue) {
    return typeof props.isOptionDisabled === "function" ? props.isOptionDisabled(option, selectValue) : false;
  }
  function _isOptionSelected(props, option, selectValue) {
    if (selectValue.indexOf(option) > -1) {
      return true;
    }
    if (typeof props.isOptionSelected === "function") {
      return props.isOptionSelected(option, selectValue);
    }
    var candidate = getOptionValue3(props, option);
    return selectValue.some(function(i) {
      return getOptionValue3(props, i) === candidate;
    });
  }
  function _filterOption(props, option, inputValue) {
    return props.filterOption ? props.filterOption(option, inputValue) : true;
  }
  var shouldHideSelectedOptions = function shouldHideSelectedOptions2(props) {
    var hideSelectedOptions = props.hideSelectedOptions, isMulti = props.isMulti;
    if (hideSelectedOptions === void 0) {
      return isMulti;
    }
    return hideSelectedOptions;
  };
  var instanceId = 1;
  var Select = /* @__PURE__ */ (function(_Component) {
    function Select3(_props) {
      var _this;
      _classCallCheck(this, Select3);
      _this = _callSuper3(this, Select3, [_props]);
      _defineProperty(_this, "state", {
        ariaSelection: null,
        focusedOption: null,
        focusedOptionId: null,
        focusableOptionsWithIds: [],
        focusedValue: null,
        focusedValueId: null,
        inputIsHidden: false,
        isFocused: false,
        selectValue: [],
        clearFocusValueOnUpdate: false,
        prevWasFocused: false,
        inputIsHiddenAfterUpdate: void 0,
        prevProps: void 0,
        instancePrefix: ""
      });
      _defineProperty(_this, "blockOptionHover", false);
      _defineProperty(_this, "isComposing", false);
      _defineProperty(_this, "initialTouchX", 0);
      _defineProperty(_this, "initialTouchY", 0);
      _defineProperty(_this, "openAfterFocus", false);
      _defineProperty(_this, "scrollToFocusedOptionOnUpdate", false);
      _defineProperty(_this, "controlRef", null);
      _defineProperty(_this, "getControlRef", function(ref) {
        _this.controlRef = ref;
      });
      _defineProperty(_this, "focusedOptionRef", null);
      _defineProperty(_this, "getFocusedOptionRef", function(ref) {
        _this.focusedOptionRef = ref;
      });
      _defineProperty(_this, "menuListRef", null);
      _defineProperty(_this, "getMenuListRef", function(ref) {
        _this.menuListRef = ref;
      });
      _defineProperty(_this, "inputRef", null);
      _defineProperty(_this, "getInputRef", function(ref) {
        _this.inputRef = ref;
      });
      _defineProperty(_this, "focus", _this.focusInput);
      _defineProperty(_this, "blur", _this.blurInput);
      _defineProperty(_this, "onChange", function(newValue, actionMeta) {
        var _this$props = _this.props, onChange2 = _this$props.onChange, name = _this$props.name;
        actionMeta.name = name;
        _this.ariaOnChange(newValue, actionMeta);
        onChange2(newValue, actionMeta);
      });
      _defineProperty(_this, "setValue", function(newValue, action, option) {
        var _this$props2 = _this.props, closeMenuOnSelect = _this$props2.closeMenuOnSelect, isMulti = _this$props2.isMulti, inputValue = _this$props2.inputValue;
        if (isMulti && (0, import_platform_feature_flags20.fg)("platform_do_not_clear_input_for_multiselect")) {
          _this.onInputChange(inputValue, {
            action: "set-value",
            prevInputValue: inputValue
          });
        } else {
          _this.onInputChange("", {
            action: "set-value",
            prevInputValue: inputValue
          });
        }
        if (closeMenuOnSelect) {
          _this.setState({
            inputIsHiddenAfterUpdate: !isMulti
          });
          _this.onMenuClose();
        }
        _this.setState({
          clearFocusValueOnUpdate: true
        });
        _this.onChange(newValue, {
          action,
          option
        });
      });
      _defineProperty(_this, "selectOption", function(newValue) {
        var _this$props3 = _this.props, blurInputOnSelect = _this$props3.blurInputOnSelect, isMulti = _this$props3.isMulti, name = _this$props3.name;
        var selectValue = _this.state.selectValue;
        var deselected = isMulti && _this.isOptionSelected(newValue, selectValue);
        var isDisabled = _this.isOptionDisabled(newValue, selectValue);
        if (deselected) {
          var candidate = _this.getOptionValue(newValue);
          _this.setValue(multiValueAsValue(selectValue.filter(function(i) {
            return _this.getOptionValue(i) !== candidate;
          })), "deselect-option", newValue);
        } else if (!isDisabled) {
          if (isMulti) {
            _this.setValue(multiValueAsValue([].concat(_toConsumableArray(selectValue), [newValue])), "select-option", newValue);
          } else {
            _this.setValue(singleValueAsValue(newValue), "select-option");
          }
        } else {
          _this.ariaOnChange(singleValueAsValue(newValue), {
            action: "select-option",
            option: newValue,
            name
          });
          return;
        }
        if (blurInputOnSelect) {
          _this.blurInput();
        }
      });
      _defineProperty(_this, "removeValue", function(removedValue) {
        var isMulti = _this.props.isMulti;
        var selectValue = _this.state.selectValue;
        var candidate = _this.getOptionValue(removedValue);
        var newValueArray = selectValue.filter(function(i) {
          return _this.getOptionValue(i) !== candidate;
        });
        var newValue = valueTernary(isMulti, newValueArray, newValueArray[0] || null);
        _this.onChange(newValue, {
          action: "remove-value",
          removedValue
        });
        _this.focusInput();
      });
      _defineProperty(_this, "clearValue", function() {
        var selectValue = _this.state.selectValue;
        _this.onChange(valueTernary(_this.props.isMulti, [], null), {
          action: "clear",
          removedValues: selectValue
        });
      });
      _defineProperty(_this, "popValue", function() {
        var isMulti = _this.props.isMulti;
        var selectValue = _this.state.selectValue;
        var lastSelectedValue = selectValue[selectValue.length - 1];
        var newValueArray = selectValue.slice(0, selectValue.length - 1);
        var newValue = valueTernary(isMulti, newValueArray, newValueArray[0] || null);
        _this.onChange(newValue, {
          action: "pop-value",
          removedValue: lastSelectedValue
        });
      });
      _defineProperty(_this, "getFocusedOptionId", function(focusedOption) {
        return getFocusedOptionId(_this.state.focusableOptionsWithIds, focusedOption);
      });
      _defineProperty(_this, "getFocusableOptionsWithIds", function() {
        return buildFocusableOptionsWithIds(buildCategorizedOptions(_this.props, _this.state.selectValue), _this.getElementId("option"));
      });
      _defineProperty(_this, "getValue", function() {
        return _this.state.selectValue;
      });
      _defineProperty(_this, "cx", function() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return classNames.apply(void 0, [_this.props.classNamePrefix].concat(args));
      });
      _defineProperty(_this, "getOptionLabel", function(data) {
        return getOptionLabel3(_this.props, data);
      });
      _defineProperty(_this, "getOptionValue", function(data) {
        return getOptionValue3(_this.props, data);
      });
      _defineProperty(_this, "getStyles", function(key, props) {
        var base = defaultStyles2[key](props);
        base.boxSizing = "border-box";
        var custom = _this.props.styles[key];
        if (!custom) {
          return base;
        }
        var customStyles = filterUnsupportedSelectors(custom(base, props));
        return customStyles;
      });
      _defineProperty(_this, "getClassNames", function(key, props) {
        var _this$props$className, _this$props$className2;
        return (_this$props$className = (_this$props$className2 = _this.props.classNames)[key]) === null || _this$props$className === void 0 ? void 0 : _this$props$className.call(_this$props$className2, props);
      });
      _defineProperty(_this, "getElementId", function(element) {
        return "".concat(_this.state.instancePrefix, "-").concat(element);
      });
      _defineProperty(_this, "getComponents", function() {
        return defaultComponents(_this.props);
      });
      _defineProperty(_this, "buildCategorizedOptions", function() {
        return buildCategorizedOptions(_this.props, _this.state.selectValue);
      });
      _defineProperty(_this, "getCategorizedOptions", function() {
        return _this.props.menuIsOpen ? _this.buildCategorizedOptions() : [];
      });
      _defineProperty(_this, "buildFocusableOptions", function() {
        return buildFocusableOptionsFromCategorizedOptions(_this.buildCategorizedOptions());
      });
      _defineProperty(_this, "getFocusableOptions", function() {
        return _this.props.menuIsOpen ? _this.buildFocusableOptions() : [];
      });
      _defineProperty(_this, "ariaOnChange", function(value, actionMeta) {
        _this.setState({
          ariaSelection: _objectSpread23({
            value
          }, actionMeta)
        });
      });
      _defineProperty(_this, "onMenuMouseDown", function(event) {
        if (event.button !== 0) {
          return;
        }
        event.stopPropagation();
        event.preventDefault();
        _this.focusInput();
      });
      _defineProperty(_this, "onMenuMouseMove", function(event) {
        _this.blockOptionHover = false;
      });
      _defineProperty(_this, "onControlMouseDown", function(event) {
        if (event.defaultPrevented) {
          var _this$controlRef;
          if (!((_this$controlRef = _this.controlRef) !== null && _this$controlRef !== void 0 && _this$controlRef.closest("[data-rbd-draggable-context-id]"))) {
            return;
          }
        }
        var openMenuOnClick = _this.props.openMenuOnClick;
        if (!_this.state.isFocused) {
          if (openMenuOnClick) {
            _this.openAfterFocus = true;
          }
          _this.focusInput();
        } else if (!_this.props.menuIsOpen) {
          if (openMenuOnClick) {
            _this.openMenu("first");
          }
        } else {
          if (event.target.tagName !== "INPUT" && event.target.tagName !== "TEXTAREA") {
            _this.onMenuClose();
          }
        }
        if (event.target.tagName !== "INPUT" && event.target.tagName !== "TEXTAREA") {
          event.preventDefault();
        }
      });
      _defineProperty(_this, "onDropdownIndicatorMouseDown", function(event) {
        if (event && event.type === "mousedown" && event.button !== 0) {
          return;
        }
        if (_this.props.isDisabled) {
          return;
        }
        var _this$props4 = _this.props, isMulti = _this$props4.isMulti, menuIsOpen = _this$props4.menuIsOpen;
        _this.focusInput();
        if (menuIsOpen) {
          _this.setState({
            inputIsHiddenAfterUpdate: !isMulti
          });
          _this.onMenuClose();
        } else {
          _this.openMenu("first");
        }
        event.preventDefault();
      });
      _defineProperty(_this, "onClearIndicatorMouseDown", function(event) {
        if (event && event.type === "mousedown" && event.button !== 0) {
          return;
        }
        _this.clearValue();
        event.preventDefault();
        _this.openAfterFocus = false;
        if (event.type === "touchend") {
          _this.focusInput();
        } else {
          setTimeout(function() {
            return _this.focusInput();
          });
        }
      });
      _defineProperty(_this, "onScroll", function(event) {
        if (typeof _this.props.closeMenuOnScroll === "boolean") {
          if (event.target instanceof HTMLElement && isDocumentElement(event.target)) {
            _this.props.onMenuClose();
          }
        } else if (typeof _this.props.closeMenuOnScroll === "function") {
          if (_this.props.closeMenuOnScroll(event)) {
            _this.props.onMenuClose();
          }
        }
      });
      _defineProperty(_this, "onCompositionStart", function() {
        _this.isComposing = true;
      });
      _defineProperty(_this, "onCompositionEnd", function() {
        _this.isComposing = false;
      });
      _defineProperty(_this, "onTouchStart", function(_ref2) {
        var touches = _ref2.touches;
        var touch = touches && touches.item(0);
        if (!touch) {
          return;
        }
        _this.initialTouchX = touch.clientX;
        _this.initialTouchY = touch.clientY;
        _this.userIsDragging = false;
      });
      _defineProperty(_this, "onTouchMove", function(_ref3) {
        var touches = _ref3.touches;
        var touch = touches && touches.item(0);
        if (!touch) {
          return;
        }
        var deltaX = Math.abs(touch.clientX - _this.initialTouchX);
        var deltaY = Math.abs(touch.clientY - _this.initialTouchY);
        var moveThreshold = 5;
        _this.userIsDragging = deltaX > moveThreshold || deltaY > moveThreshold;
      });
      _defineProperty(_this, "onTouchEnd", function(event) {
        if (_this.userIsDragging) {
          return;
        }
        if (_this.controlRef && !_this.controlRef.contains(event.target) && _this.menuListRef && !_this.menuListRef.contains(event.target)) {
          _this.blurInput();
        }
        _this.initialTouchX = 0;
        _this.initialTouchY = 0;
      });
      _defineProperty(_this, "onControlTouchEnd", function(event) {
        if (_this.userIsDragging) {
          return;
        }
        _this.onControlMouseDown(event);
      });
      _defineProperty(_this, "onClearIndicatorTouchEnd", function(event) {
        if (_this.userIsDragging) {
          return;
        }
        _this.onClearIndicatorMouseDown(event);
      });
      _defineProperty(_this, "onDropdownIndicatorTouchEnd", function(event) {
        if (_this.userIsDragging) {
          return;
        }
        _this.onDropdownIndicatorMouseDown(event);
      });
      _defineProperty(_this, "handleInputChange", function(event) {
        var prevInputValue = _this.props.inputValue;
        var inputValue = event.currentTarget.value;
        _this.setState({
          inputIsHiddenAfterUpdate: false
        });
        _this.onInputChange(inputValue, {
          action: "input-change",
          prevInputValue
        });
        if (!_this.props.menuIsOpen) {
          _this.onMenuOpen();
        }
      });
      _defineProperty(_this, "onInputFocus", function(event) {
        if (_this.props.onFocus) {
          _this.props.onFocus(event);
        }
        _this.setState({
          inputIsHiddenAfterUpdate: false,
          isFocused: true
        });
        if (_this.openAfterFocus || _this.props.openMenuOnFocus) {
          _this.openMenu("first");
        }
        _this.openAfterFocus = false;
      });
      _defineProperty(_this, "onInputBlur", function(event) {
        var prevInputValue = _this.props.inputValue;
        if (_this.menuListRef && _this.menuListRef.contains(document.activeElement)) {
          _this.inputRef.focus();
          return;
        }
        if (_this.props.onBlur) {
          _this.props.onBlur(event);
        }
        _this.onInputChange("", {
          action: "input-blur",
          prevInputValue
        });
        if ((0, import_platform_feature_flags20.fg)("platform_dst_select_menu_close_on_blur")) {
          _this.props.menuIsOpen && _this.onMenuClose();
        } else {
          _this.onMenuClose();
        }
        _this.setState({
          focusedValue: null,
          isFocused: false
        });
      });
      _defineProperty(_this, "onOptionHover", function(focusedOption) {
        if (_this.blockOptionHover || _this.state.focusedOption === focusedOption) {
          return;
        }
        var options2 = _this.getFocusableOptions();
        var focusedOptionIndex = options2.indexOf(focusedOption);
        _this.setState({
          focusedOption,
          focusedOptionId: focusedOptionIndex > -1 ? _this.getFocusedOptionId(focusedOption) : null
        });
      });
      _defineProperty(_this, "shouldHideSelectedOptions", function() {
        return shouldHideSelectedOptions(_this.props);
      });
      _defineProperty(_this, "onValueInputFocus", function(e) {
        e.preventDefault();
        e.stopPropagation();
        _this.focus();
      });
      _defineProperty(_this, "onKeyDown", function(event) {
        var _this$props5 = _this.props, isMulti = _this$props5.isMulti, backspaceRemovesValue = _this$props5.backspaceRemovesValue, escapeClearsValue = _this$props5.escapeClearsValue, inputValue = _this$props5.inputValue, isClearable = _this$props5.isClearable, isDisabled = _this$props5.isDisabled, menuIsOpen = _this$props5.menuIsOpen, onKeyDown = _this$props5.onKeyDown, tabSelectsValue = _this$props5.tabSelectsValue, openMenuOnFocus = _this$props5.openMenuOnFocus;
        var _this$state = _this.state, focusedOption = _this$state.focusedOption, focusedValue = _this$state.focusedValue, selectValue = _this$state.selectValue;
        if (isDisabled) {
          return;
        }
        if (typeof onKeyDown === "function") {
          onKeyDown(event);
          if (event.defaultPrevented) {
            return;
          }
        }
        _this.blockOptionHover = true;
        switch (event.key) {
          case "ArrowLeft":
            if (!isMulti || inputValue) {
              return;
            }
            _this.focusValue("previous");
            break;
          case "ArrowRight":
            if (!isMulti || inputValue) {
              return;
            }
            _this.focusValue("next");
            break;
          case "Delete":
          case "Backspace":
            if (inputValue) {
              return;
            }
            if (focusedValue) {
              _this.removeValue(focusedValue);
            } else {
              if (!backspaceRemovesValue) {
                return;
              }
              if (isMulti) {
                _this.popValue();
              } else if (isClearable) {
                _this.clearValue();
              }
            }
            break;
          case "Tab":
            if (_this.isComposing) {
              return;
            }
            if (event.shiftKey || !menuIsOpen || !tabSelectsValue || !focusedOption || // don't capture the event if the menu opens on focus and the focused
            // option is already selected; it breaks the flow of navigation
            openMenuOnFocus && _this.isOptionSelected(focusedOption, selectValue)) {
              return;
            }
            _this.selectOption(focusedOption);
            break;
          case "Enter":
            if (event.keyCode === 229) {
              break;
            }
            if (focusedValue) {
              _this.removeValue(focusedValue);
            }
            if (menuIsOpen) {
              if (!focusedOption) {
                return;
              }
              if (_this.isComposing) {
                return;
              }
              _this.selectOption(focusedOption);
              break;
            }
            return;
          case "Escape":
            if (menuIsOpen) {
              _this.setState({
                inputIsHiddenAfterUpdate: false
              });
              _this.onInputChange("", {
                action: "menu-close",
                prevInputValue: inputValue
              });
              _this.onMenuClose();
            } else if (isClearable && escapeClearsValue) {
              _this.clearValue();
            }
            break;
          case " ":
            if (inputValue) {
              return;
            }
            if (!menuIsOpen) {
              _this.openMenu("first");
              break;
            }
            if (!focusedOption) {
              return;
            }
            _this.selectOption(focusedOption);
            break;
          case "ArrowUp":
            if (menuIsOpen) {
              _this.focusOption("up");
            } else {
              _this.openMenu("last");
            }
            break;
          case "ArrowDown":
            if (menuIsOpen) {
              _this.focusOption("down");
            } else {
              _this.openMenu("first");
            }
            break;
          case "PageUp":
            if (!menuIsOpen) {
              return;
            }
            _this.focusOption("pageup");
            break;
          case "PageDown":
            if (!menuIsOpen) {
              return;
            }
            _this.focusOption("pagedown");
            break;
          case "Home":
            if (!menuIsOpen) {
              return;
            }
            _this.focusOption("first");
            break;
          case "End":
            if (!menuIsOpen) {
              return;
            }
            _this.focusOption("last");
            break;
          default:
            return;
        }
        event.preventDefault();
      });
      _defineProperty(_this, "handleOpenLayerObserverCloseSignal", function() {
        _this.onMenuClose();
      });
      _this.state.instancePrefix = "react-select-" + (_this.props.instanceId || ++instanceId);
      _this.state.selectValue = cleanValue(_props.value);
      if (_props.menuIsOpen) {
        var focusableOptionsWithIds = _this.getFocusableOptionsWithIds();
        var focusableOptions = _this.buildFocusableOptions();
        var optionIndex = focusableOptions.indexOf(_this.state.selectValue[0]);
        _this.state.focusableOptionsWithIds = focusableOptionsWithIds;
        _this.state.focusedOption = focusableOptions[optionIndex];
        _this.state.focusedOptionId = getFocusedOptionId(focusableOptionsWithIds, focusableOptions[optionIndex]);
      }
      return _this;
    }
    _inherits(Select3, _Component);
    return _createClass(Select3, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        this.startListeningComposition();
        this.startListeningToTouch();
        if (this.props.closeMenuOnScroll && document && document.addEventListener) {
          document.addEventListener("scroll", this.onScroll, true);
        }
        if (this.props.autoFocus) {
          this.focusInput();
        }
        if (this.props.menuIsOpen && this.state.focusedOption && this.menuListRef && this.focusedOptionRef) {
          scrollIntoView(this.menuListRef, this.focusedOptionRef);
        }
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate(prevProps) {
        var _this$props6 = this.props, isDisabled = _this$props6.isDisabled, menuIsOpen = _this$props6.menuIsOpen;
        var isFocused = this.state.isFocused;
        if (
          // ensure focus is restored correctly when the control becomes enabled
          isFocused && !isDisabled && prevProps.isDisabled || // ensure focus is on the Input when the menu opens
          isFocused && menuIsOpen && !prevProps.menuIsOpen
        ) {
          this.focusInput();
        }
        if (isFocused && isDisabled && !prevProps.isDisabled) {
          this.setState({
            isFocused: false
          }, this.onMenuClose);
        } else if (!isFocused && !isDisabled && prevProps.isDisabled && this.inputRef === document.activeElement) {
          this.setState({
            isFocused: true
          });
        }
        if (this.menuListRef && this.focusedOptionRef && this.scrollToFocusedOptionOnUpdate) {
          scrollIntoView(this.menuListRef, this.focusedOptionRef);
          this.scrollToFocusedOptionOnUpdate = false;
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        this.stopListeningComposition();
        this.stopListeningToTouch();
        document.removeEventListener("scroll", this.onScroll, true);
      }
      // ==============================
      // Consumer Handlers
      // ==============================
    }, {
      key: "onMenuOpen",
      value: function onMenuOpen() {
        this.props.onMenuOpen();
      }
    }, {
      key: "onMenuClose",
      value: function onMenuClose() {
        this.onInputChange("", {
          action: "menu-close",
          prevInputValue: this.props.inputValue
        });
        this.props.onMenuClose();
      }
    }, {
      key: "onInputChange",
      value: function onInputChange(newValue, actionMeta) {
        this.props.onInputChange(newValue, actionMeta);
      }
      // ==============================
      // Methods
      // ==============================
    }, {
      key: "focusInput",
      value: function focusInput() {
        if (!this.inputRef) {
          return;
        }
        this.inputRef.focus();
      }
    }, {
      key: "blurInput",
      value: function blurInput() {
        if (!this.inputRef) {
          return;
        }
        this.inputRef.blur();
      }
    }, {
      key: "openMenu",
      value: function openMenu(focusOption) {
        var _this2 = this;
        var _this$state2 = this.state, selectValue = _this$state2.selectValue, isFocused = _this$state2.isFocused;
        var focusableOptions = this.buildFocusableOptions();
        var openAtIndex = focusOption === "first" ? 0 : focusableOptions.length - 1;
        if (!this.props.isMulti) {
          var selectedIndex = focusableOptions.indexOf(selectValue[0]);
          if (selectedIndex > -1) {
            openAtIndex = selectedIndex;
          }
        }
        var focusedOption = focusableOptions[openAtIndex];
        this.scrollToFocusedOptionOnUpdate = !(isFocused && this.menuListRef);
        this.setState({
          inputIsHiddenAfterUpdate: false,
          focusedValue: null,
          focusedOption,
          focusedOptionId: this.getFocusedOptionId(focusedOption)
        }, function() {
          return _this2.onMenuOpen();
        });
        isSafari() && focusedOption && this.updateInputLabel(this.calculateInputLabel(focusedOption, openAtIndex));
      }
    }, {
      key: "updateInputLabel",
      value: function updateInputLabel(inputLabel) {
        var _this3 = this;
        if (inputLabel) {
          var _this$inputRef;
          (_this$inputRef = this.inputRef) === null || _this$inputRef === void 0 || _this$inputRef.setAttribute("aria-label", inputLabel);
          setTimeout(function() {
            var normalizedLabel = _this3.props["aria-label"] || _this3.props.label;
            if (normalizedLabel) {
              var _this3$inputRef;
              (_this3$inputRef = _this3.inputRef) === null || _this3$inputRef === void 0 || _this3$inputRef.setAttribute("aria-label", normalizedLabel);
            } else {
              var _this3$inputRef2;
              (_this3$inputRef2 = _this3.inputRef) === null || _this3$inputRef2 === void 0 || _this3$inputRef2.removeAttribute("aria-label");
            }
          }, 500);
        }
      }
    }, {
      key: "calculateInputLabel",
      value: function calculateInputLabel(focusedOption, optionIndex) {
        var _this4 = this;
        var options2 = this.props.options;
        var isOptionsGrouped = options2 === null || options2 === void 0 ? void 0 : options2.every(function(obj) {
          return _typeof(obj) === "object" && obj !== null && "options" in obj;
        });
        var inputLabel = this.getOptionLabel(focusedOption);
        var isOptionFocused = function isOptionFocused2(option) {
          return _this4.getOptionLabel(option) === inputLabel;
        };
        var groupData = options2 === null || options2 === void 0 ? void 0 : options2.find(function(option) {
          var _groupCandidate$optio, _groupCandidate$optio2;
          var groupCandidate = option;
          return (_groupCandidate$optio = (_groupCandidate$optio2 = groupCandidate.options) === null || _groupCandidate$optio2 === void 0 ? void 0 : _groupCandidate$optio2.some(isOptionFocused)) !== null && _groupCandidate$optio !== void 0 ? _groupCandidate$optio : false;
        });
        if (isOptionsGrouped) {
          var _groupData$options$fi;
          var groupOptionIndex = (_groupData$options$fi = groupData === null || groupData === void 0 ? void 0 : groupData.options.findIndex(isOptionFocused)) !== null && _groupData$options$fi !== void 0 ? _groupData$options$fi : 0;
          var totalLength = options2 === null || options2 === void 0 ? void 0 : options2.reduce(function(acc, currentGroup) {
            var _group$options;
            var group = currentGroup;
            acc += group === null || group === void 0 || (_group$options = group.options) === null || _group$options === void 0 ? void 0 : _group$options.length;
            return acc;
          }, 0);
          inputLabel = "".concat(inputLabel, ", ").concat(groupData === null || groupData === void 0 ? void 0 : groupData.label, " (").concat(groupOptionIndex + 1, " of ").concat(totalLength, ")");
        } else {
          inputLabel = "".concat(inputLabel, " (").concat(optionIndex + 1, " of ").concat(options2 === null || options2 === void 0 ? void 0 : options2.length, ")");
        }
        return inputLabel;
      }
    }, {
      key: "focusValue",
      value: function focusValue(direction) {
        var _this$state3 = this.state, selectValue = _this$state3.selectValue, focusedValue = _this$state3.focusedValue;
        if (!this.props.isMulti) {
          return;
        }
        this.setState({
          focusedOption: null
        });
        var focusedIndex = selectValue.indexOf(focusedValue);
        if (!focusedValue) {
          focusedIndex = -1;
        }
        var lastIndex = selectValue.length - 1;
        var nextFocus = -1;
        if (!selectValue.length) {
          return;
        }
        switch (direction) {
          case "previous":
            if (focusedIndex === 0) {
              nextFocus = 0;
            } else if (focusedIndex === -1) {
              nextFocus = lastIndex;
            } else {
              nextFocus = focusedIndex - 1;
            }
            break;
          case "next":
            if (focusedIndex > -1 && focusedIndex < lastIndex) {
              nextFocus = focusedIndex + 1;
            }
            break;
        }
        this.setState({
          inputIsHidden: nextFocus !== -1,
          focusedValue: selectValue[nextFocus],
          focusedValueId: "".concat(this.getElementId("selected-value"), "-").concat(nextFocus, "-remove"),
          focusedOption: null,
          focusedOptionId: null
        });
      }
    }, {
      key: "focusOption",
      value: function focusOption() {
        var direction = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "first";
        var pageSize = this.props.pageSize;
        var focusedOption = this.state.focusedOption;
        var options2 = this.getFocusableOptions();
        if (!options2.length) {
          return;
        }
        var nextFocus = 0;
        var focusedIndex = options2.indexOf(focusedOption);
        if (!focusedOption) {
          focusedIndex = -1;
        }
        if (direction === "up") {
          nextFocus = focusedIndex > 0 ? focusedIndex - 1 : options2.length - 1;
        } else if (direction === "down") {
          nextFocus = (focusedIndex + 1) % options2.length;
        } else if (direction === "pageup") {
          nextFocus = focusedIndex - pageSize;
          if (nextFocus < 0) {
            nextFocus = 0;
          }
        } else if (direction === "pagedown") {
          nextFocus = focusedIndex + pageSize;
          if (nextFocus > options2.length - 1) {
            nextFocus = options2.length - 1;
          }
        } else if (direction === "last") {
          nextFocus = options2.length - 1;
        }
        this.scrollToFocusedOptionOnUpdate = true;
        this.setState({
          focusedOption: options2[nextFocus],
          focusedValue: null,
          focusedValueId: null,
          focusedOptionId: this.getFocusedOptionId(options2[nextFocus])
        });
      }
    }, {
      key: "getCommonProps",
      value: function getCommonProps() {
        var clearValue = this.clearValue, cx3 = this.cx, getStyles = this.getStyles, getClassNames = this.getClassNames, getValue = this.getValue, selectOption = this.selectOption, setValue = this.setValue, props = this.props;
        var isMulti = props.isMulti, isRtl = props.isRtl, options2 = props.options;
        var hasValue = this.hasValue();
        return {
          clearValue,
          cx: cx3,
          getStyles,
          getClassNames,
          getValue,
          hasValue,
          isMulti,
          isRtl,
          options: options2,
          selectOption,
          selectProps: props,
          setValue
        };
      }
    }, {
      key: "hasValue",
      value: function hasValue() {
        var selectValue = this.state.selectValue;
        return selectValue.length > 0;
      }
    }, {
      key: "hasOptions",
      value: function hasOptions() {
        return !!this.getFocusableOptions().length;
      }
    }, {
      key: "isClearable",
      value: function isClearable() {
        var _this$props7 = this.props, isClearable2 = _this$props7.isClearable, isMulti = _this$props7.isMulti;
        if (isClearable2 === void 0) {
          return isMulti;
        }
        return isClearable2;
      }
    }, {
      key: "isOptionDisabled",
      value: function isOptionDisabled3(option, selectValue) {
        return _isOptionDisabled(this.props, option, selectValue);
      }
    }, {
      key: "isOptionSelected",
      value: function isOptionSelected(option, selectValue) {
        return _isOptionSelected(this.props, option, selectValue);
      }
    }, {
      key: "filterOption",
      value: function filterOption(option, inputValue) {
        return _filterOption(this.props, option, inputValue);
      }
    }, {
      key: "formatOptionLabel",
      value: function formatOptionLabel(data, context) {
        if (typeof this.props.formatOptionLabel === "function") {
          var inputValue = this.props.inputValue;
          var selectValue = this.state.selectValue;
          return this.props.formatOptionLabel(data, {
            context,
            inputValue,
            selectValue
          });
        } else {
          return this.getOptionLabel(data);
        }
      }
    }, {
      key: "formatGroupLabel",
      value: function formatGroupLabel3(data) {
        return this.props.formatGroupLabel(data);
      }
    }, {
      key: "calculateDescription",
      value: function calculateDescription() {
        var descriptionProp = this.props["aria-describedby"] || this.props.descriptionId;
        var isMulti = this.props.isMulti;
        var hasValue = this.state.selectValue.length > 0;
        var baseDescriptionId = hasValue ? isMulti ? "" : this.getElementId("single-value") : this.getElementId("placeholder");
        if (!isMulti && !descriptionProp) {
          return {
            "aria-describedby": baseDescriptionId
          };
        }
        var describedBy = baseDescriptionId;
        if (descriptionProp) {
          describedBy = describedBy ? "".concat(descriptionProp, " ").concat(describedBy) : descriptionProp;
        }
        if (isMulti) {
          var multiMessage = this.getElementId("multi-message");
          describedBy = describedBy ? "".concat(describedBy, " ").concat(multiMessage) : multiMessage;
        }
        return {
          "aria-describedby": describedBy
        };
      }
    }, {
      key: "startListeningComposition",
      value: (
        // ==============================
        // Composition Handlers
        // ==============================
        function startListeningComposition() {
          if (document && document.addEventListener) {
            document.addEventListener("compositionstart", this.onCompositionStart, false);
            document.addEventListener("compositionend", this.onCompositionEnd, false);
          }
        }
      )
    }, {
      key: "stopListeningComposition",
      value: function stopListeningComposition() {
        if (document && document.removeEventListener) {
          document.removeEventListener("compositionstart", this.onCompositionStart);
          document.removeEventListener("compositionend", this.onCompositionEnd);
        }
      }
    }, {
      key: "startListeningToTouch",
      value: (
        // ==============================
        // Touch Handlers
        // ==============================
        function startListeningToTouch() {
          if (document && document.addEventListener) {
            document.addEventListener("touchstart", this.onTouchStart, false);
            document.addEventListener("touchmove", this.onTouchMove, false);
            document.addEventListener("touchend", this.onTouchEnd, false);
          }
        }
      )
    }, {
      key: "stopListeningToTouch",
      value: function stopListeningToTouch() {
        if (document && document.removeEventListener) {
          document.removeEventListener("touchstart", this.onTouchStart);
          document.removeEventListener("touchmove", this.onTouchMove);
          document.removeEventListener("touchend", this.onTouchEnd);
        }
      }
    }, {
      key: "renderInput",
      value: (
        // ==============================
        // Renderers
        // ==============================
        function renderInput() {
          var _this$props8 = this.props, form = _this$props8.form, inputId = _this$props8.inputId, inputValue = _this$props8.inputValue, isDisabled = _this$props8.isDisabled, isInvalid = _this$props8.isInvalid, isRequired = _this$props8.isRequired, isSearchable = _this$props8.isSearchable, label = _this$props8.label, labelId = _this$props8.labelId, menuIsOpen = _this$props8.menuIsOpen, required = _this$props8.required, _this$props8$tabIndex = _this$props8.tabIndex, tabIndex = _this$props8$tabIndex === void 0 ? 0 : _this$props8$tabIndex, testId = _this$props8.testId;
          var _this$getComponents = this.getComponents(), Input3 = _this$getComponents.Input;
          var inputIsHidden = this.state.inputIsHidden;
          var commonProps = this.commonProps;
          var id = inputId || this.getElementId("input");
          var ariaAttributes = _objectSpread23(_objectSpread23(_objectSpread23({
            "aria-autocomplete": "both",
            "aria-errormessage": this.props["aria-errormessage"],
            "aria-expanded": menuIsOpen,
            // TODO: aria-haspopup is implied as listbox with role="combobox" and was deprecated for aria 1.2, we still might need to keep it for back compat
            "aria-haspopup": this.props["UNSAFE_is_experimental_generic"] ? "dialog" : "listbox",
            "aria-invalid": this.props["aria-invalid"] || isInvalid,
            "aria-label": this.props["aria-label"] || label,
            "aria-labelledby": this.props["aria-labelledby"] || labelId,
            "aria-required": required || isRequired,
            role: "combobox",
            "aria-activedescendant": this.props["UNSAFE_is_experimental_generic"] ? void 0 : this.state.focusedOptionId || this.state.focusedValueId || void 0
          }, menuIsOpen && {
            "aria-controls": this.getElementId("listbox")
          }), !isSearchable && {
            "aria-readonly": true
          }), this.calculateDescription());
          if (!isSearchable) {
            return /* @__PURE__ */ import_react134.default.createElement(DummyInput, _extends({
              id,
              innerRef: this.getInputRef,
              onBlur: this.onInputBlur,
              onChange: noop4,
              onFocus: this.onInputFocus,
              disabled: isDisabled,
              tabIndex,
              inputMode: "none",
              form,
              value: "",
              "data-testid": testId && "".concat(testId, "-select--input")
            }, ariaAttributes));
          }
          return /* @__PURE__ */ import_react134.default.createElement(Input3, _extends({}, commonProps, {
            autoCapitalize: "none",
            autoComplete: "off",
            autoCorrect: "off",
            id,
            testId,
            innerRef: this.getInputRef,
            isDisabled,
            isHidden: inputIsHidden,
            onBlur: this.onInputBlur,
            onChange: this.handleInputChange,
            onFocus: this.onInputFocus,
            spellCheck: "false",
            tabIndex,
            form,
            type: "text",
            value: inputValue
          }, ariaAttributes));
        }
      )
    }, {
      key: "renderPlaceholderOrValue",
      value: function renderPlaceholderOrValue() {
        var _this5 = this;
        var _this$getComponents2 = this.getComponents(), MultiValue3 = _this$getComponents2.MultiValue, MultiValueContainer3 = _this$getComponents2.MultiValueContainer, MultiValueLabel3 = _this$getComponents2.MultiValueLabel, MultiValueRemove2 = _this$getComponents2.MultiValueRemove, SingleValue3 = _this$getComponents2.SingleValue, Placeholder3 = _this$getComponents2.Placeholder;
        var commonProps = this.commonProps;
        var _this$props9 = this.props, controlShouldRenderValue = _this$props9.controlShouldRenderValue, isDisabled = _this$props9.isDisabled, isMulti = _this$props9.isMulti, inputValue = _this$props9.inputValue, placeholder = _this$props9.placeholder, testId = _this$props9.testId;
        var _this$state4 = this.state, selectValue = _this$state4.selectValue, focusedValue = _this$state4.focusedValue, isFocused = _this$state4.isFocused;
        if (!this.hasValue() || !controlShouldRenderValue) {
          return inputValue ? null : /* @__PURE__ */ import_react134.default.createElement(Placeholder3, _extends({}, commonProps, {
            key: "placeholder",
            isDisabled,
            isFocused,
            innerProps: _objectSpread23({
              id: this.getElementId("placeholder")
            }, testId && {
              "data-testid": "".concat(testId, "-select--placeholder")
            })
          }), placeholder);
        }
        if (isMulti) {
          return selectValue.map(function(opt, index2) {
            var isOptionFocused = opt === focusedValue;
            var key = "".concat(_this5.getOptionLabel(opt), "-").concat(_this5.getOptionValue(opt));
            return /* @__PURE__ */ import_react134.default.createElement(MultiValue3, _extends({}, commonProps, {
              components: {
                Container: MultiValueContainer3,
                Label: MultiValueLabel3,
                Remove: MultiValueRemove2
              },
              isFocused: isOptionFocused,
              isDisabled,
              key,
              index: index2,
              removeProps: _objectSpread23(_objectSpread23({
                onClick: function onClick() {
                  return _this5.removeValue(opt);
                },
                onTouchEnd: function onTouchEnd() {
                  return _this5.removeValue(opt);
                },
                onMouseDown: function onMouseDown(e) {
                  e.preventDefault();
                }
              }, testId && {
                "data-testid": "".concat(testId, "-select--multivalue-").concat(index2, "-remove")
              }), {}, {
                id: "".concat(_this5.getElementId("selected-value"), "-").concat(index2, "-remove")
              }),
              data: opt,
              innerProps: _objectSpread23(_objectSpread23({}, testId && {
                "data-testid": "".concat(testId, "-select--multivalue-").concat(index2)
              }), {}, {
                id: "".concat(_this5.getElementId("selected-value"), "-").concat(index2)
              })
            }), _this5.formatOptionLabel(opt, "value"));
          });
        }
        if (inputValue) {
          return null;
        }
        var singleValue = selectValue[0];
        return /* @__PURE__ */ import_react134.default.createElement(SingleValue3, _extends({}, commonProps, {
          data: singleValue,
          isDisabled,
          innerProps: {
            id: this.getElementId("single-value")
          }
        }), this.formatOptionLabel(singleValue, "value"));
      }
    }, {
      key: "renderClearIndicator",
      value: function renderClearIndicator() {
        var _this$getComponents3 = this.getComponents(), ClearIndicator3 = _this$getComponents3.ClearIndicator;
        var commonProps = this.commonProps;
        var _this$props0 = this.props, clearControlLabel = _this$props0.clearControlLabel, isDisabled = _this$props0.isDisabled, isLoading = _this$props0.isLoading, spacing = _this$props0.spacing, testId = _this$props0.testId;
        var isFocused = this.state.isFocused;
        if (!this.isClearable() || !ClearIndicator3 || isDisabled || !this.hasValue() || isLoading) {
          return null;
        }
        var innerProps = _objectSpread23({
          onMouseDown: this.onClearIndicatorMouseDown,
          onTouchEnd: this.onClearIndicatorTouchEnd
        }, testId && {
          "data-testid": "".concat(testId, "-select--clear-indicator")
        });
        var isCompact = spacing === "compact";
        return /* @__PURE__ */ import_react134.default.createElement(ClearIndicator3, _extends({
          clearControlLabel
        }, commonProps, {
          innerProps,
          isFocused,
          isCompact
        }));
      }
    }, {
      key: "renderLoadingIndicator",
      value: function renderLoadingIndicator() {
        var _this$getComponents4 = this.getComponents(), LoadingIndicator3 = _this$getComponents4.LoadingIndicator;
        var commonProps = this.commonProps;
        var _this$props1 = this.props, isDisabled = _this$props1.isDisabled, isLoading = _this$props1.isLoading, spacing = _this$props1.spacing, testId = _this$props1.testId;
        var isFocused = this.state.isFocused;
        if (!LoadingIndicator3 || !isLoading) {
          return null;
        }
        var isCompact = spacing === "compact";
        var innerProps = {
          "aria-hidden": "true"
        };
        return /* @__PURE__ */ import_react134.default.createElement(LoadingIndicator3, _extends({
          "data-testid": testId && "".concat(testId, "-select--loading-indicator")
        }, commonProps, {
          innerProps,
          isDisabled,
          isFocused,
          isCompact
        }));
      }
    }, {
      key: "renderDropdownIndicator",
      value: function renderDropdownIndicator() {
        var _this$getComponents5 = this.getComponents(), DropdownIndicator3 = _this$getComponents5.DropdownIndicator;
        if (!DropdownIndicator3) {
          return null;
        }
        var commonProps = this.commonProps;
        var _this$props10 = this.props, isDisabled = _this$props10.isDisabled, spacing = _this$props10.spacing, testId = _this$props10.testId;
        var isFocused = this.state.isFocused;
        var isCompact = spacing === "compact";
        var innerProps = _objectSpread23({
          onMouseDown: this.onDropdownIndicatorMouseDown,
          onTouchEnd: this.onDropdownIndicatorTouchEnd,
          "aria-hidden": "true"
        }, testId && {
          "data-testid": "".concat(testId, "-select--dropdown-indicator")
        });
        return /* @__PURE__ */ import_react134.default.createElement(DropdownIndicator3, _extends({}, commonProps, {
          innerProps,
          isDisabled,
          isFocused,
          isCompact
        }));
      }
    }, {
      key: "renderMenu",
      value: function renderMenu() {
        var _this6 = this;
        var _this$getComponents6 = this.getComponents(), Group3 = _this$getComponents6.Group, GroupHeading3 = _this$getComponents6.GroupHeading, Menu3 = _this$getComponents6.Menu, MenuList3 = _this$getComponents6.MenuList, MenuPortal3 = _this$getComponents6.MenuPortal, LoadingMessage3 = _this$getComponents6.LoadingMessage, NoOptionsMessage3 = _this$getComponents6.NoOptionsMessage, Option3 = _this$getComponents6.Option;
        var commonProps = this.commonProps;
        var focusedOption = this.state.focusedOption;
        var _this$props11 = this.props, captureMenuScroll = _this$props11.captureMenuScroll, inputValue = _this$props11.inputValue, isLoading = _this$props11.isLoading, loadingMessage2 = _this$props11.loadingMessage, minMenuHeight = _this$props11.minMenuHeight, maxMenuHeight = _this$props11.maxMenuHeight, menuIsOpen = _this$props11.menuIsOpen, menuPlacement = _this$props11.menuPlacement, menuPosition = _this$props11.menuPosition, menuPortalTarget = _this$props11.menuPortalTarget, menuShouldBlockScroll = _this$props11.menuShouldBlockScroll, menuShouldScrollIntoView = _this$props11.menuShouldScrollIntoView, noOptionsMessage2 = _this$props11.noOptionsMessage, onMenuScrollToTop = _this$props11.onMenuScrollToTop, onMenuScrollToBottom = _this$props11.onMenuScrollToBottom, testId = _this$props11.testId;
        if (!menuIsOpen) {
          return null;
        }
        var render = function render2(props, id, headingId) {
          var type = props.type, data = props.data, isDisabled = props.isDisabled, isSelected = props.isSelected, label = props.label, value = props.value;
          var isFocused = focusedOption === data;
          var onHover = isDisabled ? void 0 : function() {
            return _this6.onOptionHover(data);
          };
          var onSelect = isDisabled ? void 0 : function() {
            return _this6.selectOption(data);
          };
          var optionId = "".concat(_this6.getElementId("option"), "-").concat(id);
          var innerProps = _objectSpread23({
            id: optionId,
            onClick: onSelect,
            onMouseMove: onHover,
            onMouseOver: onHover,
            role: _this6.props["UNSAFE_is_experimental_generic"] ? "listitem" : "option",
            "aria-selected": _this6.props["UNSAFE_is_experimental_generic"] ? void 0 : isSelected,
            // We don't want aria-disabled if it's false. It's just noisy.
            "aria-disabled": !isDisabled ? void 0 : isDisabled,
            "aria-describedby": headingId
          }, testId && {
            "data-testid": "".concat(testId, "-select--option-").concat(id)
          });
          return /* @__PURE__ */ import_react134.default.createElement(Option3, _extends({}, commonProps, {
            innerProps,
            data,
            isDisabled,
            isSelected,
            key: optionId,
            label,
            type,
            value,
            isFocused,
            innerRef: isFocused ? _this6.getFocusedOptionRef : void 0
          }), _this6.formatOptionLabel(props.data, "menu"));
        };
        var menuUI;
        if (this.hasOptions()) {
          var items = this.getCategorizedOptions();
          menuUI = items.map(function(item) {
            if (item.type === "group") {
              var data = item.data, options2 = item.options, groupIndex = item.index;
              var groupId = "".concat(_this6.getElementId("group"), "-").concat(groupIndex);
              var headingId = "".concat(groupId, "-heading");
              return /* @__PURE__ */ import_react134.default.createElement(Group3, _extends({}, commonProps, {
                key: groupId,
                data,
                options: options2,
                Heading: GroupHeading3,
                headingProps: _objectSpread23({
                  id: headingId,
                  data: item.data
                }, testId && {
                  "data-testid": "".concat(testId, "-select--group-").concat(groupIndex, "-heading")
                }),
                label: _this6.formatGroupLabel(item.data)
              }), item.options.map(function(option) {
                return render(option, "".concat(groupIndex, "-").concat(option.index), headingId);
              }));
            } else if (item.type === "option") {
              return render(item, "".concat(item.index));
            }
          });
        } else if (isLoading) {
          var message2 = loadingMessage2({
            inputValue
          });
          if (message2 === null) {
            return null;
          }
          menuUI = /* @__PURE__ */ import_react134.default.createElement(LoadingMessage3, commonProps, message2);
        } else {
          var _message = noOptionsMessage2({
            inputValue
          });
          if (_message === null) {
            return null;
          }
          menuUI = /* @__PURE__ */ import_react134.default.createElement(NoOptionsMessage3, _extends({}, commonProps, {
            innerProps: _objectSpread23({}, testId && {
              "data-testid": "".concat(testId, "-select--no-options")
            })
          }), _message);
        }
        var menuPlacementProps = {
          minMenuHeight,
          maxMenuHeight,
          menuPlacement,
          menuPosition,
          menuShouldScrollIntoView
        };
        var menuElement = /* @__PURE__ */ import_react134.default.createElement(MenuPlacer, _extends({}, commonProps, menuPlacementProps), function(_ref4) {
          var ref = _ref4.ref, _ref4$placerProps = _ref4.placerProps, placement = _ref4$placerProps.placement, maxHeight = _ref4$placerProps.maxHeight;
          return /* @__PURE__ */ import_react134.default.createElement(Menu3, _extends({}, commonProps, menuPlacementProps, {
            innerRef: ref,
            innerProps: _objectSpread23({
              onMouseDown: _this6.onMenuMouseDown,
              onMouseMove: _this6.onMenuMouseMove,
              id: _this6.props.components.Menu ? _this6.getElementId("listbox") : void 0
            }, testId && {
              "data-testid": "".concat(testId, "-select--listbox-container")
            }),
            isLoading,
            placement
          }), /* @__PURE__ */ import_react134.default.createElement(ScrollManager, {
            captureEnabled: captureMenuScroll,
            onTopArrive: onMenuScrollToTop,
            onBottomArrive: onMenuScrollToBottom,
            lockEnabled: menuShouldBlockScroll
          }, function(scrollTargetRef) {
            var _this6$inputRef, _this6$inputRef2;
            return /* @__PURE__ */ import_react134.default.createElement(MenuList3, _extends({}, commonProps, {
              innerRef: function innerRef(instance) {
                _this6.getMenuListRef(instance);
                scrollTargetRef(instance);
              },
              innerProps: _objectSpread23(_objectSpread23(_objectSpread23({
                role: _this6.props["UNSAFE_is_experimental_generic"] ? "dialog" : "listbox"
              }, _this6.props["UNSAFE_is_experimental_generic"] && {
                "aria-labelledby": ((_this6$inputRef = _this6.inputRef) === null || _this6$inputRef === void 0 ? void 0 : _this6$inputRef.id) || _this6.getElementId("input")
              }), {}, {
                "aria-multiselectable": !commonProps.isMulti || _this6.props["UNSAFE_is_experimental_generic"] ? void 0 : commonProps.isMulti,
                id: _this6.getElementId("listbox")
              }, testId && {
                "data-testid": "".concat(testId, "-select--listbox")
              }), isSafari() && !_this6.props["UNSAFE_is_experimental_generic"] && {
                "aria-describedby": ((_this6$inputRef2 = _this6.inputRef) === null || _this6$inputRef2 === void 0 ? void 0 : _this6$inputRef2.id) || _this6.getElementId("input")
              }),
              isLoading,
              maxHeight,
              focusedOption
            }), _this6.props["UNSAFE_is_experimental_generic"] ? /* @__PURE__ */ import_react134.default.createElement("div", {
              role: "list"
            }, menuUI) : menuUI);
          }));
        });
        return menuPortalTarget || menuPosition === "fixed" ? /* @__PURE__ */ import_react134.default.createElement(MenuPortal3, _extends({}, commonProps, {
          appendTo: menuPortalTarget,
          controlElement: this.controlRef,
          menuPlacement,
          menuPosition
        }), menuElement) : menuElement;
      }
    }, {
      key: "renderFormField",
      value: function renderFormField() {
        var _this7 = this;
        var _this$props12 = this.props, delimiter2 = _this$props12.delimiter, isDisabled = _this$props12.isDisabled, isMulti = _this$props12.isMulti, required = _this$props12.required, name = _this$props12.name;
        var selectValue = this.state.selectValue;
        if (required && !this.hasValue() && !isDisabled) {
          return /* @__PURE__ */ import_react134.default.createElement(required_input_default, {
            name,
            onFocus: this.onValueInputFocus
          });
        }
        if (!name || isDisabled) {
          return;
        }
        if (isMulti) {
          if (delimiter2) {
            var value = selectValue.map(function(opt) {
              return _this7.getOptionValue(opt);
            }).join(delimiter2);
            return /* @__PURE__ */ import_react134.default.createElement("input", {
              name,
              type: "hidden",
              value
            });
          } else {
            var input = selectValue.length > 0 ? selectValue.map(function(opt, i) {
              return /* @__PURE__ */ import_react134.default.createElement("input", {
                key: "i-".concat(i),
                name,
                type: "hidden",
                value: _this7.getOptionValue(opt)
              });
            }) : /* @__PURE__ */ import_react134.default.createElement("input", {
              name,
              type: "hidden",
              value: ""
            });
            return /* @__PURE__ */ import_react134.default.createElement("div", null, input);
          }
        } else {
          var _value = selectValue[0] ? this.getOptionValue(selectValue[0]) : "";
          return /* @__PURE__ */ import_react134.default.createElement("input", {
            name,
            type: "hidden",
            value: _value
          });
        }
      }
    }, {
      key: "renderLiveRegion",
      value: function renderLiveRegion() {
        var commonProps = this.commonProps;
        var _this$state5 = this.state, ariaSelection = _this$state5.ariaSelection, isFocused = _this$state5.isFocused, selectValue = _this$state5.selectValue;
        var focusableOptions = this.getFocusableOptions();
        return /* @__PURE__ */ import_react134.default.createElement(live_region_default, _extends({}, commonProps, {
          id: this.getElementId("live-region"),
          ariaSelection,
          isFocused,
          selectValue,
          focusableOptions
        }));
      }
    }, {
      key: "renderMultiselectMessage",
      value: function renderMultiselectMessage() {
        var msg = ", multiple selections available, ".concat(this.state.selectValue.length ? "Use left or right arrow keys to navigate selected items" : "");
        return (
          // eslint-disable-next-line @atlaskit/design-system/use-primitives-text
          /* @__PURE__ */ import_react134.default.createElement("span", {
            id: this.getElementId("multi-message"),
            hidden: true
          }, msg)
        );
      }
    }, {
      key: "render",
      value: function render() {
        var _this$getComponents7 = this.getComponents(), Control3 = _this$getComponents7.Control, IndicatorsContainer3 = _this$getComponents7.IndicatorsContainer, SelectContainer3 = _this$getComponents7.SelectContainer, ValueContainer3 = _this$getComponents7.ValueContainer;
        var _this$props13 = this.props, className = _this$props13.className, id = _this$props13.id, isDisabled = _this$props13.isDisabled, menuIsOpen = _this$props13.menuIsOpen, isInvalid = _this$props13.isInvalid, testId = _this$props13.testId, _this$props13$appeara = _this$props13.appearance, appearance = _this$props13$appeara === void 0 ? "default" : _this$props13$appeara, _this$props13$spacing = _this$props13.spacing, spacing = _this$props13$spacing === void 0 ? "default" : _this$props13$spacing;
        var isFocused = this.state.isFocused;
        var commonProps = this.commonProps = this.getCommonProps();
        var isCompact = spacing === "compact";
        return /* @__PURE__ */ import_react134.default.createElement(SelectContainer3, _extends({}, commonProps, {
          // eslint-disable-next-line @atlaskit/ui-styling-standard/no-classname-prop
          className,
          innerProps: _objectSpread23({
            id,
            onKeyDown: this.onKeyDown
          }, testId && {
            "data-testid": testId && "".concat(testId, "-select--container")
          }),
          isDisabled,
          isFocused
        }), this.renderLiveRegion(), commonProps.isMulti && this.renderMultiselectMessage(), /* @__PURE__ */ import_react134.default.createElement(Control3, _extends({}, commonProps, {
          innerRef: this.getControlRef,
          innerProps: _objectSpread23({
            onMouseDown: this.onControlMouseDown,
            onTouchEnd: this.onControlTouchEnd
          }, testId && {
            "data-testid": "".concat(testId, "-select--control")
          }),
          appearance,
          isInvalid,
          isDisabled,
          isFocused,
          menuIsOpen,
          isCompact
        }), /* @__PURE__ */ import_react134.default.createElement(ValueContainer3, _extends({}, commonProps, {
          isDisabled,
          isCompact,
          innerProps: _objectSpread23(_objectSpread23({}, testId && {
            "data-testid": "".concat(testId, "-select--value-container")
          }), commonProps.isMulti && commonProps.hasValue && !isAppleDevice() && {
            // Required to keep JAWS from popping out of forms mode when using LEFT/RIGHT arrow keys.
            // This is Jedi Master level ARIA and not taken lightly. Do not modify without consulting
            // DST Accessibility.
            role: "application"
          })
        }), this.renderPlaceholderOrValue(), this.renderInput()), /* @__PURE__ */ import_react134.default.createElement(IndicatorsContainer3, _extends({}, commonProps, {
          isDisabled,
          innerProps: _objectSpread23({}, testId && {
            "data-testid": "".concat(testId, "-select--indicators-container")
          })
        }), this.renderClearIndicator(), this.renderLoadingIndicator(), this.renderDropdownIndicator())), this.renderMenu(), this.renderFormField(), /* @__PURE__ */ import_react134.default.createElement(NotifyOpenLayerObserver, {
          isOpen: this.props.menuIsOpen,
          onClose: this.handleOpenLayerObserverCloseSignal
        }));
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function getDerivedStateFromProps(props, state) {
        var prevProps = state.prevProps, clearFocusValueOnUpdate = state.clearFocusValueOnUpdate, inputIsHiddenAfterUpdate = state.inputIsHiddenAfterUpdate, ariaSelection = state.ariaSelection, isFocused = state.isFocused, prevWasFocused = state.prevWasFocused, instancePrefix = state.instancePrefix;
        var options2 = props.options, value = props.value, menuIsOpen = props.menuIsOpen, inputValue = props.inputValue, isMulti = props.isMulti;
        var selectValue = cleanValue(value);
        var newMenuOptionsState = {};
        if (prevProps && (value !== prevProps.value || options2 !== prevProps.options || menuIsOpen !== prevProps.menuIsOpen || inputValue !== prevProps.inputValue)) {
          var focusableOptions = menuIsOpen ? buildFocusableOptions(props, selectValue) : [];
          var focusableOptionsWithIds = menuIsOpen ? buildFocusableOptionsWithIds(buildCategorizedOptions(props, selectValue), "".concat(instancePrefix, "-option")) : [];
          var focusedValue = clearFocusValueOnUpdate ? getNextFocusedValue(state, selectValue) : null;
          var focusedOption = getNextFocusedOption(state, focusableOptions);
          var focusedOptionId = getFocusedOptionId(focusableOptionsWithIds, focusedOption);
          newMenuOptionsState = {
            selectValue,
            focusedOption,
            focusedOptionId,
            focusableOptionsWithIds,
            focusedValue,
            clearFocusValueOnUpdate: false
          };
        }
        var newInputIsHiddenState = inputIsHiddenAfterUpdate != null && props !== prevProps ? {
          inputIsHidden: inputIsHiddenAfterUpdate,
          inputIsHiddenAfterUpdate: void 0
        } : {};
        var newAriaSelection = ariaSelection;
        var hasKeptFocus = isFocused && prevWasFocused;
        if (isFocused && !hasKeptFocus) {
          newAriaSelection = {
            value: valueTernary(isMulti, selectValue, selectValue[0] || null),
            options: selectValue,
            action: "initial-input-focus"
          };
          hasKeptFocus = !prevWasFocused;
        }
        if ((ariaSelection === null || ariaSelection === void 0 ? void 0 : ariaSelection.action) === "initial-input-focus") {
          newAriaSelection = null;
        }
        return _objectSpread23(_objectSpread23(_objectSpread23({}, newMenuOptionsState), newInputIsHiddenState), {}, {
          prevProps: props,
          ariaSelection: newAriaSelection,
          prevWasFocused: hasKeptFocus
        });
      }
    }]);
  })(import_react134.Component);
  _defineProperty(Select, "defaultProps", defaultProps);

  // node_modules/@atlaskit/react-select/dist/esm/async.js
  var import_react136 = __toESM(require_react());

  // node_modules/@atlaskit/react-select/dist/esm/use-async.js
  init_defineProperty();
  init_slicedToArray();
  var import_react135 = __toESM(require_react());
  var _excluded20 = ["defaultOptions", "cacheOptions", "loadOptions", "options", "isLoading", "onInputChange", "filterOption"];
  function ownKeys24(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r && (o = o.filter(function(r2) {
        return Object.getOwnPropertyDescriptor(e, r2).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread24(e) {
    for (var r = 1; r < arguments.length; r++) {
      var t = null != arguments[r] ? arguments[r] : {};
      r % 2 ? ownKeys24(Object(t), true).forEach(function(r2) {
        _defineProperty(e, r2, t[r2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys24(Object(t)).forEach(function(r2) {
        Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
      });
    }
    return e;
  }
  function useAsync(_ref2) {
    var _ref$defaultOptions = _ref2.defaultOptions, propsDefaultOptions = _ref$defaultOptions === void 0 ? false : _ref$defaultOptions, _ref$cacheOptions = _ref2.cacheOptions, cacheOptions = _ref$cacheOptions === void 0 ? false : _ref$cacheOptions, propsLoadOptions = _ref2.loadOptions, propsOptions = _ref2.options, _ref$isLoading = _ref2.isLoading, propsIsLoading = _ref$isLoading === void 0 ? false : _ref$isLoading, propsOnInputChange = _ref2.onInputChange, _ref$filterOption = _ref2.filterOption, filterOption = _ref$filterOption === void 0 ? null : _ref$filterOption, restSelectProps = _objectWithoutProperties(_ref2, _excluded20);
    var propsInputValue = restSelectProps.inputValue;
    var lastRequest = (0, import_react135.useRef)(void 0);
    var mounted = (0, import_react135.useRef)(false);
    var _useState = (0, import_react135.useState)(Array.isArray(propsDefaultOptions) ? propsDefaultOptions : void 0), _useState2 = _slicedToArray(_useState, 2), defaultOptions4 = _useState2[0], setDefaultOptions = _useState2[1];
    var _useState3 = (0, import_react135.useState)(typeof propsInputValue !== "undefined" ? propsInputValue : ""), _useState4 = _slicedToArray(_useState3, 2), stateInputValue = _useState4[0], setStateInputValue = _useState4[1];
    var _useState5 = (0, import_react135.useState)(propsDefaultOptions === true), _useState6 = _slicedToArray(_useState5, 2), isLoading = _useState6[0], setIsLoading = _useState6[1];
    var _useState7 = (0, import_react135.useState)(void 0), _useState8 = _slicedToArray(_useState7, 2), loadedInputValue = _useState8[0], setLoadedInputValue = _useState8[1];
    var _useState9 = (0, import_react135.useState)([]), _useState0 = _slicedToArray(_useState9, 2), loadedOptions = _useState0[0], setLoadedOptions = _useState0[1];
    var _useState1 = (0, import_react135.useState)(false), _useState10 = _slicedToArray(_useState1, 2), passEmptyOptions = _useState10[0], setPassEmptyOptions = _useState10[1];
    var _useState11 = (0, import_react135.useState)({}), _useState12 = _slicedToArray(_useState11, 2), optionsCache = _useState12[0], setOptionsCache = _useState12[1];
    var _useState13 = (0, import_react135.useState)(void 0), _useState14 = _slicedToArray(_useState13, 2), prevDefaultOptions = _useState14[0], setPrevDefaultOptions = _useState14[1];
    var _useState15 = (0, import_react135.useState)(void 0), _useState16 = _slicedToArray(_useState15, 2), prevCacheOptions = _useState16[0], setPrevCacheOptions = _useState16[1];
    if (cacheOptions !== prevCacheOptions) {
      setOptionsCache({});
      setPrevCacheOptions(cacheOptions);
    }
    if (propsDefaultOptions !== prevDefaultOptions) {
      setDefaultOptions(Array.isArray(propsDefaultOptions) ? propsDefaultOptions : void 0);
      setPrevDefaultOptions(propsDefaultOptions);
    }
    (0, import_react135.useEffect)(function() {
      mounted.current = true;
      return function() {
        mounted.current = false;
      };
    }, []);
    var loadOptions = (0, import_react135.useCallback)(function(inputValue, callback) {
      if (!propsLoadOptions) {
        return callback();
      }
      var loader = propsLoadOptions(inputValue, callback);
      if (loader && typeof loader.then === "function") {
        loader.then(callback, function() {
          return callback();
        });
      }
    }, [propsLoadOptions]);
    (0, import_react135.useEffect)(function() {
      if (propsDefaultOptions === true) {
        loadOptions(stateInputValue, function(options3) {
          if (!mounted.current) {
            return;
          }
          setDefaultOptions(options3 || []);
          setIsLoading(!!lastRequest.current);
        });
      }
    }, []);
    var onInputChange = (0, import_react135.useCallback)(function(newValue, actionMeta) {
      var inputValue = handleInputChange(newValue, actionMeta, propsOnInputChange);
      if (!inputValue) {
        lastRequest.current = void 0;
        setStateInputValue("");
        setLoadedInputValue("");
        setLoadedOptions([]);
        setIsLoading(false);
        setPassEmptyOptions(false);
        return;
      }
      if (cacheOptions && optionsCache[inputValue]) {
        setStateInputValue(inputValue);
        setLoadedInputValue(inputValue);
        setLoadedOptions(optionsCache[inputValue]);
        setIsLoading(false);
        setPassEmptyOptions(false);
      } else {
        var request = lastRequest.current = {};
        setStateInputValue(inputValue);
        setIsLoading(true);
        setPassEmptyOptions(!loadedInputValue);
        loadOptions(inputValue, function(options3) {
          if (!mounted) {
            return;
          }
          if (request !== lastRequest.current) {
            return;
          }
          lastRequest.current = void 0;
          setIsLoading(false);
          setLoadedInputValue(inputValue);
          setLoadedOptions(options3 || []);
          setPassEmptyOptions(false);
          setOptionsCache(options3 ? _objectSpread24(_objectSpread24({}, optionsCache), {}, _defineProperty({}, inputValue, options3)) : optionsCache);
        });
      }
    }, [cacheOptions, loadOptions, loadedInputValue, optionsCache, propsOnInputChange]);
    var options2 = passEmptyOptions ? [] : stateInputValue && loadedInputValue ? loadedOptions : defaultOptions4 || [];
    return _objectSpread24(_objectSpread24({}, restSelectProps), {}, {
      options: options2,
      isLoading: isLoading || propsIsLoading,
      onInputChange,
      filterOption
    });
  }

  // node_modules/@atlaskit/react-select/dist/esm/async.js
  var AsyncSelect = /* @__PURE__ */ (0, import_react136.forwardRef)(function(props, ref) {
    var isAsyncEnabledInBaseSelect = props.isAsync && !props.options && (!!props.loadOptions || !!props.defaultOptions);
    var stateManagedProps = useAsync(props);
    var selectAsyncProps = !props.isAsync || isAsyncEnabledInBaseSelect ? stateManagedProps : props;
    var selectProps = useStateManager(selectAsyncProps);
    return /* @__PURE__ */ import_react136.default.createElement(Select, _extends({
      ref
    }, selectProps));
  });
  var async_default = AsyncSelect;

  // node_modules/@atlaskit/select/dist/esm/createSelect.js
  var import_react137 = __toESM(require_react());
  var _excluded21 = ["ariaLiveMessages", "isInvalid", "onClickPreventDefault", "tabSelectsValue", "validationState"];
  function createSelect(WrappedComponent) {
    var AtlaskitSelect = /* @__PURE__ */ (0, import_react137.forwardRef)(function AtlaskitSelect2(props, forwardedRef) {
      var ariaLiveMessages = props.ariaLiveMessages, isInvalid = props.isInvalid, _props$onClickPrevent = props.onClickPreventDefault, onClickPreventDefault = _props$onClickPrevent === void 0 ? true : _props$onClickPrevent, _props$tabSelectsValu = props.tabSelectsValue, tabSelectsValue = _props$tabSelectsValu === void 0 ? false : _props$tabSelectsValu, _props$validationStat = props.validationState, validationState = _props$validationStat === void 0 ? "default" : _props$validationStat, restProps = _objectWithoutProperties(props, _excluded21);
      var internalSelectRef = (0, import_react137.useRef)(null);
      (0, import_react137.useImperativeHandle)(forwardedRef, function() {
        return {
          select: internalSelectRef.current,
          focus: function focus() {
            var _internalSelectRef$cu;
            return (_internalSelectRef$cu = internalSelectRef.current) === null || _internalSelectRef$cu === void 0 ? void 0 : _internalSelectRef$cu.focus();
          },
          blur: function blur() {
            var _internalSelectRef$cu2;
            return (_internalSelectRef$cu2 = internalSelectRef.current) === null || _internalSelectRef$cu2 === void 0 ? void 0 : _internalSelectRef$cu2.blur();
          }
        };
      }, []);
      return /* @__PURE__ */ import_react137.default.createElement(WrappedComponent, _extends({
        ref: internalSelectRef,
        ariaLiveMessages,
        tabSelectsValue,
        onClickPreventDefault,
        isInvalid: isInvalid || validationState === "error"
      }, restProps, {
        // indicates react-select to be async by default using the base Select component
        // so that makers can pass all async props on the base select to async load options.
        isAsync: true
      }));
    });
    AtlaskitSelect.displayName = "AtlaskitSelect";
    return AtlaskitSelect;
  }

  // node_modules/@atlaskit/select/dist/esm/Select.js
  var packageName2 = "@atlaskit/select";
  var packageVersion2 = "21.2.3";
  var SelectWithoutAnalytics = createSelect(async_default);
  var createAndFireEventOnAtlaskit = createAndFireEvent_default("atlaskit");
  var Select2 = withAnalyticsContext_default({
    componentName: "select",
    packageName: packageName2,
    packageVersion: packageVersion2
  })(withAnalyticsEvents_default({
    onChange: createAndFireEventOnAtlaskit({
      action: "changed",
      actionSubject: "option",
      attributes: {
        componentName: "select",
        packageName: packageName2,
        packageVersion: packageVersion2
      }
    })
  })(SelectWithoutAnalytics));
  var Select_default = Select2;

  // src/components/StatusLegend/StatusLegend.tsx
  var import_jsx_runtime6 = __toESM(require_jsx_runtime());
  function StatusLegend() {
    return /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)("div", { className: "legend", children: [
      /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("span", { className: "legend-item legend-completed", children: "Completed" }),
      /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("span", { className: "legend-item legend-in-progress", children: "In Progress" }),
      /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("span", { className: "legend-item legend-pending", children: "Pending" }),
      /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("span", { className: "legend-item legend-paused", children: "Paused" }),
      /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("span", { className: "legend-item legend-cancelled", children: "Cancelled" }),
      /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("span", { className: "legend-item legend-missed-update", children: "Missed Update" }),
      /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("span", { className: "legend-item legend-none", children: "No Status" })
    ] });
  }

  // src/components/ProjectStatusHistoryModal/ProjectStatusHistoryModal.tsx
  var import_jsx_runtime7 = __toESM(require_jsx_runtime());
  function CustomModalHeader() {
    const { onClose, titleId } = useModal();
    return /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)("div", { className: "custom-modal-header", children: [
      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("h2", { id: titleId, className: "custom-modal-title", children: "Atlas-Xray Project History Timeline" }),
      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
        button_default,
        {
          appearance: "subtle",
          onClick: onClose,
          iconBefore: import_cross4.default,
          children: "Close"
        }
      )
    ] });
  }
  function ProjectStatusHistoryModal({ open, onClose, children }) {
    const [weekLimit, setWeekLimit] = (0, import_react138.useState)(12);
    const weekOptions = [
      { label: "4 weeks", value: 4 },
      { label: "8 weeks", value: 8 },
      { label: "12 weeks", value: 12 },
      { label: "24 weeks", value: 24 },
      { label: "All", value: Infinity }
    ];
    if (!open) return null;
    return /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(modal_transition_default, { children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(FullScreenModalDialog, { onClose, children: /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)("div", { className: "project-status-history-modal", children: [
      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CustomModalHeader, {}),
      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(modal_body_default, { hasInlinePadding: true, children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
        box_default2,
        {
          style: {
            maxWidth: "1128px",
            margin: "0 auto",
            width: "100%",
            minHeight: "calc(100vh - 200px)",
            // Ensure minimum height for scrolling
            overflow: "auto"
            // Enable scrolling
          },
          children: /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)(grid_default, { children: [
            /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(StatusLegend, {}),
            /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("div", { style: { marginBottom: 16, maxWidth: 200 }, children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
              Select_default,
              {
                options: weekOptions,
                value: weekOptions.find((opt) => opt.value === weekLimit),
                onChange: (option) => setWeekLimit(option.value),
                placeholder: "Weeks to show",
                isSearchable: false
              }
            ) }),
            typeof children === "function" ? children(weekLimit) : children
          ] })
        }
      ) })
    ] }) }) });
  }

  // node_modules/ts-invariant/lib/invariant.js
  var genericMessage = "Invariant Violation";
  var _a = Object.setPrototypeOf;
  var setPrototypeOf = _a === void 0 ? function(obj, proto) {
    obj.__proto__ = proto;
    return obj;
  } : _a;
  var InvariantError = (
    /** @class */
    (function(_super) {
      __extends(InvariantError2, _super);
      function InvariantError2(message2) {
        if (message2 === void 0) {
          message2 = genericMessage;
        }
        var _this = _super.call(this, typeof message2 === "number" ? genericMessage + ": " + message2 + " (see https://github.com/apollographql/invariant-packages)" : message2) || this;
        _this.framesToPop = 1;
        _this.name = genericMessage;
        setPrototypeOf(_this, InvariantError2.prototype);
        return _this;
      }
      return InvariantError2;
    })(Error)
  );
  function invariant2(condition, message2) {
    if (!condition) {
      throw new InvariantError(message2);
    }
  }
  var verbosityLevels = ["debug", "log", "warn", "error", "silent"];
  var verbosityLevel = verbosityLevels.indexOf("log");
  function wrapConsoleMethod(name) {
    return function() {
      if (verbosityLevels.indexOf(name) >= verbosityLevel) {
        var method = console[name] || console.log;
        return method.apply(console, arguments);
      }
    };
  }
  (function(invariant6) {
    invariant6.debug = wrapConsoleMethod("debug");
    invariant6.log = wrapConsoleMethod("log");
    invariant6.warn = wrapConsoleMethod("warn");
    invariant6.error = wrapConsoleMethod("error");
  })(invariant2 || (invariant2 = {}));
  function setVerbosity(level) {
    var old = verbosityLevels[verbosityLevel];
    verbosityLevel = Math.max(0, verbosityLevels.indexOf(level));
    return old;
  }

  // node_modules/@apollo/client/version.js
  var version = "3.13.9";

  // node_modules/@apollo/client/utilities/globals/maybe.js
  function maybe(thunk) {
    try {
      return thunk();
    } catch (_a2) {
    }
  }

  // node_modules/@apollo/client/utilities/globals/global.js
  var global_default = maybe(function() {
    return globalThis;
  }) || maybe(function() {
    return window;
  }) || maybe(function() {
    return self;
  }) || maybe(function() {
    return global;
  }) || // We don't expect the Function constructor ever to be invoked at runtime, as
  // long as at least one of globalThis, window, self, or global is defined, so
  // we are under no obligation to make it easy for static analysis tools to
  // detect syntactic usage of the Function constructor. If you think you can
  // improve your static analysis to detect this obfuscation, think again. This
  // is an arms race you cannot win, at least not in JavaScript.
  maybe(function() {
    return maybe.constructor("return this")();
  });

  // node_modules/@apollo/client/utilities/common/makeUniqueId.js
  var prefixCounts = /* @__PURE__ */ new Map();
  function makeUniqueId(prefix3) {
    var count = prefixCounts.get(prefix3) || 1;
    prefixCounts.set(prefix3, count + 1);
    return "".concat(prefix3, ":").concat(count, ":").concat(Math.random().toString(36).slice(2));
  }

  // node_modules/@apollo/client/utilities/common/stringifyForDisplay.js
  function stringifyForDisplay(value, space) {
    if (space === void 0) {
      space = 0;
    }
    var undefId = makeUniqueId("stringifyForDisplay");
    return JSON.stringify(value, function(key, value2) {
      return value2 === void 0 ? undefId : value2;
    }, space).split(JSON.stringify(undefId)).join("<undefined>");
  }

  // node_modules/@apollo/client/utilities/globals/invariantWrappers.js
  function wrap(fn2) {
    return function(message2) {
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      if (typeof message2 === "number") {
        var arg0 = message2;
        message2 = getHandledErrorMsg(arg0);
        if (!message2) {
          message2 = getFallbackErrorMsg(arg0, args);
          args = [];
        }
      }
      fn2.apply(void 0, [message2].concat(args));
    };
  }
  var invariant3 = Object.assign(function invariant4(condition, message2) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    if (!condition) {
      invariant2(condition, getHandledErrorMsg(message2, args) || getFallbackErrorMsg(message2, args));
    }
  }, {
    debug: wrap(invariant2.debug),
    log: wrap(invariant2.log),
    warn: wrap(invariant2.warn),
    error: wrap(invariant2.error)
  });
  function newInvariantError(message2) {
    var optionalParams = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      optionalParams[_i - 1] = arguments[_i];
    }
    return new InvariantError(getHandledErrorMsg(message2, optionalParams) || getFallbackErrorMsg(message2, optionalParams));
  }
  var ApolloErrorMessageHandler = Symbol.for("ApolloErrorMessageHandler_" + version);
  function stringify2(arg) {
    if (typeof arg == "string") {
      return arg;
    }
    try {
      return stringifyForDisplay(arg, 2).slice(0, 1e3);
    } catch (_a2) {
      return "<non-serializable>";
    }
  }
  function getHandledErrorMsg(message2, messageArgs) {
    if (messageArgs === void 0) {
      messageArgs = [];
    }
    if (!message2)
      return;
    return global_default[ApolloErrorMessageHandler] && global_default[ApolloErrorMessageHandler](message2, messageArgs.map(stringify2));
  }
  function getFallbackErrorMsg(message2, messageArgs) {
    if (messageArgs === void 0) {
      messageArgs = [];
    }
    if (!message2)
      return;
    return "An error occurred! For more details, see the full error text at https://go.apollo.dev/c/err#".concat(encodeURIComponent(JSON.stringify({
      version,
      message: message2,
      args: messageArgs.map(stringify2)
    })));
  }

  // node_modules/@apollo/client/utilities/globals/index.js
  var DEV = globalThis.__DEV__ !== false;

  // node_modules/graphql/jsutils/devAssert.mjs
  function devAssert(condition, message2) {
    const booleanCondition = Boolean(condition);
    if (!booleanCondition) {
      throw new Error(message2);
    }
  }

  // node_modules/graphql/jsutils/isObjectLike.mjs
  function isObjectLike(value) {
    return typeof value == "object" && value !== null;
  }

  // node_modules/graphql/jsutils/invariant.mjs
  function invariant5(condition, message2) {
    const booleanCondition = Boolean(condition);
    if (!booleanCondition) {
      throw new Error(
        message2 != null ? message2 : "Unexpected invariant triggered."
      );
    }
  }

  // node_modules/graphql/language/location.mjs
  var LineRegExp = /\r\n|[\n\r]/g;
  function getLocation(source2, position2) {
    let lastLineStart = 0;
    let line2 = 1;
    for (const match3 of source2.body.matchAll(LineRegExp)) {
      typeof match3.index === "number" || invariant5(false);
      if (match3.index >= position2) {
        break;
      }
      lastLineStart = match3.index + match3[0].length;
      line2 += 1;
    }
    return {
      line: line2,
      column: position2 + 1 - lastLineStart
    };
  }

  // node_modules/graphql/language/printLocation.mjs
  function printLocation(location2) {
    return printSourceLocation(
      location2.source,
      getLocation(location2.source, location2.start)
    );
  }
  function printSourceLocation(source2, sourceLocation) {
    const firstLineColumnOffset = source2.locationOffset.column - 1;
    const body = "".padStart(firstLineColumnOffset) + source2.body;
    const lineIndex = sourceLocation.line - 1;
    const lineOffset = source2.locationOffset.line - 1;
    const lineNum = sourceLocation.line + lineOffset;
    const columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;
    const columnNum = sourceLocation.column + columnOffset;
    const locationStr = `${source2.name}:${lineNum}:${columnNum}
`;
    const lines = body.split(/\r\n|[\n\r]/g);
    const locationLine = lines[lineIndex];
    if (locationLine.length > 120) {
      const subLineIndex = Math.floor(columnNum / 80);
      const subLineColumnNum = columnNum % 80;
      const subLines = [];
      for (let i = 0; i < locationLine.length; i += 80) {
        subLines.push(locationLine.slice(i, i + 80));
      }
      return locationStr + printPrefixedLines([
        [`${lineNum} |`, subLines[0]],
        ...subLines.slice(1, subLineIndex + 1).map((subLine) => ["|", subLine]),
        ["|", "^".padStart(subLineColumnNum)],
        ["|", subLines[subLineIndex + 1]]
      ]);
    }
    return locationStr + printPrefixedLines([
      // Lines specified like this: ["prefix", "string"],
      [`${lineNum - 1} |`, lines[lineIndex - 1]],
      [`${lineNum} |`, locationLine],
      ["|", "^".padStart(columnNum)],
      [`${lineNum + 1} |`, lines[lineIndex + 1]]
    ]);
  }
  function printPrefixedLines(lines) {
    const existingLines = lines.filter(([_, line2]) => line2 !== void 0);
    const padLen = Math.max(...existingLines.map(([prefix3]) => prefix3.length));
    return existingLines.map(([prefix3, line2]) => prefix3.padStart(padLen) + (line2 ? " " + line2 : "")).join("\n");
  }

  // node_modules/graphql/error/GraphQLError.mjs
  function toNormalizedOptions(args) {
    const firstArg = args[0];
    if (firstArg == null || "kind" in firstArg || "length" in firstArg) {
      return {
        nodes: firstArg,
        source: args[1],
        positions: args[2],
        path: args[3],
        originalError: args[4],
        extensions: args[5]
      };
    }
    return firstArg;
  }
  var GraphQLError = class _GraphQLError extends Error {
    /**
     * An array of `{ line, column }` locations within the source GraphQL document
     * which correspond to this error.
     *
     * Errors during validation often contain multiple locations, for example to
     * point out two things with the same name. Errors during execution include a
     * single location, the field which produced the error.
     *
     * Enumerable, and appears in the result of JSON.stringify().
     */
    /**
     * An array describing the JSON-path into the execution response which
     * corresponds to this error. Only included for errors during execution.
     *
     * Enumerable, and appears in the result of JSON.stringify().
     */
    /**
     * An array of GraphQL AST Nodes corresponding to this error.
     */
    /**
     * The source GraphQL document for the first location of this error.
     *
     * Note that if this Error represents more than one node, the source may not
     * represent nodes after the first node.
     */
    /**
     * An array of character offsets within the source GraphQL document
     * which correspond to this error.
     */
    /**
     * The original error thrown from a field resolver during execution.
     */
    /**
     * Extension fields to add to the formatted error.
     */
    /**
     * @deprecated Please use the `GraphQLErrorOptions` constructor overload instead.
     */
    constructor(message2, ...rawArgs) {
      var _this$nodes, _nodeLocations$, _ref2;
      const { nodes, source: source2, positions, path, originalError, extensions } = toNormalizedOptions(rawArgs);
      super(message2);
      this.name = "GraphQLError";
      this.path = path !== null && path !== void 0 ? path : void 0;
      this.originalError = originalError !== null && originalError !== void 0 ? originalError : void 0;
      this.nodes = undefinedIfEmpty(
        Array.isArray(nodes) ? nodes : nodes ? [nodes] : void 0
      );
      const nodeLocations = undefinedIfEmpty(
        (_this$nodes = this.nodes) === null || _this$nodes === void 0 ? void 0 : _this$nodes.map((node2) => node2.loc).filter((loc) => loc != null)
      );
      this.source = source2 !== null && source2 !== void 0 ? source2 : nodeLocations === null || nodeLocations === void 0 ? void 0 : (_nodeLocations$ = nodeLocations[0]) === null || _nodeLocations$ === void 0 ? void 0 : _nodeLocations$.source;
      this.positions = positions !== null && positions !== void 0 ? positions : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => loc.start);
      this.locations = positions && source2 ? positions.map((pos) => getLocation(source2, pos)) : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => getLocation(loc.source, loc.start));
      const originalExtensions = isObjectLike(
        originalError === null || originalError === void 0 ? void 0 : originalError.extensions
      ) ? originalError === null || originalError === void 0 ? void 0 : originalError.extensions : void 0;
      this.extensions = (_ref2 = extensions !== null && extensions !== void 0 ? extensions : originalExtensions) !== null && _ref2 !== void 0 ? _ref2 : /* @__PURE__ */ Object.create(null);
      Object.defineProperties(this, {
        message: {
          writable: true,
          enumerable: true
        },
        name: {
          enumerable: false
        },
        nodes: {
          enumerable: false
        },
        source: {
          enumerable: false
        },
        positions: {
          enumerable: false
        },
        originalError: {
          enumerable: false
        }
      });
      if (originalError !== null && originalError !== void 0 && originalError.stack) {
        Object.defineProperty(this, "stack", {
          value: originalError.stack,
          writable: true,
          configurable: true
        });
      } else if (Error.captureStackTrace) {
        Error.captureStackTrace(this, _GraphQLError);
      } else {
        Object.defineProperty(this, "stack", {
          value: Error().stack,
          writable: true,
          configurable: true
        });
      }
    }
    get [Symbol.toStringTag]() {
      return "GraphQLError";
    }
    toString() {
      let output = this.message;
      if (this.nodes) {
        for (const node2 of this.nodes) {
          if (node2.loc) {
            output += "\n\n" + printLocation(node2.loc);
          }
        }
      } else if (this.source && this.locations) {
        for (const location2 of this.locations) {
          output += "\n\n" + printSourceLocation(this.source, location2);
        }
      }
      return output;
    }
    toJSON() {
      const formattedError = {
        message: this.message
      };
      if (this.locations != null) {
        formattedError.locations = this.locations;
      }
      if (this.path != null) {
        formattedError.path = this.path;
      }
      if (this.extensions != null && Object.keys(this.extensions).length > 0) {
        formattedError.extensions = this.extensions;
      }
      return formattedError;
    }
  };
  function undefinedIfEmpty(array) {
    return array === void 0 || array.length === 0 ? void 0 : array;
  }

  // node_modules/graphql/error/syntaxError.mjs
  function syntaxError(source2, position2, description) {
    return new GraphQLError(`Syntax Error: ${description}`, {
      source: source2,
      positions: [position2]
    });
  }

  // node_modules/graphql/language/ast.mjs
  var Location = class {
    /**
     * The character offset at which this Node begins.
     */
    /**
     * The character offset at which this Node ends.
     */
    /**
     * The Token at which this Node begins.
     */
    /**
     * The Token at which this Node ends.
     */
    /**
     * The Source document the AST represents.
     */
    constructor(startToken, endToken, source2) {
      this.start = startToken.start;
      this.end = endToken.end;
      this.startToken = startToken;
      this.endToken = endToken;
      this.source = source2;
    }
    get [Symbol.toStringTag]() {
      return "Location";
    }
    toJSON() {
      return {
        start: this.start,
        end: this.end
      };
    }
  };
  var Token = class {
    /**
     * The kind of Token.
     */
    /**
     * The character offset at which this Node begins.
     */
    /**
     * The character offset at which this Node ends.
     */
    /**
     * The 1-indexed line number on which this Token appears.
     */
    /**
     * The 1-indexed column number at which this Token begins.
     */
    /**
     * For non-punctuation tokens, represents the interpreted value of the token.
     *
     * Note: is undefined for punctuation tokens, but typed as string for
     * convenience in the parser.
     */
    /**
     * Tokens exist as nodes in a double-linked-list amongst all tokens
     * including ignored tokens. <SOF> is always the first node and <EOF>
     * the last.
     */
    constructor(kind, start3, end2, line2, column2, value) {
      this.kind = kind;
      this.start = start3;
      this.end = end2;
      this.line = line2;
      this.column = column2;
      this.value = value;
      this.prev = null;
      this.next = null;
    }
    get [Symbol.toStringTag]() {
      return "Token";
    }
    toJSON() {
      return {
        kind: this.kind,
        value: this.value,
        line: this.line,
        column: this.column
      };
    }
  };
  var QueryDocumentKeys = {
    Name: [],
    Document: ["definitions"],
    OperationDefinition: [
      "name",
      "variableDefinitions",
      "directives",
      "selectionSet"
    ],
    VariableDefinition: ["variable", "type", "defaultValue", "directives"],
    Variable: ["name"],
    SelectionSet: ["selections"],
    Field: ["alias", "name", "arguments", "directives", "selectionSet"],
    Argument: ["name", "value"],
    FragmentSpread: ["name", "directives"],
    InlineFragment: ["typeCondition", "directives", "selectionSet"],
    FragmentDefinition: [
      "name",
      // Note: fragment variable definitions are deprecated and will removed in v17.0.0
      "variableDefinitions",
      "typeCondition",
      "directives",
      "selectionSet"
    ],
    IntValue: [],
    FloatValue: [],
    StringValue: [],
    BooleanValue: [],
    NullValue: [],
    EnumValue: [],
    ListValue: ["values"],
    ObjectValue: ["fields"],
    ObjectField: ["name", "value"],
    Directive: ["name", "arguments"],
    NamedType: ["name"],
    ListType: ["type"],
    NonNullType: ["type"],
    SchemaDefinition: ["description", "directives", "operationTypes"],
    OperationTypeDefinition: ["type"],
    ScalarTypeDefinition: ["description", "name", "directives"],
    ObjectTypeDefinition: [
      "description",
      "name",
      "interfaces",
      "directives",
      "fields"
    ],
    FieldDefinition: ["description", "name", "arguments", "type", "directives"],
    InputValueDefinition: [
      "description",
      "name",
      "type",
      "defaultValue",
      "directives"
    ],
    InterfaceTypeDefinition: [
      "description",
      "name",
      "interfaces",
      "directives",
      "fields"
    ],
    UnionTypeDefinition: ["description", "name", "directives", "types"],
    EnumTypeDefinition: ["description", "name", "directives", "values"],
    EnumValueDefinition: ["description", "name", "directives"],
    InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
    DirectiveDefinition: ["description", "name", "arguments", "locations"],
    SchemaExtension: ["directives", "operationTypes"],
    ScalarTypeExtension: ["name", "directives"],
    ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
    InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
    UnionTypeExtension: ["name", "directives", "types"],
    EnumTypeExtension: ["name", "directives", "values"],
    InputObjectTypeExtension: ["name", "directives", "fields"]
  };
  var kindValues = new Set(Object.keys(QueryDocumentKeys));
  function isNode2(maybeNode) {
    const maybeKind = maybeNode === null || maybeNode === void 0 ? void 0 : maybeNode.kind;
    return typeof maybeKind === "string" && kindValues.has(maybeKind);
  }
  var OperationTypeNode;
  (function(OperationTypeNode2) {
    OperationTypeNode2["QUERY"] = "query";
    OperationTypeNode2["MUTATION"] = "mutation";
    OperationTypeNode2["SUBSCRIPTION"] = "subscription";
  })(OperationTypeNode || (OperationTypeNode = {}));

  // node_modules/graphql/language/directiveLocation.mjs
  var DirectiveLocation;
  (function(DirectiveLocation2) {
    DirectiveLocation2["QUERY"] = "QUERY";
    DirectiveLocation2["MUTATION"] = "MUTATION";
    DirectiveLocation2["SUBSCRIPTION"] = "SUBSCRIPTION";
    DirectiveLocation2["FIELD"] = "FIELD";
    DirectiveLocation2["FRAGMENT_DEFINITION"] = "FRAGMENT_DEFINITION";
    DirectiveLocation2["FRAGMENT_SPREAD"] = "FRAGMENT_SPREAD";
    DirectiveLocation2["INLINE_FRAGMENT"] = "INLINE_FRAGMENT";
    DirectiveLocation2["VARIABLE_DEFINITION"] = "VARIABLE_DEFINITION";
    DirectiveLocation2["SCHEMA"] = "SCHEMA";
    DirectiveLocation2["SCALAR"] = "SCALAR";
    DirectiveLocation2["OBJECT"] = "OBJECT";
    DirectiveLocation2["FIELD_DEFINITION"] = "FIELD_DEFINITION";
    DirectiveLocation2["ARGUMENT_DEFINITION"] = "ARGUMENT_DEFINITION";
    DirectiveLocation2["INTERFACE"] = "INTERFACE";
    DirectiveLocation2["UNION"] = "UNION";
    DirectiveLocation2["ENUM"] = "ENUM";
    DirectiveLocation2["ENUM_VALUE"] = "ENUM_VALUE";
    DirectiveLocation2["INPUT_OBJECT"] = "INPUT_OBJECT";
    DirectiveLocation2["INPUT_FIELD_DEFINITION"] = "INPUT_FIELD_DEFINITION";
  })(DirectiveLocation || (DirectiveLocation = {}));

  // node_modules/graphql/language/kinds.mjs
  var Kind;
  (function(Kind2) {
    Kind2["NAME"] = "Name";
    Kind2["DOCUMENT"] = "Document";
    Kind2["OPERATION_DEFINITION"] = "OperationDefinition";
    Kind2["VARIABLE_DEFINITION"] = "VariableDefinition";
    Kind2["SELECTION_SET"] = "SelectionSet";
    Kind2["FIELD"] = "Field";
    Kind2["ARGUMENT"] = "Argument";
    Kind2["FRAGMENT_SPREAD"] = "FragmentSpread";
    Kind2["INLINE_FRAGMENT"] = "InlineFragment";
    Kind2["FRAGMENT_DEFINITION"] = "FragmentDefinition";
    Kind2["VARIABLE"] = "Variable";
    Kind2["INT"] = "IntValue";
    Kind2["FLOAT"] = "FloatValue";
    Kind2["STRING"] = "StringValue";
    Kind2["BOOLEAN"] = "BooleanValue";
    Kind2["NULL"] = "NullValue";
    Kind2["ENUM"] = "EnumValue";
    Kind2["LIST"] = "ListValue";
    Kind2["OBJECT"] = "ObjectValue";
    Kind2["OBJECT_FIELD"] = "ObjectField";
    Kind2["DIRECTIVE"] = "Directive";
    Kind2["NAMED_TYPE"] = "NamedType";
    Kind2["LIST_TYPE"] = "ListType";
    Kind2["NON_NULL_TYPE"] = "NonNullType";
    Kind2["SCHEMA_DEFINITION"] = "SchemaDefinition";
    Kind2["OPERATION_TYPE_DEFINITION"] = "OperationTypeDefinition";
    Kind2["SCALAR_TYPE_DEFINITION"] = "ScalarTypeDefinition";
    Kind2["OBJECT_TYPE_DEFINITION"] = "ObjectTypeDefinition";
    Kind2["FIELD_DEFINITION"] = "FieldDefinition";
    Kind2["INPUT_VALUE_DEFINITION"] = "InputValueDefinition";
    Kind2["INTERFACE_TYPE_DEFINITION"] = "InterfaceTypeDefinition";
    Kind2["UNION_TYPE_DEFINITION"] = "UnionTypeDefinition";
    Kind2["ENUM_TYPE_DEFINITION"] = "EnumTypeDefinition";
    Kind2["ENUM_VALUE_DEFINITION"] = "EnumValueDefinition";
    Kind2["INPUT_OBJECT_TYPE_DEFINITION"] = "InputObjectTypeDefinition";
    Kind2["DIRECTIVE_DEFINITION"] = "DirectiveDefinition";
    Kind2["SCHEMA_EXTENSION"] = "SchemaExtension";
    Kind2["SCALAR_TYPE_EXTENSION"] = "ScalarTypeExtension";
    Kind2["OBJECT_TYPE_EXTENSION"] = "ObjectTypeExtension";
    Kind2["INTERFACE_TYPE_EXTENSION"] = "InterfaceTypeExtension";
    Kind2["UNION_TYPE_EXTENSION"] = "UnionTypeExtension";
    Kind2["ENUM_TYPE_EXTENSION"] = "EnumTypeExtension";
    Kind2["INPUT_OBJECT_TYPE_EXTENSION"] = "InputObjectTypeExtension";
  })(Kind || (Kind = {}));

  // node_modules/graphql/language/characterClasses.mjs
  function isWhiteSpace(code) {
    return code === 9 || code === 32;
  }
  function isDigit(code) {
    return code >= 48 && code <= 57;
  }
  function isLetter(code) {
    return code >= 97 && code <= 122 || // A-Z
    code >= 65 && code <= 90;
  }
  function isNameStart(code) {
    return isLetter(code) || code === 95;
  }
  function isNameContinue(code) {
    return isLetter(code) || isDigit(code) || code === 95;
  }

  // node_modules/graphql/language/blockString.mjs
  function dedentBlockStringLines(lines) {
    var _firstNonEmptyLine2;
    let commonIndent = Number.MAX_SAFE_INTEGER;
    let firstNonEmptyLine = null;
    let lastNonEmptyLine = -1;
    for (let i = 0; i < lines.length; ++i) {
      var _firstNonEmptyLine;
      const line2 = lines[i];
      const indent2 = leadingWhitespace(line2);
      if (indent2 === line2.length) {
        continue;
      }
      firstNonEmptyLine = (_firstNonEmptyLine = firstNonEmptyLine) !== null && _firstNonEmptyLine !== void 0 ? _firstNonEmptyLine : i;
      lastNonEmptyLine = i;
      if (i !== 0 && indent2 < commonIndent) {
        commonIndent = indent2;
      }
    }
    return lines.map((line2, i) => i === 0 ? line2 : line2.slice(commonIndent)).slice(
      (_firstNonEmptyLine2 = firstNonEmptyLine) !== null && _firstNonEmptyLine2 !== void 0 ? _firstNonEmptyLine2 : 0,
      lastNonEmptyLine + 1
    );
  }
  function leadingWhitespace(str) {
    let i = 0;
    while (i < str.length && isWhiteSpace(str.charCodeAt(i))) {
      ++i;
    }
    return i;
  }
  function printBlockString(value, options2) {
    const escapedValue = value.replace(/"""/g, '\\"""');
    const lines = escapedValue.split(/\r\n|[\n\r]/g);
    const isSingleLine = lines.length === 1;
    const forceLeadingNewLine = lines.length > 1 && lines.slice(1).every((line2) => line2.length === 0 || isWhiteSpace(line2.charCodeAt(0)));
    const hasTrailingTripleQuotes = escapedValue.endsWith('\\"""');
    const hasTrailingQuote = value.endsWith('"') && !hasTrailingTripleQuotes;
    const hasTrailingSlash = value.endsWith("\\");
    const forceTrailingNewline = hasTrailingQuote || hasTrailingSlash;
    const printAsMultipleLines = !(options2 !== null && options2 !== void 0 && options2.minimize) && // add leading and trailing new lines only if it improves readability
    (!isSingleLine || value.length > 70 || forceTrailingNewline || forceLeadingNewLine || hasTrailingTripleQuotes);
    let result2 = "";
    const skipLeadingNewLine = isSingleLine && isWhiteSpace(value.charCodeAt(0));
    if (printAsMultipleLines && !skipLeadingNewLine || forceLeadingNewLine) {
      result2 += "\n";
    }
    result2 += escapedValue;
    if (printAsMultipleLines || forceTrailingNewline) {
      result2 += "\n";
    }
    return '"""' + result2 + '"""';
  }

  // node_modules/graphql/language/tokenKind.mjs
  var TokenKind;
  (function(TokenKind2) {
    TokenKind2["SOF"] = "<SOF>";
    TokenKind2["EOF"] = "<EOF>";
    TokenKind2["BANG"] = "!";
    TokenKind2["DOLLAR"] = "$";
    TokenKind2["AMP"] = "&";
    TokenKind2["PAREN_L"] = "(";
    TokenKind2["PAREN_R"] = ")";
    TokenKind2["SPREAD"] = "...";
    TokenKind2["COLON"] = ":";
    TokenKind2["EQUALS"] = "=";
    TokenKind2["AT"] = "@";
    TokenKind2["BRACKET_L"] = "[";
    TokenKind2["BRACKET_R"] = "]";
    TokenKind2["BRACE_L"] = "{";
    TokenKind2["PIPE"] = "|";
    TokenKind2["BRACE_R"] = "}";
    TokenKind2["NAME"] = "Name";
    TokenKind2["INT"] = "Int";
    TokenKind2["FLOAT"] = "Float";
    TokenKind2["STRING"] = "String";
    TokenKind2["BLOCK_STRING"] = "BlockString";
    TokenKind2["COMMENT"] = "Comment";
  })(TokenKind || (TokenKind = {}));

  // node_modules/graphql/language/lexer.mjs
  var Lexer = class {
    /**
     * The previously focused non-ignored token.
     */
    /**
     * The currently focused non-ignored token.
     */
    /**
     * The (1-indexed) line containing the current token.
     */
    /**
     * The character offset at which the current line begins.
     */
    constructor(source2) {
      const startOfFileToken = new Token(TokenKind.SOF, 0, 0, 0, 0);
      this.source = source2;
      this.lastToken = startOfFileToken;
      this.token = startOfFileToken;
      this.line = 1;
      this.lineStart = 0;
    }
    get [Symbol.toStringTag]() {
      return "Lexer";
    }
    /**
     * Advances the token stream to the next non-ignored token.
     */
    advance() {
      this.lastToken = this.token;
      const token2 = this.token = this.lookahead();
      return token2;
    }
    /**
     * Looks ahead and returns the next non-ignored token, but does not change
     * the state of Lexer.
     */
    lookahead() {
      let token2 = this.token;
      if (token2.kind !== TokenKind.EOF) {
        do {
          if (token2.next) {
            token2 = token2.next;
          } else {
            const nextToken = readNextToken(this, token2.end);
            token2.next = nextToken;
            nextToken.prev = token2;
            token2 = nextToken;
          }
        } while (token2.kind === TokenKind.COMMENT);
      }
      return token2;
    }
  };
  function isPunctuatorTokenKind(kind) {
    return kind === TokenKind.BANG || kind === TokenKind.DOLLAR || kind === TokenKind.AMP || kind === TokenKind.PAREN_L || kind === TokenKind.PAREN_R || kind === TokenKind.SPREAD || kind === TokenKind.COLON || kind === TokenKind.EQUALS || kind === TokenKind.AT || kind === TokenKind.BRACKET_L || kind === TokenKind.BRACKET_R || kind === TokenKind.BRACE_L || kind === TokenKind.PIPE || kind === TokenKind.BRACE_R;
  }
  function isUnicodeScalarValue(code) {
    return code >= 0 && code <= 55295 || code >= 57344 && code <= 1114111;
  }
  function isSupplementaryCodePoint(body, location2) {
    return isLeadingSurrogate(body.charCodeAt(location2)) && isTrailingSurrogate(body.charCodeAt(location2 + 1));
  }
  function isLeadingSurrogate(code) {
    return code >= 55296 && code <= 56319;
  }
  function isTrailingSurrogate(code) {
    return code >= 56320 && code <= 57343;
  }
  function printCodePointAt(lexer, location2) {
    const code = lexer.source.body.codePointAt(location2);
    if (code === void 0) {
      return TokenKind.EOF;
    } else if (code >= 32 && code <= 126) {
      const char2 = String.fromCodePoint(code);
      return char2 === '"' ? `'"'` : `"${char2}"`;
    }
    return "U+" + code.toString(16).toUpperCase().padStart(4, "0");
  }
  function createToken(lexer, kind, start3, end2, value) {
    const line2 = lexer.line;
    const col = 1 + start3 - lexer.lineStart;
    return new Token(kind, start3, end2, line2, col, value);
  }
  function readNextToken(lexer, start3) {
    const body = lexer.source.body;
    const bodyLength = body.length;
    let position2 = start3;
    while (position2 < bodyLength) {
      const code = body.charCodeAt(position2);
      switch (code) {
        // Ignored ::
        //   - UnicodeBOM
        //   - WhiteSpace
        //   - LineTerminator
        //   - Comment
        //   - Comma
        //
        // UnicodeBOM :: "Byte Order Mark (U+FEFF)"
        //
        // WhiteSpace ::
        //   - "Horizontal Tab (U+0009)"
        //   - "Space (U+0020)"
        //
        // Comma :: ,
        case 65279:
        // <BOM>
        case 9:
        // \t
        case 32:
        // <space>
        case 44:
          ++position2;
          continue;
        // LineTerminator ::
        //   - "New Line (U+000A)"
        //   - "Carriage Return (U+000D)" [lookahead != "New Line (U+000A)"]
        //   - "Carriage Return (U+000D)" "New Line (U+000A)"
        case 10:
          ++position2;
          ++lexer.line;
          lexer.lineStart = position2;
          continue;
        case 13:
          if (body.charCodeAt(position2 + 1) === 10) {
            position2 += 2;
          } else {
            ++position2;
          }
          ++lexer.line;
          lexer.lineStart = position2;
          continue;
        // Comment
        case 35:
          return readComment(lexer, position2);
        // Token ::
        //   - Punctuator
        //   - Name
        //   - IntValue
        //   - FloatValue
        //   - StringValue
        //
        // Punctuator :: one of ! $ & ( ) ... : = @ [ ] { | }
        case 33:
          return createToken(lexer, TokenKind.BANG, position2, position2 + 1);
        case 36:
          return createToken(lexer, TokenKind.DOLLAR, position2, position2 + 1);
        case 38:
          return createToken(lexer, TokenKind.AMP, position2, position2 + 1);
        case 40:
          return createToken(lexer, TokenKind.PAREN_L, position2, position2 + 1);
        case 41:
          return createToken(lexer, TokenKind.PAREN_R, position2, position2 + 1);
        case 46:
          if (body.charCodeAt(position2 + 1) === 46 && body.charCodeAt(position2 + 2) === 46) {
            return createToken(lexer, TokenKind.SPREAD, position2, position2 + 3);
          }
          break;
        case 58:
          return createToken(lexer, TokenKind.COLON, position2, position2 + 1);
        case 61:
          return createToken(lexer, TokenKind.EQUALS, position2, position2 + 1);
        case 64:
          return createToken(lexer, TokenKind.AT, position2, position2 + 1);
        case 91:
          return createToken(lexer, TokenKind.BRACKET_L, position2, position2 + 1);
        case 93:
          return createToken(lexer, TokenKind.BRACKET_R, position2, position2 + 1);
        case 123:
          return createToken(lexer, TokenKind.BRACE_L, position2, position2 + 1);
        case 124:
          return createToken(lexer, TokenKind.PIPE, position2, position2 + 1);
        case 125:
          return createToken(lexer, TokenKind.BRACE_R, position2, position2 + 1);
        // StringValue
        case 34:
          if (body.charCodeAt(position2 + 1) === 34 && body.charCodeAt(position2 + 2) === 34) {
            return readBlockString(lexer, position2);
          }
          return readString(lexer, position2);
      }
      if (isDigit(code) || code === 45) {
        return readNumber(lexer, position2, code);
      }
      if (isNameStart(code)) {
        return readName(lexer, position2);
      }
      throw syntaxError(
        lexer.source,
        position2,
        code === 39 ? `Unexpected single quote character ('), did you mean to use a double quote (")?` : isUnicodeScalarValue(code) || isSupplementaryCodePoint(body, position2) ? `Unexpected character: ${printCodePointAt(lexer, position2)}.` : `Invalid character: ${printCodePointAt(lexer, position2)}.`
      );
    }
    return createToken(lexer, TokenKind.EOF, bodyLength, bodyLength);
  }
  function readComment(lexer, start3) {
    const body = lexer.source.body;
    const bodyLength = body.length;
    let position2 = start3 + 1;
    while (position2 < bodyLength) {
      const code = body.charCodeAt(position2);
      if (code === 10 || code === 13) {
        break;
      }
      if (isUnicodeScalarValue(code)) {
        ++position2;
      } else if (isSupplementaryCodePoint(body, position2)) {
        position2 += 2;
      } else {
        break;
      }
    }
    return createToken(
      lexer,
      TokenKind.COMMENT,
      start3,
      position2,
      body.slice(start3 + 1, position2)
    );
  }
  function readNumber(lexer, start3, firstCode) {
    const body = lexer.source.body;
    let position2 = start3;
    let code = firstCode;
    let isFloat = false;
    if (code === 45) {
      code = body.charCodeAt(++position2);
    }
    if (code === 48) {
      code = body.charCodeAt(++position2);
      if (isDigit(code)) {
        throw syntaxError(
          lexer.source,
          position2,
          `Invalid number, unexpected digit after 0: ${printCodePointAt(
            lexer,
            position2
          )}.`
        );
      }
    } else {
      position2 = readDigits(lexer, position2, code);
      code = body.charCodeAt(position2);
    }
    if (code === 46) {
      isFloat = true;
      code = body.charCodeAt(++position2);
      position2 = readDigits(lexer, position2, code);
      code = body.charCodeAt(position2);
    }
    if (code === 69 || code === 101) {
      isFloat = true;
      code = body.charCodeAt(++position2);
      if (code === 43 || code === 45) {
        code = body.charCodeAt(++position2);
      }
      position2 = readDigits(lexer, position2, code);
      code = body.charCodeAt(position2);
    }
    if (code === 46 || isNameStart(code)) {
      throw syntaxError(
        lexer.source,
        position2,
        `Invalid number, expected digit but got: ${printCodePointAt(
          lexer,
          position2
        )}.`
      );
    }
    return createToken(
      lexer,
      isFloat ? TokenKind.FLOAT : TokenKind.INT,
      start3,
      position2,
      body.slice(start3, position2)
    );
  }
  function readDigits(lexer, start3, firstCode) {
    if (!isDigit(firstCode)) {
      throw syntaxError(
        lexer.source,
        start3,
        `Invalid number, expected digit but got: ${printCodePointAt(
          lexer,
          start3
        )}.`
      );
    }
    const body = lexer.source.body;
    let position2 = start3 + 1;
    while (isDigit(body.charCodeAt(position2))) {
      ++position2;
    }
    return position2;
  }
  function readString(lexer, start3) {
    const body = lexer.source.body;
    const bodyLength = body.length;
    let position2 = start3 + 1;
    let chunkStart = position2;
    let value = "";
    while (position2 < bodyLength) {
      const code = body.charCodeAt(position2);
      if (code === 34) {
        value += body.slice(chunkStart, position2);
        return createToken(lexer, TokenKind.STRING, start3, position2 + 1, value);
      }
      if (code === 92) {
        value += body.slice(chunkStart, position2);
        const escape = body.charCodeAt(position2 + 1) === 117 ? body.charCodeAt(position2 + 2) === 123 ? readEscapedUnicodeVariableWidth(lexer, position2) : readEscapedUnicodeFixedWidth(lexer, position2) : readEscapedCharacter(lexer, position2);
        value += escape.value;
        position2 += escape.size;
        chunkStart = position2;
        continue;
      }
      if (code === 10 || code === 13) {
        break;
      }
      if (isUnicodeScalarValue(code)) {
        ++position2;
      } else if (isSupplementaryCodePoint(body, position2)) {
        position2 += 2;
      } else {
        throw syntaxError(
          lexer.source,
          position2,
          `Invalid character within String: ${printCodePointAt(
            lexer,
            position2
          )}.`
        );
      }
    }
    throw syntaxError(lexer.source, position2, "Unterminated string.");
  }
  function readEscapedUnicodeVariableWidth(lexer, position2) {
    const body = lexer.source.body;
    let point = 0;
    let size2 = 3;
    while (size2 < 12) {
      const code = body.charCodeAt(position2 + size2++);
      if (code === 125) {
        if (size2 < 5 || !isUnicodeScalarValue(point)) {
          break;
        }
        return {
          value: String.fromCodePoint(point),
          size: size2
        };
      }
      point = point << 4 | readHexDigit(code);
      if (point < 0) {
        break;
      }
    }
    throw syntaxError(
      lexer.source,
      position2,
      `Invalid Unicode escape sequence: "${body.slice(
        position2,
        position2 + size2
      )}".`
    );
  }
  function readEscapedUnicodeFixedWidth(lexer, position2) {
    const body = lexer.source.body;
    const code = read16BitHexCode(body, position2 + 2);
    if (isUnicodeScalarValue(code)) {
      return {
        value: String.fromCodePoint(code),
        size: 6
      };
    }
    if (isLeadingSurrogate(code)) {
      if (body.charCodeAt(position2 + 6) === 92 && body.charCodeAt(position2 + 7) === 117) {
        const trailingCode = read16BitHexCode(body, position2 + 8);
        if (isTrailingSurrogate(trailingCode)) {
          return {
            value: String.fromCodePoint(code, trailingCode),
            size: 12
          };
        }
      }
    }
    throw syntaxError(
      lexer.source,
      position2,
      `Invalid Unicode escape sequence: "${body.slice(position2, position2 + 6)}".`
    );
  }
  function read16BitHexCode(body, position2) {
    return readHexDigit(body.charCodeAt(position2)) << 12 | readHexDigit(body.charCodeAt(position2 + 1)) << 8 | readHexDigit(body.charCodeAt(position2 + 2)) << 4 | readHexDigit(body.charCodeAt(position2 + 3));
  }
  function readHexDigit(code) {
    return code >= 48 && code <= 57 ? code - 48 : code >= 65 && code <= 70 ? code - 55 : code >= 97 && code <= 102 ? code - 87 : -1;
  }
  function readEscapedCharacter(lexer, position2) {
    const body = lexer.source.body;
    const code = body.charCodeAt(position2 + 1);
    switch (code) {
      case 34:
        return {
          value: '"',
          size: 2
        };
      case 92:
        return {
          value: "\\",
          size: 2
        };
      case 47:
        return {
          value: "/",
          size: 2
        };
      case 98:
        return {
          value: "\b",
          size: 2
        };
      case 102:
        return {
          value: "\f",
          size: 2
        };
      case 110:
        return {
          value: "\n",
          size: 2
        };
      case 114:
        return {
          value: "\r",
          size: 2
        };
      case 116:
        return {
          value: "	",
          size: 2
        };
    }
    throw syntaxError(
      lexer.source,
      position2,
      `Invalid character escape sequence: "${body.slice(
        position2,
        position2 + 2
      )}".`
    );
  }
  function readBlockString(lexer, start3) {
    const body = lexer.source.body;
    const bodyLength = body.length;
    let lineStart = lexer.lineStart;
    let position2 = start3 + 3;
    let chunkStart = position2;
    let currentLine = "";
    const blockLines = [];
    while (position2 < bodyLength) {
      const code = body.charCodeAt(position2);
      if (code === 34 && body.charCodeAt(position2 + 1) === 34 && body.charCodeAt(position2 + 2) === 34) {
        currentLine += body.slice(chunkStart, position2);
        blockLines.push(currentLine);
        const token2 = createToken(
          lexer,
          TokenKind.BLOCK_STRING,
          start3,
          position2 + 3,
          // Return a string of the lines joined with U+000A.
          dedentBlockStringLines(blockLines).join("\n")
        );
        lexer.line += blockLines.length - 1;
        lexer.lineStart = lineStart;
        return token2;
      }
      if (code === 92 && body.charCodeAt(position2 + 1) === 34 && body.charCodeAt(position2 + 2) === 34 && body.charCodeAt(position2 + 3) === 34) {
        currentLine += body.slice(chunkStart, position2);
        chunkStart = position2 + 1;
        position2 += 4;
        continue;
      }
      if (code === 10 || code === 13) {
        currentLine += body.slice(chunkStart, position2);
        blockLines.push(currentLine);
        if (code === 13 && body.charCodeAt(position2 + 1) === 10) {
          position2 += 2;
        } else {
          ++position2;
        }
        currentLine = "";
        chunkStart = position2;
        lineStart = position2;
        continue;
      }
      if (isUnicodeScalarValue(code)) {
        ++position2;
      } else if (isSupplementaryCodePoint(body, position2)) {
        position2 += 2;
      } else {
        throw syntaxError(
          lexer.source,
          position2,
          `Invalid character within String: ${printCodePointAt(
            lexer,
            position2
          )}.`
        );
      }
    }
    throw syntaxError(lexer.source, position2, "Unterminated string.");
  }
  function readName(lexer, start3) {
    const body = lexer.source.body;
    const bodyLength = body.length;
    let position2 = start3 + 1;
    while (position2 < bodyLength) {
      const code = body.charCodeAt(position2);
      if (isNameContinue(code)) {
        ++position2;
      } else {
        break;
      }
    }
    return createToken(
      lexer,
      TokenKind.NAME,
      start3,
      position2,
      body.slice(start3, position2)
    );
  }

  // node_modules/graphql/jsutils/inspect.mjs
  var MAX_ARRAY_LENGTH = 10;
  var MAX_RECURSIVE_DEPTH = 2;
  function inspect(value) {
    return formatValue(value, []);
  }
  function formatValue(value, seenValues) {
    switch (typeof value) {
      case "string":
        return JSON.stringify(value);
      case "function":
        return value.name ? `[function ${value.name}]` : "[function]";
      case "object":
        return formatObjectValue(value, seenValues);
      default:
        return String(value);
    }
  }
  function formatObjectValue(value, previouslySeenValues) {
    if (value === null) {
      return "null";
    }
    if (previouslySeenValues.includes(value)) {
      return "[Circular]";
    }
    const seenValues = [...previouslySeenValues, value];
    if (isJSONable(value)) {
      const jsonValue = value.toJSON();
      if (jsonValue !== value) {
        return typeof jsonValue === "string" ? jsonValue : formatValue(jsonValue, seenValues);
      }
    } else if (Array.isArray(value)) {
      return formatArray(value, seenValues);
    }
    return formatObject(value, seenValues);
  }
  function isJSONable(value) {
    return typeof value.toJSON === "function";
  }
  function formatObject(object, seenValues) {
    const entries = Object.entries(object);
    if (entries.length === 0) {
      return "{}";
    }
    if (seenValues.length > MAX_RECURSIVE_DEPTH) {
      return "[" + getObjectTag(object) + "]";
    }
    const properties = entries.map(
      ([key, value]) => key + ": " + formatValue(value, seenValues)
    );
    return "{ " + properties.join(", ") + " }";
  }
  function formatArray(array, seenValues) {
    if (array.length === 0) {
      return "[]";
    }
    if (seenValues.length > MAX_RECURSIVE_DEPTH) {
      return "[Array]";
    }
    const len = Math.min(MAX_ARRAY_LENGTH, array.length);
    const remaining = array.length - len;
    const items = [];
    for (let i = 0; i < len; ++i) {
      items.push(formatValue(array[i], seenValues));
    }
    if (remaining === 1) {
      items.push("... 1 more item");
    } else if (remaining > 1) {
      items.push(`... ${remaining} more items`);
    }
    return "[" + items.join(", ") + "]";
  }
  function getObjectTag(object) {
    const tag = Object.prototype.toString.call(object).replace(/^\[object /, "").replace(/]$/, "");
    if (tag === "Object" && typeof object.constructor === "function") {
      const name = object.constructor.name;
      if (typeof name === "string" && name !== "") {
        return name;
      }
    }
    return tag;
  }

  // node_modules/graphql/jsutils/instanceOf.mjs
  var isProduction2 = globalThis.process && // eslint-disable-next-line no-undef
  true;
  var instanceOf = (
    /* c8 ignore next 6 */
    // FIXME: https://github.com/graphql/graphql-js/issues/2317
    isProduction2 ? function instanceOf2(value, constructor) {
      return value instanceof constructor;
    } : function instanceOf3(value, constructor) {
      if (value instanceof constructor) {
        return true;
      }
      if (typeof value === "object" && value !== null) {
        var _value$constructor;
        const className = constructor.prototype[Symbol.toStringTag];
        const valueClassName = (
          // We still need to support constructor's name to detect conflicts with older versions of this library.
          Symbol.toStringTag in value ? value[Symbol.toStringTag] : (_value$constructor = value.constructor) === null || _value$constructor === void 0 ? void 0 : _value$constructor.name
        );
        if (className === valueClassName) {
          const stringifiedValue = inspect(value);
          throw new Error(`Cannot use ${className} "${stringifiedValue}" from another module or realm.

Ensure that there is only one instance of "graphql" in the node_modules
directory. If different versions of "graphql" are the dependencies of other
relied on modules, use "resolutions" to ensure only one version is installed.

https://yarnpkg.com/en/docs/selective-version-resolutions

Duplicate "graphql" modules cannot be used at the same time since different
versions may have different capabilities and behavior. The data from one
version used in the function from another could produce confusing and
spurious results.`);
        }
      }
      return false;
    }
  );

  // node_modules/graphql/language/source.mjs
  var Source = class {
    constructor(body, name = "GraphQL request", locationOffset = {
      line: 1,
      column: 1
    }) {
      typeof body === "string" || devAssert(false, `Body must be a string. Received: ${inspect(body)}.`);
      this.body = body;
      this.name = name;
      this.locationOffset = locationOffset;
      this.locationOffset.line > 0 || devAssert(
        false,
        "line in locationOffset is 1-indexed and must be positive."
      );
      this.locationOffset.column > 0 || devAssert(
        false,
        "column in locationOffset is 1-indexed and must be positive."
      );
    }
    get [Symbol.toStringTag]() {
      return "Source";
    }
  };
  function isSource(source2) {
    return instanceOf(source2, Source);
  }

  // node_modules/graphql/language/parser.mjs
  function parse4(source2, options2) {
    const parser = new Parser(source2, options2);
    const document2 = parser.parseDocument();
    Object.defineProperty(document2, "tokenCount", {
      enumerable: false,
      value: parser.tokenCount
    });
    return document2;
  }
  var Parser = class {
    constructor(source2, options2 = {}) {
      const sourceObj = isSource(source2) ? source2 : new Source(source2);
      this._lexer = new Lexer(sourceObj);
      this._options = options2;
      this._tokenCounter = 0;
    }
    get tokenCount() {
      return this._tokenCounter;
    }
    /**
     * Converts a name lex token into a name parse node.
     */
    parseName() {
      const token2 = this.expectToken(TokenKind.NAME);
      return this.node(token2, {
        kind: Kind.NAME,
        value: token2.value
      });
    }
    // Implements the parsing rules in the Document section.
    /**
     * Document : Definition+
     */
    parseDocument() {
      return this.node(this._lexer.token, {
        kind: Kind.DOCUMENT,
        definitions: this.many(
          TokenKind.SOF,
          this.parseDefinition,
          TokenKind.EOF
        )
      });
    }
    /**
     * Definition :
     *   - ExecutableDefinition
     *   - TypeSystemDefinition
     *   - TypeSystemExtension
     *
     * ExecutableDefinition :
     *   - OperationDefinition
     *   - FragmentDefinition
     *
     * TypeSystemDefinition :
     *   - SchemaDefinition
     *   - TypeDefinition
     *   - DirectiveDefinition
     *
     * TypeDefinition :
     *   - ScalarTypeDefinition
     *   - ObjectTypeDefinition
     *   - InterfaceTypeDefinition
     *   - UnionTypeDefinition
     *   - EnumTypeDefinition
     *   - InputObjectTypeDefinition
     */
    parseDefinition() {
      if (this.peek(TokenKind.BRACE_L)) {
        return this.parseOperationDefinition();
      }
      const hasDescription = this.peekDescription();
      const keywordToken = hasDescription ? this._lexer.lookahead() : this._lexer.token;
      if (keywordToken.kind === TokenKind.NAME) {
        switch (keywordToken.value) {
          case "schema":
            return this.parseSchemaDefinition();
          case "scalar":
            return this.parseScalarTypeDefinition();
          case "type":
            return this.parseObjectTypeDefinition();
          case "interface":
            return this.parseInterfaceTypeDefinition();
          case "union":
            return this.parseUnionTypeDefinition();
          case "enum":
            return this.parseEnumTypeDefinition();
          case "input":
            return this.parseInputObjectTypeDefinition();
          case "directive":
            return this.parseDirectiveDefinition();
        }
        if (hasDescription) {
          throw syntaxError(
            this._lexer.source,
            this._lexer.token.start,
            "Unexpected description, descriptions are supported only on type definitions."
          );
        }
        switch (keywordToken.value) {
          case "query":
          case "mutation":
          case "subscription":
            return this.parseOperationDefinition();
          case "fragment":
            return this.parseFragmentDefinition();
          case "extend":
            return this.parseTypeSystemExtension();
        }
      }
      throw this.unexpected(keywordToken);
    }
    // Implements the parsing rules in the Operations section.
    /**
     * OperationDefinition :
     *  - SelectionSet
     *  - OperationType Name? VariableDefinitions? Directives? SelectionSet
     */
    parseOperationDefinition() {
      const start3 = this._lexer.token;
      if (this.peek(TokenKind.BRACE_L)) {
        return this.node(start3, {
          kind: Kind.OPERATION_DEFINITION,
          operation: OperationTypeNode.QUERY,
          name: void 0,
          variableDefinitions: [],
          directives: [],
          selectionSet: this.parseSelectionSet()
        });
      }
      const operation = this.parseOperationType();
      let name;
      if (this.peek(TokenKind.NAME)) {
        name = this.parseName();
      }
      return this.node(start3, {
        kind: Kind.OPERATION_DEFINITION,
        operation,
        name,
        variableDefinitions: this.parseVariableDefinitions(),
        directives: this.parseDirectives(false),
        selectionSet: this.parseSelectionSet()
      });
    }
    /**
     * OperationType : one of query mutation subscription
     */
    parseOperationType() {
      const operationToken = this.expectToken(TokenKind.NAME);
      switch (operationToken.value) {
        case "query":
          return OperationTypeNode.QUERY;
        case "mutation":
          return OperationTypeNode.MUTATION;
        case "subscription":
          return OperationTypeNode.SUBSCRIPTION;
      }
      throw this.unexpected(operationToken);
    }
    /**
     * VariableDefinitions : ( VariableDefinition+ )
     */
    parseVariableDefinitions() {
      return this.optionalMany(
        TokenKind.PAREN_L,
        this.parseVariableDefinition,
        TokenKind.PAREN_R
      );
    }
    /**
     * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?
     */
    parseVariableDefinition() {
      return this.node(this._lexer.token, {
        kind: Kind.VARIABLE_DEFINITION,
        variable: this.parseVariable(),
        type: (this.expectToken(TokenKind.COLON), this.parseTypeReference()),
        defaultValue: this.expectOptionalToken(TokenKind.EQUALS) ? this.parseConstValueLiteral() : void 0,
        directives: this.parseConstDirectives()
      });
    }
    /**
     * Variable : $ Name
     */
    parseVariable() {
      const start3 = this._lexer.token;
      this.expectToken(TokenKind.DOLLAR);
      return this.node(start3, {
        kind: Kind.VARIABLE,
        name: this.parseName()
      });
    }
    /**
     * ```
     * SelectionSet : { Selection+ }
     * ```
     */
    parseSelectionSet() {
      return this.node(this._lexer.token, {
        kind: Kind.SELECTION_SET,
        selections: this.many(
          TokenKind.BRACE_L,
          this.parseSelection,
          TokenKind.BRACE_R
        )
      });
    }
    /**
     * Selection :
     *   - Field
     *   - FragmentSpread
     *   - InlineFragment
     */
    parseSelection() {
      return this.peek(TokenKind.SPREAD) ? this.parseFragment() : this.parseField();
    }
    /**
     * Field : Alias? Name Arguments? Directives? SelectionSet?
     *
     * Alias : Name :
     */
    parseField() {
      const start3 = this._lexer.token;
      const nameOrAlias = this.parseName();
      let alias;
      let name;
      if (this.expectOptionalToken(TokenKind.COLON)) {
        alias = nameOrAlias;
        name = this.parseName();
      } else {
        name = nameOrAlias;
      }
      return this.node(start3, {
        kind: Kind.FIELD,
        alias,
        name,
        arguments: this.parseArguments(false),
        directives: this.parseDirectives(false),
        selectionSet: this.peek(TokenKind.BRACE_L) ? this.parseSelectionSet() : void 0
      });
    }
    /**
     * Arguments[Const] : ( Argument[?Const]+ )
     */
    parseArguments(isConst) {
      const item = isConst ? this.parseConstArgument : this.parseArgument;
      return this.optionalMany(TokenKind.PAREN_L, item, TokenKind.PAREN_R);
    }
    /**
     * Argument[Const] : Name : Value[?Const]
     */
    parseArgument(isConst = false) {
      const start3 = this._lexer.token;
      const name = this.parseName();
      this.expectToken(TokenKind.COLON);
      return this.node(start3, {
        kind: Kind.ARGUMENT,
        name,
        value: this.parseValueLiteral(isConst)
      });
    }
    parseConstArgument() {
      return this.parseArgument(true);
    }
    // Implements the parsing rules in the Fragments section.
    /**
     * Corresponds to both FragmentSpread and InlineFragment in the spec.
     *
     * FragmentSpread : ... FragmentName Directives?
     *
     * InlineFragment : ... TypeCondition? Directives? SelectionSet
     */
    parseFragment() {
      const start3 = this._lexer.token;
      this.expectToken(TokenKind.SPREAD);
      const hasTypeCondition = this.expectOptionalKeyword("on");
      if (!hasTypeCondition && this.peek(TokenKind.NAME)) {
        return this.node(start3, {
          kind: Kind.FRAGMENT_SPREAD,
          name: this.parseFragmentName(),
          directives: this.parseDirectives(false)
        });
      }
      return this.node(start3, {
        kind: Kind.INLINE_FRAGMENT,
        typeCondition: hasTypeCondition ? this.parseNamedType() : void 0,
        directives: this.parseDirectives(false),
        selectionSet: this.parseSelectionSet()
      });
    }
    /**
     * FragmentDefinition :
     *   - fragment FragmentName on TypeCondition Directives? SelectionSet
     *
     * TypeCondition : NamedType
     */
    parseFragmentDefinition() {
      const start3 = this._lexer.token;
      this.expectKeyword("fragment");
      if (this._options.allowLegacyFragmentVariables === true) {
        return this.node(start3, {
          kind: Kind.FRAGMENT_DEFINITION,
          name: this.parseFragmentName(),
          variableDefinitions: this.parseVariableDefinitions(),
          typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
          directives: this.parseDirectives(false),
          selectionSet: this.parseSelectionSet()
        });
      }
      return this.node(start3, {
        kind: Kind.FRAGMENT_DEFINITION,
        name: this.parseFragmentName(),
        typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
        directives: this.parseDirectives(false),
        selectionSet: this.parseSelectionSet()
      });
    }
    /**
     * FragmentName : Name but not `on`
     */
    parseFragmentName() {
      if (this._lexer.token.value === "on") {
        throw this.unexpected();
      }
      return this.parseName();
    }
    // Implements the parsing rules in the Values section.
    /**
     * Value[Const] :
     *   - [~Const] Variable
     *   - IntValue
     *   - FloatValue
     *   - StringValue
     *   - BooleanValue
     *   - NullValue
     *   - EnumValue
     *   - ListValue[?Const]
     *   - ObjectValue[?Const]
     *
     * BooleanValue : one of `true` `false`
     *
     * NullValue : `null`
     *
     * EnumValue : Name but not `true`, `false` or `null`
     */
    parseValueLiteral(isConst) {
      const token2 = this._lexer.token;
      switch (token2.kind) {
        case TokenKind.BRACKET_L:
          return this.parseList(isConst);
        case TokenKind.BRACE_L:
          return this.parseObject(isConst);
        case TokenKind.INT:
          this.advanceLexer();
          return this.node(token2, {
            kind: Kind.INT,
            value: token2.value
          });
        case TokenKind.FLOAT:
          this.advanceLexer();
          return this.node(token2, {
            kind: Kind.FLOAT,
            value: token2.value
          });
        case TokenKind.STRING:
        case TokenKind.BLOCK_STRING:
          return this.parseStringLiteral();
        case TokenKind.NAME:
          this.advanceLexer();
          switch (token2.value) {
            case "true":
              return this.node(token2, {
                kind: Kind.BOOLEAN,
                value: true
              });
            case "false":
              return this.node(token2, {
                kind: Kind.BOOLEAN,
                value: false
              });
            case "null":
              return this.node(token2, {
                kind: Kind.NULL
              });
            default:
              return this.node(token2, {
                kind: Kind.ENUM,
                value: token2.value
              });
          }
        case TokenKind.DOLLAR:
          if (isConst) {
            this.expectToken(TokenKind.DOLLAR);
            if (this._lexer.token.kind === TokenKind.NAME) {
              const varName = this._lexer.token.value;
              throw syntaxError(
                this._lexer.source,
                token2.start,
                `Unexpected variable "$${varName}" in constant value.`
              );
            } else {
              throw this.unexpected(token2);
            }
          }
          return this.parseVariable();
        default:
          throw this.unexpected();
      }
    }
    parseConstValueLiteral() {
      return this.parseValueLiteral(true);
    }
    parseStringLiteral() {
      const token2 = this._lexer.token;
      this.advanceLexer();
      return this.node(token2, {
        kind: Kind.STRING,
        value: token2.value,
        block: token2.kind === TokenKind.BLOCK_STRING
      });
    }
    /**
     * ListValue[Const] :
     *   - [ ]
     *   - [ Value[?Const]+ ]
     */
    parseList(isConst) {
      const item = () => this.parseValueLiteral(isConst);
      return this.node(this._lexer.token, {
        kind: Kind.LIST,
        values: this.any(TokenKind.BRACKET_L, item, TokenKind.BRACKET_R)
      });
    }
    /**
     * ```
     * ObjectValue[Const] :
     *   - { }
     *   - { ObjectField[?Const]+ }
     * ```
     */
    parseObject(isConst) {
      const item = () => this.parseObjectField(isConst);
      return this.node(this._lexer.token, {
        kind: Kind.OBJECT,
        fields: this.any(TokenKind.BRACE_L, item, TokenKind.BRACE_R)
      });
    }
    /**
     * ObjectField[Const] : Name : Value[?Const]
     */
    parseObjectField(isConst) {
      const start3 = this._lexer.token;
      const name = this.parseName();
      this.expectToken(TokenKind.COLON);
      return this.node(start3, {
        kind: Kind.OBJECT_FIELD,
        name,
        value: this.parseValueLiteral(isConst)
      });
    }
    // Implements the parsing rules in the Directives section.
    /**
     * Directives[Const] : Directive[?Const]+
     */
    parseDirectives(isConst) {
      const directives = [];
      while (this.peek(TokenKind.AT)) {
        directives.push(this.parseDirective(isConst));
      }
      return directives;
    }
    parseConstDirectives() {
      return this.parseDirectives(true);
    }
    /**
     * ```
     * Directive[Const] : @ Name Arguments[?Const]?
     * ```
     */
    parseDirective(isConst) {
      const start3 = this._lexer.token;
      this.expectToken(TokenKind.AT);
      return this.node(start3, {
        kind: Kind.DIRECTIVE,
        name: this.parseName(),
        arguments: this.parseArguments(isConst)
      });
    }
    // Implements the parsing rules in the Types section.
    /**
     * Type :
     *   - NamedType
     *   - ListType
     *   - NonNullType
     */
    parseTypeReference() {
      const start3 = this._lexer.token;
      let type;
      if (this.expectOptionalToken(TokenKind.BRACKET_L)) {
        const innerType = this.parseTypeReference();
        this.expectToken(TokenKind.BRACKET_R);
        type = this.node(start3, {
          kind: Kind.LIST_TYPE,
          type: innerType
        });
      } else {
        type = this.parseNamedType();
      }
      if (this.expectOptionalToken(TokenKind.BANG)) {
        return this.node(start3, {
          kind: Kind.NON_NULL_TYPE,
          type
        });
      }
      return type;
    }
    /**
     * NamedType : Name
     */
    parseNamedType() {
      return this.node(this._lexer.token, {
        kind: Kind.NAMED_TYPE,
        name: this.parseName()
      });
    }
    // Implements the parsing rules in the Type Definition section.
    peekDescription() {
      return this.peek(TokenKind.STRING) || this.peek(TokenKind.BLOCK_STRING);
    }
    /**
     * Description : StringValue
     */
    parseDescription() {
      if (this.peekDescription()) {
        return this.parseStringLiteral();
      }
    }
    /**
     * ```
     * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }
     * ```
     */
    parseSchemaDefinition() {
      const start3 = this._lexer.token;
      const description = this.parseDescription();
      this.expectKeyword("schema");
      const directives = this.parseConstDirectives();
      const operationTypes = this.many(
        TokenKind.BRACE_L,
        this.parseOperationTypeDefinition,
        TokenKind.BRACE_R
      );
      return this.node(start3, {
        kind: Kind.SCHEMA_DEFINITION,
        description,
        directives,
        operationTypes
      });
    }
    /**
     * OperationTypeDefinition : OperationType : NamedType
     */
    parseOperationTypeDefinition() {
      const start3 = this._lexer.token;
      const operation = this.parseOperationType();
      this.expectToken(TokenKind.COLON);
      const type = this.parseNamedType();
      return this.node(start3, {
        kind: Kind.OPERATION_TYPE_DEFINITION,
        operation,
        type
      });
    }
    /**
     * ScalarTypeDefinition : Description? scalar Name Directives[Const]?
     */
    parseScalarTypeDefinition() {
      const start3 = this._lexer.token;
      const description = this.parseDescription();
      this.expectKeyword("scalar");
      const name = this.parseName();
      const directives = this.parseConstDirectives();
      return this.node(start3, {
        kind: Kind.SCALAR_TYPE_DEFINITION,
        description,
        name,
        directives
      });
    }
    /**
     * ObjectTypeDefinition :
     *   Description?
     *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?
     */
    parseObjectTypeDefinition() {
      const start3 = this._lexer.token;
      const description = this.parseDescription();
      this.expectKeyword("type");
      const name = this.parseName();
      const interfaces = this.parseImplementsInterfaces();
      const directives = this.parseConstDirectives();
      const fields = this.parseFieldsDefinition();
      return this.node(start3, {
        kind: Kind.OBJECT_TYPE_DEFINITION,
        description,
        name,
        interfaces,
        directives,
        fields
      });
    }
    /**
     * ImplementsInterfaces :
     *   - implements `&`? NamedType
     *   - ImplementsInterfaces & NamedType
     */
    parseImplementsInterfaces() {
      return this.expectOptionalKeyword("implements") ? this.delimitedMany(TokenKind.AMP, this.parseNamedType) : [];
    }
    /**
     * ```
     * FieldsDefinition : { FieldDefinition+ }
     * ```
     */
    parseFieldsDefinition() {
      return this.optionalMany(
        TokenKind.BRACE_L,
        this.parseFieldDefinition,
        TokenKind.BRACE_R
      );
    }
    /**
     * FieldDefinition :
     *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?
     */
    parseFieldDefinition() {
      const start3 = this._lexer.token;
      const description = this.parseDescription();
      const name = this.parseName();
      const args = this.parseArgumentDefs();
      this.expectToken(TokenKind.COLON);
      const type = this.parseTypeReference();
      const directives = this.parseConstDirectives();
      return this.node(start3, {
        kind: Kind.FIELD_DEFINITION,
        description,
        name,
        arguments: args,
        type,
        directives
      });
    }
    /**
     * ArgumentsDefinition : ( InputValueDefinition+ )
     */
    parseArgumentDefs() {
      return this.optionalMany(
        TokenKind.PAREN_L,
        this.parseInputValueDef,
        TokenKind.PAREN_R
      );
    }
    /**
     * InputValueDefinition :
     *   - Description? Name : Type DefaultValue? Directives[Const]?
     */
    parseInputValueDef() {
      const start3 = this._lexer.token;
      const description = this.parseDescription();
      const name = this.parseName();
      this.expectToken(TokenKind.COLON);
      const type = this.parseTypeReference();
      let defaultValue;
      if (this.expectOptionalToken(TokenKind.EQUALS)) {
        defaultValue = this.parseConstValueLiteral();
      }
      const directives = this.parseConstDirectives();
      return this.node(start3, {
        kind: Kind.INPUT_VALUE_DEFINITION,
        description,
        name,
        type,
        defaultValue,
        directives
      });
    }
    /**
     * InterfaceTypeDefinition :
     *   - Description? interface Name Directives[Const]? FieldsDefinition?
     */
    parseInterfaceTypeDefinition() {
      const start3 = this._lexer.token;
      const description = this.parseDescription();
      this.expectKeyword("interface");
      const name = this.parseName();
      const interfaces = this.parseImplementsInterfaces();
      const directives = this.parseConstDirectives();
      const fields = this.parseFieldsDefinition();
      return this.node(start3, {
        kind: Kind.INTERFACE_TYPE_DEFINITION,
        description,
        name,
        interfaces,
        directives,
        fields
      });
    }
    /**
     * UnionTypeDefinition :
     *   - Description? union Name Directives[Const]? UnionMemberTypes?
     */
    parseUnionTypeDefinition() {
      const start3 = this._lexer.token;
      const description = this.parseDescription();
      this.expectKeyword("union");
      const name = this.parseName();
      const directives = this.parseConstDirectives();
      const types = this.parseUnionMemberTypes();
      return this.node(start3, {
        kind: Kind.UNION_TYPE_DEFINITION,
        description,
        name,
        directives,
        types
      });
    }
    /**
     * UnionMemberTypes :
     *   - = `|`? NamedType
     *   - UnionMemberTypes | NamedType
     */
    parseUnionMemberTypes() {
      return this.expectOptionalToken(TokenKind.EQUALS) ? this.delimitedMany(TokenKind.PIPE, this.parseNamedType) : [];
    }
    /**
     * EnumTypeDefinition :
     *   - Description? enum Name Directives[Const]? EnumValuesDefinition?
     */
    parseEnumTypeDefinition() {
      const start3 = this._lexer.token;
      const description = this.parseDescription();
      this.expectKeyword("enum");
      const name = this.parseName();
      const directives = this.parseConstDirectives();
      const values = this.parseEnumValuesDefinition();
      return this.node(start3, {
        kind: Kind.ENUM_TYPE_DEFINITION,
        description,
        name,
        directives,
        values
      });
    }
    /**
     * ```
     * EnumValuesDefinition : { EnumValueDefinition+ }
     * ```
     */
    parseEnumValuesDefinition() {
      return this.optionalMany(
        TokenKind.BRACE_L,
        this.parseEnumValueDefinition,
        TokenKind.BRACE_R
      );
    }
    /**
     * EnumValueDefinition : Description? EnumValue Directives[Const]?
     */
    parseEnumValueDefinition() {
      const start3 = this._lexer.token;
      const description = this.parseDescription();
      const name = this.parseEnumValueName();
      const directives = this.parseConstDirectives();
      return this.node(start3, {
        kind: Kind.ENUM_VALUE_DEFINITION,
        description,
        name,
        directives
      });
    }
    /**
     * EnumValue : Name but not `true`, `false` or `null`
     */
    parseEnumValueName() {
      if (this._lexer.token.value === "true" || this._lexer.token.value === "false" || this._lexer.token.value === "null") {
        throw syntaxError(
          this._lexer.source,
          this._lexer.token.start,
          `${getTokenDesc(
            this._lexer.token
          )} is reserved and cannot be used for an enum value.`
        );
      }
      return this.parseName();
    }
    /**
     * InputObjectTypeDefinition :
     *   - Description? input Name Directives[Const]? InputFieldsDefinition?
     */
    parseInputObjectTypeDefinition() {
      const start3 = this._lexer.token;
      const description = this.parseDescription();
      this.expectKeyword("input");
      const name = this.parseName();
      const directives = this.parseConstDirectives();
      const fields = this.parseInputFieldsDefinition();
      return this.node(start3, {
        kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,
        description,
        name,
        directives,
        fields
      });
    }
    /**
     * ```
     * InputFieldsDefinition : { InputValueDefinition+ }
     * ```
     */
    parseInputFieldsDefinition() {
      return this.optionalMany(
        TokenKind.BRACE_L,
        this.parseInputValueDef,
        TokenKind.BRACE_R
      );
    }
    /**
     * TypeSystemExtension :
     *   - SchemaExtension
     *   - TypeExtension
     *
     * TypeExtension :
     *   - ScalarTypeExtension
     *   - ObjectTypeExtension
     *   - InterfaceTypeExtension
     *   - UnionTypeExtension
     *   - EnumTypeExtension
     *   - InputObjectTypeDefinition
     */
    parseTypeSystemExtension() {
      const keywordToken = this._lexer.lookahead();
      if (keywordToken.kind === TokenKind.NAME) {
        switch (keywordToken.value) {
          case "schema":
            return this.parseSchemaExtension();
          case "scalar":
            return this.parseScalarTypeExtension();
          case "type":
            return this.parseObjectTypeExtension();
          case "interface":
            return this.parseInterfaceTypeExtension();
          case "union":
            return this.parseUnionTypeExtension();
          case "enum":
            return this.parseEnumTypeExtension();
          case "input":
            return this.parseInputObjectTypeExtension();
        }
      }
      throw this.unexpected(keywordToken);
    }
    /**
     * ```
     * SchemaExtension :
     *  - extend schema Directives[Const]? { OperationTypeDefinition+ }
     *  - extend schema Directives[Const]
     * ```
     */
    parseSchemaExtension() {
      const start3 = this._lexer.token;
      this.expectKeyword("extend");
      this.expectKeyword("schema");
      const directives = this.parseConstDirectives();
      const operationTypes = this.optionalMany(
        TokenKind.BRACE_L,
        this.parseOperationTypeDefinition,
        TokenKind.BRACE_R
      );
      if (directives.length === 0 && operationTypes.length === 0) {
        throw this.unexpected();
      }
      return this.node(start3, {
        kind: Kind.SCHEMA_EXTENSION,
        directives,
        operationTypes
      });
    }
    /**
     * ScalarTypeExtension :
     *   - extend scalar Name Directives[Const]
     */
    parseScalarTypeExtension() {
      const start3 = this._lexer.token;
      this.expectKeyword("extend");
      this.expectKeyword("scalar");
      const name = this.parseName();
      const directives = this.parseConstDirectives();
      if (directives.length === 0) {
        throw this.unexpected();
      }
      return this.node(start3, {
        kind: Kind.SCALAR_TYPE_EXTENSION,
        name,
        directives
      });
    }
    /**
     * ObjectTypeExtension :
     *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
     *  - extend type Name ImplementsInterfaces? Directives[Const]
     *  - extend type Name ImplementsInterfaces
     */
    parseObjectTypeExtension() {
      const start3 = this._lexer.token;
      this.expectKeyword("extend");
      this.expectKeyword("type");
      const name = this.parseName();
      const interfaces = this.parseImplementsInterfaces();
      const directives = this.parseConstDirectives();
      const fields = this.parseFieldsDefinition();
      if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
        throw this.unexpected();
      }
      return this.node(start3, {
        kind: Kind.OBJECT_TYPE_EXTENSION,
        name,
        interfaces,
        directives,
        fields
      });
    }
    /**
     * InterfaceTypeExtension :
     *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
     *  - extend interface Name ImplementsInterfaces? Directives[Const]
     *  - extend interface Name ImplementsInterfaces
     */
    parseInterfaceTypeExtension() {
      const start3 = this._lexer.token;
      this.expectKeyword("extend");
      this.expectKeyword("interface");
      const name = this.parseName();
      const interfaces = this.parseImplementsInterfaces();
      const directives = this.parseConstDirectives();
      const fields = this.parseFieldsDefinition();
      if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
        throw this.unexpected();
      }
      return this.node(start3, {
        kind: Kind.INTERFACE_TYPE_EXTENSION,
        name,
        interfaces,
        directives,
        fields
      });
    }
    /**
     * UnionTypeExtension :
     *   - extend union Name Directives[Const]? UnionMemberTypes
     *   - extend union Name Directives[Const]
     */
    parseUnionTypeExtension() {
      const start3 = this._lexer.token;
      this.expectKeyword("extend");
      this.expectKeyword("union");
      const name = this.parseName();
      const directives = this.parseConstDirectives();
      const types = this.parseUnionMemberTypes();
      if (directives.length === 0 && types.length === 0) {
        throw this.unexpected();
      }
      return this.node(start3, {
        kind: Kind.UNION_TYPE_EXTENSION,
        name,
        directives,
        types
      });
    }
    /**
     * EnumTypeExtension :
     *   - extend enum Name Directives[Const]? EnumValuesDefinition
     *   - extend enum Name Directives[Const]
     */
    parseEnumTypeExtension() {
      const start3 = this._lexer.token;
      this.expectKeyword("extend");
      this.expectKeyword("enum");
      const name = this.parseName();
      const directives = this.parseConstDirectives();
      const values = this.parseEnumValuesDefinition();
      if (directives.length === 0 && values.length === 0) {
        throw this.unexpected();
      }
      return this.node(start3, {
        kind: Kind.ENUM_TYPE_EXTENSION,
        name,
        directives,
        values
      });
    }
    /**
     * InputObjectTypeExtension :
     *   - extend input Name Directives[Const]? InputFieldsDefinition
     *   - extend input Name Directives[Const]
     */
    parseInputObjectTypeExtension() {
      const start3 = this._lexer.token;
      this.expectKeyword("extend");
      this.expectKeyword("input");
      const name = this.parseName();
      const directives = this.parseConstDirectives();
      const fields = this.parseInputFieldsDefinition();
      if (directives.length === 0 && fields.length === 0) {
        throw this.unexpected();
      }
      return this.node(start3, {
        kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,
        name,
        directives,
        fields
      });
    }
    /**
     * ```
     * DirectiveDefinition :
     *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations
     * ```
     */
    parseDirectiveDefinition() {
      const start3 = this._lexer.token;
      const description = this.parseDescription();
      this.expectKeyword("directive");
      this.expectToken(TokenKind.AT);
      const name = this.parseName();
      const args = this.parseArgumentDefs();
      const repeatable = this.expectOptionalKeyword("repeatable");
      this.expectKeyword("on");
      const locations = this.parseDirectiveLocations();
      return this.node(start3, {
        kind: Kind.DIRECTIVE_DEFINITION,
        description,
        name,
        arguments: args,
        repeatable,
        locations
      });
    }
    /**
     * DirectiveLocations :
     *   - `|`? DirectiveLocation
     *   - DirectiveLocations | DirectiveLocation
     */
    parseDirectiveLocations() {
      return this.delimitedMany(TokenKind.PIPE, this.parseDirectiveLocation);
    }
    /*
     * DirectiveLocation :
     *   - ExecutableDirectiveLocation
     *   - TypeSystemDirectiveLocation
     *
     * ExecutableDirectiveLocation : one of
     *   `QUERY`
     *   `MUTATION`
     *   `SUBSCRIPTION`
     *   `FIELD`
     *   `FRAGMENT_DEFINITION`
     *   `FRAGMENT_SPREAD`
     *   `INLINE_FRAGMENT`
     *
     * TypeSystemDirectiveLocation : one of
     *   `SCHEMA`
     *   `SCALAR`
     *   `OBJECT`
     *   `FIELD_DEFINITION`
     *   `ARGUMENT_DEFINITION`
     *   `INTERFACE`
     *   `UNION`
     *   `ENUM`
     *   `ENUM_VALUE`
     *   `INPUT_OBJECT`
     *   `INPUT_FIELD_DEFINITION`
     */
    parseDirectiveLocation() {
      const start3 = this._lexer.token;
      const name = this.parseName();
      if (Object.prototype.hasOwnProperty.call(DirectiveLocation, name.value)) {
        return name;
      }
      throw this.unexpected(start3);
    }
    // Core parsing utility functions
    /**
     * Returns a node that, if configured to do so, sets a "loc" field as a
     * location object, used to identify the place in the source that created a
     * given parsed object.
     */
    node(startToken, node2) {
      if (this._options.noLocation !== true) {
        node2.loc = new Location(
          startToken,
          this._lexer.lastToken,
          this._lexer.source
        );
      }
      return node2;
    }
    /**
     * Determines if the next token is of a given kind
     */
    peek(kind) {
      return this._lexer.token.kind === kind;
    }
    /**
     * If the next token is of the given kind, return that token after advancing the lexer.
     * Otherwise, do not change the parser state and throw an error.
     */
    expectToken(kind) {
      const token2 = this._lexer.token;
      if (token2.kind === kind) {
        this.advanceLexer();
        return token2;
      }
      throw syntaxError(
        this._lexer.source,
        token2.start,
        `Expected ${getTokenKindDesc(kind)}, found ${getTokenDesc(token2)}.`
      );
    }
    /**
     * If the next token is of the given kind, return "true" after advancing the lexer.
     * Otherwise, do not change the parser state and return "false".
     */
    expectOptionalToken(kind) {
      const token2 = this._lexer.token;
      if (token2.kind === kind) {
        this.advanceLexer();
        return true;
      }
      return false;
    }
    /**
     * If the next token is a given keyword, advance the lexer.
     * Otherwise, do not change the parser state and throw an error.
     */
    expectKeyword(value) {
      const token2 = this._lexer.token;
      if (token2.kind === TokenKind.NAME && token2.value === value) {
        this.advanceLexer();
      } else {
        throw syntaxError(
          this._lexer.source,
          token2.start,
          `Expected "${value}", found ${getTokenDesc(token2)}.`
        );
      }
    }
    /**
     * If the next token is a given keyword, return "true" after advancing the lexer.
     * Otherwise, do not change the parser state and return "false".
     */
    expectOptionalKeyword(value) {
      const token2 = this._lexer.token;
      if (token2.kind === TokenKind.NAME && token2.value === value) {
        this.advanceLexer();
        return true;
      }
      return false;
    }
    /**
     * Helper function for creating an error when an unexpected lexed token is encountered.
     */
    unexpected(atToken) {
      const token2 = atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;
      return syntaxError(
        this._lexer.source,
        token2.start,
        `Unexpected ${getTokenDesc(token2)}.`
      );
    }
    /**
     * Returns a possibly empty list of parse nodes, determined by the parseFn.
     * This list begins with a lex token of openKind and ends with a lex token of closeKind.
     * Advances the parser to the next lex token after the closing token.
     */
    any(openKind, parseFn, closeKind) {
      this.expectToken(openKind);
      const nodes = [];
      while (!this.expectOptionalToken(closeKind)) {
        nodes.push(parseFn.call(this));
      }
      return nodes;
    }
    /**
     * Returns a list of parse nodes, determined by the parseFn.
     * It can be empty only if open token is missing otherwise it will always return non-empty list
     * that begins with a lex token of openKind and ends with a lex token of closeKind.
     * Advances the parser to the next lex token after the closing token.
     */
    optionalMany(openKind, parseFn, closeKind) {
      if (this.expectOptionalToken(openKind)) {
        const nodes = [];
        do {
          nodes.push(parseFn.call(this));
        } while (!this.expectOptionalToken(closeKind));
        return nodes;
      }
      return [];
    }
    /**
     * Returns a non-empty list of parse nodes, determined by the parseFn.
     * This list begins with a lex token of openKind and ends with a lex token of closeKind.
     * Advances the parser to the next lex token after the closing token.
     */
    many(openKind, parseFn, closeKind) {
      this.expectToken(openKind);
      const nodes = [];
      do {
        nodes.push(parseFn.call(this));
      } while (!this.expectOptionalToken(closeKind));
      return nodes;
    }
    /**
     * Returns a non-empty list of parse nodes, determined by the parseFn.
     * This list may begin with a lex token of delimiterKind followed by items separated by lex tokens of tokenKind.
     * Advances the parser to the next lex token after last item in the list.
     */
    delimitedMany(delimiterKind, parseFn) {
      this.expectOptionalToken(delimiterKind);
      const nodes = [];
      do {
        nodes.push(parseFn.call(this));
      } while (this.expectOptionalToken(delimiterKind));
      return nodes;
    }
    advanceLexer() {
      const { maxTokens } = this._options;
      const token2 = this._lexer.advance();
      if (token2.kind !== TokenKind.EOF) {
        ++this._tokenCounter;
        if (maxTokens !== void 0 && this._tokenCounter > maxTokens) {
          throw syntaxError(
            this._lexer.source,
            token2.start,
            `Document contains more that ${maxTokens} tokens. Parsing aborted.`
          );
        }
      }
    }
  };
  function getTokenDesc(token2) {
    const value = token2.value;
    return getTokenKindDesc(token2.kind) + (value != null ? ` "${value}"` : "");
  }
  function getTokenKindDesc(kind) {
    return isPunctuatorTokenKind(kind) ? `"${kind}"` : kind;
  }

  // node_modules/graphql/language/printString.mjs
  function printString(str) {
    return `"${str.replace(escapedRegExp, escapedReplacer)}"`;
  }
  var escapedRegExp = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
  function escapedReplacer(str) {
    return escapeSequences[str.charCodeAt(0)];
  }
  var escapeSequences = [
    "\\u0000",
    "\\u0001",
    "\\u0002",
    "\\u0003",
    "\\u0004",
    "\\u0005",
    "\\u0006",
    "\\u0007",
    "\\b",
    "\\t",
    "\\n",
    "\\u000B",
    "\\f",
    "\\r",
    "\\u000E",
    "\\u000F",
    "\\u0010",
    "\\u0011",
    "\\u0012",
    "\\u0013",
    "\\u0014",
    "\\u0015",
    "\\u0016",
    "\\u0017",
    "\\u0018",
    "\\u0019",
    "\\u001A",
    "\\u001B",
    "\\u001C",
    "\\u001D",
    "\\u001E",
    "\\u001F",
    "",
    "",
    '\\"',
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    // 2F
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    // 3F
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    // 4F
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "\\\\",
    "",
    "",
    "",
    // 5F
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    // 6F
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "\\u007F",
    "\\u0080",
    "\\u0081",
    "\\u0082",
    "\\u0083",
    "\\u0084",
    "\\u0085",
    "\\u0086",
    "\\u0087",
    "\\u0088",
    "\\u0089",
    "\\u008A",
    "\\u008B",
    "\\u008C",
    "\\u008D",
    "\\u008E",
    "\\u008F",
    "\\u0090",
    "\\u0091",
    "\\u0092",
    "\\u0093",
    "\\u0094",
    "\\u0095",
    "\\u0096",
    "\\u0097",
    "\\u0098",
    "\\u0099",
    "\\u009A",
    "\\u009B",
    "\\u009C",
    "\\u009D",
    "\\u009E",
    "\\u009F"
  ];

  // node_modules/graphql/language/visitor.mjs
  var BREAK = Object.freeze({});
  function visit(root2, visitor, visitorKeys = QueryDocumentKeys) {
    const enterLeaveMap = /* @__PURE__ */ new Map();
    for (const kind of Object.values(Kind)) {
      enterLeaveMap.set(kind, getEnterLeaveForKind(visitor, kind));
    }
    let stack = void 0;
    let inArray = Array.isArray(root2);
    let keys = [root2];
    let index2 = -1;
    let edits = [];
    let node2 = root2;
    let key = void 0;
    let parent = void 0;
    const path = [];
    const ancestors = [];
    do {
      index2++;
      const isLeaving = index2 === keys.length;
      const isEdited = isLeaving && edits.length !== 0;
      if (isLeaving) {
        key = ancestors.length === 0 ? void 0 : path[path.length - 1];
        node2 = parent;
        parent = ancestors.pop();
        if (isEdited) {
          if (inArray) {
            node2 = node2.slice();
            let editOffset = 0;
            for (const [editKey, editValue] of edits) {
              const arrayKey = editKey - editOffset;
              if (editValue === null) {
                node2.splice(arrayKey, 1);
                editOffset++;
              } else {
                node2[arrayKey] = editValue;
              }
            }
          } else {
            node2 = { ...node2 };
            for (const [editKey, editValue] of edits) {
              node2[editKey] = editValue;
            }
          }
        }
        index2 = stack.index;
        keys = stack.keys;
        edits = stack.edits;
        inArray = stack.inArray;
        stack = stack.prev;
      } else if (parent) {
        key = inArray ? index2 : keys[index2];
        node2 = parent[key];
        if (node2 === null || node2 === void 0) {
          continue;
        }
        path.push(key);
      }
      let result2;
      if (!Array.isArray(node2)) {
        var _enterLeaveMap$get, _enterLeaveMap$get2;
        isNode2(node2) || devAssert(false, `Invalid AST Node: ${inspect(node2)}.`);
        const visitFn = isLeaving ? (_enterLeaveMap$get = enterLeaveMap.get(node2.kind)) === null || _enterLeaveMap$get === void 0 ? void 0 : _enterLeaveMap$get.leave : (_enterLeaveMap$get2 = enterLeaveMap.get(node2.kind)) === null || _enterLeaveMap$get2 === void 0 ? void 0 : _enterLeaveMap$get2.enter;
        result2 = visitFn === null || visitFn === void 0 ? void 0 : visitFn.call(visitor, node2, key, parent, path, ancestors);
        if (result2 === BREAK) {
          break;
        }
        if (result2 === false) {
          if (!isLeaving) {
            path.pop();
            continue;
          }
        } else if (result2 !== void 0) {
          edits.push([key, result2]);
          if (!isLeaving) {
            if (isNode2(result2)) {
              node2 = result2;
            } else {
              path.pop();
              continue;
            }
          }
        }
      }
      if (result2 === void 0 && isEdited) {
        edits.push([key, node2]);
      }
      if (isLeaving) {
        path.pop();
      } else {
        var _node$kind;
        stack = {
          inArray,
          index: index2,
          keys,
          edits,
          prev: stack
        };
        inArray = Array.isArray(node2);
        keys = inArray ? node2 : (_node$kind = visitorKeys[node2.kind]) !== null && _node$kind !== void 0 ? _node$kind : [];
        index2 = -1;
        edits = [];
        if (parent) {
          ancestors.push(parent);
        }
        parent = node2;
      }
    } while (stack !== void 0);
    if (edits.length !== 0) {
      return edits[edits.length - 1][1];
    }
    return root2;
  }
  function getEnterLeaveForKind(visitor, kind) {
    const kindVisitor = visitor[kind];
    if (typeof kindVisitor === "object") {
      return kindVisitor;
    } else if (typeof kindVisitor === "function") {
      return {
        enter: kindVisitor,
        leave: void 0
      };
    }
    return {
      enter: visitor.enter,
      leave: visitor.leave
    };
  }

  // node_modules/graphql/language/printer.mjs
  function print(ast) {
    return visit(ast, printDocASTReducer);
  }
  var MAX_LINE_LENGTH = 80;
  var printDocASTReducer = {
    Name: {
      leave: (node2) => node2.value
    },
    Variable: {
      leave: (node2) => "$" + node2.name
    },
    // Document
    Document: {
      leave: (node2) => join(node2.definitions, "\n\n")
    },
    OperationDefinition: {
      leave(node2) {
        const varDefs = wrap2("(", join(node2.variableDefinitions, ", "), ")");
        const prefix3 = join(
          [
            node2.operation,
            join([node2.name, varDefs]),
            join(node2.directives, " ")
          ],
          " "
        );
        return (prefix3 === "query" ? "" : prefix3 + " ") + node2.selectionSet;
      }
    },
    VariableDefinition: {
      leave: ({ variable, type, defaultValue, directives }) => variable + ": " + type + wrap2(" = ", defaultValue) + wrap2(" ", join(directives, " "))
    },
    SelectionSet: {
      leave: ({ selections }) => block(selections)
    },
    Field: {
      leave({ alias, name, arguments: args, directives, selectionSet }) {
        const prefix3 = wrap2("", alias, ": ") + name;
        let argsLine = prefix3 + wrap2("(", join(args, ", "), ")");
        if (argsLine.length > MAX_LINE_LENGTH) {
          argsLine = prefix3 + wrap2("(\n", indent(join(args, "\n")), "\n)");
        }
        return join([argsLine, join(directives, " "), selectionSet], " ");
      }
    },
    Argument: {
      leave: ({ name, value }) => name + ": " + value
    },
    // Fragments
    FragmentSpread: {
      leave: ({ name, directives }) => "..." + name + wrap2(" ", join(directives, " "))
    },
    InlineFragment: {
      leave: ({ typeCondition, directives, selectionSet }) => join(
        [
          "...",
          wrap2("on ", typeCondition),
          join(directives, " "),
          selectionSet
        ],
        " "
      )
    },
    FragmentDefinition: {
      leave: ({ name, typeCondition, variableDefinitions, directives, selectionSet }) => (
        // or removed in the future.
        `fragment ${name}${wrap2("(", join(variableDefinitions, ", "), ")")} on ${typeCondition} ${wrap2("", join(directives, " "), " ")}` + selectionSet
      )
    },
    // Value
    IntValue: {
      leave: ({ value }) => value
    },
    FloatValue: {
      leave: ({ value }) => value
    },
    StringValue: {
      leave: ({ value, block: isBlockString }) => isBlockString ? printBlockString(value) : printString(value)
    },
    BooleanValue: {
      leave: ({ value }) => value ? "true" : "false"
    },
    NullValue: {
      leave: () => "null"
    },
    EnumValue: {
      leave: ({ value }) => value
    },
    ListValue: {
      leave: ({ values }) => "[" + join(values, ", ") + "]"
    },
    ObjectValue: {
      leave: ({ fields }) => "{" + join(fields, ", ") + "}"
    },
    ObjectField: {
      leave: ({ name, value }) => name + ": " + value
    },
    // Directive
    Directive: {
      leave: ({ name, arguments: args }) => "@" + name + wrap2("(", join(args, ", "), ")")
    },
    // Type
    NamedType: {
      leave: ({ name }) => name
    },
    ListType: {
      leave: ({ type }) => "[" + type + "]"
    },
    NonNullType: {
      leave: ({ type }) => type + "!"
    },
    // Type System Definitions
    SchemaDefinition: {
      leave: ({ description, directives, operationTypes }) => wrap2("", description, "\n") + join(["schema", join(directives, " "), block(operationTypes)], " ")
    },
    OperationTypeDefinition: {
      leave: ({ operation, type }) => operation + ": " + type
    },
    ScalarTypeDefinition: {
      leave: ({ description, name, directives }) => wrap2("", description, "\n") + join(["scalar", name, join(directives, " ")], " ")
    },
    ObjectTypeDefinition: {
      leave: ({ description, name, interfaces, directives, fields }) => wrap2("", description, "\n") + join(
        [
          "type",
          name,
          wrap2("implements ", join(interfaces, " & ")),
          join(directives, " "),
          block(fields)
        ],
        " "
      )
    },
    FieldDefinition: {
      leave: ({ description, name, arguments: args, type, directives }) => wrap2("", description, "\n") + name + (hasMultilineItems(args) ? wrap2("(\n", indent(join(args, "\n")), "\n)") : wrap2("(", join(args, ", "), ")")) + ": " + type + wrap2(" ", join(directives, " "))
    },
    InputValueDefinition: {
      leave: ({ description, name, type, defaultValue, directives }) => wrap2("", description, "\n") + join(
        [name + ": " + type, wrap2("= ", defaultValue), join(directives, " ")],
        " "
      )
    },
    InterfaceTypeDefinition: {
      leave: ({ description, name, interfaces, directives, fields }) => wrap2("", description, "\n") + join(
        [
          "interface",
          name,
          wrap2("implements ", join(interfaces, " & ")),
          join(directives, " "),
          block(fields)
        ],
        " "
      )
    },
    UnionTypeDefinition: {
      leave: ({ description, name, directives, types }) => wrap2("", description, "\n") + join(
        ["union", name, join(directives, " "), wrap2("= ", join(types, " | "))],
        " "
      )
    },
    EnumTypeDefinition: {
      leave: ({ description, name, directives, values }) => wrap2("", description, "\n") + join(["enum", name, join(directives, " "), block(values)], " ")
    },
    EnumValueDefinition: {
      leave: ({ description, name, directives }) => wrap2("", description, "\n") + join([name, join(directives, " ")], " ")
    },
    InputObjectTypeDefinition: {
      leave: ({ description, name, directives, fields }) => wrap2("", description, "\n") + join(["input", name, join(directives, " "), block(fields)], " ")
    },
    DirectiveDefinition: {
      leave: ({ description, name, arguments: args, repeatable, locations }) => wrap2("", description, "\n") + "directive @" + name + (hasMultilineItems(args) ? wrap2("(\n", indent(join(args, "\n")), "\n)") : wrap2("(", join(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join(locations, " | ")
    },
    SchemaExtension: {
      leave: ({ directives, operationTypes }) => join(
        ["extend schema", join(directives, " "), block(operationTypes)],
        " "
      )
    },
    ScalarTypeExtension: {
      leave: ({ name, directives }) => join(["extend scalar", name, join(directives, " ")], " ")
    },
    ObjectTypeExtension: {
      leave: ({ name, interfaces, directives, fields }) => join(
        [
          "extend type",
          name,
          wrap2("implements ", join(interfaces, " & ")),
          join(directives, " "),
          block(fields)
        ],
        " "
      )
    },
    InterfaceTypeExtension: {
      leave: ({ name, interfaces, directives, fields }) => join(
        [
          "extend interface",
          name,
          wrap2("implements ", join(interfaces, " & ")),
          join(directives, " "),
          block(fields)
        ],
        " "
      )
    },
    UnionTypeExtension: {
      leave: ({ name, directives, types }) => join(
        [
          "extend union",
          name,
          join(directives, " "),
          wrap2("= ", join(types, " | "))
        ],
        " "
      )
    },
    EnumTypeExtension: {
      leave: ({ name, directives, values }) => join(["extend enum", name, join(directives, " "), block(values)], " ")
    },
    InputObjectTypeExtension: {
      leave: ({ name, directives, fields }) => join(["extend input", name, join(directives, " "), block(fields)], " ")
    }
  };
  function join(maybeArray, separator = "") {
    var _maybeArray$filter$jo;
    return (_maybeArray$filter$jo = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.filter((x) => x).join(separator)) !== null && _maybeArray$filter$jo !== void 0 ? _maybeArray$filter$jo : "";
  }
  function block(array) {
    return wrap2("{\n", indent(join(array, "\n")), "\n}");
  }
  function wrap2(start3, maybeString, end2 = "") {
    return maybeString != null && maybeString !== "" ? start3 + maybeString + end2 : "";
  }
  function indent(str) {
    return wrap2("  ", str.replace(/\n/g, "\n  "));
  }
  function hasMultilineItems(maybeArray) {
    var _maybeArray$some;
    return (_maybeArray$some = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some((str) => str.includes("\n"))) !== null && _maybeArray$some !== void 0 ? _maybeArray$some : false;
  }

  // node_modules/graphql/language/predicates.mjs
  function isSelectionNode(node2) {
    return node2.kind === Kind.FIELD || node2.kind === Kind.FRAGMENT_SPREAD || node2.kind === Kind.INLINE_FRAGMENT;
  }

  // node_modules/@apollo/client/utilities/graphql/directives.js
  function shouldInclude(_a2, variables) {
    var directives = _a2.directives;
    if (!directives || !directives.length) {
      return true;
    }
    return getInclusionDirectives(directives).every(function(_a3) {
      var directive = _a3.directive, ifArgument = _a3.ifArgument;
      var evaledValue = false;
      if (ifArgument.value.kind === "Variable") {
        evaledValue = variables && variables[ifArgument.value.name.value];
        invariant3(evaledValue !== void 0, 78, directive.name.value);
      } else {
        evaledValue = ifArgument.value.value;
      }
      return directive.name.value === "skip" ? !evaledValue : evaledValue;
    });
  }
  function hasDirectives(names, root2, all) {
    var nameSet = new Set(names);
    var uniqueCount = nameSet.size;
    visit(root2, {
      Directive: function(node2) {
        if (nameSet.delete(node2.name.value) && (!all || !nameSet.size)) {
          return BREAK;
        }
      }
    });
    return all ? !nameSet.size : nameSet.size < uniqueCount;
  }
  function hasClientExports(document2) {
    return document2 && hasDirectives(["client", "export"], document2, true);
  }
  function isInclusionDirective(_a2) {
    var value = _a2.name.value;
    return value === "skip" || value === "include";
  }
  function getInclusionDirectives(directives) {
    var result2 = [];
    if (directives && directives.length) {
      directives.forEach(function(directive) {
        if (!isInclusionDirective(directive))
          return;
        var directiveArguments = directive.arguments;
        var directiveName = directive.name.value;
        invariant3(directiveArguments && directiveArguments.length === 1, 79, directiveName);
        var ifArgument = directiveArguments[0];
        invariant3(ifArgument.name && ifArgument.name.value === "if", 80, directiveName);
        var ifValue = ifArgument.value;
        invariant3(ifValue && (ifValue.kind === "Variable" || ifValue.kind === "BooleanValue"), 81, directiveName);
        result2.push({ directive, ifArgument });
      });
    }
    return result2;
  }
  function getFragmentMaskMode(fragment) {
    var _a2, _b;
    var directive = (_a2 = fragment.directives) === null || _a2 === void 0 ? void 0 : _a2.find(function(_a3) {
      var name = _a3.name;
      return name.value === "unmask";
    });
    if (!directive) {
      return "mask";
    }
    var modeArg = (_b = directive.arguments) === null || _b === void 0 ? void 0 : _b.find(function(_a3) {
      var name = _a3.name;
      return name.value === "mode";
    });
    if (globalThis.__DEV__ !== false) {
      if (modeArg) {
        if (modeArg.value.kind === Kind.VARIABLE) {
          globalThis.__DEV__ !== false && invariant3.warn(82);
        } else if (modeArg.value.kind !== Kind.STRING) {
          globalThis.__DEV__ !== false && invariant3.warn(83);
        } else if (modeArg.value.value !== "migrate") {
          globalThis.__DEV__ !== false && invariant3.warn(84, modeArg.value.value);
        }
      }
    }
    if (modeArg && "value" in modeArg.value && modeArg.value.value === "migrate") {
      return "migrate";
    }
    return "unmask";
  }

  // node_modules/@wry/trie/lib/index.js
  var defaultMakeData = () => /* @__PURE__ */ Object.create(null);
  var { forEach, slice: slice2 } = Array.prototype;
  var { hasOwnProperty } = Object.prototype;
  var Trie = class _Trie {
    constructor(weakness = true, makeData = defaultMakeData) {
      this.weakness = weakness;
      this.makeData = makeData;
    }
    lookup() {
      return this.lookupArray(arguments);
    }
    lookupArray(array) {
      let node2 = this;
      forEach.call(array, (key) => node2 = node2.getChildTrie(key));
      return hasOwnProperty.call(node2, "data") ? node2.data : node2.data = this.makeData(slice2.call(array));
    }
    peek() {
      return this.peekArray(arguments);
    }
    peekArray(array) {
      let node2 = this;
      for (let i = 0, len = array.length; node2 && i < len; ++i) {
        const map = node2.mapFor(array[i], false);
        node2 = map && map.get(array[i]);
      }
      return node2 && node2.data;
    }
    remove() {
      return this.removeArray(arguments);
    }
    removeArray(array) {
      let data;
      if (array.length) {
        const head = array[0];
        const map = this.mapFor(head, false);
        const child = map && map.get(head);
        if (child) {
          data = child.removeArray(slice2.call(array, 1));
          if (!child.data && !child.weak && !(child.strong && child.strong.size)) {
            map.delete(head);
          }
        }
      } else {
        data = this.data;
        delete this.data;
      }
      return data;
    }
    getChildTrie(key) {
      const map = this.mapFor(key, true);
      let child = map.get(key);
      if (!child)
        map.set(key, child = new _Trie(this.weakness, this.makeData));
      return child;
    }
    mapFor(key, create) {
      return this.weakness && isObjRef(key) ? this.weak || (create ? this.weak = /* @__PURE__ */ new WeakMap() : void 0) : this.strong || (create ? this.strong = /* @__PURE__ */ new Map() : void 0);
    }
  };
  function isObjRef(value) {
    switch (typeof value) {
      case "object":
        if (value === null)
          break;
      // Fall through to return true...
      case "function":
        return true;
    }
    return false;
  }

  // node_modules/@apollo/client/utilities/common/canUse.js
  var isReactNative = maybe(function() {
    return navigator.product;
  }) == "ReactNative";
  var canUseWeakMap = typeof WeakMap === "function" && !(isReactNative && !global.HermesInternal);
  var canUseWeakSet = typeof WeakSet === "function";
  var canUseSymbol = typeof Symbol === "function" && typeof Symbol.for === "function";
  var canUseAsyncIteratorSymbol = canUseSymbol && Symbol.asyncIterator;
  var canUseDOM2 = typeof maybe(function() {
    return window.document.createElement;
  }) === "function";
  var usingJSDOM = (
    // Following advice found in this comment from @domenic (maintainer of jsdom):
    // https://github.com/jsdom/jsdom/issues/1537#issuecomment-229405327
    //
    // Since we control the version of Jest and jsdom used when running Apollo
    // Client tests, and that version is recent enought to include " jsdom/x.y.z"
    // at the end of the user agent string, I believe this case is all we need to
    // check. Testing for "Node.js" was recommended for backwards compatibility
    // with older version of jsdom, but we don't have that problem.
    maybe(function() {
      return navigator.userAgent.indexOf("jsdom") >= 0;
    }) || false
  );

  // node_modules/@apollo/client/utilities/common/objects.js
  function isNonNullObject(obj) {
    return obj !== null && typeof obj === "object";
  }

  // node_modules/@apollo/client/utilities/graphql/fragments.js
  function getFragmentQueryDocument(document2, fragmentName) {
    var actualFragmentName = fragmentName;
    var fragments = [];
    document2.definitions.forEach(function(definition) {
      if (definition.kind === "OperationDefinition") {
        throw newInvariantError(
          85,
          definition.operation,
          definition.name ? " named '".concat(definition.name.value, "'") : ""
        );
      }
      if (definition.kind === "FragmentDefinition") {
        fragments.push(definition);
      }
    });
    if (typeof actualFragmentName === "undefined") {
      invariant3(fragments.length === 1, 86, fragments.length);
      actualFragmentName = fragments[0].name.value;
    }
    var query = __assign(__assign({}, document2), { definitions: __spreadArray([
      {
        kind: "OperationDefinition",
        // OperationTypeNode is an enum
        operation: "query",
        selectionSet: {
          kind: "SelectionSet",
          selections: [
            {
              kind: "FragmentSpread",
              name: {
                kind: "Name",
                value: actualFragmentName
              }
            }
          ]
        }
      }
    ], document2.definitions, true) });
    return query;
  }
  function createFragmentMap(fragments) {
    if (fragments === void 0) {
      fragments = [];
    }
    var symTable = {};
    fragments.forEach(function(fragment) {
      symTable[fragment.name.value] = fragment;
    });
    return symTable;
  }
  function getFragmentFromSelection(selection, fragmentMap) {
    switch (selection.kind) {
      case "InlineFragment":
        return selection;
      case "FragmentSpread": {
        var fragmentName = selection.name.value;
        if (typeof fragmentMap === "function") {
          return fragmentMap(fragmentName);
        }
        var fragment = fragmentMap && fragmentMap[fragmentName];
        invariant3(fragment, 87, fragmentName);
        return fragment || null;
      }
      default:
        return null;
    }
  }
  function isFullyUnmaskedOperation(document2) {
    var isUnmasked = true;
    visit(document2, {
      FragmentSpread: function(node2) {
        isUnmasked = !!node2.directives && node2.directives.some(function(directive) {
          return directive.name.value === "unmask";
        });
        if (!isUnmasked) {
          return BREAK;
        }
      }
    });
    return isUnmasked;
  }

  // node_modules/@wry/caches/lib/strong.js
  function defaultDispose() {
  }
  var StrongCache = class {
    constructor(max3 = Infinity, dispose = defaultDispose) {
      this.max = max3;
      this.dispose = dispose;
      this.map = /* @__PURE__ */ new Map();
      this.newest = null;
      this.oldest = null;
    }
    has(key) {
      return this.map.has(key);
    }
    get(key) {
      const node2 = this.getNode(key);
      return node2 && node2.value;
    }
    get size() {
      return this.map.size;
    }
    getNode(key) {
      const node2 = this.map.get(key);
      if (node2 && node2 !== this.newest) {
        const { older, newer } = node2;
        if (newer) {
          newer.older = older;
        }
        if (older) {
          older.newer = newer;
        }
        node2.older = this.newest;
        node2.older.newer = node2;
        node2.newer = null;
        this.newest = node2;
        if (node2 === this.oldest) {
          this.oldest = newer;
        }
      }
      return node2;
    }
    set(key, value) {
      let node2 = this.getNode(key);
      if (node2) {
        return node2.value = value;
      }
      node2 = {
        key,
        value,
        newer: null,
        older: this.newest
      };
      if (this.newest) {
        this.newest.newer = node2;
      }
      this.newest = node2;
      this.oldest = this.oldest || node2;
      this.map.set(key, node2);
      return node2.value;
    }
    clean() {
      while (this.oldest && this.map.size > this.max) {
        this.delete(this.oldest.key);
      }
    }
    delete(key) {
      const node2 = this.map.get(key);
      if (node2) {
        if (node2 === this.newest) {
          this.newest = node2.older;
        }
        if (node2 === this.oldest) {
          this.oldest = node2.newer;
        }
        if (node2.newer) {
          node2.newer.older = node2.older;
        }
        if (node2.older) {
          node2.older.newer = node2.newer;
        }
        this.map.delete(key);
        this.dispose(node2.value, key);
        return true;
      }
      return false;
    }
  };

  // node_modules/@wry/caches/lib/weak.js
  function noop6() {
  }
  var defaultDispose2 = noop6;
  var _WeakRef = typeof WeakRef !== "undefined" ? WeakRef : function(value) {
    return { deref: () => value };
  };
  var _WeakMap = typeof WeakMap !== "undefined" ? WeakMap : Map;
  var _FinalizationRegistry = typeof FinalizationRegistry !== "undefined" ? FinalizationRegistry : function() {
    return {
      register: noop6,
      unregister: noop6
    };
  };
  var finalizationBatchSize = 10024;
  var WeakCache = class {
    constructor(max3 = Infinity, dispose = defaultDispose2) {
      this.max = max3;
      this.dispose = dispose;
      this.map = new _WeakMap();
      this.newest = null;
      this.oldest = null;
      this.unfinalizedNodes = /* @__PURE__ */ new Set();
      this.finalizationScheduled = false;
      this.size = 0;
      this.finalize = () => {
        const iterator = this.unfinalizedNodes.values();
        for (let i = 0; i < finalizationBatchSize; i++) {
          const node2 = iterator.next().value;
          if (!node2)
            break;
          this.unfinalizedNodes.delete(node2);
          const key = node2.key;
          delete node2.key;
          node2.keyRef = new _WeakRef(key);
          this.registry.register(key, node2, node2);
        }
        if (this.unfinalizedNodes.size > 0) {
          queueMicrotask(this.finalize);
        } else {
          this.finalizationScheduled = false;
        }
      };
      this.registry = new _FinalizationRegistry(this.deleteNode.bind(this));
    }
    has(key) {
      return this.map.has(key);
    }
    get(key) {
      const node2 = this.getNode(key);
      return node2 && node2.value;
    }
    getNode(key) {
      const node2 = this.map.get(key);
      if (node2 && node2 !== this.newest) {
        const { older, newer } = node2;
        if (newer) {
          newer.older = older;
        }
        if (older) {
          older.newer = newer;
        }
        node2.older = this.newest;
        node2.older.newer = node2;
        node2.newer = null;
        this.newest = node2;
        if (node2 === this.oldest) {
          this.oldest = newer;
        }
      }
      return node2;
    }
    set(key, value) {
      let node2 = this.getNode(key);
      if (node2) {
        return node2.value = value;
      }
      node2 = {
        key,
        value,
        newer: null,
        older: this.newest
      };
      if (this.newest) {
        this.newest.newer = node2;
      }
      this.newest = node2;
      this.oldest = this.oldest || node2;
      this.scheduleFinalization(node2);
      this.map.set(key, node2);
      this.size++;
      return node2.value;
    }
    clean() {
      while (this.oldest && this.size > this.max) {
        this.deleteNode(this.oldest);
      }
    }
    deleteNode(node2) {
      if (node2 === this.newest) {
        this.newest = node2.older;
      }
      if (node2 === this.oldest) {
        this.oldest = node2.newer;
      }
      if (node2.newer) {
        node2.newer.older = node2.older;
      }
      if (node2.older) {
        node2.older.newer = node2.newer;
      }
      this.size--;
      const key = node2.key || node2.keyRef && node2.keyRef.deref();
      this.dispose(node2.value, key);
      if (!node2.keyRef) {
        this.unfinalizedNodes.delete(node2);
      } else {
        this.registry.unregister(node2);
      }
      if (key)
        this.map.delete(key);
    }
    delete(key) {
      const node2 = this.map.get(key);
      if (node2) {
        this.deleteNode(node2);
        return true;
      }
      return false;
    }
    scheduleFinalization(node2) {
      this.unfinalizedNodes.add(node2);
      if (!this.finalizationScheduled) {
        this.finalizationScheduled = true;
        queueMicrotask(this.finalize);
      }
    }
  };

  // node_modules/@apollo/client/utilities/caching/caches.js
  var scheduledCleanup = /* @__PURE__ */ new WeakSet();
  function schedule(cache) {
    if (cache.size <= (cache.max || -1)) {
      return;
    }
    if (!scheduledCleanup.has(cache)) {
      scheduledCleanup.add(cache);
      setTimeout(function() {
        cache.clean();
        scheduledCleanup.delete(cache);
      }, 100);
    }
  }
  var AutoCleanedWeakCache = function(max3, dispose) {
    var cache = new WeakCache(max3, dispose);
    cache.set = function(key, value) {
      var ret = WeakCache.prototype.set.call(this, key, value);
      schedule(this);
      return ret;
    };
    return cache;
  };
  var AutoCleanedStrongCache = function(max3, dispose) {
    var cache = new StrongCache(max3, dispose);
    cache.set = function(key, value) {
      var ret = StrongCache.prototype.set.call(this, key, value);
      schedule(this);
      return ret;
    };
    return cache;
  };

  // node_modules/@apollo/client/utilities/caching/sizes.js
  var cacheSizeSymbol = Symbol.for("apollo.cacheSize");
  var cacheSizes = __assign({}, global_default[cacheSizeSymbol]);

  // node_modules/@apollo/client/utilities/caching/getMemoryInternals.js
  var globalCaches = {};
  function registerGlobalCache(name, getSize) {
    globalCaches[name] = getSize;
  }
  var getApolloClientMemoryInternals = globalThis.__DEV__ !== false ? _getApolloClientMemoryInternals : void 0;
  var getInMemoryCacheMemoryInternals = globalThis.__DEV__ !== false ? _getInMemoryCacheMemoryInternals : void 0;
  var getApolloCacheMemoryInternals = globalThis.__DEV__ !== false ? _getApolloCacheMemoryInternals : void 0;
  function getCurrentCacheSizes() {
    var defaults = {
      parser: 1e3,
      canonicalStringify: 1e3,
      print: 2e3,
      "documentTransform.cache": 2e3,
      "queryManager.getDocumentInfo": 2e3,
      "PersistedQueryLink.persistedQueryHashes": 2e3,
      "fragmentRegistry.transform": 2e3,
      "fragmentRegistry.lookup": 1e3,
      "fragmentRegistry.findFragmentSpreads": 4e3,
      "cache.fragmentQueryDocuments": 1e3,
      "removeTypenameFromVariables.getVariableDefinitions": 2e3,
      "inMemoryCache.maybeBroadcastWatch": 5e3,
      "inMemoryCache.executeSelectionSet": 5e4,
      "inMemoryCache.executeSubSelectedArray": 1e4
    };
    return Object.fromEntries(Object.entries(defaults).map(function(_a2) {
      var k = _a2[0], v = _a2[1];
      return [
        k,
        cacheSizes[k] || v
      ];
    }));
  }
  function _getApolloClientMemoryInternals() {
    var _a2, _b, _c, _d, _e;
    if (!(globalThis.__DEV__ !== false))
      throw new Error("only supported in development mode");
    return {
      limits: getCurrentCacheSizes(),
      sizes: __assign({ print: (_a2 = globalCaches.print) === null || _a2 === void 0 ? void 0 : _a2.call(globalCaches), parser: (_b = globalCaches.parser) === null || _b === void 0 ? void 0 : _b.call(globalCaches), canonicalStringify: (_c = globalCaches.canonicalStringify) === null || _c === void 0 ? void 0 : _c.call(globalCaches), links: linkInfo(this.link), queryManager: {
        getDocumentInfo: this["queryManager"]["transformCache"].size,
        documentTransforms: transformInfo(this["queryManager"].documentTransform)
      } }, (_e = (_d = this.cache).getMemoryInternals) === null || _e === void 0 ? void 0 : _e.call(_d))
    };
  }
  function _getApolloCacheMemoryInternals() {
    return {
      cache: {
        fragmentQueryDocuments: getWrapperInformation(this["getFragmentDoc"])
      }
    };
  }
  function _getInMemoryCacheMemoryInternals() {
    var fragments = this.config.fragments;
    return __assign(__assign({}, _getApolloCacheMemoryInternals.apply(this)), { addTypenameDocumentTransform: transformInfo(this["addTypenameTransform"]), inMemoryCache: {
      executeSelectionSet: getWrapperInformation(this["storeReader"]["executeSelectionSet"]),
      executeSubSelectedArray: getWrapperInformation(this["storeReader"]["executeSubSelectedArray"]),
      maybeBroadcastWatch: getWrapperInformation(this["maybeBroadcastWatch"])
    }, fragmentRegistry: {
      findFragmentSpreads: getWrapperInformation(fragments === null || fragments === void 0 ? void 0 : fragments.findFragmentSpreads),
      lookup: getWrapperInformation(fragments === null || fragments === void 0 ? void 0 : fragments.lookup),
      transform: getWrapperInformation(fragments === null || fragments === void 0 ? void 0 : fragments.transform)
    } });
  }
  function isWrapper(f) {
    return !!f && "dirtyKey" in f;
  }
  function getWrapperInformation(f) {
    return isWrapper(f) ? f.size : void 0;
  }
  function isDefined2(value) {
    return value != null;
  }
  function transformInfo(transform) {
    return recurseTransformInfo(transform).map(function(cache) {
      return { cache };
    });
  }
  function recurseTransformInfo(transform) {
    return transform ? __spreadArray(__spreadArray([
      getWrapperInformation(transform === null || transform === void 0 ? void 0 : transform["performWork"])
    ], recurseTransformInfo(transform === null || transform === void 0 ? void 0 : transform["left"]), true), recurseTransformInfo(transform === null || transform === void 0 ? void 0 : transform["right"]), true).filter(isDefined2) : [];
  }
  function linkInfo(link) {
    var _a2;
    return link ? __spreadArray(__spreadArray([
      (_a2 = link === null || link === void 0 ? void 0 : link.getMemoryInternals) === null || _a2 === void 0 ? void 0 : _a2.call(link)
    ], linkInfo(link === null || link === void 0 ? void 0 : link.left), true), linkInfo(link === null || link === void 0 ? void 0 : link.right), true).filter(isDefined2) : [];
  }

  // node_modules/@apollo/client/utilities/common/canonicalStringify.js
  var canonicalStringify = Object.assign(function canonicalStringify2(value) {
    return JSON.stringify(value, stableObjectReplacer);
  }, {
    reset: function() {
      sortingMap = new AutoCleanedStrongCache(
        cacheSizes.canonicalStringify || 1e3
        /* defaultCacheSizes.canonicalStringify */
      );
    }
  });
  if (globalThis.__DEV__ !== false) {
    registerGlobalCache("canonicalStringify", function() {
      return sortingMap.size;
    });
  }
  var sortingMap;
  canonicalStringify.reset();
  function stableObjectReplacer(key, value) {
    if (value && typeof value === "object") {
      var proto = Object.getPrototypeOf(value);
      if (proto === Object.prototype || proto === null) {
        var keys = Object.keys(value);
        if (keys.every(everyKeyInOrder))
          return value;
        var unsortedKey = JSON.stringify(keys);
        var sortedKeys = sortingMap.get(unsortedKey);
        if (!sortedKeys) {
          keys.sort();
          var sortedKey = JSON.stringify(keys);
          sortedKeys = sortingMap.get(sortedKey) || keys;
          sortingMap.set(unsortedKey, sortedKeys);
          sortingMap.set(sortedKey, sortedKeys);
        }
        var sortedObject_1 = Object.create(proto);
        sortedKeys.forEach(function(key2) {
          sortedObject_1[key2] = value[key2];
        });
        return sortedObject_1;
      }
    }
    return value;
  }
  function everyKeyInOrder(key, i, keys) {
    return i === 0 || keys[i - 1] <= key;
  }

  // node_modules/@apollo/client/utilities/graphql/storeUtils.js
  function makeReference(id) {
    return { __ref: String(id) };
  }
  function isReference(obj) {
    return Boolean(obj && typeof obj === "object" && typeof obj.__ref === "string");
  }
  function isDocumentNode(value) {
    return isNonNullObject(value) && value.kind === "Document" && Array.isArray(value.definitions);
  }
  function isStringValue(value) {
    return value.kind === "StringValue";
  }
  function isBooleanValue(value) {
    return value.kind === "BooleanValue";
  }
  function isIntValue(value) {
    return value.kind === "IntValue";
  }
  function isFloatValue(value) {
    return value.kind === "FloatValue";
  }
  function isVariable(value) {
    return value.kind === "Variable";
  }
  function isObjectValue(value) {
    return value.kind === "ObjectValue";
  }
  function isListValue(value) {
    return value.kind === "ListValue";
  }
  function isEnumValue(value) {
    return value.kind === "EnumValue";
  }
  function isNullValue(value) {
    return value.kind === "NullValue";
  }
  function valueToObjectRepresentation(argObj, name, value, variables) {
    if (isIntValue(value) || isFloatValue(value)) {
      argObj[name.value] = Number(value.value);
    } else if (isBooleanValue(value) || isStringValue(value)) {
      argObj[name.value] = value.value;
    } else if (isObjectValue(value)) {
      var nestedArgObj_1 = {};
      value.fields.map(function(obj) {
        return valueToObjectRepresentation(nestedArgObj_1, obj.name, obj.value, variables);
      });
      argObj[name.value] = nestedArgObj_1;
    } else if (isVariable(value)) {
      var variableValue = (variables || {})[value.name.value];
      argObj[name.value] = variableValue;
    } else if (isListValue(value)) {
      argObj[name.value] = value.values.map(function(listValue) {
        var nestedArgArrayObj = {};
        valueToObjectRepresentation(nestedArgArrayObj, name, listValue, variables);
        return nestedArgArrayObj[name.value];
      });
    } else if (isEnumValue(value)) {
      argObj[name.value] = value.value;
    } else if (isNullValue(value)) {
      argObj[name.value] = null;
    } else {
      throw newInvariantError(96, name.value, value.kind);
    }
  }
  function storeKeyNameFromField(field, variables) {
    var directivesObj = null;
    if (field.directives) {
      directivesObj = {};
      field.directives.forEach(function(directive) {
        directivesObj[directive.name.value] = {};
        if (directive.arguments) {
          directive.arguments.forEach(function(_a2) {
            var name = _a2.name, value = _a2.value;
            return valueToObjectRepresentation(directivesObj[directive.name.value], name, value, variables);
          });
        }
      });
    }
    var argObj = null;
    if (field.arguments && field.arguments.length) {
      argObj = {};
      field.arguments.forEach(function(_a2) {
        var name = _a2.name, value = _a2.value;
        return valueToObjectRepresentation(argObj, name, value, variables);
      });
    }
    return getStoreKeyName(field.name.value, argObj, directivesObj);
  }
  var KNOWN_DIRECTIVES = [
    "connection",
    "include",
    "skip",
    "client",
    "rest",
    "export",
    "nonreactive"
  ];
  var storeKeyNameStringify = canonicalStringify;
  var getStoreKeyName = Object.assign(function(fieldName, args, directives) {
    if (args && directives && directives["connection"] && directives["connection"]["key"]) {
      if (directives["connection"]["filter"] && directives["connection"]["filter"].length > 0) {
        var filterKeys = directives["connection"]["filter"] ? directives["connection"]["filter"] : [];
        filterKeys.sort();
        var filteredArgs_1 = {};
        filterKeys.forEach(function(key) {
          filteredArgs_1[key] = args[key];
        });
        return "".concat(directives["connection"]["key"], "(").concat(storeKeyNameStringify(filteredArgs_1), ")");
      } else {
        return directives["connection"]["key"];
      }
    }
    var completeFieldName = fieldName;
    if (args) {
      var stringifiedArgs = storeKeyNameStringify(args);
      completeFieldName += "(".concat(stringifiedArgs, ")");
    }
    if (directives) {
      Object.keys(directives).forEach(function(key) {
        if (KNOWN_DIRECTIVES.indexOf(key) !== -1)
          return;
        if (directives[key] && Object.keys(directives[key]).length) {
          completeFieldName += "@".concat(key, "(").concat(storeKeyNameStringify(directives[key]), ")");
        } else {
          completeFieldName += "@".concat(key);
        }
      });
    }
    return completeFieldName;
  }, {
    setStringify: function(s) {
      var previous = storeKeyNameStringify;
      storeKeyNameStringify = s;
      return previous;
    }
  });
  function argumentsObjectFromField(field, variables) {
    if (field.arguments && field.arguments.length) {
      var argObj_1 = {};
      field.arguments.forEach(function(_a2) {
        var name = _a2.name, value = _a2.value;
        return valueToObjectRepresentation(argObj_1, name, value, variables);
      });
      return argObj_1;
    }
    return null;
  }
  function resultKeyNameFromField(field) {
    return field.alias ? field.alias.value : field.name.value;
  }
  function getTypenameFromResult(result2, selectionSet, fragmentMap) {
    var fragments;
    for (var _i = 0, _a2 = selectionSet.selections; _i < _a2.length; _i++) {
      var selection = _a2[_i];
      if (isField(selection)) {
        if (selection.name.value === "__typename") {
          return result2[resultKeyNameFromField(selection)];
        }
      } else if (fragments) {
        fragments.push(selection);
      } else {
        fragments = [selection];
      }
    }
    if (typeof result2.__typename === "string") {
      return result2.__typename;
    }
    if (fragments) {
      for (var _b = 0, fragments_1 = fragments; _b < fragments_1.length; _b++) {
        var selection = fragments_1[_b];
        var typename = getTypenameFromResult(result2, getFragmentFromSelection(selection, fragmentMap).selectionSet, fragmentMap);
        if (typeof typename === "string") {
          return typename;
        }
      }
    }
  }
  function isField(selection) {
    return selection.kind === "Field";
  }
  function isInlineFragment(selection) {
    return selection.kind === "InlineFragment";
  }

  // node_modules/@apollo/client/utilities/graphql/getFromAST.js
  function checkDocument(doc) {
    invariant3(doc && doc.kind === "Document", 88);
    var operations = doc.definitions.filter(function(d) {
      return d.kind !== "FragmentDefinition";
    }).map(function(definition) {
      if (definition.kind !== "OperationDefinition") {
        throw newInvariantError(89, definition.kind);
      }
      return definition;
    });
    invariant3(operations.length <= 1, 90, operations.length);
    return doc;
  }
  function getOperationDefinition(doc) {
    checkDocument(doc);
    return doc.definitions.filter(function(definition) {
      return definition.kind === "OperationDefinition";
    })[0];
  }
  function getOperationName(doc) {
    return doc.definitions.filter(function(definition) {
      return definition.kind === "OperationDefinition" && !!definition.name;
    }).map(function(x) {
      return x.name.value;
    })[0] || null;
  }
  function getFragmentDefinitions(doc) {
    return doc.definitions.filter(function(definition) {
      return definition.kind === "FragmentDefinition";
    });
  }
  function getQueryDefinition(doc) {
    var queryDef = getOperationDefinition(doc);
    invariant3(queryDef && queryDef.operation === "query", 91);
    return queryDef;
  }
  function getFragmentDefinition(doc) {
    invariant3(doc.kind === "Document", 92);
    invariant3(doc.definitions.length <= 1, 93);
    var fragmentDef = doc.definitions[0];
    invariant3(fragmentDef.kind === "FragmentDefinition", 94);
    return fragmentDef;
  }
  function getMainDefinition(queryDoc) {
    checkDocument(queryDoc);
    var fragmentDefinition;
    for (var _i = 0, _a2 = queryDoc.definitions; _i < _a2.length; _i++) {
      var definition = _a2[_i];
      if (definition.kind === "OperationDefinition") {
        var operation = definition.operation;
        if (operation === "query" || operation === "mutation" || operation === "subscription") {
          return definition;
        }
      }
      if (definition.kind === "FragmentDefinition" && !fragmentDefinition) {
        fragmentDefinition = definition;
      }
    }
    if (fragmentDefinition) {
      return fragmentDefinition;
    }
    throw newInvariantError(95);
  }
  function getDefaultValues(definition) {
    var defaultValues = /* @__PURE__ */ Object.create(null);
    var defs = definition && definition.variableDefinitions;
    if (defs && defs.length) {
      defs.forEach(function(def) {
        if (def.defaultValue) {
          valueToObjectRepresentation(defaultValues, def.variable.name, def.defaultValue);
        }
      });
    }
    return defaultValues;
  }

  // node_modules/@wry/context/lib/slot.js
  var currentContext = null;
  var MISSING_VALUE = {};
  var idCounter = 1;
  var makeSlotClass = () => class Slot {
    constructor() {
      this.id = [
        "slot",
        idCounter++,
        Date.now(),
        Math.random().toString(36).slice(2)
      ].join(":");
    }
    hasValue() {
      for (let context = currentContext; context; context = context.parent) {
        if (this.id in context.slots) {
          const value = context.slots[this.id];
          if (value === MISSING_VALUE)
            break;
          if (context !== currentContext) {
            currentContext.slots[this.id] = value;
          }
          return true;
        }
      }
      if (currentContext) {
        currentContext.slots[this.id] = MISSING_VALUE;
      }
      return false;
    }
    getValue() {
      if (this.hasValue()) {
        return currentContext.slots[this.id];
      }
    }
    withValue(value, callback, args, thisArg) {
      const slots = {
        __proto__: null,
        [this.id]: value
      };
      const parent = currentContext;
      currentContext = { parent, slots };
      try {
        return callback.apply(thisArg, args);
      } finally {
        currentContext = parent;
      }
    }
    // Capture the current context and wrap a callback function so that it
    // reestablishes the captured context when called.
    static bind(callback) {
      const context = currentContext;
      return function() {
        const saved = currentContext;
        try {
          currentContext = context;
          return callback.apply(this, arguments);
        } finally {
          currentContext = saved;
        }
      };
    }
    // Immediately run a callback function without any captured context.
    static noContext(callback, args, thisArg) {
      if (currentContext) {
        const saved = currentContext;
        try {
          currentContext = null;
          return callback.apply(thisArg, args);
        } finally {
          currentContext = saved;
        }
      } else {
        return callback.apply(thisArg, args);
      }
    }
  };
  function maybe2(fn2) {
    try {
      return fn2();
    } catch (ignored) {
    }
  }
  var globalKey = "@wry/context:Slot";
  var host = (
    // Prefer globalThis when available.
    // https://github.com/benjamn/wryware/issues/347
    maybe2(() => globalThis) || // Fall back to global, which works in Node.js and may be converted by some
    // bundlers to the appropriate identifier (window, self, ...) depending on the
    // bundling target. https://github.com/endojs/endo/issues/576#issuecomment-1178515224
    maybe2(() => global) || // Otherwise, use a dummy host that's local to this module. We used to fall
    // back to using the Array constructor as a namespace, but that was flagged in
    // https://github.com/benjamn/wryware/issues/347, and can be avoided.
    /* @__PURE__ */ Object.create(null)
  );
  var globalHost = host;
  var Slot = globalHost[globalKey] || // Earlier versions of this package stored the globalKey property on the Array
  // constructor, so we check there as well, to prevent Slot class duplication.
  Array[globalKey] || (function(Slot2) {
    try {
      Object.defineProperty(globalHost, globalKey, {
        value: Slot2,
        enumerable: false,
        writable: false,
        // When it was possible for globalHost to be the Array constructor (a
        // legacy Slot dedup strategy), it was important for the property to be
        // configurable:true so it could be deleted. That does not seem to be as
        // important when globalHost is the global object, but I don't want to
        // cause similar problems again, and configurable:true seems safest.
        // https://github.com/endojs/endo/issues/576#issuecomment-1178274008
        configurable: true
      });
    } finally {
      return Slot2;
    }
  })(makeSlotClass());

  // node_modules/@wry/context/lib/index.js
  var { bind: bind12, noContext } = Slot;

  // node_modules/optimism/lib/context.js
  var parentEntrySlot = new Slot();

  // node_modules/optimism/lib/helpers.js
  var { hasOwnProperty: hasOwnProperty2 } = Object.prototype;
  var arrayFromSet = Array.from || function(set) {
    const array = [];
    set.forEach((item) => array.push(item));
    return array;
  };
  function maybeUnsubscribe(entryOrDep) {
    const { unsubscribe } = entryOrDep;
    if (typeof unsubscribe === "function") {
      entryOrDep.unsubscribe = void 0;
      unsubscribe();
    }
  }

  // node_modules/optimism/lib/entry.js
  var emptySetPool = [];
  var POOL_TARGET_SIZE = 100;
  function assert(condition, optionalMessage) {
    if (!condition) {
      throw new Error(optionalMessage || "assertion failure");
    }
  }
  function valueIs(a, b) {
    const len = a.length;
    return (
      // Unknown values are not equal to each other.
      len > 0 && // Both values must be ordinary (or both exceptional) to be equal.
      len === b.length && // The underlying value or exception must be the same.
      a[len - 1] === b[len - 1]
    );
  }
  function valueGet(value) {
    switch (value.length) {
      case 0:
        throw new Error("unknown value");
      case 1:
        return value[0];
      case 2:
        throw value[1];
    }
  }
  function valueCopy(value) {
    return value.slice(0);
  }
  var Entry = class _Entry {
    constructor(fn2) {
      this.fn = fn2;
      this.parents = /* @__PURE__ */ new Set();
      this.childValues = /* @__PURE__ */ new Map();
      this.dirtyChildren = null;
      this.dirty = true;
      this.recomputing = false;
      this.value = [];
      this.deps = null;
      ++_Entry.count;
    }
    peek() {
      if (this.value.length === 1 && !mightBeDirty(this)) {
        rememberParent(this);
        return this.value[0];
      }
    }
    // This is the most important method of the Entry API, because it
    // determines whether the cached this.value can be returned immediately,
    // or must be recomputed. The overall performance of the caching system
    // depends on the truth of the following observations: (1) this.dirty is
    // usually false, (2) this.dirtyChildren is usually null/empty, and thus
    // (3) valueGet(this.value) is usually returned without recomputation.
    recompute(args) {
      assert(!this.recomputing, "already recomputing");
      rememberParent(this);
      return mightBeDirty(this) ? reallyRecompute(this, args) : valueGet(this.value);
    }
    setDirty() {
      if (this.dirty)
        return;
      this.dirty = true;
      reportDirty(this);
      maybeUnsubscribe(this);
    }
    dispose() {
      this.setDirty();
      forgetChildren(this);
      eachParent(this, (parent, child) => {
        parent.setDirty();
        forgetChild(parent, this);
      });
    }
    forget() {
      this.dispose();
    }
    dependOn(dep2) {
      dep2.add(this);
      if (!this.deps) {
        this.deps = emptySetPool.pop() || /* @__PURE__ */ new Set();
      }
      this.deps.add(dep2);
    }
    forgetDeps() {
      if (this.deps) {
        arrayFromSet(this.deps).forEach((dep2) => dep2.delete(this));
        this.deps.clear();
        emptySetPool.push(this.deps);
        this.deps = null;
      }
    }
  };
  Entry.count = 0;
  function rememberParent(child) {
    const parent = parentEntrySlot.getValue();
    if (parent) {
      child.parents.add(parent);
      if (!parent.childValues.has(child)) {
        parent.childValues.set(child, []);
      }
      if (mightBeDirty(child)) {
        reportDirtyChild(parent, child);
      } else {
        reportCleanChild(parent, child);
      }
      return parent;
    }
  }
  function reallyRecompute(entry, args) {
    forgetChildren(entry);
    parentEntrySlot.withValue(entry, recomputeNewValue, [entry, args]);
    if (maybeSubscribe(entry, args)) {
      setClean(entry);
    }
    return valueGet(entry.value);
  }
  function recomputeNewValue(entry, args) {
    entry.recomputing = true;
    const { normalizeResult } = entry;
    let oldValueCopy;
    if (normalizeResult && entry.value.length === 1) {
      oldValueCopy = valueCopy(entry.value);
    }
    entry.value.length = 0;
    try {
      entry.value[0] = entry.fn.apply(null, args);
      if (normalizeResult && oldValueCopy && !valueIs(oldValueCopy, entry.value)) {
        try {
          entry.value[0] = normalizeResult(entry.value[0], oldValueCopy[0]);
        } catch (_a2) {
        }
      }
    } catch (e) {
      entry.value[1] = e;
    }
    entry.recomputing = false;
  }
  function mightBeDirty(entry) {
    return entry.dirty || !!(entry.dirtyChildren && entry.dirtyChildren.size);
  }
  function setClean(entry) {
    entry.dirty = false;
    if (mightBeDirty(entry)) {
      return;
    }
    reportClean(entry);
  }
  function reportDirty(child) {
    eachParent(child, reportDirtyChild);
  }
  function reportClean(child) {
    eachParent(child, reportCleanChild);
  }
  function eachParent(child, callback) {
    const parentCount = child.parents.size;
    if (parentCount) {
      const parents = arrayFromSet(child.parents);
      for (let i = 0; i < parentCount; ++i) {
        callback(parents[i], child);
      }
    }
  }
  function reportDirtyChild(parent, child) {
    assert(parent.childValues.has(child));
    assert(mightBeDirty(child));
    const parentWasClean = !mightBeDirty(parent);
    if (!parent.dirtyChildren) {
      parent.dirtyChildren = emptySetPool.pop() || /* @__PURE__ */ new Set();
    } else if (parent.dirtyChildren.has(child)) {
      return;
    }
    parent.dirtyChildren.add(child);
    if (parentWasClean) {
      reportDirty(parent);
    }
  }
  function reportCleanChild(parent, child) {
    assert(parent.childValues.has(child));
    assert(!mightBeDirty(child));
    const childValue = parent.childValues.get(child);
    if (childValue.length === 0) {
      parent.childValues.set(child, valueCopy(child.value));
    } else if (!valueIs(childValue, child.value)) {
      parent.setDirty();
    }
    removeDirtyChild(parent, child);
    if (mightBeDirty(parent)) {
      return;
    }
    reportClean(parent);
  }
  function removeDirtyChild(parent, child) {
    const dc = parent.dirtyChildren;
    if (dc) {
      dc.delete(child);
      if (dc.size === 0) {
        if (emptySetPool.length < POOL_TARGET_SIZE) {
          emptySetPool.push(dc);
        }
        parent.dirtyChildren = null;
      }
    }
  }
  function forgetChildren(parent) {
    if (parent.childValues.size > 0) {
      parent.childValues.forEach((_value, child) => {
        forgetChild(parent, child);
      });
    }
    parent.forgetDeps();
    assert(parent.dirtyChildren === null);
  }
  function forgetChild(parent, child) {
    child.parents.delete(parent);
    parent.childValues.delete(child);
    removeDirtyChild(parent, child);
  }
  function maybeSubscribe(entry, args) {
    if (typeof entry.subscribe === "function") {
      try {
        maybeUnsubscribe(entry);
        entry.unsubscribe = entry.subscribe.apply(null, args);
      } catch (e) {
        entry.setDirty();
        return false;
      }
    }
    return true;
  }

  // node_modules/optimism/lib/dep.js
  var EntryMethods = {
    setDirty: true,
    dispose: true,
    forget: true
    // Fully remove parent Entry from LRU cache and computation graph
  };
  function dep(options2) {
    const depsByKey = /* @__PURE__ */ new Map();
    const subscribe = options2 && options2.subscribe;
    function depend(key) {
      const parent = parentEntrySlot.getValue();
      if (parent) {
        let dep2 = depsByKey.get(key);
        if (!dep2) {
          depsByKey.set(key, dep2 = /* @__PURE__ */ new Set());
        }
        parent.dependOn(dep2);
        if (typeof subscribe === "function") {
          maybeUnsubscribe(dep2);
          dep2.unsubscribe = subscribe(key);
        }
      }
    }
    depend.dirty = function dirty(key, entryMethodName) {
      const dep2 = depsByKey.get(key);
      if (dep2) {
        const m = entryMethodName && hasOwnProperty2.call(EntryMethods, entryMethodName) ? entryMethodName : "setDirty";
        arrayFromSet(dep2).forEach((entry) => entry[m]());
        depsByKey.delete(key);
        maybeUnsubscribe(dep2);
      }
    };
    return depend;
  }

  // node_modules/optimism/lib/index.js
  var defaultKeyTrie;
  function defaultMakeCacheKey(...args) {
    const trie = defaultKeyTrie || (defaultKeyTrie = new Trie(typeof WeakMap === "function"));
    return trie.lookupArray(args);
  }
  var caches = /* @__PURE__ */ new Set();
  function wrap3(originalFunction, { max: max3 = Math.pow(2, 16), keyArgs, makeCacheKey = defaultMakeCacheKey, normalizeResult, subscribe, cache: cacheOption = StrongCache } = /* @__PURE__ */ Object.create(null)) {
    const cache = typeof cacheOption === "function" ? new cacheOption(max3, (entry) => entry.dispose()) : cacheOption;
    const optimistic = function() {
      const key = makeCacheKey.apply(null, keyArgs ? keyArgs.apply(null, arguments) : arguments);
      if (key === void 0) {
        return originalFunction.apply(null, arguments);
      }
      let entry = cache.get(key);
      if (!entry) {
        cache.set(key, entry = new Entry(originalFunction));
        entry.normalizeResult = normalizeResult;
        entry.subscribe = subscribe;
        entry.forget = () => cache.delete(key);
      }
      const value = entry.recompute(Array.prototype.slice.call(arguments));
      cache.set(key, entry);
      caches.add(cache);
      if (!parentEntrySlot.hasValue()) {
        caches.forEach((cache2) => cache2.clean());
        caches.clear();
      }
      return value;
    };
    Object.defineProperty(optimistic, "size", {
      get: () => cache.size,
      configurable: false,
      enumerable: false
    });
    Object.freeze(optimistic.options = {
      max: max3,
      keyArgs,
      makeCacheKey,
      normalizeResult,
      subscribe,
      cache
    });
    function dirtyKey(key) {
      const entry = key && cache.get(key);
      if (entry) {
        entry.setDirty();
      }
    }
    optimistic.dirtyKey = dirtyKey;
    optimistic.dirty = function dirty() {
      dirtyKey(makeCacheKey.apply(null, arguments));
    };
    function peekKey(key) {
      const entry = key && cache.get(key);
      if (entry) {
        return entry.peek();
      }
    }
    optimistic.peekKey = peekKey;
    optimistic.peek = function peek2() {
      return peekKey(makeCacheKey.apply(null, arguments));
    };
    function forgetKey(key) {
      return key ? cache.delete(key) : false;
    }
    optimistic.forgetKey = forgetKey;
    optimistic.forget = function forget() {
      return forgetKey(makeCacheKey.apply(null, arguments));
    };
    optimistic.makeCacheKey = makeCacheKey;
    optimistic.getKey = keyArgs ? function getKey() {
      return makeCacheKey.apply(null, keyArgs.apply(null, arguments));
    } : makeCacheKey;
    return Object.freeze(optimistic);
  }

  // node_modules/@apollo/client/utilities/graphql/DocumentTransform.js
  function identity(document2) {
    return document2;
  }
  var DocumentTransform = (
    /** @class */
    (function() {
      function DocumentTransform2(transform, options2) {
        if (options2 === void 0) {
          options2 = /* @__PURE__ */ Object.create(null);
        }
        this.resultCache = canUseWeakSet ? /* @__PURE__ */ new WeakSet() : /* @__PURE__ */ new Set();
        this.transform = transform;
        if (options2.getCacheKey) {
          this.getCacheKey = options2.getCacheKey;
        }
        this.cached = options2.cache !== false;
        this.resetCache();
      }
      DocumentTransform2.prototype.getCacheKey = function(document2) {
        return [document2];
      };
      DocumentTransform2.identity = function() {
        return new DocumentTransform2(identity, { cache: false });
      };
      DocumentTransform2.split = function(predicate, left2, right2) {
        if (right2 === void 0) {
          right2 = DocumentTransform2.identity();
        }
        return Object.assign(new DocumentTransform2(
          function(document2) {
            var documentTransform = predicate(document2) ? left2 : right2;
            return documentTransform.transformDocument(document2);
          },
          // Reasonably assume both `left` and `right` transforms handle their own caching
          { cache: false }
        ), { left: left2, right: right2 });
      };
      DocumentTransform2.prototype.resetCache = function() {
        var _this = this;
        if (this.cached) {
          var stableCacheKeys_1 = new Trie(canUseWeakMap);
          this.performWork = wrap3(DocumentTransform2.prototype.performWork.bind(this), {
            makeCacheKey: function(document2) {
              var cacheKeys = _this.getCacheKey(document2);
              if (cacheKeys) {
                invariant3(Array.isArray(cacheKeys), 77);
                return stableCacheKeys_1.lookupArray(cacheKeys);
              }
            },
            max: cacheSizes["documentTransform.cache"],
            cache: WeakCache
          });
        }
      };
      DocumentTransform2.prototype.performWork = function(document2) {
        checkDocument(document2);
        return this.transform(document2);
      };
      DocumentTransform2.prototype.transformDocument = function(document2) {
        if (this.resultCache.has(document2)) {
          return document2;
        }
        var transformedDocument = this.performWork(document2);
        this.resultCache.add(transformedDocument);
        return transformedDocument;
      };
      DocumentTransform2.prototype.concat = function(otherTransform) {
        var _this = this;
        return Object.assign(new DocumentTransform2(
          function(document2) {
            return otherTransform.transformDocument(_this.transformDocument(document2));
          },
          // Reasonably assume both transforms handle their own caching
          { cache: false }
        ), {
          left: this,
          right: otherTransform
        });
      };
      return DocumentTransform2;
    })()
  );

  // node_modules/@apollo/client/utilities/graphql/print.js
  var printCache;
  var print2 = Object.assign(function(ast) {
    var result2 = printCache.get(ast);
    if (!result2) {
      result2 = print(ast);
      printCache.set(ast, result2);
    }
    return result2;
  }, {
    reset: function() {
      printCache = new AutoCleanedWeakCache(
        cacheSizes.print || 2e3
        /* defaultCacheSizes.print */
      );
    }
  });
  print2.reset();
  if (globalThis.__DEV__ !== false) {
    registerGlobalCache("print", function() {
      return printCache ? printCache.size : 0;
    });
  }

  // node_modules/@apollo/client/utilities/common/arrays.js
  var isArray2 = Array.isArray;
  function isNonEmptyArray(value) {
    return Array.isArray(value) && value.length > 0;
  }

  // node_modules/@apollo/client/utilities/graphql/transform.js
  var TYPENAME_FIELD = {
    kind: Kind.FIELD,
    name: {
      kind: Kind.NAME,
      value: "__typename"
    }
  };
  function isEmpty(op, fragmentMap) {
    return !op || op.selectionSet.selections.every(function(selection) {
      return selection.kind === Kind.FRAGMENT_SPREAD && isEmpty(fragmentMap[selection.name.value], fragmentMap);
    });
  }
  function nullIfDocIsEmpty(doc) {
    return isEmpty(getOperationDefinition(doc) || getFragmentDefinition(doc), createFragmentMap(getFragmentDefinitions(doc))) ? null : doc;
  }
  function getDirectiveMatcher(configs) {
    var names = /* @__PURE__ */ new Map();
    var tests = /* @__PURE__ */ new Map();
    configs.forEach(function(directive) {
      if (directive) {
        if (directive.name) {
          names.set(directive.name, directive);
        } else if (directive.test) {
          tests.set(directive.test, directive);
        }
      }
    });
    return function(directive) {
      var config = names.get(directive.name.value);
      if (!config && tests.size) {
        tests.forEach(function(testConfig, test) {
          if (test(directive)) {
            config = testConfig;
          }
        });
      }
      return config;
    };
  }
  function makeInUseGetterFunction(defaultKey) {
    var map = /* @__PURE__ */ new Map();
    return function inUseGetterFunction(key) {
      if (key === void 0) {
        key = defaultKey;
      }
      var inUse = map.get(key);
      if (!inUse) {
        map.set(key, inUse = {
          // Variable and fragment spread names used directly within this
          // operation or fragment definition, as identified by key. These sets
          // will be populated during the first traversal of the document in
          // removeDirectivesFromDocument below.
          variables: /* @__PURE__ */ new Set(),
          fragmentSpreads: /* @__PURE__ */ new Set()
        });
      }
      return inUse;
    };
  }
  function removeDirectivesFromDocument(directives, doc) {
    checkDocument(doc);
    var getInUseByOperationName = makeInUseGetterFunction("");
    var getInUseByFragmentName = makeInUseGetterFunction("");
    var getInUse = function(ancestors) {
      for (var p = 0, ancestor = void 0; p < ancestors.length && (ancestor = ancestors[p]); ++p) {
        if (isArray2(ancestor))
          continue;
        if (ancestor.kind === Kind.OPERATION_DEFINITION) {
          return getInUseByOperationName(ancestor.name && ancestor.name.value);
        }
        if (ancestor.kind === Kind.FRAGMENT_DEFINITION) {
          return getInUseByFragmentName(ancestor.name.value);
        }
      }
      globalThis.__DEV__ !== false && invariant3.error(97);
      return null;
    };
    var operationCount = 0;
    for (var i = doc.definitions.length - 1; i >= 0; --i) {
      if (doc.definitions[i].kind === Kind.OPERATION_DEFINITION) {
        ++operationCount;
      }
    }
    var directiveMatcher = getDirectiveMatcher(directives);
    var shouldRemoveField = function(nodeDirectives) {
      return isNonEmptyArray(nodeDirectives) && nodeDirectives.map(directiveMatcher).some(function(config) {
        return config && config.remove;
      });
    };
    var originalFragmentDefsByPath = /* @__PURE__ */ new Map();
    var firstVisitMadeChanges = false;
    var fieldOrInlineFragmentVisitor = {
      enter: function(node2) {
        if (shouldRemoveField(node2.directives)) {
          firstVisitMadeChanges = true;
          return null;
        }
      }
    };
    var docWithoutDirectiveSubtrees = visit(doc, {
      // These two AST node types share the same implementation, defined above.
      Field: fieldOrInlineFragmentVisitor,
      InlineFragment: fieldOrInlineFragmentVisitor,
      VariableDefinition: {
        enter: function() {
          return false;
        }
      },
      Variable: {
        enter: function(node2, _key, _parent, _path, ancestors) {
          var inUse = getInUse(ancestors);
          if (inUse) {
            inUse.variables.add(node2.name.value);
          }
        }
      },
      FragmentSpread: {
        enter: function(node2, _key, _parent, _path, ancestors) {
          if (shouldRemoveField(node2.directives)) {
            firstVisitMadeChanges = true;
            return null;
          }
          var inUse = getInUse(ancestors);
          if (inUse) {
            inUse.fragmentSpreads.add(node2.name.value);
          }
        }
      },
      FragmentDefinition: {
        enter: function(node2, _key, _parent, path) {
          originalFragmentDefsByPath.set(JSON.stringify(path), node2);
        },
        leave: function(node2, _key, _parent, path) {
          var originalNode = originalFragmentDefsByPath.get(JSON.stringify(path));
          if (node2 === originalNode) {
            return node2;
          }
          if (
            // This logic applies only if the document contains one or more
            // operations, since removing all fragments from a document containing
            // only fragments makes the document useless.
            operationCount > 0 && node2.selectionSet.selections.every(function(selection) {
              return selection.kind === Kind.FIELD && selection.name.value === "__typename";
            })
          ) {
            getInUseByFragmentName(node2.name.value).removed = true;
            firstVisitMadeChanges = true;
            return null;
          }
        }
      },
      Directive: {
        leave: function(node2) {
          if (directiveMatcher(node2)) {
            firstVisitMadeChanges = true;
            return null;
          }
        }
      }
    });
    if (!firstVisitMadeChanges) {
      return doc;
    }
    var populateTransitiveVars = function(inUse) {
      if (!inUse.transitiveVars) {
        inUse.transitiveVars = new Set(inUse.variables);
        if (!inUse.removed) {
          inUse.fragmentSpreads.forEach(function(childFragmentName) {
            populateTransitiveVars(getInUseByFragmentName(childFragmentName)).transitiveVars.forEach(function(varName) {
              inUse.transitiveVars.add(varName);
            });
          });
        }
      }
      return inUse;
    };
    var allFragmentNamesUsed = /* @__PURE__ */ new Set();
    docWithoutDirectiveSubtrees.definitions.forEach(function(def) {
      if (def.kind === Kind.OPERATION_DEFINITION) {
        populateTransitiveVars(getInUseByOperationName(def.name && def.name.value)).fragmentSpreads.forEach(function(childFragmentName) {
          allFragmentNamesUsed.add(childFragmentName);
        });
      } else if (def.kind === Kind.FRAGMENT_DEFINITION && // If there are no operations in the document, then all fragment
      // definitions count as usages of their own fragment names. This heuristic
      // prevents accidentally removing all fragment definitions from the
      // document just because it contains no operations that use the fragments.
      operationCount === 0 && !getInUseByFragmentName(def.name.value).removed) {
        allFragmentNamesUsed.add(def.name.value);
      }
    });
    allFragmentNamesUsed.forEach(function(fragmentName) {
      populateTransitiveVars(getInUseByFragmentName(fragmentName)).fragmentSpreads.forEach(function(childFragmentName) {
        allFragmentNamesUsed.add(childFragmentName);
      });
    });
    var fragmentWillBeRemoved = function(fragmentName) {
      return !!// A fragment definition will be removed if there are no spreads that refer
      // to it, or the fragment was explicitly removed because it had no fields
      // other than __typename.
      (!allFragmentNamesUsed.has(fragmentName) || getInUseByFragmentName(fragmentName).removed);
    };
    var enterVisitor = {
      enter: function(node2) {
        if (fragmentWillBeRemoved(node2.name.value)) {
          return null;
        }
      }
    };
    return nullIfDocIsEmpty(visit(docWithoutDirectiveSubtrees, {
      // If the fragment is going to be removed, then leaving any dangling
      // FragmentSpread nodes with the same name would be a mistake.
      FragmentSpread: enterVisitor,
      // This is where the fragment definition is actually removed.
      FragmentDefinition: enterVisitor,
      OperationDefinition: {
        leave: function(node2) {
          if (node2.variableDefinitions) {
            var usedVariableNames_1 = populateTransitiveVars(
              // If an operation is anonymous, we use the empty string as its key.
              getInUseByOperationName(node2.name && node2.name.value)
            ).transitiveVars;
            if (usedVariableNames_1.size < node2.variableDefinitions.length) {
              return __assign(__assign({}, node2), { variableDefinitions: node2.variableDefinitions.filter(function(varDef) {
                return usedVariableNames_1.has(varDef.variable.name.value);
              }) });
            }
          }
        }
      }
    }));
  }
  var addTypenameToDocument = Object.assign(function(doc) {
    return visit(doc, {
      SelectionSet: {
        enter: function(node2, _key, parent) {
          if (parent && parent.kind === Kind.OPERATION_DEFINITION) {
            return;
          }
          var selections = node2.selections;
          if (!selections) {
            return;
          }
          var skip = selections.some(function(selection) {
            return isField(selection) && (selection.name.value === "__typename" || selection.name.value.lastIndexOf("__", 0) === 0);
          });
          if (skip) {
            return;
          }
          var field = parent;
          if (isField(field) && field.directives && field.directives.some(function(d) {
            return d.name.value === "export";
          })) {
            return;
          }
          return __assign(__assign({}, node2), { selections: __spreadArray(__spreadArray([], selections, true), [TYPENAME_FIELD], false) });
        }
      }
    });
  }, {
    added: function(field) {
      return field === TYPENAME_FIELD;
    }
  });
  function buildQueryFromSelectionSet(document2) {
    var definition = getMainDefinition(document2);
    var definitionOperation = definition.operation;
    if (definitionOperation === "query") {
      return document2;
    }
    var modifiedDoc = visit(document2, {
      OperationDefinition: {
        enter: function(node2) {
          return __assign(__assign({}, node2), { operation: "query" });
        }
      }
    });
    return modifiedDoc;
  }
  function removeClientSetsFromDocument(document2) {
    checkDocument(document2);
    var modifiedDoc = removeDirectivesFromDocument([
      {
        test: function(directive) {
          return directive.name.value === "client";
        },
        remove: true
      }
    ], document2);
    return modifiedDoc;
  }
  function addNonReactiveToNamedFragments(document2) {
    checkDocument(document2);
    return visit(document2, {
      FragmentSpread: function(node2) {
        var _a2;
        if ((_a2 = node2.directives) === null || _a2 === void 0 ? void 0 : _a2.some(function(directive) {
          return directive.name.value === "unmask";
        })) {
          return;
        }
        return __assign(__assign({}, node2), { directives: __spreadArray(__spreadArray([], node2.directives || [], true), [
          {
            kind: Kind.DIRECTIVE,
            name: { kind: Kind.NAME, value: "nonreactive" }
          }
        ], false) });
      }
    });
  }

  // node_modules/@apollo/client/utilities/common/mergeDeep.js
  var hasOwnProperty3 = Object.prototype.hasOwnProperty;
  function mergeDeep() {
    var sources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      sources[_i] = arguments[_i];
    }
    return mergeDeepArray(sources);
  }
  function mergeDeepArray(sources) {
    var target = sources[0] || {};
    var count = sources.length;
    if (count > 1) {
      var merger = new DeepMerger();
      for (var i = 1; i < count; ++i) {
        target = merger.merge(target, sources[i]);
      }
    }
    return target;
  }
  var defaultReconciler = function(target, source2, property) {
    return this.merge(target[property], source2[property]);
  };
  var DeepMerger = (
    /** @class */
    (function() {
      function DeepMerger2(reconciler) {
        if (reconciler === void 0) {
          reconciler = defaultReconciler;
        }
        this.reconciler = reconciler;
        this.isObject = isNonNullObject;
        this.pastCopies = /* @__PURE__ */ new Set();
      }
      DeepMerger2.prototype.merge = function(target, source2) {
        var _this = this;
        var context = [];
        for (var _i = 2; _i < arguments.length; _i++) {
          context[_i - 2] = arguments[_i];
        }
        if (isNonNullObject(source2) && isNonNullObject(target)) {
          Object.keys(source2).forEach(function(sourceKey) {
            if (hasOwnProperty3.call(target, sourceKey)) {
              var targetValue = target[sourceKey];
              if (source2[sourceKey] !== targetValue) {
                var result2 = _this.reconciler.apply(_this, __spreadArray([
                  target,
                  source2,
                  sourceKey
                ], context, false));
                if (result2 !== targetValue) {
                  target = _this.shallowCopyForMerge(target);
                  target[sourceKey] = result2;
                }
              }
            } else {
              target = _this.shallowCopyForMerge(target);
              target[sourceKey] = source2[sourceKey];
            }
          });
          return target;
        }
        return source2;
      };
      DeepMerger2.prototype.shallowCopyForMerge = function(value) {
        if (isNonNullObject(value)) {
          if (!this.pastCopies.has(value)) {
            if (Array.isArray(value)) {
              value = value.slice(0);
            } else {
              value = __assign({ __proto__: Object.getPrototypeOf(value) }, value);
            }
            this.pastCopies.add(value);
          }
        }
        return value;
      };
      return DeepMerger2;
    })()
  );

  // node_modules/zen-observable-ts/module.js
  function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (it) return (it = it.call(o)).next.bind(it);
    if (Array.isArray(o) || (it = _unsupportedIterableToArray5(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      return function() {
        if (i >= o.length) return { done: true };
        return { done: false, value: o[i++] };
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _unsupportedIterableToArray5(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray5(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray5(o, minLen);
  }
  function _arrayLikeToArray5(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  function _defineProperties2(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass2(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties2(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties2(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", { writable: false });
    return Constructor;
  }
  var hasSymbols = function() {
    return typeof Symbol === "function";
  };
  var hasSymbol = function(name) {
    return hasSymbols() && Boolean(Symbol[name]);
  };
  var getSymbol = function(name) {
    return hasSymbol(name) ? Symbol[name] : "@@" + name;
  };
  if (hasSymbols() && !hasSymbol("observable")) {
    Symbol.observable = Symbol("observable");
  }
  var SymbolIterator = getSymbol("iterator");
  var SymbolObservable = getSymbol("observable");
  var SymbolSpecies = getSymbol("species");
  function getMethod(obj, key) {
    var value = obj[key];
    if (value == null) return void 0;
    if (typeof value !== "function") throw new TypeError(value + " is not a function");
    return value;
  }
  function getSpecies(obj) {
    var ctor = obj.constructor;
    if (ctor !== void 0) {
      ctor = ctor[SymbolSpecies];
      if (ctor === null) {
        ctor = void 0;
      }
    }
    return ctor !== void 0 ? ctor : Observable;
  }
  function isObservable(x) {
    return x instanceof Observable;
  }
  function hostReportError(e) {
    if (hostReportError.log) {
      hostReportError.log(e);
    } else {
      setTimeout(function() {
        throw e;
      });
    }
  }
  function enqueue(fn2) {
    Promise.resolve().then(function() {
      try {
        fn2();
      } catch (e) {
        hostReportError(e);
      }
    });
  }
  function cleanupSubscription(subscription) {
    var cleanup = subscription._cleanup;
    if (cleanup === void 0) return;
    subscription._cleanup = void 0;
    if (!cleanup) {
      return;
    }
    try {
      if (typeof cleanup === "function") {
        cleanup();
      } else {
        var unsubscribe = getMethod(cleanup, "unsubscribe");
        if (unsubscribe) {
          unsubscribe.call(cleanup);
        }
      }
    } catch (e) {
      hostReportError(e);
    }
  }
  function closeSubscription(subscription) {
    subscription._observer = void 0;
    subscription._queue = void 0;
    subscription._state = "closed";
  }
  function flushSubscription(subscription) {
    var queue = subscription._queue;
    if (!queue) {
      return;
    }
    subscription._queue = void 0;
    subscription._state = "ready";
    for (var i = 0; i < queue.length; ++i) {
      notifySubscription(subscription, queue[i].type, queue[i].value);
      if (subscription._state === "closed") break;
    }
  }
  function notifySubscription(subscription, type, value) {
    subscription._state = "running";
    var observer = subscription._observer;
    try {
      var m = getMethod(observer, type);
      switch (type) {
        case "next":
          if (m) m.call(observer, value);
          break;
        case "error":
          closeSubscription(subscription);
          if (m) m.call(observer, value);
          else throw value;
          break;
        case "complete":
          closeSubscription(subscription);
          if (m) m.call(observer);
          break;
      }
    } catch (e) {
      hostReportError(e);
    }
    if (subscription._state === "closed") cleanupSubscription(subscription);
    else if (subscription._state === "running") subscription._state = "ready";
  }
  function onNotify(subscription, type, value) {
    if (subscription._state === "closed") return;
    if (subscription._state === "buffering") {
      subscription._queue.push({
        type,
        value
      });
      return;
    }
    if (subscription._state !== "ready") {
      subscription._state = "buffering";
      subscription._queue = [{
        type,
        value
      }];
      enqueue(function() {
        return flushSubscription(subscription);
      });
      return;
    }
    notifySubscription(subscription, type, value);
  }
  var Subscription = /* @__PURE__ */ (function() {
    function Subscription2(observer, subscriber) {
      this._cleanup = void 0;
      this._observer = observer;
      this._queue = void 0;
      this._state = "initializing";
      var subscriptionObserver = new SubscriptionObserver(this);
      try {
        this._cleanup = subscriber.call(void 0, subscriptionObserver);
      } catch (e) {
        subscriptionObserver.error(e);
      }
      if (this._state === "initializing") this._state = "ready";
    }
    var _proto = Subscription2.prototype;
    _proto.unsubscribe = function unsubscribe() {
      if (this._state !== "closed") {
        closeSubscription(this);
        cleanupSubscription(this);
      }
    };
    _createClass2(Subscription2, [{
      key: "closed",
      get: function() {
        return this._state === "closed";
      }
    }]);
    return Subscription2;
  })();
  var SubscriptionObserver = /* @__PURE__ */ (function() {
    function SubscriptionObserver2(subscription) {
      this._subscription = subscription;
    }
    var _proto2 = SubscriptionObserver2.prototype;
    _proto2.next = function next2(value) {
      onNotify(this._subscription, "next", value);
    };
    _proto2.error = function error(value) {
      onNotify(this._subscription, "error", value);
    };
    _proto2.complete = function complete() {
      onNotify(this._subscription, "complete");
    };
    _createClass2(SubscriptionObserver2, [{
      key: "closed",
      get: function() {
        return this._subscription._state === "closed";
      }
    }]);
    return SubscriptionObserver2;
  })();
  var Observable = /* @__PURE__ */ (function() {
    function Observable2(subscriber) {
      if (!(this instanceof Observable2)) throw new TypeError("Observable cannot be called as a function");
      if (typeof subscriber !== "function") throw new TypeError("Observable initializer must be a function");
      this._subscriber = subscriber;
    }
    var _proto3 = Observable2.prototype;
    _proto3.subscribe = function subscribe(observer) {
      if (typeof observer !== "object" || observer === null) {
        observer = {
          next: observer,
          error: arguments[1],
          complete: arguments[2]
        };
      }
      return new Subscription(observer, this._subscriber);
    };
    _proto3.forEach = function forEach2(fn2) {
      var _this = this;
      return new Promise(function(resolve, reject) {
        if (typeof fn2 !== "function") {
          reject(new TypeError(fn2 + " is not a function"));
          return;
        }
        function done() {
          subscription.unsubscribe();
          resolve();
        }
        var subscription = _this.subscribe({
          next: function(value) {
            try {
              fn2(value, done);
            } catch (e) {
              reject(e);
              subscription.unsubscribe();
            }
          },
          error: reject,
          complete: resolve
        });
      });
    };
    _proto3.map = function map(fn2) {
      var _this2 = this;
      if (typeof fn2 !== "function") throw new TypeError(fn2 + " is not a function");
      var C = getSpecies(this);
      return new C(function(observer) {
        return _this2.subscribe({
          next: function(value) {
            try {
              value = fn2(value);
            } catch (e) {
              return observer.error(e);
            }
            observer.next(value);
          },
          error: function(e) {
            observer.error(e);
          },
          complete: function() {
            observer.complete();
          }
        });
      });
    };
    _proto3.filter = function filter(fn2) {
      var _this3 = this;
      if (typeof fn2 !== "function") throw new TypeError(fn2 + " is not a function");
      var C = getSpecies(this);
      return new C(function(observer) {
        return _this3.subscribe({
          next: function(value) {
            try {
              if (!fn2(value)) return;
            } catch (e) {
              return observer.error(e);
            }
            observer.next(value);
          },
          error: function(e) {
            observer.error(e);
          },
          complete: function() {
            observer.complete();
          }
        });
      });
    };
    _proto3.reduce = function reduce(fn2) {
      var _this4 = this;
      if (typeof fn2 !== "function") throw new TypeError(fn2 + " is not a function");
      var C = getSpecies(this);
      var hasSeed = arguments.length > 1;
      var hasValue = false;
      var seed = arguments[1];
      var acc = seed;
      return new C(function(observer) {
        return _this4.subscribe({
          next: function(value) {
            var first = !hasValue;
            hasValue = true;
            if (!first || hasSeed) {
              try {
                acc = fn2(acc, value);
              } catch (e) {
                return observer.error(e);
              }
            } else {
              acc = value;
            }
          },
          error: function(e) {
            observer.error(e);
          },
          complete: function() {
            if (!hasValue && !hasSeed) return observer.error(new TypeError("Cannot reduce an empty sequence"));
            observer.next(acc);
            observer.complete();
          }
        });
      });
    };
    _proto3.concat = function concat() {
      var _this5 = this;
      for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {
        sources[_key] = arguments[_key];
      }
      var C = getSpecies(this);
      return new C(function(observer) {
        var subscription;
        var index2 = 0;
        function startNext(next2) {
          subscription = next2.subscribe({
            next: function(v) {
              observer.next(v);
            },
            error: function(e) {
              observer.error(e);
            },
            complete: function() {
              if (index2 === sources.length) {
                subscription = void 0;
                observer.complete();
              } else {
                startNext(C.from(sources[index2++]));
              }
            }
          });
        }
        startNext(_this5);
        return function() {
          if (subscription) {
            subscription.unsubscribe();
            subscription = void 0;
          }
        };
      });
    };
    _proto3.flatMap = function flatMap(fn2) {
      var _this6 = this;
      if (typeof fn2 !== "function") throw new TypeError(fn2 + " is not a function");
      var C = getSpecies(this);
      return new C(function(observer) {
        var subscriptions = [];
        var outer = _this6.subscribe({
          next: function(value) {
            if (fn2) {
              try {
                value = fn2(value);
              } catch (e) {
                return observer.error(e);
              }
            }
            var inner = C.from(value).subscribe({
              next: function(value2) {
                observer.next(value2);
              },
              error: function(e) {
                observer.error(e);
              },
              complete: function() {
                var i = subscriptions.indexOf(inner);
                if (i >= 0) subscriptions.splice(i, 1);
                completeIfDone();
              }
            });
            subscriptions.push(inner);
          },
          error: function(e) {
            observer.error(e);
          },
          complete: function() {
            completeIfDone();
          }
        });
        function completeIfDone() {
          if (outer.closed && subscriptions.length === 0) observer.complete();
        }
        return function() {
          subscriptions.forEach(function(s) {
            return s.unsubscribe();
          });
          outer.unsubscribe();
        };
      });
    };
    _proto3[SymbolObservable] = function() {
      return this;
    };
    Observable2.from = function from2(x) {
      var C = typeof this === "function" ? this : Observable2;
      if (x == null) throw new TypeError(x + " is not an object");
      var method = getMethod(x, SymbolObservable);
      if (method) {
        var observable = method.call(x);
        if (Object(observable) !== observable) throw new TypeError(observable + " is not an object");
        if (isObservable(observable) && observable.constructor === C) return observable;
        return new C(function(observer) {
          return observable.subscribe(observer);
        });
      }
      if (hasSymbol("iterator")) {
        method = getMethod(x, SymbolIterator);
        if (method) {
          return new C(function(observer) {
            enqueue(function() {
              if (observer.closed) return;
              for (var _iterator = _createForOfIteratorHelperLoose(method.call(x)), _step; !(_step = _iterator()).done; ) {
                var item = _step.value;
                observer.next(item);
                if (observer.closed) return;
              }
              observer.complete();
            });
          });
        }
      }
      if (Array.isArray(x)) {
        return new C(function(observer) {
          enqueue(function() {
            if (observer.closed) return;
            for (var i = 0; i < x.length; ++i) {
              observer.next(x[i]);
              if (observer.closed) return;
            }
            observer.complete();
          });
        });
      }
      throw new TypeError(x + " is not observable");
    };
    Observable2.of = function of() {
      for (var _len2 = arguments.length, items = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        items[_key2] = arguments[_key2];
      }
      var C = typeof this === "function" ? this : Observable2;
      return new C(function(observer) {
        enqueue(function() {
          if (observer.closed) return;
          for (var i = 0; i < items.length; ++i) {
            observer.next(items[i]);
            if (observer.closed) return;
          }
          observer.complete();
        });
      });
    };
    _createClass2(Observable2, null, [{
      key: SymbolSpecies,
      get: function() {
        return this;
      }
    }]);
    return Observable2;
  })();
  if (hasSymbols()) {
    Object.defineProperty(Observable, Symbol("extensions"), {
      value: {
        symbol: SymbolObservable,
        hostReportError
      },
      configurable: true
    });
  }

  // node_modules/symbol-observable/es/ponyfill.js
  function symbolObservablePonyfill(root2) {
    var result2;
    var Symbol2 = root2.Symbol;
    if (typeof Symbol2 === "function") {
      if (Symbol2.observable) {
        result2 = Symbol2.observable;
      } else {
        if (typeof Symbol2.for === "function") {
          result2 = Symbol2.for("https://github.com/benlesh/symbol-observable");
        } else {
          result2 = Symbol2("https://github.com/benlesh/symbol-observable");
        }
        try {
          Symbol2.observable = result2;
        } catch (err) {
        }
      }
    } else {
      result2 = "@@observable";
    }
    return result2;
  }

  // node_modules/symbol-observable/es/index.js
  var root;
  if (typeof self !== "undefined") {
    root = self;
  } else if (typeof window !== "undefined") {
    root = window;
  } else if (typeof global !== "undefined") {
    root = global;
  } else if (typeof module !== "undefined") {
    root = module;
  } else {
    root = Function("return this")();
  }
  var result = symbolObservablePonyfill(root);

  // node_modules/@apollo/client/utilities/observables/Observable.js
  var prototype = Observable.prototype;
  var fakeObsSymbol = "@@observable";
  if (!prototype[fakeObsSymbol]) {
    prototype[fakeObsSymbol] = function() {
      return this;
    };
  }

  // node_modules/@apollo/client/utilities/promises/preventUnhandledRejection.js
  function preventUnhandledRejection(promise) {
    promise.catch(function() {
    });
    return promise;
  }

  // node_modules/@apollo/client/utilities/common/cloneDeep.js
  var toString = Object.prototype.toString;
  function cloneDeep(value) {
    return cloneDeepHelper(value);
  }
  function cloneDeepHelper(val, seen) {
    switch (toString.call(val)) {
      case "[object Array]": {
        seen = seen || /* @__PURE__ */ new Map();
        if (seen.has(val))
          return seen.get(val);
        var copy_1 = val.slice(0);
        seen.set(val, copy_1);
        copy_1.forEach(function(child, i) {
          copy_1[i] = cloneDeepHelper(child, seen);
        });
        return copy_1;
      }
      case "[object Object]": {
        seen = seen || /* @__PURE__ */ new Map();
        if (seen.has(val))
          return seen.get(val);
        var copy_2 = Object.create(Object.getPrototypeOf(val));
        seen.set(val, copy_2);
        Object.keys(val).forEach(function(key) {
          copy_2[key] = cloneDeepHelper(val[key], seen);
        });
        return copy_2;
      }
      default:
        return val;
    }
  }

  // node_modules/@apollo/client/utilities/common/maybeDeepFreeze.js
  function deepFreeze(value) {
    var workSet = /* @__PURE__ */ new Set([value]);
    workSet.forEach(function(obj) {
      if (isNonNullObject(obj) && shallowFreeze(obj) === obj) {
        Object.getOwnPropertyNames(obj).forEach(function(name) {
          if (isNonNullObject(obj[name]))
            workSet.add(obj[name]);
        });
      }
    });
    return value;
  }
  function shallowFreeze(obj) {
    if (globalThis.__DEV__ !== false && !Object.isFrozen(obj)) {
      try {
        Object.freeze(obj);
      } catch (e) {
        if (e instanceof TypeError)
          return null;
        throw e;
      }
    }
    return obj;
  }
  function maybeDeepFreeze(obj) {
    if (globalThis.__DEV__ !== false) {
      deepFreeze(obj);
    }
    return obj;
  }

  // node_modules/@apollo/client/utilities/observables/iteration.js
  function iterateObserversSafely(observers, method, argument) {
    var observersWithMethod = [];
    observers.forEach(function(obs) {
      return obs[method] && observersWithMethod.push(obs);
    });
    observersWithMethod.forEach(function(obs) {
      return obs[method](argument);
    });
  }

  // node_modules/@apollo/client/utilities/observables/asyncMap.js
  function asyncMap(observable, mapFn, catchFn) {
    return new Observable(function(observer) {
      var promiseQueue = {
        // Normally we would initialize promiseQueue to Promise.resolve(), but
        // in this case, for backwards compatibility, we need to be careful to
        // invoke the first callback synchronously.
        then: function(callback) {
          return new Promise(function(resolve) {
            return resolve(callback());
          });
        }
      };
      function makeCallback(examiner, key) {
        return function(arg) {
          if (examiner) {
            var both = function() {
              return observer.closed ? (
                /* will be swallowed */
                0
              ) : examiner(arg);
            };
            promiseQueue = promiseQueue.then(both, both).then(function(result2) {
              return observer.next(result2);
            }, function(error) {
              return observer.error(error);
            });
          } else {
            observer[key](arg);
          }
        };
      }
      var handler = {
        next: makeCallback(mapFn, "next"),
        error: makeCallback(catchFn, "error"),
        complete: function() {
          promiseQueue.then(function() {
            return observer.complete();
          });
        }
      };
      var sub = observable.subscribe(handler);
      return function() {
        return sub.unsubscribe();
      };
    });
  }

  // node_modules/@apollo/client/utilities/observables/subclassing.js
  function fixObservableSubclass(subclass) {
    function set(key) {
      Object.defineProperty(subclass, key, { value: Observable });
    }
    if (canUseSymbol && Symbol.species) {
      set(Symbol.species);
    }
    set("@@species");
    return subclass;
  }

  // node_modules/@apollo/client/utilities/observables/Concast.js
  function isPromiseLike(value) {
    return value && typeof value.then === "function";
  }
  var Concast = (
    /** @class */
    (function(_super) {
      __extends(Concast2, _super);
      function Concast2(sources) {
        var _this = _super.call(this, function(observer) {
          _this.addObserver(observer);
          return function() {
            return _this.removeObserver(observer);
          };
        }) || this;
        _this.observers = /* @__PURE__ */ new Set();
        _this.promise = new Promise(function(resolve, reject) {
          _this.resolve = resolve;
          _this.reject = reject;
        });
        _this.handlers = {
          next: function(result2) {
            if (_this.sub !== null) {
              _this.latest = ["next", result2];
              _this.notify("next", result2);
              iterateObserversSafely(_this.observers, "next", result2);
            }
          },
          error: function(error) {
            var sub = _this.sub;
            if (sub !== null) {
              if (sub)
                setTimeout(function() {
                  return sub.unsubscribe();
                });
              _this.sub = null;
              _this.latest = ["error", error];
              _this.reject(error);
              _this.notify("error", error);
              iterateObserversSafely(_this.observers, "error", error);
            }
          },
          complete: function() {
            var _a2 = _this, sub = _a2.sub, _b = _a2.sources, sources2 = _b === void 0 ? [] : _b;
            if (sub !== null) {
              var value = sources2.shift();
              if (!value) {
                if (sub)
                  setTimeout(function() {
                    return sub.unsubscribe();
                  });
                _this.sub = null;
                if (_this.latest && _this.latest[0] === "next") {
                  _this.resolve(_this.latest[1]);
                } else {
                  _this.resolve();
                }
                _this.notify("complete");
                iterateObserversSafely(_this.observers, "complete");
              } else if (isPromiseLike(value)) {
                value.then(function(obs) {
                  return _this.sub = obs.subscribe(_this.handlers);
                }, _this.handlers.error);
              } else {
                _this.sub = value.subscribe(_this.handlers);
              }
            }
          }
        };
        _this.nextResultListeners = /* @__PURE__ */ new Set();
        _this.cancel = function(reason) {
          _this.reject(reason);
          _this.sources = [];
          _this.handlers.error(reason);
        };
        _this.promise.catch(function(_) {
        });
        if (typeof sources === "function") {
          sources = [new Observable(sources)];
        }
        if (isPromiseLike(sources)) {
          sources.then(function(iterable) {
            return _this.start(iterable);
          }, _this.handlers.error);
        } else {
          _this.start(sources);
        }
        return _this;
      }
      Concast2.prototype.start = function(sources) {
        if (this.sub !== void 0)
          return;
        this.sources = Array.from(sources);
        this.handlers.complete();
      };
      Concast2.prototype.deliverLastMessage = function(observer) {
        if (this.latest) {
          var nextOrError = this.latest[0];
          var method = observer[nextOrError];
          if (method) {
            method.call(observer, this.latest[1]);
          }
          if (this.sub === null && nextOrError === "next" && observer.complete) {
            observer.complete();
          }
        }
      };
      Concast2.prototype.addObserver = function(observer) {
        if (!this.observers.has(observer)) {
          this.deliverLastMessage(observer);
          this.observers.add(observer);
        }
      };
      Concast2.prototype.removeObserver = function(observer) {
        if (this.observers.delete(observer) && this.observers.size < 1) {
          this.handlers.complete();
        }
      };
      Concast2.prototype.notify = function(method, arg) {
        var nextResultListeners = this.nextResultListeners;
        if (nextResultListeners.size) {
          this.nextResultListeners = /* @__PURE__ */ new Set();
          nextResultListeners.forEach(function(listener) {
            return listener(method, arg);
          });
        }
      };
      Concast2.prototype.beforeNext = function(callback) {
        var called = false;
        this.nextResultListeners.add(function(method, arg) {
          if (!called) {
            called = true;
            callback(method, arg);
          }
        });
      };
      return Concast2;
    })(Observable)
  );
  fixObservableSubclass(Concast);

  // node_modules/@apollo/client/utilities/common/incrementalResult.js
  function isExecutionPatchIncrementalResult(value) {
    return "incremental" in value;
  }
  function isExecutionPatchInitialResult(value) {
    return "hasNext" in value && "data" in value;
  }
  function isExecutionPatchResult(value) {
    return isExecutionPatchIncrementalResult(value) || isExecutionPatchInitialResult(value);
  }
  function isApolloPayloadResult(value) {
    return isNonNullObject(value) && "payload" in value;
  }
  function mergeIncrementalData(prevResult, result2) {
    var mergedData = prevResult;
    var merger = new DeepMerger();
    if (isExecutionPatchIncrementalResult(result2) && isNonEmptyArray(result2.incremental)) {
      result2.incremental.forEach(function(_a2) {
        var data = _a2.data, path = _a2.path;
        for (var i = path.length - 1; i >= 0; --i) {
          var key = path[i];
          var isNumericKey = !isNaN(+key);
          var parent_1 = isNumericKey ? [] : {};
          parent_1[key] = data;
          data = parent_1;
        }
        mergedData = merger.merge(mergedData, data);
      });
    }
    return mergedData;
  }

  // node_modules/@apollo/client/utilities/common/errorHandling.js
  function graphQLResultHasError(result2) {
    var errors = getGraphQLErrorsFromResult(result2);
    return isNonEmptyArray(errors);
  }
  function getGraphQLErrorsFromResult(result2) {
    var graphQLErrors = isNonEmptyArray(result2.errors) ? result2.errors.slice(0) : [];
    if (isExecutionPatchIncrementalResult(result2) && isNonEmptyArray(result2.incremental)) {
      result2.incremental.forEach(function(incrementalResult) {
        if (incrementalResult.errors) {
          graphQLErrors.push.apply(graphQLErrors, incrementalResult.errors);
        }
      });
    }
    return graphQLErrors;
  }

  // node_modules/@apollo/client/utilities/common/compact.js
  function compact() {
    var objects = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      objects[_i] = arguments[_i];
    }
    var result2 = /* @__PURE__ */ Object.create(null);
    objects.forEach(function(obj) {
      if (!obj)
        return;
      Object.keys(obj).forEach(function(key) {
        var value = obj[key];
        if (value !== void 0) {
          result2[key] = value;
        }
      });
    });
    return result2;
  }

  // node_modules/@apollo/client/utilities/common/mergeOptions.js
  function mergeOptions(defaults, options2) {
    return compact(defaults, options2, options2.variables && {
      variables: compact(__assign(__assign({}, defaults && defaults.variables), options2.variables))
    });
  }

  // node_modules/@apollo/client/link/utils/fromError.js
  function fromError(errorValue) {
    return new Observable(function(observer) {
      observer.error(errorValue);
    });
  }

  // node_modules/@apollo/client/link/utils/throwServerError.js
  var throwServerError = function(response, result2, message2) {
    var error = new Error(message2);
    error.name = "ServerError";
    error.response = response;
    error.statusCode = response.status;
    error.result = result2;
    throw error;
  };

  // node_modules/@apollo/client/link/utils/validateOperation.js
  function validateOperation(operation) {
    var OPERATION_FIELDS = [
      "query",
      "operationName",
      "variables",
      "extensions",
      "context"
    ];
    for (var _i = 0, _a2 = Object.keys(operation); _i < _a2.length; _i++) {
      var key = _a2[_i];
      if (OPERATION_FIELDS.indexOf(key) < 0) {
        throw newInvariantError(46, key);
      }
    }
    return operation;
  }

  // node_modules/@apollo/client/link/utils/createOperation.js
  function createOperation(starting, operation) {
    var context = __assign({}, starting);
    var setContext = function(next2) {
      if (typeof next2 === "function") {
        context = __assign(__assign({}, context), next2(context));
      } else {
        context = __assign(__assign({}, context), next2);
      }
    };
    var getContext = function() {
      return __assign({}, context);
    };
    Object.defineProperty(operation, "setContext", {
      enumerable: false,
      value: setContext
    });
    Object.defineProperty(operation, "getContext", {
      enumerable: false,
      value: getContext
    });
    return operation;
  }

  // node_modules/@apollo/client/link/utils/transformOperation.js
  function transformOperation(operation) {
    var transformedOperation = {
      variables: operation.variables || {},
      extensions: operation.extensions || {},
      operationName: operation.operationName,
      query: operation.query
    };
    if (!transformedOperation.operationName) {
      transformedOperation.operationName = typeof transformedOperation.query !== "string" ? getOperationName(transformedOperation.query) || void 0 : "";
    }
    return transformedOperation;
  }

  // node_modules/@apollo/client/link/utils/filterOperationVariables.js
  function filterOperationVariables(variables, query) {
    var result2 = __assign({}, variables);
    var unusedNames = new Set(Object.keys(variables));
    visit(query, {
      Variable: function(node2, _key, parent) {
        if (parent && parent.kind !== "VariableDefinition") {
          unusedNames.delete(node2.name.value);
        }
      }
    });
    unusedNames.forEach(function(name) {
      delete result2[name];
    });
    return result2;
  }

  // node_modules/@apollo/client/link/core/ApolloLink.js
  function passthrough(op, forward) {
    return forward ? forward(op) : Observable.of();
  }
  function toLink(handler) {
    return typeof handler === "function" ? new ApolloLink(handler) : handler;
  }
  function isTerminating(link) {
    return link.request.length <= 1;
  }
  var ApolloLink = (
    /** @class */
    (function() {
      function ApolloLink2(request) {
        if (request)
          this.request = request;
      }
      ApolloLink2.empty = function() {
        return new ApolloLink2(function() {
          return Observable.of();
        });
      };
      ApolloLink2.from = function(links) {
        if (links.length === 0)
          return ApolloLink2.empty();
        return links.map(toLink).reduce(function(x, y) {
          return x.concat(y);
        });
      };
      ApolloLink2.split = function(test, left2, right2) {
        var leftLink = toLink(left2);
        var rightLink = toLink(right2 || new ApolloLink2(passthrough));
        var ret;
        if (isTerminating(leftLink) && isTerminating(rightLink)) {
          ret = new ApolloLink2(function(operation) {
            return test(operation) ? leftLink.request(operation) || Observable.of() : rightLink.request(operation) || Observable.of();
          });
        } else {
          ret = new ApolloLink2(function(operation, forward) {
            return test(operation) ? leftLink.request(operation, forward) || Observable.of() : rightLink.request(operation, forward) || Observable.of();
          });
        }
        return Object.assign(ret, { left: leftLink, right: rightLink });
      };
      ApolloLink2.execute = function(link, operation) {
        return link.request(createOperation(operation.context, transformOperation(validateOperation(operation)))) || Observable.of();
      };
      ApolloLink2.concat = function(first, second) {
        var firstLink = toLink(first);
        if (isTerminating(firstLink)) {
          globalThis.__DEV__ !== false && invariant3.warn(38, firstLink);
          return firstLink;
        }
        var nextLink = toLink(second);
        var ret;
        if (isTerminating(nextLink)) {
          ret = new ApolloLink2(function(operation) {
            return firstLink.request(operation, function(op) {
              return nextLink.request(op) || Observable.of();
            }) || Observable.of();
          });
        } else {
          ret = new ApolloLink2(function(operation, forward) {
            return firstLink.request(operation, function(op) {
              return nextLink.request(op, forward) || Observable.of();
            }) || Observable.of();
          });
        }
        return Object.assign(ret, { left: firstLink, right: nextLink });
      };
      ApolloLink2.prototype.split = function(test, left2, right2) {
        return this.concat(ApolloLink2.split(test, left2, right2 || new ApolloLink2(passthrough)));
      };
      ApolloLink2.prototype.concat = function(next2) {
        return ApolloLink2.concat(this, next2);
      };
      ApolloLink2.prototype.request = function(operation, forward) {
        throw newInvariantError(39);
      };
      ApolloLink2.prototype.onError = function(error, observer) {
        if (observer && observer.error) {
          observer.error(error);
          return false;
        }
        throw error;
      };
      ApolloLink2.prototype.setOnError = function(fn2) {
        this.onError = fn2;
        return this;
      };
      return ApolloLink2;
    })()
  );

  // node_modules/@apollo/client/link/core/execute.js
  var execute = ApolloLink.execute;

  // node_modules/@apollo/client/link/http/iterators/async.js
  function asyncIterator(source2) {
    var _a2;
    var iterator = source2[Symbol.asyncIterator]();
    return _a2 = {
      next: function() {
        return iterator.next();
      }
    }, _a2[Symbol.asyncIterator] = function() {
      return this;
    }, _a2;
  }

  // node_modules/@apollo/client/link/http/iterators/nodeStream.js
  function nodeStreamIterator(stream) {
    var cleanup = null;
    var error = null;
    var done = false;
    var data = [];
    var waiting = [];
    function onData(chunk) {
      if (error)
        return;
      if (waiting.length) {
        var shiftedArr = waiting.shift();
        if (Array.isArray(shiftedArr) && shiftedArr[0]) {
          return shiftedArr[0]({ value: chunk, done: false });
        }
      }
      data.push(chunk);
    }
    function onError(err) {
      error = err;
      var all = waiting.slice();
      all.forEach(function(pair) {
        pair[1](err);
      });
      !cleanup || cleanup();
    }
    function onEnd() {
      done = true;
      var all = waiting.slice();
      all.forEach(function(pair) {
        pair[0]({ value: void 0, done: true });
      });
      !cleanup || cleanup();
    }
    cleanup = function() {
      cleanup = null;
      stream.removeListener("data", onData);
      stream.removeListener("error", onError);
      stream.removeListener("end", onEnd);
      stream.removeListener("finish", onEnd);
      stream.removeListener("close", onEnd);
    };
    stream.on("data", onData);
    stream.on("error", onError);
    stream.on("end", onEnd);
    stream.on("finish", onEnd);
    stream.on("close", onEnd);
    function getNext() {
      return new Promise(function(resolve, reject) {
        if (error)
          return reject(error);
        if (data.length)
          return resolve({ value: data.shift(), done: false });
        if (done)
          return resolve({ value: void 0, done: true });
        waiting.push([resolve, reject]);
      });
    }
    var iterator = {
      next: function() {
        return getNext();
      }
    };
    if (canUseAsyncIteratorSymbol) {
      iterator[Symbol.asyncIterator] = function() {
        return this;
      };
    }
    return iterator;
  }

  // node_modules/@apollo/client/link/http/iterators/promise.js
  function promiseIterator(promise) {
    var resolved = false;
    var iterator = {
      next: function() {
        if (resolved)
          return Promise.resolve({
            value: void 0,
            done: true
          });
        resolved = true;
        return new Promise(function(resolve, reject) {
          promise.then(function(value) {
            resolve({ value, done: false });
          }).catch(reject);
        });
      }
    };
    if (canUseAsyncIteratorSymbol) {
      iterator[Symbol.asyncIterator] = function() {
        return this;
      };
    }
    return iterator;
  }

  // node_modules/@apollo/client/link/http/iterators/reader.js
  function readerIterator(reader) {
    var iterator = {
      next: function() {
        return reader.read();
      }
    };
    if (canUseAsyncIteratorSymbol) {
      iterator[Symbol.asyncIterator] = function() {
        return this;
      };
    }
    return iterator;
  }

  // node_modules/@apollo/client/link/http/responseIterator.js
  function isNodeResponse(value) {
    return !!value.body;
  }
  function isReadableStream(value) {
    return !!value.getReader;
  }
  function isAsyncIterableIterator(value) {
    return !!(canUseAsyncIteratorSymbol && value[Symbol.asyncIterator]);
  }
  function isStreamableBlob(value) {
    return !!value.stream;
  }
  function isBlob(value) {
    return !!value.arrayBuffer;
  }
  function isNodeReadableStream(value) {
    return !!value.pipe;
  }
  function responseIterator(response) {
    var body = response;
    if (isNodeResponse(response))
      body = response.body;
    if (isAsyncIterableIterator(body))
      return asyncIterator(body);
    if (isReadableStream(body))
      return readerIterator(body.getReader());
    if (isStreamableBlob(body)) {
      return readerIterator(body.stream().getReader());
    }
    if (isBlob(body))
      return promiseIterator(body.arrayBuffer());
    if (isNodeReadableStream(body))
      return nodeStreamIterator(body);
    throw new Error("Unknown body type for responseIterator. Please pass a streamable response.");
  }

  // node_modules/@apollo/client/errors/index.js
  var PROTOCOL_ERRORS_SYMBOL = Symbol();
  function graphQLResultHasProtocolErrors(result2) {
    if (result2.extensions) {
      return Array.isArray(result2.extensions[PROTOCOL_ERRORS_SYMBOL]);
    }
    return false;
  }
  function isApolloError(err) {
    return err.hasOwnProperty("graphQLErrors");
  }
  var generateErrorMessage = function(err) {
    var errors = __spreadArray(__spreadArray(__spreadArray([], err.graphQLErrors, true), err.clientErrors, true), err.protocolErrors, true);
    if (err.networkError)
      errors.push(err.networkError);
    return errors.map(function(err2) {
      return isNonNullObject(err2) && err2.message || "Error message not found.";
    }).join("\n");
  };
  var ApolloError = (
    /** @class */
    (function(_super) {
      __extends(ApolloError2, _super);
      function ApolloError2(_a2) {
        var graphQLErrors = _a2.graphQLErrors, protocolErrors = _a2.protocolErrors, clientErrors = _a2.clientErrors, networkError = _a2.networkError, errorMessage = _a2.errorMessage, extraInfo = _a2.extraInfo;
        var _this = _super.call(this, errorMessage) || this;
        _this.name = "ApolloError";
        _this.graphQLErrors = graphQLErrors || [];
        _this.protocolErrors = protocolErrors || [];
        _this.clientErrors = clientErrors || [];
        _this.networkError = networkError || null;
        _this.message = errorMessage || generateErrorMessage(_this);
        _this.extraInfo = extraInfo;
        _this.cause = __spreadArray(__spreadArray(__spreadArray([
          networkError
        ], graphQLErrors || [], true), protocolErrors || [], true), clientErrors || [], true).find(function(e) {
          return !!e;
        }) || null;
        _this.__proto__ = ApolloError2.prototype;
        return _this;
      }
      return ApolloError2;
    })(Error)
  );

  // node_modules/@apollo/client/link/http/parseAndCheckHttpResponse.js
  var hasOwnProperty4 = Object.prototype.hasOwnProperty;
  function readMultipartBody(response, nextValue) {
    return __awaiter(this, void 0, void 0, function() {
      var decoder, contentType, delimiter2, boundaryVal, boundary, buffer, iterator, running, _a2, value, done, chunk, searchFrom, bi, message2, i, headers, contentType_1, body, result2, next2;
      var _b, _c;
      var _d;
      return __generator(this, function(_e) {
        switch (_e.label) {
          case 0:
            if (TextDecoder === void 0) {
              throw new Error("TextDecoder must be defined in the environment: please import a polyfill.");
            }
            decoder = new TextDecoder("utf-8");
            contentType = (_d = response.headers) === null || _d === void 0 ? void 0 : _d.get("content-type");
            delimiter2 = "boundary=";
            boundaryVal = (contentType === null || contentType === void 0 ? void 0 : contentType.includes(delimiter2)) ? contentType === null || contentType === void 0 ? void 0 : contentType.substring((contentType === null || contentType === void 0 ? void 0 : contentType.indexOf(delimiter2)) + delimiter2.length).replace(/['"]/g, "").replace(/\;(.*)/gm, "").trim() : "-";
            boundary = "\r\n--".concat(boundaryVal);
            buffer = "";
            iterator = responseIterator(response);
            running = true;
            _e.label = 1;
          case 1:
            if (!running) return [3, 3];
            return [4, iterator.next()];
          case 2:
            _a2 = _e.sent(), value = _a2.value, done = _a2.done;
            chunk = typeof value === "string" ? value : decoder.decode(value);
            searchFrom = buffer.length - boundary.length + 1;
            running = !done;
            buffer += chunk;
            bi = buffer.indexOf(boundary, searchFrom);
            while (bi > -1) {
              message2 = void 0;
              _b = [
                buffer.slice(0, bi),
                buffer.slice(bi + boundary.length)
              ], message2 = _b[0], buffer = _b[1];
              i = message2.indexOf("\r\n\r\n");
              headers = parseHeaders(message2.slice(0, i));
              contentType_1 = headers["content-type"];
              if (contentType_1 && contentType_1.toLowerCase().indexOf("application/json") === -1) {
                throw new Error("Unsupported patch content type: application/json is required.");
              }
              body = message2.slice(i);
              if (body) {
                result2 = parseJsonBody(response, body);
                if (Object.keys(result2).length > 1 || "data" in result2 || "incremental" in result2 || "errors" in result2 || "payload" in result2) {
                  if (isApolloPayloadResult(result2)) {
                    next2 = {};
                    if ("payload" in result2) {
                      if (Object.keys(result2).length === 1 && result2.payload === null) {
                        return [
                          2
                          /*return*/
                        ];
                      }
                      next2 = __assign({}, result2.payload);
                    }
                    if ("errors" in result2) {
                      next2 = __assign(__assign({}, next2), { extensions: __assign(__assign({}, "extensions" in next2 ? next2.extensions : null), (_c = {}, _c[PROTOCOL_ERRORS_SYMBOL] = result2.errors, _c)) });
                    }
                    nextValue(next2);
                  } else {
                    nextValue(result2);
                  }
                } else if (
                  // If the chunk contains only a "hasNext: false", we can call
                  // observer.complete() immediately.
                  Object.keys(result2).length === 1 && "hasNext" in result2 && !result2.hasNext
                ) {
                  return [
                    2
                    /*return*/
                  ];
                }
              }
              bi = buffer.indexOf(boundary);
            }
            return [3, 1];
          case 3:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  }
  function parseHeaders(headerText) {
    var headersInit = {};
    headerText.split("\n").forEach(function(line2) {
      var i = line2.indexOf(":");
      if (i > -1) {
        var name_1 = line2.slice(0, i).trim().toLowerCase();
        var value = line2.slice(i + 1).trim();
        headersInit[name_1] = value;
      }
    });
    return headersInit;
  }
  function parseJsonBody(response, bodyText) {
    if (response.status >= 300) {
      var getResult = function() {
        try {
          return JSON.parse(bodyText);
        } catch (err) {
          return bodyText;
        }
      };
      throwServerError(response, getResult(), "Response not successful: Received status code ".concat(response.status));
    }
    try {
      return JSON.parse(bodyText);
    } catch (err) {
      var parseError = err;
      parseError.name = "ServerParseError";
      parseError.response = response;
      parseError.statusCode = response.status;
      parseError.bodyText = bodyText;
      throw parseError;
    }
  }
  function handleError(err, observer) {
    if (err.result && err.result.errors && err.result.data) {
      observer.next(err.result);
    }
    observer.error(err);
  }
  function parseAndCheckHttpResponse(operations) {
    return function(response) {
      return response.text().then(function(bodyText) {
        return parseJsonBody(response, bodyText);
      }).then(function(result2) {
        if (!Array.isArray(result2) && !hasOwnProperty4.call(result2, "data") && !hasOwnProperty4.call(result2, "errors")) {
          throwServerError(response, result2, "Server response was missing for query '".concat(Array.isArray(operations) ? operations.map(function(op) {
            return op.operationName;
          }) : operations.operationName, "'."));
        }
        return result2;
      });
    };
  }

  // node_modules/@apollo/client/link/http/serializeFetchParameter.js
  var serializeFetchParameter = function(p, label) {
    var serialized;
    try {
      serialized = JSON.stringify(p);
    } catch (e) {
      var parseError = newInvariantError(42, label, e.message);
      parseError.parseError = e;
      throw parseError;
    }
    return serialized;
  };

  // node_modules/@apollo/client/link/http/selectHttpOptionsAndBody.js
  var defaultHttpOptions = {
    includeQuery: true,
    includeExtensions: false,
    preserveHeaderCase: false
  };
  var defaultHeaders = {
    // headers are case insensitive (https://stackoverflow.com/a/5259004)
    accept: "*/*",
    // The content-type header describes the type of the body of the request, and
    // so it typically only is sent with requests that actually have bodies. One
    // could imagine that Apollo Client would remove this header when constructing
    // a GET request (which has no body), but we historically have not done that.
    // This means that browsers will preflight all Apollo Client requests (even
    // GET requests). Apollo Server's CSRF prevention feature (introduced in
    // AS3.7) takes advantage of this fact and does not block requests with this
    // header. If you want to drop this header from GET requests, then you should
    // probably replace it with a `apollo-require-preflight` header, or servers
    // with CSRF prevention enabled might block your GET request. See
    // https://www.apollographql.com/docs/apollo-server/security/cors/#preventing-cross-site-request-forgery-csrf
    // for more details.
    "content-type": "application/json"
  };
  var defaultOptions3 = {
    method: "POST"
  };
  var fallbackHttpConfig = {
    http: defaultHttpOptions,
    headers: defaultHeaders,
    options: defaultOptions3
  };
  var defaultPrinter = function(ast, printer) {
    return printer(ast);
  };
  function selectHttpOptionsAndBodyInternal(operation, printer) {
    var configs = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      configs[_i - 2] = arguments[_i];
    }
    var options2 = {};
    var http = {};
    configs.forEach(function(config) {
      options2 = __assign(__assign(__assign({}, options2), config.options), { headers: __assign(__assign({}, options2.headers), config.headers) });
      if (config.credentials) {
        options2.credentials = config.credentials;
      }
      http = __assign(__assign({}, http), config.http);
    });
    if (options2.headers) {
      options2.headers = removeDuplicateHeaders(options2.headers, http.preserveHeaderCase);
    }
    var operationName = operation.operationName, extensions = operation.extensions, variables = operation.variables, query = operation.query;
    var body = { operationName, variables };
    if (http.includeExtensions)
      body.extensions = extensions;
    if (http.includeQuery)
      body.query = printer(query, print2);
    return {
      options: options2,
      body
    };
  }
  function removeDuplicateHeaders(headers, preserveHeaderCase) {
    if (!preserveHeaderCase) {
      var normalizedHeaders_1 = {};
      Object.keys(Object(headers)).forEach(function(name) {
        normalizedHeaders_1[name.toLowerCase()] = headers[name];
      });
      return normalizedHeaders_1;
    }
    var headerData = {};
    Object.keys(Object(headers)).forEach(function(name) {
      headerData[name.toLowerCase()] = {
        originalName: name,
        value: headers[name]
      };
    });
    var normalizedHeaders = {};
    Object.keys(headerData).forEach(function(name) {
      normalizedHeaders[headerData[name].originalName] = headerData[name].value;
    });
    return normalizedHeaders;
  }

  // node_modules/@apollo/client/link/http/checkFetcher.js
  var checkFetcher = function(fetcher) {
    if (!fetcher && typeof fetch === "undefined") {
      throw newInvariantError(40);
    }
  };

  // node_modules/@apollo/client/link/http/selectURI.js
  var selectURI = function(operation, fallbackURI) {
    var context = operation.getContext();
    var contextURI = context.uri;
    if (contextURI) {
      return contextURI;
    } else if (typeof fallbackURI === "function") {
      return fallbackURI(operation);
    } else {
      return fallbackURI || "/graphql";
    }
  };

  // node_modules/@apollo/client/link/http/rewriteURIForGET.js
  function rewriteURIForGET(chosenURI, body) {
    var queryParams = [];
    var addQueryParam = function(key, value) {
      queryParams.push("".concat(key, "=").concat(encodeURIComponent(value)));
    };
    if ("query" in body) {
      addQueryParam("query", body.query);
    }
    if (body.operationName) {
      addQueryParam("operationName", body.operationName);
    }
    if (body.variables) {
      var serializedVariables = void 0;
      try {
        serializedVariables = serializeFetchParameter(body.variables, "Variables map");
      } catch (parseError) {
        return { parseError };
      }
      addQueryParam("variables", serializedVariables);
    }
    if (body.extensions) {
      var serializedExtensions = void 0;
      try {
        serializedExtensions = serializeFetchParameter(body.extensions, "Extensions map");
      } catch (parseError) {
        return { parseError };
      }
      addQueryParam("extensions", serializedExtensions);
    }
    var fragment = "", preFragment = chosenURI;
    var fragmentStart = chosenURI.indexOf("#");
    if (fragmentStart !== -1) {
      fragment = chosenURI.substr(fragmentStart);
      preFragment = chosenURI.substr(0, fragmentStart);
    }
    var queryParamsPrefix = preFragment.indexOf("?") === -1 ? "?" : "&";
    var newURI = preFragment + queryParamsPrefix + queryParams.join("&") + fragment;
    return { newURI };
  }

  // node_modules/@apollo/client/link/http/createHttpLink.js
  var backupFetch = maybe(function() {
    return fetch;
  });
  var createHttpLink = function(linkOptions) {
    if (linkOptions === void 0) {
      linkOptions = {};
    }
    var _a2 = linkOptions.uri, uri = _a2 === void 0 ? "/graphql" : _a2, preferredFetch = linkOptions.fetch, _b = linkOptions.print, print3 = _b === void 0 ? defaultPrinter : _b, includeExtensions = linkOptions.includeExtensions, preserveHeaderCase = linkOptions.preserveHeaderCase, useGETForQueries = linkOptions.useGETForQueries, _c = linkOptions.includeUnusedVariables, includeUnusedVariables = _c === void 0 ? false : _c, requestOptions = __rest(linkOptions, ["uri", "fetch", "print", "includeExtensions", "preserveHeaderCase", "useGETForQueries", "includeUnusedVariables"]);
    if (globalThis.__DEV__ !== false) {
      checkFetcher(preferredFetch || backupFetch);
    }
    var linkConfig = {
      http: { includeExtensions, preserveHeaderCase },
      options: requestOptions.fetchOptions,
      credentials: requestOptions.credentials,
      headers: requestOptions.headers
    };
    return new ApolloLink(function(operation) {
      var chosenURI = selectURI(operation, uri);
      var context = operation.getContext();
      var clientAwarenessHeaders = {};
      if (context.clientAwareness) {
        var _a3 = context.clientAwareness, name_1 = _a3.name, version2 = _a3.version;
        if (name_1) {
          clientAwarenessHeaders["apollographql-client-name"] = name_1;
        }
        if (version2) {
          clientAwarenessHeaders["apollographql-client-version"] = version2;
        }
      }
      var contextHeaders = __assign(__assign({}, clientAwarenessHeaders), context.headers);
      var contextConfig = {
        http: context.http,
        options: context.fetchOptions,
        credentials: context.credentials,
        headers: contextHeaders
      };
      if (hasDirectives(["client"], operation.query)) {
        var transformedQuery = removeClientSetsFromDocument(operation.query);
        if (!transformedQuery) {
          return fromError(new Error("HttpLink: Trying to send a client-only query to the server. To send to the server, ensure a non-client field is added to the query or set the `transformOptions.removeClientFields` option to `true`."));
        }
        operation.query = transformedQuery;
      }
      var _b2 = selectHttpOptionsAndBodyInternal(operation, print3, fallbackHttpConfig, linkConfig, contextConfig), options2 = _b2.options, body = _b2.body;
      if (body.variables && !includeUnusedVariables) {
        body.variables = filterOperationVariables(body.variables, operation.query);
      }
      var controller;
      if (!options2.signal && typeof AbortController !== "undefined") {
        controller = new AbortController();
        options2.signal = controller.signal;
      }
      var definitionIsMutation = function(d) {
        return d.kind === "OperationDefinition" && d.operation === "mutation";
      };
      var definitionIsSubscription = function(d) {
        return d.kind === "OperationDefinition" && d.operation === "subscription";
      };
      var isSubscription = definitionIsSubscription(getMainDefinition(operation.query));
      var hasDefer = hasDirectives(["defer"], operation.query);
      if (useGETForQueries && !operation.query.definitions.some(definitionIsMutation)) {
        options2.method = "GET";
      }
      if (hasDefer || isSubscription) {
        options2.headers = options2.headers || {};
        var acceptHeader = "multipart/mixed;";
        if (isSubscription && hasDefer) {
          globalThis.__DEV__ !== false && invariant3.warn(41);
        }
        if (isSubscription) {
          acceptHeader += "boundary=graphql;subscriptionSpec=1.0,application/json";
        } else if (hasDefer) {
          acceptHeader += "deferSpec=20220824,application/json";
        }
        options2.headers.accept = acceptHeader;
      }
      if (options2.method === "GET") {
        var _c2 = rewriteURIForGET(chosenURI, body), newURI = _c2.newURI, parseError = _c2.parseError;
        if (parseError) {
          return fromError(parseError);
        }
        chosenURI = newURI;
      } else {
        try {
          options2.body = serializeFetchParameter(body, "Payload");
        } catch (parseError2) {
          return fromError(parseError2);
        }
      }
      return new Observable(function(observer) {
        var currentFetch = preferredFetch || maybe(function() {
          return fetch;
        }) || backupFetch;
        var observerNext = observer.next.bind(observer);
        currentFetch(chosenURI, options2).then(function(response) {
          var _a4;
          operation.setContext({ response });
          var ctype = (_a4 = response.headers) === null || _a4 === void 0 ? void 0 : _a4.get("content-type");
          if (ctype !== null && /^multipart\/mixed/i.test(ctype)) {
            return readMultipartBody(response, observerNext);
          } else {
            return parseAndCheckHttpResponse(operation)(response).then(observerNext);
          }
        }).then(function() {
          controller = void 0;
          observer.complete();
        }).catch(function(err) {
          controller = void 0;
          handleError(err, observer);
        });
        return function() {
          if (controller)
            controller.abort();
        };
      });
    });
  };

  // node_modules/@apollo/client/link/http/HttpLink.js
  var HttpLink = (
    /** @class */
    (function(_super) {
      __extends(HttpLink2, _super);
      function HttpLink2(options2) {
        if (options2 === void 0) {
          options2 = {};
        }
        var _this = _super.call(this, createHttpLink(options2).request) || this;
        _this.options = options2;
        return _this;
      }
      return HttpLink2;
    })(ApolloLink)
  );

  // node_modules/@wry/equality/lib/index.js
  var { toString: toString2, hasOwnProperty: hasOwnProperty5 } = Object.prototype;
  var fnToStr = Function.prototype.toString;
  var previousComparisons = /* @__PURE__ */ new Map();
  function equal(a, b) {
    try {
      return check(a, b);
    } finally {
      previousComparisons.clear();
    }
  }
  var lib_default = equal;
  function check(a, b) {
    if (a === b) {
      return true;
    }
    const aTag = toString2.call(a);
    const bTag = toString2.call(b);
    if (aTag !== bTag) {
      return false;
    }
    switch (aTag) {
      case "[object Array]":
        if (a.length !== b.length)
          return false;
      // Fall through to object case...
      case "[object Object]": {
        if (previouslyCompared(a, b))
          return true;
        const aKeys = definedKeys(a);
        const bKeys = definedKeys(b);
        const keyCount = aKeys.length;
        if (keyCount !== bKeys.length)
          return false;
        for (let k = 0; k < keyCount; ++k) {
          if (!hasOwnProperty5.call(b, aKeys[k])) {
            return false;
          }
        }
        for (let k = 0; k < keyCount; ++k) {
          const key = aKeys[k];
          if (!check(a[key], b[key])) {
            return false;
          }
        }
        return true;
      }
      case "[object Error]":
        return a.name === b.name && a.message === b.message;
      case "[object Number]":
        if (a !== a)
          return b !== b;
      // Fall through to shared +a === +b case...
      case "[object Boolean]":
      case "[object Date]":
        return +a === +b;
      case "[object RegExp]":
      case "[object String]":
        return a == `${b}`;
      case "[object Map]":
      case "[object Set]": {
        if (a.size !== b.size)
          return false;
        if (previouslyCompared(a, b))
          return true;
        const aIterator = a.entries();
        const isMap = aTag === "[object Map]";
        while (true) {
          const info = aIterator.next();
          if (info.done)
            break;
          const [aKey, aValue] = info.value;
          if (!b.has(aKey)) {
            return false;
          }
          if (isMap && !check(aValue, b.get(aKey))) {
            return false;
          }
        }
        return true;
      }
      case "[object Uint16Array]":
      case "[object Uint8Array]":
      // Buffer, in Node.js.
      case "[object Uint32Array]":
      case "[object Int32Array]":
      case "[object Int8Array]":
      case "[object Int16Array]":
      case "[object ArrayBuffer]":
        a = new Uint8Array(a);
        b = new Uint8Array(b);
      // Fall through...
      case "[object DataView]": {
        let len = a.byteLength;
        if (len === b.byteLength) {
          while (len-- && a[len] === b[len]) {
          }
        }
        return len === -1;
      }
      case "[object AsyncFunction]":
      case "[object GeneratorFunction]":
      case "[object AsyncGeneratorFunction]":
      case "[object Function]": {
        const aCode = fnToStr.call(a);
        if (aCode !== fnToStr.call(b)) {
          return false;
        }
        return !endsWith(aCode, nativeCodeSuffix);
      }
    }
    return false;
  }
  function definedKeys(obj) {
    return Object.keys(obj).filter(isDefinedKey, obj);
  }
  function isDefinedKey(key) {
    return this[key] !== void 0;
  }
  var nativeCodeSuffix = "{ [native code] }";
  function endsWith(full, suffix) {
    const fromIndex = full.length - suffix.length;
    return fromIndex >= 0 && full.indexOf(suffix, fromIndex) === fromIndex;
  }
  function previouslyCompared(a, b) {
    let bSet = previousComparisons.get(a);
    if (bSet) {
      if (bSet.has(b))
        return true;
    } else {
      previousComparisons.set(a, bSet = /* @__PURE__ */ new Set());
    }
    bSet.add(b);
    return false;
  }

  // node_modules/@apollo/client/core/equalByQuery.js
  function equalByQuery(query, _a2, _b, variables) {
    var aData = _a2.data, aRest = __rest(_a2, ["data"]);
    var bData = _b.data, bRest = __rest(_b, ["data"]);
    return lib_default(aRest, bRest) && equalBySelectionSet(getMainDefinition(query).selectionSet, aData, bData, {
      fragmentMap: createFragmentMap(getFragmentDefinitions(query)),
      variables
    });
  }
  function equalBySelectionSet(selectionSet, aResult, bResult, context) {
    if (aResult === bResult) {
      return true;
    }
    var seenSelections = /* @__PURE__ */ new Set();
    return selectionSet.selections.every(function(selection) {
      if (seenSelections.has(selection))
        return true;
      seenSelections.add(selection);
      if (!shouldInclude(selection, context.variables))
        return true;
      if (selectionHasNonreactiveDirective(selection))
        return true;
      if (isField(selection)) {
        var resultKey = resultKeyNameFromField(selection);
        var aResultChild = aResult && aResult[resultKey];
        var bResultChild = bResult && bResult[resultKey];
        var childSelectionSet = selection.selectionSet;
        if (!childSelectionSet) {
          return lib_default(aResultChild, bResultChild);
        }
        var aChildIsArray = Array.isArray(aResultChild);
        var bChildIsArray = Array.isArray(bResultChild);
        if (aChildIsArray !== bChildIsArray)
          return false;
        if (aChildIsArray && bChildIsArray) {
          var length_1 = aResultChild.length;
          if (bResultChild.length !== length_1) {
            return false;
          }
          for (var i = 0; i < length_1; ++i) {
            if (!equalBySelectionSet(childSelectionSet, aResultChild[i], bResultChild[i], context)) {
              return false;
            }
          }
          return true;
        }
        return equalBySelectionSet(childSelectionSet, aResultChild, bResultChild, context);
      } else {
        var fragment = getFragmentFromSelection(selection, context.fragmentMap);
        if (fragment) {
          if (selectionHasNonreactiveDirective(fragment))
            return true;
          return equalBySelectionSet(
            fragment.selectionSet,
            // Notice that we reuse the same aResult and bResult values here,
            // since the fragment ...spread does not specify a field name, but
            // consists of multiple fields (within the fragment's selection set)
            // that should be applied to the current result value(s).
            aResult,
            bResult,
            context
          );
        }
      }
    });
  }
  function selectionHasNonreactiveDirective(selection) {
    return !!selection.directives && selection.directives.some(directiveIsNonreactive);
  }
  function directiveIsNonreactive(dir) {
    return dir.name.value === "nonreactive";
  }

  // node_modules/@apollo/client/masking/utils.js
  var MapImpl = canUseWeakMap ? WeakMap : Map;
  var SetImpl = canUseWeakSet ? WeakSet : Set;
  var disableWarningsSlot = new Slot();
  var issuedWarning = false;
  function warnOnImproperCacheImplementation() {
    if (!issuedWarning) {
      issuedWarning = true;
      globalThis.__DEV__ !== false && invariant3.warn(52);
    }
  }

  // node_modules/@apollo/client/masking/maskDefinition.js
  function maskDefinition(data, selectionSet, context) {
    return disableWarningsSlot.withValue(true, function() {
      var masked = maskSelectionSet(data, selectionSet, context, false);
      if (Object.isFrozen(data)) {
        maybeDeepFreeze(masked);
      }
      return masked;
    });
  }
  function getMutableTarget(data, mutableTargets) {
    if (mutableTargets.has(data)) {
      return mutableTargets.get(data);
    }
    var mutableTarget = Array.isArray(data) ? [] : /* @__PURE__ */ Object.create(null);
    mutableTargets.set(data, mutableTarget);
    return mutableTarget;
  }
  function maskSelectionSet(data, selectionSet, context, migration, path) {
    var _a2;
    var knownChanged = context.knownChanged;
    var memo10 = getMutableTarget(data, context.mutableTargets);
    if (Array.isArray(data)) {
      for (var _i = 0, _b = Array.from(data.entries()); _i < _b.length; _i++) {
        var _c = _b[_i], index2 = _c[0], item = _c[1];
        if (item === null) {
          memo10[index2] = null;
          continue;
        }
        var masked = maskSelectionSet(item, selectionSet, context, migration, globalThis.__DEV__ !== false ? "".concat(path || "", "[").concat(index2, "]") : void 0);
        if (knownChanged.has(masked)) {
          knownChanged.add(memo10);
        }
        memo10[index2] = masked;
      }
      return knownChanged.has(memo10) ? memo10 : data;
    }
    for (var _d = 0, _e = selectionSet.selections; _d < _e.length; _d++) {
      var selection = _e[_d];
      var value = void 0;
      if (migration) {
        knownChanged.add(memo10);
      }
      if (selection.kind === Kind.FIELD) {
        var keyName = resultKeyNameFromField(selection);
        var childSelectionSet = selection.selectionSet;
        value = memo10[keyName] || data[keyName];
        if (value === void 0) {
          continue;
        }
        if (childSelectionSet && value !== null) {
          var masked = maskSelectionSet(data[keyName], childSelectionSet, context, migration, globalThis.__DEV__ !== false ? "".concat(path || "", ".").concat(keyName) : void 0);
          if (knownChanged.has(masked)) {
            value = masked;
          }
        }
        if (!(globalThis.__DEV__ !== false)) {
          memo10[keyName] = value;
        }
        if (globalThis.__DEV__ !== false) {
          if (migration && keyName !== "__typename" && // either the field is not present in the memo object
          // or it has a `get` descriptor, not a `value` descriptor
          // => it is a warning accessor and we can overwrite it
          // with another accessor
          !((_a2 = Object.getOwnPropertyDescriptor(memo10, keyName)) === null || _a2 === void 0 ? void 0 : _a2.value)) {
            Object.defineProperty(memo10, keyName, getAccessorWarningDescriptor(keyName, value, path || "", context.operationName, context.operationType));
          } else {
            delete memo10[keyName];
            memo10[keyName] = value;
          }
        }
      }
      if (selection.kind === Kind.INLINE_FRAGMENT && (!selection.typeCondition || context.cache.fragmentMatches(selection, data.__typename))) {
        value = maskSelectionSet(data, selection.selectionSet, context, migration, path);
      }
      if (selection.kind === Kind.FRAGMENT_SPREAD) {
        var fragmentName = selection.name.value;
        var fragment = context.fragmentMap[fragmentName] || (context.fragmentMap[fragmentName] = context.cache.lookupFragment(fragmentName));
        invariant3(fragment, 47, fragmentName);
        var mode = getFragmentMaskMode(selection);
        if (mode !== "mask") {
          value = maskSelectionSet(data, fragment.selectionSet, context, mode === "migrate", path);
        }
      }
      if (knownChanged.has(value)) {
        knownChanged.add(memo10);
      }
    }
    if ("__typename" in data && !("__typename" in memo10)) {
      memo10.__typename = data.__typename;
    }
    if (Object.keys(memo10).length !== Object.keys(data).length) {
      knownChanged.add(memo10);
    }
    return knownChanged.has(memo10) ? memo10 : data;
  }
  function getAccessorWarningDescriptor(fieldName, value, path, operationName, operationType) {
    var getValue = function() {
      if (disableWarningsSlot.getValue()) {
        return value;
      }
      globalThis.__DEV__ !== false && invariant3.warn(48, operationName ? "".concat(operationType, " '").concat(operationName, "'") : "anonymous ".concat(operationType), "".concat(path, ".").concat(fieldName).replace(/^\./, ""));
      getValue = function() {
        return value;
      };
      return value;
    };
    return {
      get: function() {
        return getValue();
      },
      set: function(newValue) {
        getValue = function() {
          return newValue;
        };
      },
      enumerable: true,
      configurable: true
    };
  }

  // node_modules/@apollo/client/masking/maskFragment.js
  function maskFragment(data, document2, cache, fragmentName) {
    if (!cache.fragmentMatches) {
      if (globalThis.__DEV__ !== false) {
        warnOnImproperCacheImplementation();
      }
      return data;
    }
    var fragments = document2.definitions.filter(function(node2) {
      return node2.kind === Kind.FRAGMENT_DEFINITION;
    });
    if (typeof fragmentName === "undefined") {
      invariant3(fragments.length === 1, 49, fragments.length);
      fragmentName = fragments[0].name.value;
    }
    var fragment = fragments.find(function(fragment2) {
      return fragment2.name.value === fragmentName;
    });
    invariant3(!!fragment, 50, fragmentName);
    if (data == null) {
      return data;
    }
    if (lib_default(data, {})) {
      return data;
    }
    return maskDefinition(data, fragment.selectionSet, {
      operationType: "fragment",
      operationName: fragment.name.value,
      fragmentMap: createFragmentMap(getFragmentDefinitions(document2)),
      cache,
      mutableTargets: new MapImpl(),
      knownChanged: new SetImpl()
    });
  }

  // node_modules/@apollo/client/masking/maskOperation.js
  function maskOperation(data, document2, cache) {
    var _a2;
    if (!cache.fragmentMatches) {
      if (globalThis.__DEV__ !== false) {
        warnOnImproperCacheImplementation();
      }
      return data;
    }
    var definition = getOperationDefinition(document2);
    invariant3(definition, 51);
    if (data == null) {
      return data;
    }
    return maskDefinition(data, definition.selectionSet, {
      operationType: definition.operation,
      operationName: (_a2 = definition.name) === null || _a2 === void 0 ? void 0 : _a2.value,
      fragmentMap: createFragmentMap(getFragmentDefinitions(document2)),
      cache,
      mutableTargets: new MapImpl(),
      knownChanged: new SetImpl()
    });
  }

  // node_modules/@apollo/client/cache/core/cache.js
  var ApolloCache = (
    /** @class */
    (function() {
      function ApolloCache2() {
        this.assumeImmutableResults = false;
        this.getFragmentDoc = wrap3(getFragmentQueryDocument, {
          max: cacheSizes["cache.fragmentQueryDocuments"] || 1e3,
          cache: WeakCache
        });
      }
      ApolloCache2.prototype.lookupFragment = function(fragmentName) {
        return null;
      };
      ApolloCache2.prototype.batch = function(options2) {
        var _this = this;
        var optimisticId = typeof options2.optimistic === "string" ? options2.optimistic : options2.optimistic === false ? null : void 0;
        var updateResult;
        this.performTransaction(function() {
          return updateResult = options2.update(_this);
        }, optimisticId);
        return updateResult;
      };
      ApolloCache2.prototype.recordOptimisticTransaction = function(transaction, optimisticId) {
        this.performTransaction(transaction, optimisticId);
      };
      ApolloCache2.prototype.transformDocument = function(document2) {
        return document2;
      };
      ApolloCache2.prototype.transformForLink = function(document2) {
        return document2;
      };
      ApolloCache2.prototype.identify = function(object) {
        return;
      };
      ApolloCache2.prototype.gc = function() {
        return [];
      };
      ApolloCache2.prototype.modify = function(options2) {
        return false;
      };
      ApolloCache2.prototype.readQuery = function(options2, optimistic) {
        if (optimistic === void 0) {
          optimistic = !!options2.optimistic;
        }
        return this.read(__assign(__assign({}, options2), { rootId: options2.id || "ROOT_QUERY", optimistic }));
      };
      ApolloCache2.prototype.watchFragment = function(options2) {
        var _this = this;
        var fragment = options2.fragment, fragmentName = options2.fragmentName, from2 = options2.from, _a2 = options2.optimistic, optimistic = _a2 === void 0 ? true : _a2, otherOptions = __rest(options2, ["fragment", "fragmentName", "from", "optimistic"]);
        var query = this.getFragmentDoc(fragment, fragmentName);
        var id = typeof from2 === "undefined" || typeof from2 === "string" ? from2 : this.identify(from2);
        var dataMasking = !!options2[Symbol.for("apollo.dataMasking")];
        if (globalThis.__DEV__ !== false) {
          var actualFragmentName = fragmentName || getFragmentDefinition(fragment).name.value;
          if (!id) {
            globalThis.__DEV__ !== false && invariant3.warn(1, actualFragmentName);
          }
        }
        var diffOptions = __assign(__assign({}, otherOptions), { returnPartialData: true, id, query, optimistic });
        var latestDiff;
        return new Observable(function(observer) {
          return _this.watch(__assign(__assign({}, diffOptions), { immediate: true, callback: function(diff) {
            var data = dataMasking ? maskFragment(diff.result, fragment, _this, fragmentName) : diff.result;
            if (
              // Always ensure we deliver the first result
              latestDiff && equalByQuery(
                query,
                { data: latestDiff.result },
                { data },
                // TODO: Fix the type on WatchFragmentOptions so that TVars
                // extends OperationVariables
                options2.variables
              )
            ) {
              return;
            }
            var result2 = {
              data,
              complete: !!diff.complete
            };
            if (diff.missing) {
              result2.missing = mergeDeepArray(diff.missing.map(function(error) {
                return error.missing;
              }));
            }
            latestDiff = __assign(__assign({}, diff), { result: data });
            observer.next(result2);
          } }));
        });
      };
      ApolloCache2.prototype.readFragment = function(options2, optimistic) {
        if (optimistic === void 0) {
          optimistic = !!options2.optimistic;
        }
        return this.read(__assign(__assign({}, options2), { query: this.getFragmentDoc(options2.fragment, options2.fragmentName), rootId: options2.id, optimistic }));
      };
      ApolloCache2.prototype.writeQuery = function(_a2) {
        var id = _a2.id, data = _a2.data, options2 = __rest(_a2, ["id", "data"]);
        return this.write(Object.assign(options2, {
          dataId: id || "ROOT_QUERY",
          result: data
        }));
      };
      ApolloCache2.prototype.writeFragment = function(_a2) {
        var id = _a2.id, data = _a2.data, fragment = _a2.fragment, fragmentName = _a2.fragmentName, options2 = __rest(_a2, ["id", "data", "fragment", "fragmentName"]);
        return this.write(Object.assign(options2, {
          query: this.getFragmentDoc(fragment, fragmentName),
          dataId: id,
          result: data
        }));
      };
      ApolloCache2.prototype.updateQuery = function(options2, update) {
        return this.batch({
          update: function(cache) {
            var value = cache.readQuery(options2);
            var data = update(value);
            if (data === void 0 || data === null)
              return value;
            cache.writeQuery(__assign(__assign({}, options2), { data }));
            return data;
          }
        });
      };
      ApolloCache2.prototype.updateFragment = function(options2, update) {
        return this.batch({
          update: function(cache) {
            var value = cache.readFragment(options2);
            var data = update(value);
            if (data === void 0 || data === null)
              return value;
            cache.writeFragment(__assign(__assign({}, options2), { data }));
            return data;
          }
        });
      };
      return ApolloCache2;
    })()
  );
  if (globalThis.__DEV__ !== false) {
    ApolloCache.prototype.getMemoryInternals = getApolloCacheMemoryInternals;
  }

  // node_modules/@apollo/client/cache/core/types/common.js
  var MissingFieldError = (
    /** @class */
    (function(_super) {
      __extends(MissingFieldError2, _super);
      function MissingFieldError2(message2, path, query, variables) {
        var _a2;
        var _this = _super.call(this, message2) || this;
        _this.message = message2;
        _this.path = path;
        _this.query = query;
        _this.variables = variables;
        if (Array.isArray(_this.path)) {
          _this.missing = _this.message;
          for (var i = _this.path.length - 1; i >= 0; --i) {
            _this.missing = (_a2 = {}, _a2[_this.path[i]] = _this.missing, _a2);
          }
        } else {
          _this.missing = _this.path;
        }
        _this.__proto__ = MissingFieldError2.prototype;
        return _this;
      }
      return MissingFieldError2;
    })(Error)
  );

  // node_modules/@apollo/client/cache/inmemory/helpers.js
  var hasOwn2 = Object.prototype.hasOwnProperty;
  function isNullish(value) {
    return value === null || value === void 0;
  }
  function defaultDataIdFromObject(_a2, context) {
    var __typename = _a2.__typename, id = _a2.id, _id = _a2._id;
    if (typeof __typename === "string") {
      if (context) {
        context.keyObject = !isNullish(id) ? { id } : !isNullish(_id) ? { _id } : void 0;
      }
      if (isNullish(id) && !isNullish(_id)) {
        id = _id;
      }
      if (!isNullish(id)) {
        return "".concat(__typename, ":").concat(typeof id === "number" || typeof id === "string" ? id : JSON.stringify(id));
      }
    }
  }
  var defaultConfig = {
    dataIdFromObject: defaultDataIdFromObject,
    addTypename: true,
    resultCaching: true,
    // Thanks to the shouldCanonizeResults helper, this should be the only line
    // you have to change to reenable canonization by default in the future.
    canonizeResults: false
  };
  function normalizeConfig(config) {
    return compact(defaultConfig, config);
  }
  function shouldCanonizeResults(config) {
    var value = config.canonizeResults;
    return value === void 0 ? defaultConfig.canonizeResults : value;
  }
  function getTypenameFromStoreObject(store, objectOrReference) {
    return isReference(objectOrReference) ? store.get(objectOrReference.__ref, "__typename") : objectOrReference && objectOrReference.__typename;
  }
  var TypeOrFieldNameRegExp = /^[_a-z][_0-9a-z]*/i;
  function fieldNameFromStoreName(storeFieldName) {
    var match3 = storeFieldName.match(TypeOrFieldNameRegExp);
    return match3 ? match3[0] : storeFieldName;
  }
  function selectionSetMatchesResult(selectionSet, result2, variables) {
    if (isNonNullObject(result2)) {
      return isArray2(result2) ? result2.every(function(item) {
        return selectionSetMatchesResult(selectionSet, item, variables);
      }) : selectionSet.selections.every(function(field) {
        if (isField(field) && shouldInclude(field, variables)) {
          var key = resultKeyNameFromField(field);
          return hasOwn2.call(result2, key) && (!field.selectionSet || selectionSetMatchesResult(field.selectionSet, result2[key], variables));
        }
        return true;
      });
    }
    return false;
  }
  function storeValueIsStoreObject(value) {
    return isNonNullObject(value) && !isReference(value) && !isArray2(value);
  }
  function makeProcessedFieldsMerger() {
    return new DeepMerger();
  }
  function extractFragmentContext(document2, fragments) {
    var fragmentMap = createFragmentMap(getFragmentDefinitions(document2));
    return {
      fragmentMap,
      lookupFragment: function(name) {
        var def = fragmentMap[name];
        if (!def && fragments) {
          def = fragments.lookup(name);
        }
        return def || null;
      }
    };
  }

  // node_modules/@apollo/client/cache/inmemory/entityStore.js
  var DELETE = /* @__PURE__ */ Object.create(null);
  var delModifier = function() {
    return DELETE;
  };
  var INVALIDATE = /* @__PURE__ */ Object.create(null);
  var EntityStore = (
    /** @class */
    (function() {
      function EntityStore2(policies, group) {
        var _this = this;
        this.policies = policies;
        this.group = group;
        this.data = /* @__PURE__ */ Object.create(null);
        this.rootIds = /* @__PURE__ */ Object.create(null);
        this.refs = /* @__PURE__ */ Object.create(null);
        this.getFieldValue = function(objectOrReference, storeFieldName) {
          return maybeDeepFreeze(isReference(objectOrReference) ? _this.get(objectOrReference.__ref, storeFieldName) : objectOrReference && objectOrReference[storeFieldName]);
        };
        this.canRead = function(objOrRef) {
          return isReference(objOrRef) ? _this.has(objOrRef.__ref) : typeof objOrRef === "object";
        };
        this.toReference = function(objOrIdOrRef, mergeIntoStore) {
          if (typeof objOrIdOrRef === "string") {
            return makeReference(objOrIdOrRef);
          }
          if (isReference(objOrIdOrRef)) {
            return objOrIdOrRef;
          }
          var id = _this.policies.identify(objOrIdOrRef)[0];
          if (id) {
            var ref = makeReference(id);
            if (mergeIntoStore) {
              _this.merge(id, objOrIdOrRef);
            }
            return ref;
          }
        };
      }
      EntityStore2.prototype.toObject = function() {
        return __assign({}, this.data);
      };
      EntityStore2.prototype.has = function(dataId) {
        return this.lookup(dataId, true) !== void 0;
      };
      EntityStore2.prototype.get = function(dataId, fieldName) {
        this.group.depend(dataId, fieldName);
        if (hasOwn2.call(this.data, dataId)) {
          var storeObject = this.data[dataId];
          if (storeObject && hasOwn2.call(storeObject, fieldName)) {
            return storeObject[fieldName];
          }
        }
        if (fieldName === "__typename" && hasOwn2.call(this.policies.rootTypenamesById, dataId)) {
          return this.policies.rootTypenamesById[dataId];
        }
        if (this instanceof Layer) {
          return this.parent.get(dataId, fieldName);
        }
      };
      EntityStore2.prototype.lookup = function(dataId, dependOnExistence) {
        if (dependOnExistence)
          this.group.depend(dataId, "__exists");
        if (hasOwn2.call(this.data, dataId)) {
          return this.data[dataId];
        }
        if (this instanceof Layer) {
          return this.parent.lookup(dataId, dependOnExistence);
        }
        if (this.policies.rootTypenamesById[dataId]) {
          return /* @__PURE__ */ Object.create(null);
        }
      };
      EntityStore2.prototype.merge = function(older, newer) {
        var _this = this;
        var dataId;
        if (isReference(older))
          older = older.__ref;
        if (isReference(newer))
          newer = newer.__ref;
        var existing = typeof older === "string" ? this.lookup(dataId = older) : older;
        var incoming = typeof newer === "string" ? this.lookup(dataId = newer) : newer;
        if (!incoming)
          return;
        invariant3(typeof dataId === "string", 2);
        var merged = new DeepMerger(storeObjectReconciler).merge(existing, incoming);
        this.data[dataId] = merged;
        if (merged !== existing) {
          delete this.refs[dataId];
          if (this.group.caching) {
            var fieldsToDirty_1 = /* @__PURE__ */ Object.create(null);
            if (!existing)
              fieldsToDirty_1.__exists = 1;
            Object.keys(incoming).forEach(function(storeFieldName) {
              if (!existing || existing[storeFieldName] !== merged[storeFieldName]) {
                fieldsToDirty_1[storeFieldName] = 1;
                var fieldName = fieldNameFromStoreName(storeFieldName);
                if (fieldName !== storeFieldName && !_this.policies.hasKeyArgs(merged.__typename, fieldName)) {
                  fieldsToDirty_1[fieldName] = 1;
                }
                if (merged[storeFieldName] === void 0 && !(_this instanceof Layer)) {
                  delete merged[storeFieldName];
                }
              }
            });
            if (fieldsToDirty_1.__typename && !(existing && existing.__typename) && // Since we return default root __typename strings
            // automatically from store.get, we don't need to dirty the
            // ROOT_QUERY.__typename field if merged.__typename is equal
            // to the default string (usually "Query").
            this.policies.rootTypenamesById[dataId] === merged.__typename) {
              delete fieldsToDirty_1.__typename;
            }
            Object.keys(fieldsToDirty_1).forEach(function(fieldName) {
              return _this.group.dirty(dataId, fieldName);
            });
          }
        }
      };
      EntityStore2.prototype.modify = function(dataId, fields) {
        var _this = this;
        var storeObject = this.lookup(dataId);
        if (storeObject) {
          var changedFields_1 = /* @__PURE__ */ Object.create(null);
          var needToMerge_1 = false;
          var allDeleted_1 = true;
          var sharedDetails_1 = {
            DELETE,
            INVALIDATE,
            isReference,
            toReference: this.toReference,
            canRead: this.canRead,
            readField: function(fieldNameOrOptions, from2) {
              return _this.policies.readField(typeof fieldNameOrOptions === "string" ? {
                fieldName: fieldNameOrOptions,
                from: from2 || makeReference(dataId)
              } : fieldNameOrOptions, { store: _this });
            }
          };
          Object.keys(storeObject).forEach(function(storeFieldName) {
            var fieldName = fieldNameFromStoreName(storeFieldName);
            var fieldValue = storeObject[storeFieldName];
            if (fieldValue === void 0)
              return;
            var modify = typeof fields === "function" ? fields : fields[storeFieldName] || fields[fieldName];
            if (modify) {
              var newValue = modify === delModifier ? DELETE : modify(maybeDeepFreeze(fieldValue), __assign(__assign({}, sharedDetails_1), { fieldName, storeFieldName, storage: _this.getStorage(dataId, storeFieldName) }));
              if (newValue === INVALIDATE) {
                _this.group.dirty(dataId, storeFieldName);
              } else {
                if (newValue === DELETE)
                  newValue = void 0;
                if (newValue !== fieldValue) {
                  changedFields_1[storeFieldName] = newValue;
                  needToMerge_1 = true;
                  fieldValue = newValue;
                  if (globalThis.__DEV__ !== false) {
                    var checkReference = function(ref) {
                      if (_this.lookup(ref.__ref) === void 0) {
                        globalThis.__DEV__ !== false && invariant3.warn(3, ref);
                        return true;
                      }
                    };
                    if (isReference(newValue)) {
                      checkReference(newValue);
                    } else if (Array.isArray(newValue)) {
                      var seenReference = false;
                      var someNonReference = void 0;
                      for (var _i = 0, newValue_1 = newValue; _i < newValue_1.length; _i++) {
                        var value = newValue_1[_i];
                        if (isReference(value)) {
                          seenReference = true;
                          if (checkReference(value))
                            break;
                        } else {
                          if (typeof value === "object" && !!value) {
                            var id = _this.policies.identify(value)[0];
                            if (id) {
                              someNonReference = value;
                            }
                          }
                        }
                        if (seenReference && someNonReference !== void 0) {
                          globalThis.__DEV__ !== false && invariant3.warn(4, someNonReference);
                          break;
                        }
                      }
                    }
                  }
                }
              }
            }
            if (fieldValue !== void 0) {
              allDeleted_1 = false;
            }
          });
          if (needToMerge_1) {
            this.merge(dataId, changedFields_1);
            if (allDeleted_1) {
              if (this instanceof Layer) {
                this.data[dataId] = void 0;
              } else {
                delete this.data[dataId];
              }
              this.group.dirty(dataId, "__exists");
            }
            return true;
          }
        }
        return false;
      };
      EntityStore2.prototype.delete = function(dataId, fieldName, args) {
        var _a2;
        var storeObject = this.lookup(dataId);
        if (storeObject) {
          var typename = this.getFieldValue(storeObject, "__typename");
          var storeFieldName = fieldName && args ? this.policies.getStoreFieldName({ typename, fieldName, args }) : fieldName;
          return this.modify(dataId, storeFieldName ? (_a2 = {}, _a2[storeFieldName] = delModifier, _a2) : delModifier);
        }
        return false;
      };
      EntityStore2.prototype.evict = function(options2, limit) {
        var evicted = false;
        if (options2.id) {
          if (hasOwn2.call(this.data, options2.id)) {
            evicted = this.delete(options2.id, options2.fieldName, options2.args);
          }
          if (this instanceof Layer && this !== limit) {
            evicted = this.parent.evict(options2, limit) || evicted;
          }
          if (options2.fieldName || evicted) {
            this.group.dirty(options2.id, options2.fieldName || "__exists");
          }
        }
        return evicted;
      };
      EntityStore2.prototype.clear = function() {
        this.replace(null);
      };
      EntityStore2.prototype.extract = function() {
        var _this = this;
        var obj = this.toObject();
        var extraRootIds = [];
        this.getRootIdSet().forEach(function(id) {
          if (!hasOwn2.call(_this.policies.rootTypenamesById, id)) {
            extraRootIds.push(id);
          }
        });
        if (extraRootIds.length) {
          obj.__META = { extraRootIds: extraRootIds.sort() };
        }
        return obj;
      };
      EntityStore2.prototype.replace = function(newData) {
        var _this = this;
        Object.keys(this.data).forEach(function(dataId) {
          if (!(newData && hasOwn2.call(newData, dataId))) {
            _this.delete(dataId);
          }
        });
        if (newData) {
          var __META = newData.__META, rest_1 = __rest(newData, ["__META"]);
          Object.keys(rest_1).forEach(function(dataId) {
            _this.merge(dataId, rest_1[dataId]);
          });
          if (__META) {
            __META.extraRootIds.forEach(this.retain, this);
          }
        }
      };
      EntityStore2.prototype.retain = function(rootId) {
        return this.rootIds[rootId] = (this.rootIds[rootId] || 0) + 1;
      };
      EntityStore2.prototype.release = function(rootId) {
        if (this.rootIds[rootId] > 0) {
          var count = --this.rootIds[rootId];
          if (!count)
            delete this.rootIds[rootId];
          return count;
        }
        return 0;
      };
      EntityStore2.prototype.getRootIdSet = function(ids) {
        if (ids === void 0) {
          ids = /* @__PURE__ */ new Set();
        }
        Object.keys(this.rootIds).forEach(ids.add, ids);
        if (this instanceof Layer) {
          this.parent.getRootIdSet(ids);
        } else {
          Object.keys(this.policies.rootTypenamesById).forEach(ids.add, ids);
        }
        return ids;
      };
      EntityStore2.prototype.gc = function() {
        var _this = this;
        var ids = this.getRootIdSet();
        var snapshot = this.toObject();
        ids.forEach(function(id) {
          if (hasOwn2.call(snapshot, id)) {
            Object.keys(_this.findChildRefIds(id)).forEach(ids.add, ids);
            delete snapshot[id];
          }
        });
        var idsToRemove = Object.keys(snapshot);
        if (idsToRemove.length) {
          var root_1 = this;
          while (root_1 instanceof Layer)
            root_1 = root_1.parent;
          idsToRemove.forEach(function(id) {
            return root_1.delete(id);
          });
        }
        return idsToRemove;
      };
      EntityStore2.prototype.findChildRefIds = function(dataId) {
        if (!hasOwn2.call(this.refs, dataId)) {
          var found_1 = this.refs[dataId] = /* @__PURE__ */ Object.create(null);
          var root2 = this.data[dataId];
          if (!root2)
            return found_1;
          var workSet_1 = /* @__PURE__ */ new Set([root2]);
          workSet_1.forEach(function(obj) {
            if (isReference(obj)) {
              found_1[obj.__ref] = true;
            }
            if (isNonNullObject(obj)) {
              Object.keys(obj).forEach(function(key) {
                var child = obj[key];
                if (isNonNullObject(child)) {
                  workSet_1.add(child);
                }
              });
            }
          });
        }
        return this.refs[dataId];
      };
      EntityStore2.prototype.makeCacheKey = function() {
        return this.group.keyMaker.lookupArray(arguments);
      };
      return EntityStore2;
    })()
  );
  var CacheGroup = (
    /** @class */
    (function() {
      function CacheGroup2(caching, parent) {
        if (parent === void 0) {
          parent = null;
        }
        this.caching = caching;
        this.parent = parent;
        this.d = null;
        this.resetCaching();
      }
      CacheGroup2.prototype.resetCaching = function() {
        this.d = this.caching ? dep() : null;
        this.keyMaker = new Trie(canUseWeakMap);
      };
      CacheGroup2.prototype.depend = function(dataId, storeFieldName) {
        if (this.d) {
          this.d(makeDepKey(dataId, storeFieldName));
          var fieldName = fieldNameFromStoreName(storeFieldName);
          if (fieldName !== storeFieldName) {
            this.d(makeDepKey(dataId, fieldName));
          }
          if (this.parent) {
            this.parent.depend(dataId, storeFieldName);
          }
        }
      };
      CacheGroup2.prototype.dirty = function(dataId, storeFieldName) {
        if (this.d) {
          this.d.dirty(
            makeDepKey(dataId, storeFieldName),
            // When storeFieldName === "__exists", that means the entity identified
            // by dataId has either disappeared from the cache or was newly added,
            // so the result caching system would do well to "forget everything it
            // knows" about that object. To achieve that kind of invalidation, we
            // not only dirty the associated result cache entry, but also remove it
            // completely from the dependency graph. For the optimism implementation
            // details, see https://github.com/benjamn/optimism/pull/195.
            storeFieldName === "__exists" ? "forget" : "setDirty"
          );
        }
      };
      return CacheGroup2;
    })()
  );
  function makeDepKey(dataId, storeFieldName) {
    return storeFieldName + "#" + dataId;
  }
  function maybeDependOnExistenceOfEntity(store, entityId) {
    if (supportsResultCaching(store)) {
      store.group.depend(entityId, "__exists");
    }
  }
  (function(EntityStore2) {
    var Root = (
      /** @class */
      (function(_super) {
        __extends(Root2, _super);
        function Root2(_a2) {
          var policies = _a2.policies, _b = _a2.resultCaching, resultCaching = _b === void 0 ? true : _b, seed = _a2.seed;
          var _this = _super.call(this, policies, new CacheGroup(resultCaching)) || this;
          _this.stump = new Stump(_this);
          _this.storageTrie = new Trie(canUseWeakMap);
          if (seed)
            _this.replace(seed);
          return _this;
        }
        Root2.prototype.addLayer = function(layerId, replay) {
          return this.stump.addLayer(layerId, replay);
        };
        Root2.prototype.removeLayer = function() {
          return this;
        };
        Root2.prototype.getStorage = function() {
          return this.storageTrie.lookupArray(arguments);
        };
        return Root2;
      })(EntityStore2)
    );
    EntityStore2.Root = Root;
  })(EntityStore || (EntityStore = {}));
  var Layer = (
    /** @class */
    (function(_super) {
      __extends(Layer2, _super);
      function Layer2(id, parent, replay, group) {
        var _this = _super.call(this, parent.policies, group) || this;
        _this.id = id;
        _this.parent = parent;
        _this.replay = replay;
        _this.group = group;
        replay(_this);
        return _this;
      }
      Layer2.prototype.addLayer = function(layerId, replay) {
        return new Layer2(layerId, this, replay, this.group);
      };
      Layer2.prototype.removeLayer = function(layerId) {
        var _this = this;
        var parent = this.parent.removeLayer(layerId);
        if (layerId === this.id) {
          if (this.group.caching) {
            Object.keys(this.data).forEach(function(dataId) {
              var ownStoreObject = _this.data[dataId];
              var parentStoreObject = parent["lookup"](dataId);
              if (!parentStoreObject) {
                _this.delete(dataId);
              } else if (!ownStoreObject) {
                _this.group.dirty(dataId, "__exists");
                Object.keys(parentStoreObject).forEach(function(storeFieldName) {
                  _this.group.dirty(dataId, storeFieldName);
                });
              } else if (ownStoreObject !== parentStoreObject) {
                Object.keys(ownStoreObject).forEach(function(storeFieldName) {
                  if (!equal(ownStoreObject[storeFieldName], parentStoreObject[storeFieldName])) {
                    _this.group.dirty(dataId, storeFieldName);
                  }
                });
              }
            });
          }
          return parent;
        }
        if (parent === this.parent)
          return this;
        return parent.addLayer(this.id, this.replay);
      };
      Layer2.prototype.toObject = function() {
        return __assign(__assign({}, this.parent.toObject()), this.data);
      };
      Layer2.prototype.findChildRefIds = function(dataId) {
        var fromParent = this.parent.findChildRefIds(dataId);
        return hasOwn2.call(this.data, dataId) ? __assign(__assign({}, fromParent), _super.prototype.findChildRefIds.call(this, dataId)) : fromParent;
      };
      Layer2.prototype.getStorage = function() {
        var p = this.parent;
        while (p.parent)
          p = p.parent;
        return p.getStorage.apply(
          p,
          // @ts-expect-error
          arguments
        );
      };
      return Layer2;
    })(EntityStore)
  );
  var Stump = (
    /** @class */
    (function(_super) {
      __extends(Stump2, _super);
      function Stump2(root2) {
        return _super.call(this, "EntityStore.Stump", root2, function() {
        }, new CacheGroup(root2.group.caching, root2.group)) || this;
      }
      Stump2.prototype.removeLayer = function() {
        return this;
      };
      Stump2.prototype.merge = function(older, newer) {
        return this.parent.merge(older, newer);
      };
      return Stump2;
    })(Layer)
  );
  function storeObjectReconciler(existingObject, incomingObject, property) {
    var existingValue = existingObject[property];
    var incomingValue = incomingObject[property];
    return equal(existingValue, incomingValue) ? existingValue : incomingValue;
  }
  function supportsResultCaching(store) {
    return !!(store instanceof EntityStore && store.group.caching);
  }

  // node_modules/@apollo/client/cache/inmemory/object-canon.js
  function shallowCopy(value) {
    if (isNonNullObject(value)) {
      return isArray2(value) ? value.slice(0) : __assign({ __proto__: Object.getPrototypeOf(value) }, value);
    }
    return value;
  }
  var ObjectCanon = (
    /** @class */
    (function() {
      function ObjectCanon2() {
        this.known = new (canUseWeakSet ? WeakSet : Set)();
        this.pool = new Trie(canUseWeakMap);
        this.passes = /* @__PURE__ */ new WeakMap();
        this.keysByJSON = /* @__PURE__ */ new Map();
        this.empty = this.admit({});
      }
      ObjectCanon2.prototype.isKnown = function(value) {
        return isNonNullObject(value) && this.known.has(value);
      };
      ObjectCanon2.prototype.pass = function(value) {
        if (isNonNullObject(value)) {
          var copy2 = shallowCopy(value);
          this.passes.set(copy2, value);
          return copy2;
        }
        return value;
      };
      ObjectCanon2.prototype.admit = function(value) {
        var _this = this;
        if (isNonNullObject(value)) {
          var original = this.passes.get(value);
          if (original)
            return original;
          var proto = Object.getPrototypeOf(value);
          switch (proto) {
            case Array.prototype: {
              if (this.known.has(value))
                return value;
              var array = value.map(this.admit, this);
              var node2 = this.pool.lookupArray(array);
              if (!node2.array) {
                this.known.add(node2.array = array);
                if (globalThis.__DEV__ !== false) {
                  Object.freeze(array);
                }
              }
              return node2.array;
            }
            case null:
            case Object.prototype: {
              if (this.known.has(value))
                return value;
              var proto_1 = Object.getPrototypeOf(value);
              var array_1 = [proto_1];
              var keys = this.sortedKeys(value);
              array_1.push(keys.json);
              var firstValueIndex_1 = array_1.length;
              keys.sorted.forEach(function(key) {
                array_1.push(_this.admit(value[key]));
              });
              var node2 = this.pool.lookupArray(array_1);
              if (!node2.object) {
                var obj_1 = node2.object = Object.create(proto_1);
                this.known.add(obj_1);
                keys.sorted.forEach(function(key, i) {
                  obj_1[key] = array_1[firstValueIndex_1 + i];
                });
                if (globalThis.__DEV__ !== false) {
                  Object.freeze(obj_1);
                }
              }
              return node2.object;
            }
          }
        }
        return value;
      };
      ObjectCanon2.prototype.sortedKeys = function(obj) {
        var keys = Object.keys(obj);
        var node2 = this.pool.lookupArray(keys);
        if (!node2.keys) {
          keys.sort();
          var json = JSON.stringify(keys);
          if (!(node2.keys = this.keysByJSON.get(json))) {
            this.keysByJSON.set(json, node2.keys = { sorted: keys, json });
          }
        }
        return node2.keys;
      };
      return ObjectCanon2;
    })()
  );

  // node_modules/@apollo/client/cache/inmemory/readFromStore.js
  function execSelectionSetKeyArgs(options2) {
    return [
      options2.selectionSet,
      options2.objectOrReference,
      options2.context,
      // We split out this property so we can pass different values
      // independently without modifying options.context itself.
      options2.context.canonizeResults
    ];
  }
  var StoreReader = (
    /** @class */
    (function() {
      function StoreReader2(config) {
        var _this = this;
        this.knownResults = new (canUseWeakMap ? WeakMap : Map)();
        this.config = compact(config, {
          addTypename: config.addTypename !== false,
          canonizeResults: shouldCanonizeResults(config)
        });
        this.canon = config.canon || new ObjectCanon();
        this.executeSelectionSet = wrap3(function(options2) {
          var _a2;
          var canonizeResults = options2.context.canonizeResults;
          var peekArgs = execSelectionSetKeyArgs(options2);
          peekArgs[3] = !canonizeResults;
          var other = (_a2 = _this.executeSelectionSet).peek.apply(_a2, peekArgs);
          if (other) {
            if (canonizeResults) {
              return __assign(__assign({}, other), {
                // If we previously read this result without canonizing it, we can
                // reuse that result simply by canonizing it now.
                result: _this.canon.admit(other.result)
              });
            }
            return other;
          }
          maybeDependOnExistenceOfEntity(options2.context.store, options2.enclosingRef.__ref);
          return _this.execSelectionSetImpl(options2);
        }, {
          max: this.config.resultCacheMaxSize || cacheSizes["inMemoryCache.executeSelectionSet"] || 5e4,
          keyArgs: execSelectionSetKeyArgs,
          // Note that the parameters of makeCacheKey are determined by the
          // array returned by keyArgs.
          makeCacheKey: function(selectionSet, parent, context, canonizeResults) {
            if (supportsResultCaching(context.store)) {
              return context.store.makeCacheKey(selectionSet, isReference(parent) ? parent.__ref : parent, context.varString, canonizeResults);
            }
          }
        });
        this.executeSubSelectedArray = wrap3(function(options2) {
          maybeDependOnExistenceOfEntity(options2.context.store, options2.enclosingRef.__ref);
          return _this.execSubSelectedArrayImpl(options2);
        }, {
          max: this.config.resultCacheMaxSize || cacheSizes["inMemoryCache.executeSubSelectedArray"] || 1e4,
          makeCacheKey: function(_a2) {
            var field = _a2.field, array = _a2.array, context = _a2.context;
            if (supportsResultCaching(context.store)) {
              return context.store.makeCacheKey(field, array, context.varString);
            }
          }
        });
      }
      StoreReader2.prototype.resetCanon = function() {
        this.canon = new ObjectCanon();
      };
      StoreReader2.prototype.diffQueryAgainstStore = function(_a2) {
        var store = _a2.store, query = _a2.query, _b = _a2.rootId, rootId = _b === void 0 ? "ROOT_QUERY" : _b, variables = _a2.variables, _c = _a2.returnPartialData, returnPartialData = _c === void 0 ? true : _c, _d = _a2.canonizeResults, canonizeResults = _d === void 0 ? this.config.canonizeResults : _d;
        var policies = this.config.cache.policies;
        variables = __assign(__assign({}, getDefaultValues(getQueryDefinition(query))), variables);
        var rootRef = makeReference(rootId);
        var execResult = this.executeSelectionSet({
          selectionSet: getMainDefinition(query).selectionSet,
          objectOrReference: rootRef,
          enclosingRef: rootRef,
          context: __assign({ store, query, policies, variables, varString: canonicalStringify(variables), canonizeResults }, extractFragmentContext(query, this.config.fragments))
        });
        var missing;
        if (execResult.missing) {
          missing = [
            new MissingFieldError(firstMissing(execResult.missing), execResult.missing, query, variables)
          ];
          if (!returnPartialData) {
            throw missing[0];
          }
        }
        return {
          result: execResult.result,
          complete: !missing,
          missing
        };
      };
      StoreReader2.prototype.isFresh = function(result2, parent, selectionSet, context) {
        if (supportsResultCaching(context.store) && this.knownResults.get(result2) === selectionSet) {
          var latest = this.executeSelectionSet.peek(
            selectionSet,
            parent,
            context,
            // If result is canonical, then it could only have been previously
            // cached by the canonizing version of executeSelectionSet, so we can
            // avoid checking both possibilities here.
            this.canon.isKnown(result2)
          );
          if (latest && result2 === latest.result) {
            return true;
          }
        }
        return false;
      };
      StoreReader2.prototype.execSelectionSetImpl = function(_a2) {
        var _this = this;
        var selectionSet = _a2.selectionSet, objectOrReference = _a2.objectOrReference, enclosingRef = _a2.enclosingRef, context = _a2.context;
        if (isReference(objectOrReference) && !context.policies.rootTypenamesById[objectOrReference.__ref] && !context.store.has(objectOrReference.__ref)) {
          return {
            result: this.canon.empty,
            missing: "Dangling reference to missing ".concat(objectOrReference.__ref, " object")
          };
        }
        var variables = context.variables, policies = context.policies, store = context.store;
        var typename = store.getFieldValue(objectOrReference, "__typename");
        var objectsToMerge = [];
        var missing;
        var missingMerger = new DeepMerger();
        if (this.config.addTypename && typeof typename === "string" && !policies.rootIdsByTypename[typename]) {
          objectsToMerge.push({ __typename: typename });
        }
        function handleMissing(result3, resultName) {
          var _a3;
          if (result3.missing) {
            missing = missingMerger.merge(missing, (_a3 = {}, _a3[resultName] = result3.missing, _a3));
          }
          return result3.result;
        }
        var workSet = new Set(selectionSet.selections);
        workSet.forEach(function(selection) {
          var _a3, _b;
          if (!shouldInclude(selection, variables))
            return;
          if (isField(selection)) {
            var fieldValue = policies.readField({
              fieldName: selection.name.value,
              field: selection,
              variables: context.variables,
              from: objectOrReference
            }, context);
            var resultName = resultKeyNameFromField(selection);
            if (fieldValue === void 0) {
              if (!addTypenameToDocument.added(selection)) {
                missing = missingMerger.merge(missing, (_a3 = {}, _a3[resultName] = "Can't find field '".concat(selection.name.value, "' on ").concat(isReference(objectOrReference) ? objectOrReference.__ref + " object" : "object " + JSON.stringify(objectOrReference, null, 2)), _a3));
              }
            } else if (isArray2(fieldValue)) {
              if (fieldValue.length > 0) {
                fieldValue = handleMissing(_this.executeSubSelectedArray({
                  field: selection,
                  array: fieldValue,
                  enclosingRef,
                  context
                }), resultName);
              }
            } else if (!selection.selectionSet) {
              if (context.canonizeResults) {
                fieldValue = _this.canon.pass(fieldValue);
              }
            } else if (fieldValue != null) {
              fieldValue = handleMissing(_this.executeSelectionSet({
                selectionSet: selection.selectionSet,
                objectOrReference: fieldValue,
                enclosingRef: isReference(fieldValue) ? fieldValue : enclosingRef,
                context
              }), resultName);
            }
            if (fieldValue !== void 0) {
              objectsToMerge.push((_b = {}, _b[resultName] = fieldValue, _b));
            }
          } else {
            var fragment = getFragmentFromSelection(selection, context.lookupFragment);
            if (!fragment && selection.kind === Kind.FRAGMENT_SPREAD) {
              throw newInvariantError(10, selection.name.value);
            }
            if (fragment && policies.fragmentMatches(fragment, typename)) {
              fragment.selectionSet.selections.forEach(workSet.add, workSet);
            }
          }
        });
        var result2 = mergeDeepArray(objectsToMerge);
        var finalResult = { result: result2, missing };
        var frozen = context.canonizeResults ? this.canon.admit(finalResult) : maybeDeepFreeze(finalResult);
        if (frozen.result) {
          this.knownResults.set(frozen.result, selectionSet);
        }
        return frozen;
      };
      StoreReader2.prototype.execSubSelectedArrayImpl = function(_a2) {
        var _this = this;
        var field = _a2.field, array = _a2.array, enclosingRef = _a2.enclosingRef, context = _a2.context;
        var missing;
        var missingMerger = new DeepMerger();
        function handleMissing(childResult, i) {
          var _a3;
          if (childResult.missing) {
            missing = missingMerger.merge(missing, (_a3 = {}, _a3[i] = childResult.missing, _a3));
          }
          return childResult.result;
        }
        if (field.selectionSet) {
          array = array.filter(context.store.canRead);
        }
        array = array.map(function(item, i) {
          if (item === null) {
            return null;
          }
          if (isArray2(item)) {
            return handleMissing(_this.executeSubSelectedArray({
              field,
              array: item,
              enclosingRef,
              context
            }), i);
          }
          if (field.selectionSet) {
            return handleMissing(_this.executeSelectionSet({
              selectionSet: field.selectionSet,
              objectOrReference: item,
              enclosingRef: isReference(item) ? item : enclosingRef,
              context
            }), i);
          }
          if (globalThis.__DEV__ !== false) {
            assertSelectionSetForIdValue(context.store, field, item);
          }
          return item;
        });
        return {
          result: context.canonizeResults ? this.canon.admit(array) : array,
          missing
        };
      };
      return StoreReader2;
    })()
  );
  function firstMissing(tree) {
    try {
      JSON.stringify(tree, function(_, value) {
        if (typeof value === "string")
          throw value;
        return value;
      });
    } catch (result2) {
      return result2;
    }
  }
  function assertSelectionSetForIdValue(store, field, fieldValue) {
    if (!field.selectionSet) {
      var workSet_1 = /* @__PURE__ */ new Set([fieldValue]);
      workSet_1.forEach(function(value) {
        if (isNonNullObject(value)) {
          invariant3(
            !isReference(value),
            11,
            getTypenameFromStoreObject(store, value),
            field.name.value
          );
          Object.values(value).forEach(workSet_1.add, workSet_1);
        }
      });
    }
  }

  // node_modules/@apollo/client/cache/inmemory/reactiveVars.js
  var cacheSlot = new Slot();
  var cacheInfoMap = /* @__PURE__ */ new WeakMap();
  function getCacheInfo(cache) {
    var info = cacheInfoMap.get(cache);
    if (!info) {
      cacheInfoMap.set(cache, info = {
        vars: /* @__PURE__ */ new Set(),
        dep: dep()
      });
    }
    return info;
  }
  function forgetCache(cache) {
    getCacheInfo(cache).vars.forEach(function(rv) {
      return rv.forgetCache(cache);
    });
  }
  function recallCache(cache) {
    getCacheInfo(cache).vars.forEach(function(rv) {
      return rv.attachCache(cache);
    });
  }
  function makeVar(value) {
    var caches2 = /* @__PURE__ */ new Set();
    var listeners = /* @__PURE__ */ new Set();
    var rv = function(newValue) {
      if (arguments.length > 0) {
        if (value !== newValue) {
          value = newValue;
          caches2.forEach(function(cache2) {
            getCacheInfo(cache2).dep.dirty(rv);
            broadcast(cache2);
          });
          var oldListeners = Array.from(listeners);
          listeners.clear();
          oldListeners.forEach(function(listener) {
            return listener(value);
          });
        }
      } else {
        var cache = cacheSlot.getValue();
        if (cache) {
          attach(cache);
          getCacheInfo(cache).dep(rv);
        }
      }
      return value;
    };
    rv.onNextChange = function(listener) {
      listeners.add(listener);
      return function() {
        listeners.delete(listener);
      };
    };
    var attach = rv.attachCache = function(cache) {
      caches2.add(cache);
      getCacheInfo(cache).vars.add(rv);
      return rv;
    };
    rv.forgetCache = function(cache) {
      return caches2.delete(cache);
    };
    return rv;
  }
  function broadcast(cache) {
    if (cache.broadcastWatches) {
      cache.broadcastWatches();
    }
  }

  // node_modules/@apollo/client/cache/inmemory/key-extractor.js
  var specifierInfoCache = /* @__PURE__ */ Object.create(null);
  function lookupSpecifierInfo(spec) {
    var cacheKey = JSON.stringify(spec);
    return specifierInfoCache[cacheKey] || (specifierInfoCache[cacheKey] = /* @__PURE__ */ Object.create(null));
  }
  function keyFieldsFnFromSpecifier(specifier) {
    var info = lookupSpecifierInfo(specifier);
    return info.keyFieldsFn || (info.keyFieldsFn = function(object, context) {
      var extract = function(from2, key) {
        return context.readField(key, from2);
      };
      var keyObject = context.keyObject = collectSpecifierPaths(specifier, function(schemaKeyPath) {
        var extracted = extractKeyPath(
          context.storeObject,
          schemaKeyPath,
          // Using context.readField to extract paths from context.storeObject
          // allows the extraction to see through Reference objects and respect
          // custom read functions.
          extract
        );
        if (extracted === void 0 && object !== context.storeObject && hasOwn2.call(object, schemaKeyPath[0])) {
          extracted = extractKeyPath(object, schemaKeyPath, extractKey);
        }
        invariant3(extracted !== void 0, 5, schemaKeyPath.join("."), object);
        return extracted;
      });
      return "".concat(context.typename, ":").concat(JSON.stringify(keyObject));
    });
  }
  function keyArgsFnFromSpecifier(specifier) {
    var info = lookupSpecifierInfo(specifier);
    return info.keyArgsFn || (info.keyArgsFn = function(args, _a2) {
      var field = _a2.field, variables = _a2.variables, fieldName = _a2.fieldName;
      var collected = collectSpecifierPaths(specifier, function(keyPath) {
        var firstKey = keyPath[0];
        var firstChar = firstKey.charAt(0);
        if (firstChar === "@") {
          if (field && isNonEmptyArray(field.directives)) {
            var directiveName_1 = firstKey.slice(1);
            var d = field.directives.find(function(d2) {
              return d2.name.value === directiveName_1;
            });
            var directiveArgs = d && argumentsObjectFromField(d, variables);
            return directiveArgs && extractKeyPath(
              directiveArgs,
              // If keyPath.length === 1, this code calls extractKeyPath with an
              // empty path, which works because it uses directiveArgs as the
              // extracted value.
              keyPath.slice(1)
            );
          }
          return;
        }
        if (firstChar === "$") {
          var variableName = firstKey.slice(1);
          if (variables && hasOwn2.call(variables, variableName)) {
            var varKeyPath = keyPath.slice(0);
            varKeyPath[0] = variableName;
            return extractKeyPath(variables, varKeyPath);
          }
          return;
        }
        if (args) {
          return extractKeyPath(args, keyPath);
        }
      });
      var suffix = JSON.stringify(collected);
      if (args || suffix !== "{}") {
        fieldName += ":" + suffix;
      }
      return fieldName;
    });
  }
  function collectSpecifierPaths(specifier, extractor) {
    var merger = new DeepMerger();
    return getSpecifierPaths(specifier).reduce(function(collected, path) {
      var _a2;
      var toMerge = extractor(path);
      if (toMerge !== void 0) {
        for (var i = path.length - 1; i >= 0; --i) {
          toMerge = (_a2 = {}, _a2[path[i]] = toMerge, _a2);
        }
        collected = merger.merge(collected, toMerge);
      }
      return collected;
    }, /* @__PURE__ */ Object.create(null));
  }
  function getSpecifierPaths(spec) {
    var info = lookupSpecifierInfo(spec);
    if (!info.paths) {
      var paths_1 = info.paths = [];
      var currentPath_1 = [];
      spec.forEach(function(s, i) {
        if (isArray2(s)) {
          getSpecifierPaths(s).forEach(function(p) {
            return paths_1.push(currentPath_1.concat(p));
          });
          currentPath_1.length = 0;
        } else {
          currentPath_1.push(s);
          if (!isArray2(spec[i + 1])) {
            paths_1.push(currentPath_1.slice(0));
            currentPath_1.length = 0;
          }
        }
      });
    }
    return info.paths;
  }
  function extractKey(object, key) {
    return object[key];
  }
  function extractKeyPath(object, path, extract) {
    extract = extract || extractKey;
    return normalize(path.reduce(function reducer(obj, key) {
      return isArray2(obj) ? obj.map(function(child) {
        return reducer(child, key);
      }) : obj && extract(obj, key);
    }, object));
  }
  function normalize(value) {
    if (isNonNullObject(value)) {
      if (isArray2(value)) {
        return value.map(normalize);
      }
      return collectSpecifierPaths(Object.keys(value).sort(), function(path) {
        return extractKeyPath(value, path);
      });
    }
    return value;
  }

  // node_modules/@apollo/client/cache/inmemory/policies.js
  function argsFromFieldSpecifier(spec) {
    return spec.args !== void 0 ? spec.args : spec.field ? argumentsObjectFromField(spec.field, spec.variables) : null;
  }
  var nullKeyFieldsFn = function() {
    return void 0;
  };
  var simpleKeyArgsFn = function(_args, context) {
    return context.fieldName;
  };
  var mergeTrueFn = function(existing, incoming, _a2) {
    var mergeObjects = _a2.mergeObjects;
    return mergeObjects(existing, incoming);
  };
  var mergeFalseFn = function(_, incoming) {
    return incoming;
  };
  var Policies = (
    /** @class */
    (function() {
      function Policies2(config) {
        this.config = config;
        this.typePolicies = /* @__PURE__ */ Object.create(null);
        this.toBeAdded = /* @__PURE__ */ Object.create(null);
        this.supertypeMap = /* @__PURE__ */ new Map();
        this.fuzzySubtypes = /* @__PURE__ */ new Map();
        this.rootIdsByTypename = /* @__PURE__ */ Object.create(null);
        this.rootTypenamesById = /* @__PURE__ */ Object.create(null);
        this.usingPossibleTypes = false;
        this.config = __assign({ dataIdFromObject: defaultDataIdFromObject }, config);
        this.cache = this.config.cache;
        this.setRootTypename("Query");
        this.setRootTypename("Mutation");
        this.setRootTypename("Subscription");
        if (config.possibleTypes) {
          this.addPossibleTypes(config.possibleTypes);
        }
        if (config.typePolicies) {
          this.addTypePolicies(config.typePolicies);
        }
      }
      Policies2.prototype.identify = function(object, partialContext) {
        var _a2;
        var policies = this;
        var typename = partialContext && (partialContext.typename || ((_a2 = partialContext.storeObject) === null || _a2 === void 0 ? void 0 : _a2.__typename)) || object.__typename;
        if (typename === this.rootTypenamesById.ROOT_QUERY) {
          return ["ROOT_QUERY"];
        }
        var storeObject = partialContext && partialContext.storeObject || object;
        var context = __assign(__assign({}, partialContext), { typename, storeObject, readField: partialContext && partialContext.readField || function() {
          var options2 = normalizeReadFieldOptions(arguments, storeObject);
          return policies.readField(options2, {
            store: policies.cache["data"],
            variables: options2.variables
          });
        } });
        var id;
        var policy = typename && this.getTypePolicy(typename);
        var keyFn = policy && policy.keyFn || this.config.dataIdFromObject;
        disableWarningsSlot.withValue(true, function() {
          while (keyFn) {
            var specifierOrId = keyFn(__assign(__assign({}, object), storeObject), context);
            if (isArray2(specifierOrId)) {
              keyFn = keyFieldsFnFromSpecifier(specifierOrId);
            } else {
              id = specifierOrId;
              break;
            }
          }
        });
        id = id ? String(id) : void 0;
        return context.keyObject ? [id, context.keyObject] : [id];
      };
      Policies2.prototype.addTypePolicies = function(typePolicies) {
        var _this = this;
        Object.keys(typePolicies).forEach(function(typename) {
          var _a2 = typePolicies[typename], queryType = _a2.queryType, mutationType = _a2.mutationType, subscriptionType = _a2.subscriptionType, incoming = __rest(_a2, ["queryType", "mutationType", "subscriptionType"]);
          if (queryType)
            _this.setRootTypename("Query", typename);
          if (mutationType)
            _this.setRootTypename("Mutation", typename);
          if (subscriptionType)
            _this.setRootTypename("Subscription", typename);
          if (hasOwn2.call(_this.toBeAdded, typename)) {
            _this.toBeAdded[typename].push(incoming);
          } else {
            _this.toBeAdded[typename] = [incoming];
          }
        });
      };
      Policies2.prototype.updateTypePolicy = function(typename, incoming) {
        var _this = this;
        var existing = this.getTypePolicy(typename);
        var keyFields = incoming.keyFields, fields = incoming.fields;
        function setMerge(existing2, merge) {
          existing2.merge = typeof merge === "function" ? merge : merge === true ? mergeTrueFn : merge === false ? mergeFalseFn : existing2.merge;
        }
        setMerge(existing, incoming.merge);
        existing.keyFn = // Pass false to disable normalization for this typename.
        keyFields === false ? nullKeyFieldsFn : isArray2(keyFields) ? keyFieldsFnFromSpecifier(keyFields) : typeof keyFields === "function" ? keyFields : existing.keyFn;
        if (fields) {
          Object.keys(fields).forEach(function(fieldName) {
            var existing2 = _this.getFieldPolicy(typename, fieldName, true);
            var incoming2 = fields[fieldName];
            if (typeof incoming2 === "function") {
              existing2.read = incoming2;
            } else {
              var keyArgs = incoming2.keyArgs, read2 = incoming2.read, merge = incoming2.merge;
              existing2.keyFn = // Pass false to disable argument-based differentiation of
              // field identities.
              keyArgs === false ? simpleKeyArgsFn : isArray2(keyArgs) ? keyArgsFnFromSpecifier(keyArgs) : typeof keyArgs === "function" ? keyArgs : existing2.keyFn;
              if (typeof read2 === "function") {
                existing2.read = read2;
              }
              setMerge(existing2, merge);
            }
            if (existing2.read && existing2.merge) {
              existing2.keyFn = existing2.keyFn || simpleKeyArgsFn;
            }
          });
        }
      };
      Policies2.prototype.setRootTypename = function(which, typename) {
        if (typename === void 0) {
          typename = which;
        }
        var rootId = "ROOT_" + which.toUpperCase();
        var old = this.rootTypenamesById[rootId];
        if (typename !== old) {
          invariant3(!old || old === which, 6, which);
          if (old)
            delete this.rootIdsByTypename[old];
          this.rootIdsByTypename[typename] = rootId;
          this.rootTypenamesById[rootId] = typename;
        }
      };
      Policies2.prototype.addPossibleTypes = function(possibleTypes) {
        var _this = this;
        this.usingPossibleTypes = true;
        Object.keys(possibleTypes).forEach(function(supertype) {
          _this.getSupertypeSet(supertype, true);
          possibleTypes[supertype].forEach(function(subtype) {
            _this.getSupertypeSet(subtype, true).add(supertype);
            var match3 = subtype.match(TypeOrFieldNameRegExp);
            if (!match3 || match3[0] !== subtype) {
              _this.fuzzySubtypes.set(subtype, new RegExp(subtype));
            }
          });
        });
      };
      Policies2.prototype.getTypePolicy = function(typename) {
        var _this = this;
        if (!hasOwn2.call(this.typePolicies, typename)) {
          var policy_1 = this.typePolicies[typename] = /* @__PURE__ */ Object.create(null);
          policy_1.fields = /* @__PURE__ */ Object.create(null);
          var supertypes_1 = this.supertypeMap.get(typename);
          if (!supertypes_1 && this.fuzzySubtypes.size) {
            supertypes_1 = this.getSupertypeSet(typename, true);
            this.fuzzySubtypes.forEach(function(regExp, fuzzy) {
              if (regExp.test(typename)) {
                var fuzzySupertypes = _this.supertypeMap.get(fuzzy);
                if (fuzzySupertypes) {
                  fuzzySupertypes.forEach(function(supertype) {
                    return supertypes_1.add(supertype);
                  });
                }
              }
            });
          }
          if (supertypes_1 && supertypes_1.size) {
            supertypes_1.forEach(function(supertype) {
              var _a2 = _this.getTypePolicy(supertype), fields = _a2.fields, rest = __rest(_a2, ["fields"]);
              Object.assign(policy_1, rest);
              Object.assign(policy_1.fields, fields);
            });
          }
        }
        var inbox = this.toBeAdded[typename];
        if (inbox && inbox.length) {
          inbox.splice(0).forEach(function(policy) {
            _this.updateTypePolicy(typename, policy);
          });
        }
        return this.typePolicies[typename];
      };
      Policies2.prototype.getFieldPolicy = function(typename, fieldName, createIfMissing) {
        if (typename) {
          var fieldPolicies = this.getTypePolicy(typename).fields;
          return fieldPolicies[fieldName] || createIfMissing && (fieldPolicies[fieldName] = /* @__PURE__ */ Object.create(null));
        }
      };
      Policies2.prototype.getSupertypeSet = function(subtype, createIfMissing) {
        var supertypeSet = this.supertypeMap.get(subtype);
        if (!supertypeSet && createIfMissing) {
          this.supertypeMap.set(subtype, supertypeSet = /* @__PURE__ */ new Set());
        }
        return supertypeSet;
      };
      Policies2.prototype.fragmentMatches = function(fragment, typename, result2, variables) {
        var _this = this;
        if (!fragment.typeCondition)
          return true;
        if (!typename)
          return false;
        var supertype = fragment.typeCondition.name.value;
        if (typename === supertype)
          return true;
        if (this.usingPossibleTypes && this.supertypeMap.has(supertype)) {
          var typenameSupertypeSet = this.getSupertypeSet(typename, true);
          var workQueue_1 = [typenameSupertypeSet];
          var maybeEnqueue_1 = function(subtype) {
            var supertypeSet2 = _this.getSupertypeSet(subtype, false);
            if (supertypeSet2 && supertypeSet2.size && workQueue_1.indexOf(supertypeSet2) < 0) {
              workQueue_1.push(supertypeSet2);
            }
          };
          var needToCheckFuzzySubtypes = !!(result2 && this.fuzzySubtypes.size);
          var checkingFuzzySubtypes = false;
          for (var i = 0; i < workQueue_1.length; ++i) {
            var supertypeSet = workQueue_1[i];
            if (supertypeSet.has(supertype)) {
              if (!typenameSupertypeSet.has(supertype)) {
                if (checkingFuzzySubtypes) {
                  globalThis.__DEV__ !== false && invariant3.warn(7, typename, supertype);
                }
                typenameSupertypeSet.add(supertype);
              }
              return true;
            }
            supertypeSet.forEach(maybeEnqueue_1);
            if (needToCheckFuzzySubtypes && // Start checking fuzzy subtypes only after exhausting all
            // non-fuzzy subtypes (after the final iteration of the loop).
            i === workQueue_1.length - 1 && // We could wait to compare fragment.selectionSet to result
            // after we verify the supertype, but this check is often less
            // expensive than that search, and we will have to do the
            // comparison anyway whenever we find a potential match.
            selectionSetMatchesResult(fragment.selectionSet, result2, variables)) {
              needToCheckFuzzySubtypes = false;
              checkingFuzzySubtypes = true;
              this.fuzzySubtypes.forEach(function(regExp, fuzzyString) {
                var match3 = typename.match(regExp);
                if (match3 && match3[0] === typename) {
                  maybeEnqueue_1(fuzzyString);
                }
              });
            }
          }
        }
        return false;
      };
      Policies2.prototype.hasKeyArgs = function(typename, fieldName) {
        var policy = this.getFieldPolicy(typename, fieldName, false);
        return !!(policy && policy.keyFn);
      };
      Policies2.prototype.getStoreFieldName = function(fieldSpec) {
        var typename = fieldSpec.typename, fieldName = fieldSpec.fieldName;
        var policy = this.getFieldPolicy(typename, fieldName, false);
        var storeFieldName;
        var keyFn = policy && policy.keyFn;
        if (keyFn && typename) {
          var context = {
            typename,
            fieldName,
            field: fieldSpec.field || null,
            variables: fieldSpec.variables
          };
          var args = argsFromFieldSpecifier(fieldSpec);
          while (keyFn) {
            var specifierOrString = keyFn(args, context);
            if (isArray2(specifierOrString)) {
              keyFn = keyArgsFnFromSpecifier(specifierOrString);
            } else {
              storeFieldName = specifierOrString || fieldName;
              break;
            }
          }
        }
        if (storeFieldName === void 0) {
          storeFieldName = fieldSpec.field ? storeKeyNameFromField(fieldSpec.field, fieldSpec.variables) : getStoreKeyName(fieldName, argsFromFieldSpecifier(fieldSpec));
        }
        if (storeFieldName === false) {
          return fieldName;
        }
        return fieldName === fieldNameFromStoreName(storeFieldName) ? storeFieldName : fieldName + ":" + storeFieldName;
      };
      Policies2.prototype.readField = function(options2, context) {
        var objectOrReference = options2.from;
        if (!objectOrReference)
          return;
        var nameOrField = options2.field || options2.fieldName;
        if (!nameOrField)
          return;
        if (options2.typename === void 0) {
          var typename = context.store.getFieldValue(objectOrReference, "__typename");
          if (typename)
            options2.typename = typename;
        }
        var storeFieldName = this.getStoreFieldName(options2);
        var fieldName = fieldNameFromStoreName(storeFieldName);
        var existing = context.store.getFieldValue(objectOrReference, storeFieldName);
        var policy = this.getFieldPolicy(options2.typename, fieldName, false);
        var read2 = policy && policy.read;
        if (read2) {
          var readOptions = makeFieldFunctionOptions(this, objectOrReference, options2, context, context.store.getStorage(isReference(objectOrReference) ? objectOrReference.__ref : objectOrReference, storeFieldName));
          return cacheSlot.withValue(this.cache, read2, [
            existing,
            readOptions
          ]);
        }
        return existing;
      };
      Policies2.prototype.getReadFunction = function(typename, fieldName) {
        var policy = this.getFieldPolicy(typename, fieldName, false);
        return policy && policy.read;
      };
      Policies2.prototype.getMergeFunction = function(parentTypename, fieldName, childTypename) {
        var policy = this.getFieldPolicy(parentTypename, fieldName, false);
        var merge = policy && policy.merge;
        if (!merge && childTypename) {
          policy = this.getTypePolicy(childTypename);
          merge = policy && policy.merge;
        }
        return merge;
      };
      Policies2.prototype.runMergeFunction = function(existing, incoming, _a2, context, storage) {
        var field = _a2.field, typename = _a2.typename, merge = _a2.merge;
        if (merge === mergeTrueFn) {
          return makeMergeObjectsFunction(context.store)(existing, incoming);
        }
        if (merge === mergeFalseFn) {
          return incoming;
        }
        if (context.overwrite) {
          existing = void 0;
        }
        return merge(existing, incoming, makeFieldFunctionOptions(
          this,
          // Unlike options.readField for read functions, we do not fall
          // back to the current object if no foreignObjOrRef is provided,
          // because it's not clear what the current object should be for
          // merge functions: the (possibly undefined) existing object, or
          // the incoming object? If you think your merge function needs
          // to read sibling fields in order to produce a new value for
          // the current field, you might want to rethink your strategy,
          // because that's a recipe for making merge behavior sensitive
          // to the order in which fields are written into the cache.
          // However, readField(name, ref) is useful for merge functions
          // that need to deduplicate child objects and references.
          void 0,
          {
            typename,
            fieldName: field.name.value,
            field,
            variables: context.variables
          },
          context,
          storage || /* @__PURE__ */ Object.create(null)
        ));
      };
      return Policies2;
    })()
  );
  function makeFieldFunctionOptions(policies, objectOrReference, fieldSpec, context, storage) {
    var storeFieldName = policies.getStoreFieldName(fieldSpec);
    var fieldName = fieldNameFromStoreName(storeFieldName);
    var variables = fieldSpec.variables || context.variables;
    var _a2 = context.store, toReference = _a2.toReference, canRead = _a2.canRead;
    return {
      args: argsFromFieldSpecifier(fieldSpec),
      field: fieldSpec.field || null,
      fieldName,
      storeFieldName,
      variables,
      isReference,
      toReference,
      storage,
      cache: policies.cache,
      canRead,
      readField: function() {
        return policies.readField(normalizeReadFieldOptions(arguments, objectOrReference, variables), context);
      },
      mergeObjects: makeMergeObjectsFunction(context.store)
    };
  }
  function normalizeReadFieldOptions(readFieldArgs, objectOrReference, variables) {
    var fieldNameOrOptions = readFieldArgs[0], from2 = readFieldArgs[1], argc = readFieldArgs.length;
    var options2;
    if (typeof fieldNameOrOptions === "string") {
      options2 = {
        fieldName: fieldNameOrOptions,
        // Default to objectOrReference only when no second argument was
        // passed for the from parameter, not when undefined is explicitly
        // passed as the second argument.
        from: argc > 1 ? from2 : objectOrReference
      };
    } else {
      options2 = __assign({}, fieldNameOrOptions);
      if (!hasOwn2.call(options2, "from")) {
        options2.from = objectOrReference;
      }
    }
    if (globalThis.__DEV__ !== false && options2.from === void 0) {
      globalThis.__DEV__ !== false && invariant3.warn(8, stringifyForDisplay(Array.from(readFieldArgs)));
    }
    if (void 0 === options2.variables) {
      options2.variables = variables;
    }
    return options2;
  }
  function makeMergeObjectsFunction(store) {
    return function mergeObjects(existing, incoming) {
      if (isArray2(existing) || isArray2(incoming)) {
        throw newInvariantError(9);
      }
      if (isNonNullObject(existing) && isNonNullObject(incoming)) {
        var eType = store.getFieldValue(existing, "__typename");
        var iType = store.getFieldValue(incoming, "__typename");
        var typesDiffer = eType && iType && eType !== iType;
        if (typesDiffer) {
          return incoming;
        }
        if (isReference(existing) && storeValueIsStoreObject(incoming)) {
          store.merge(existing.__ref, incoming);
          return existing;
        }
        if (storeValueIsStoreObject(existing) && isReference(incoming)) {
          store.merge(existing, incoming.__ref);
          return incoming;
        }
        if (storeValueIsStoreObject(existing) && storeValueIsStoreObject(incoming)) {
          return __assign(__assign({}, existing), incoming);
        }
      }
      return incoming;
    };
  }

  // node_modules/@apollo/client/cache/inmemory/writeToStore.js
  function getContextFlavor(context, clientOnly, deferred) {
    var key = "".concat(clientOnly).concat(deferred);
    var flavored = context.flavors.get(key);
    if (!flavored) {
      context.flavors.set(key, flavored = context.clientOnly === clientOnly && context.deferred === deferred ? context : __assign(__assign({}, context), { clientOnly, deferred }));
    }
    return flavored;
  }
  var StoreWriter = (
    /** @class */
    (function() {
      function StoreWriter2(cache, reader, fragments) {
        this.cache = cache;
        this.reader = reader;
        this.fragments = fragments;
      }
      StoreWriter2.prototype.writeToStore = function(store, _a2) {
        var _this = this;
        var query = _a2.query, result2 = _a2.result, dataId = _a2.dataId, variables = _a2.variables, overwrite = _a2.overwrite;
        var operationDefinition = getOperationDefinition(query);
        var merger = makeProcessedFieldsMerger();
        variables = __assign(__assign({}, getDefaultValues(operationDefinition)), variables);
        var context = __assign(__assign({ store, written: /* @__PURE__ */ Object.create(null), merge: function(existing, incoming) {
          return merger.merge(existing, incoming);
        }, variables, varString: canonicalStringify(variables) }, extractFragmentContext(query, this.fragments)), { overwrite: !!overwrite, incomingById: /* @__PURE__ */ new Map(), clientOnly: false, deferred: false, flavors: /* @__PURE__ */ new Map() });
        var ref = this.processSelectionSet({
          result: result2 || /* @__PURE__ */ Object.create(null),
          dataId,
          selectionSet: operationDefinition.selectionSet,
          mergeTree: { map: /* @__PURE__ */ new Map() },
          context
        });
        if (!isReference(ref)) {
          throw newInvariantError(12, result2);
        }
        context.incomingById.forEach(function(_a3, dataId2) {
          var storeObject = _a3.storeObject, mergeTree = _a3.mergeTree, fieldNodeSet = _a3.fieldNodeSet;
          var entityRef = makeReference(dataId2);
          if (mergeTree && mergeTree.map.size) {
            var applied = _this.applyMerges(mergeTree, entityRef, storeObject, context);
            if (isReference(applied)) {
              return;
            }
            storeObject = applied;
          }
          if (globalThis.__DEV__ !== false && !context.overwrite) {
            var fieldsWithSelectionSets_1 = /* @__PURE__ */ Object.create(null);
            fieldNodeSet.forEach(function(field) {
              if (field.selectionSet) {
                fieldsWithSelectionSets_1[field.name.value] = true;
              }
            });
            var hasSelectionSet_1 = function(storeFieldName) {
              return fieldsWithSelectionSets_1[fieldNameFromStoreName(storeFieldName)] === true;
            };
            var hasMergeFunction_1 = function(storeFieldName) {
              var childTree = mergeTree && mergeTree.map.get(storeFieldName);
              return Boolean(childTree && childTree.info && childTree.info.merge);
            };
            Object.keys(storeObject).forEach(function(storeFieldName) {
              if (hasSelectionSet_1(storeFieldName) && !hasMergeFunction_1(storeFieldName)) {
                warnAboutDataLoss(entityRef, storeObject, storeFieldName, context.store);
              }
            });
          }
          store.merge(dataId2, storeObject);
        });
        store.retain(ref.__ref);
        return ref;
      };
      StoreWriter2.prototype.processSelectionSet = function(_a2) {
        var _this = this;
        var dataId = _a2.dataId, result2 = _a2.result, selectionSet = _a2.selectionSet, context = _a2.context, mergeTree = _a2.mergeTree;
        var policies = this.cache.policies;
        var incoming = /* @__PURE__ */ Object.create(null);
        var typename = dataId && policies.rootTypenamesById[dataId] || getTypenameFromResult(result2, selectionSet, context.fragmentMap) || dataId && context.store.get(dataId, "__typename");
        if ("string" === typeof typename) {
          incoming.__typename = typename;
        }
        var readField = function() {
          var options2 = normalizeReadFieldOptions(arguments, incoming, context.variables);
          if (isReference(options2.from)) {
            var info = context.incomingById.get(options2.from.__ref);
            if (info) {
              var result_1 = policies.readField(__assign(__assign({}, options2), { from: info.storeObject }), context);
              if (result_1 !== void 0) {
                return result_1;
              }
            }
          }
          return policies.readField(options2, context);
        };
        var fieldNodeSet = /* @__PURE__ */ new Set();
        this.flattenFields(
          selectionSet,
          result2,
          // This WriteContext will be the default context value for fields returned
          // by the flattenFields method, but some fields may be assigned a modified
          // context, depending on the presence of @client and other directives.
          context,
          typename
        ).forEach(function(context2, field) {
          var _a3;
          var resultFieldKey = resultKeyNameFromField(field);
          var value = result2[resultFieldKey];
          fieldNodeSet.add(field);
          if (value !== void 0) {
            var storeFieldName = policies.getStoreFieldName({
              typename,
              fieldName: field.name.value,
              field,
              variables: context2.variables
            });
            var childTree = getChildMergeTree(mergeTree, storeFieldName);
            var incomingValue = _this.processFieldValue(
              value,
              field,
              // Reset context.clientOnly and context.deferred to their default
              // values before processing nested selection sets.
              field.selectionSet ? getContextFlavor(context2, false, false) : context2,
              childTree
            );
            var childTypename = void 0;
            if (field.selectionSet && (isReference(incomingValue) || storeValueIsStoreObject(incomingValue))) {
              childTypename = readField("__typename", incomingValue);
            }
            var merge = policies.getMergeFunction(typename, field.name.value, childTypename);
            if (merge) {
              childTree.info = {
                // TODO Check compatibility against any existing childTree.field?
                field,
                typename,
                merge
              };
            } else {
              maybeRecycleChildMergeTree(mergeTree, storeFieldName);
            }
            incoming = context2.merge(incoming, (_a3 = {}, _a3[storeFieldName] = incomingValue, _a3));
          } else if (globalThis.__DEV__ !== false && !context2.clientOnly && !context2.deferred && !addTypenameToDocument.added(field) && // If the field has a read function, it may be a synthetic field or
          // provide a default value, so its absence from the written data should
          // not be cause for alarm.
          !policies.getReadFunction(typename, field.name.value)) {
            globalThis.__DEV__ !== false && invariant3.error(13, resultKeyNameFromField(field), result2);
          }
        });
        try {
          var _b = policies.identify(result2, {
            typename,
            selectionSet,
            fragmentMap: context.fragmentMap,
            storeObject: incoming,
            readField
          }), id = _b[0], keyObject = _b[1];
          dataId = dataId || id;
          if (keyObject) {
            incoming = context.merge(incoming, keyObject);
          }
        } catch (e) {
          if (!dataId)
            throw e;
        }
        if ("string" === typeof dataId) {
          var dataRef = makeReference(dataId);
          var sets = context.written[dataId] || (context.written[dataId] = []);
          if (sets.indexOf(selectionSet) >= 0)
            return dataRef;
          sets.push(selectionSet);
          if (this.reader && this.reader.isFresh(result2, dataRef, selectionSet, context)) {
            return dataRef;
          }
          var previous_1 = context.incomingById.get(dataId);
          if (previous_1) {
            previous_1.storeObject = context.merge(previous_1.storeObject, incoming);
            previous_1.mergeTree = mergeMergeTrees(previous_1.mergeTree, mergeTree);
            fieldNodeSet.forEach(function(field) {
              return previous_1.fieldNodeSet.add(field);
            });
          } else {
            context.incomingById.set(dataId, {
              storeObject: incoming,
              // Save a reference to mergeTree only if it is not empty, because
              // empty MergeTrees may be recycled by maybeRecycleChildMergeTree and
              // reused for entirely different parts of the result tree.
              mergeTree: mergeTreeIsEmpty(mergeTree) ? void 0 : mergeTree,
              fieldNodeSet
            });
          }
          return dataRef;
        }
        return incoming;
      };
      StoreWriter2.prototype.processFieldValue = function(value, field, context, mergeTree) {
        var _this = this;
        if (!field.selectionSet || value === null) {
          return globalThis.__DEV__ !== false ? cloneDeep(value) : value;
        }
        if (isArray2(value)) {
          return value.map(function(item, i) {
            var value2 = _this.processFieldValue(item, field, context, getChildMergeTree(mergeTree, i));
            maybeRecycleChildMergeTree(mergeTree, i);
            return value2;
          });
        }
        return this.processSelectionSet({
          result: value,
          selectionSet: field.selectionSet,
          context,
          mergeTree
        });
      };
      StoreWriter2.prototype.flattenFields = function(selectionSet, result2, context, typename) {
        if (typename === void 0) {
          typename = getTypenameFromResult(result2, selectionSet, context.fragmentMap);
        }
        var fieldMap = /* @__PURE__ */ new Map();
        var policies = this.cache.policies;
        var limitingTrie = new Trie(false);
        (function flatten(selectionSet2, inheritedContext) {
          var visitedNode = limitingTrie.lookup(
            selectionSet2,
            // Because we take inheritedClientOnly and inheritedDeferred into
            // consideration here (in addition to selectionSet), it's possible for
            // the same selection set to be flattened more than once, if it appears
            // in the query with different @client and/or @directive configurations.
            inheritedContext.clientOnly,
            inheritedContext.deferred
          );
          if (visitedNode.visited)
            return;
          visitedNode.visited = true;
          selectionSet2.selections.forEach(function(selection) {
            if (!shouldInclude(selection, context.variables))
              return;
            var clientOnly = inheritedContext.clientOnly, deferred = inheritedContext.deferred;
            if (
              // Since the presence of @client or @defer on this field can only
              // cause clientOnly or deferred to become true, we can skip the
              // forEach loop if both clientOnly and deferred are already true.
              !(clientOnly && deferred) && isNonEmptyArray(selection.directives)
            ) {
              selection.directives.forEach(function(dir) {
                var name = dir.name.value;
                if (name === "client")
                  clientOnly = true;
                if (name === "defer") {
                  var args = argumentsObjectFromField(dir, context.variables);
                  if (!args || args.if !== false) {
                    deferred = true;
                  }
                }
              });
            }
            if (isField(selection)) {
              var existing = fieldMap.get(selection);
              if (existing) {
                clientOnly = clientOnly && existing.clientOnly;
                deferred = deferred && existing.deferred;
              }
              fieldMap.set(selection, getContextFlavor(context, clientOnly, deferred));
            } else {
              var fragment = getFragmentFromSelection(selection, context.lookupFragment);
              if (!fragment && selection.kind === Kind.FRAGMENT_SPREAD) {
                throw newInvariantError(14, selection.name.value);
              }
              if (fragment && policies.fragmentMatches(fragment, typename, result2, context.variables)) {
                flatten(fragment.selectionSet, getContextFlavor(context, clientOnly, deferred));
              }
            }
          });
        })(selectionSet, context);
        return fieldMap;
      };
      StoreWriter2.prototype.applyMerges = function(mergeTree, existing, incoming, context, getStorageArgs) {
        var _a2;
        var _this = this;
        if (mergeTree.map.size && !isReference(incoming)) {
          var e_1 = (
            // Items in the same position in different arrays are not
            // necessarily related to each other, so when incoming is an array
            // we process its elements as if there was no existing data.
            !isArray2(incoming) && // Likewise, existing must be either a Reference or a StoreObject
            // in order for its fields to be safe to merge with the fields of
            // the incoming object.
            (isReference(existing) || storeValueIsStoreObject(existing)) ? existing : void 0
          );
          var i_1 = incoming;
          if (e_1 && !getStorageArgs) {
            getStorageArgs = [isReference(e_1) ? e_1.__ref : e_1];
          }
          var changedFields_1;
          var getValue_1 = function(from2, name) {
            return isArray2(from2) ? typeof name === "number" ? from2[name] : void 0 : context.store.getFieldValue(from2, String(name));
          };
          mergeTree.map.forEach(function(childTree, storeFieldName) {
            var eVal = getValue_1(e_1, storeFieldName);
            var iVal = getValue_1(i_1, storeFieldName);
            if (void 0 === iVal)
              return;
            if (getStorageArgs) {
              getStorageArgs.push(storeFieldName);
            }
            var aVal = _this.applyMerges(childTree, eVal, iVal, context, getStorageArgs);
            if (aVal !== iVal) {
              changedFields_1 = changedFields_1 || /* @__PURE__ */ new Map();
              changedFields_1.set(storeFieldName, aVal);
            }
            if (getStorageArgs) {
              invariant3(getStorageArgs.pop() === storeFieldName);
            }
          });
          if (changedFields_1) {
            incoming = isArray2(i_1) ? i_1.slice(0) : __assign({}, i_1);
            changedFields_1.forEach(function(value, name) {
              incoming[name] = value;
            });
          }
        }
        if (mergeTree.info) {
          return this.cache.policies.runMergeFunction(existing, incoming, mergeTree.info, context, getStorageArgs && (_a2 = context.store).getStorage.apply(_a2, getStorageArgs));
        }
        return incoming;
      };
      return StoreWriter2;
    })()
  );
  var emptyMergeTreePool = [];
  function getChildMergeTree(_a2, name) {
    var map = _a2.map;
    if (!map.has(name)) {
      map.set(name, emptyMergeTreePool.pop() || { map: /* @__PURE__ */ new Map() });
    }
    return map.get(name);
  }
  function mergeMergeTrees(left2, right2) {
    if (left2 === right2 || !right2 || mergeTreeIsEmpty(right2))
      return left2;
    if (!left2 || mergeTreeIsEmpty(left2))
      return right2;
    var info = left2.info && right2.info ? __assign(__assign({}, left2.info), right2.info) : left2.info || right2.info;
    var needToMergeMaps = left2.map.size && right2.map.size;
    var map = needToMergeMaps ? /* @__PURE__ */ new Map() : left2.map.size ? left2.map : right2.map;
    var merged = { info, map };
    if (needToMergeMaps) {
      var remainingRightKeys_1 = new Set(right2.map.keys());
      left2.map.forEach(function(leftTree, key) {
        merged.map.set(key, mergeMergeTrees(leftTree, right2.map.get(key)));
        remainingRightKeys_1.delete(key);
      });
      remainingRightKeys_1.forEach(function(key) {
        merged.map.set(key, mergeMergeTrees(right2.map.get(key), left2.map.get(key)));
      });
    }
    return merged;
  }
  function mergeTreeIsEmpty(tree) {
    return !tree || !(tree.info || tree.map.size);
  }
  function maybeRecycleChildMergeTree(_a2, name) {
    var map = _a2.map;
    var childTree = map.get(name);
    if (childTree && mergeTreeIsEmpty(childTree)) {
      emptyMergeTreePool.push(childTree);
      map.delete(name);
    }
  }
  var warnings = /* @__PURE__ */ new Set();
  function warnAboutDataLoss(existingRef, incomingObj, storeFieldName, store) {
    var getChild = function(objOrRef) {
      var child = store.getFieldValue(objOrRef, storeFieldName);
      return typeof child === "object" && child;
    };
    var existing = getChild(existingRef);
    if (!existing)
      return;
    var incoming = getChild(incomingObj);
    if (!incoming)
      return;
    if (isReference(existing))
      return;
    if (equal(existing, incoming))
      return;
    if (Object.keys(existing).every(function(key) {
      return store.getFieldValue(incoming, key) !== void 0;
    })) {
      return;
    }
    var parentType = store.getFieldValue(existingRef, "__typename") || store.getFieldValue(incomingObj, "__typename");
    var fieldName = fieldNameFromStoreName(storeFieldName);
    var typeDotName = "".concat(parentType, ".").concat(fieldName);
    if (warnings.has(typeDotName))
      return;
    warnings.add(typeDotName);
    var childTypenames = [];
    if (!isArray2(existing) && !isArray2(incoming)) {
      [existing, incoming].forEach(function(child) {
        var typename = store.getFieldValue(child, "__typename");
        if (typeof typename === "string" && !childTypenames.includes(typename)) {
          childTypenames.push(typename);
        }
      });
    }
    globalThis.__DEV__ !== false && invariant3.warn(15, fieldName, parentType, childTypenames.length ? "either ensure all objects of type " + childTypenames.join(" and ") + " have an ID or a custom merge function, or " : "", typeDotName, __assign({}, existing), __assign({}, incoming));
  }

  // node_modules/@apollo/client/cache/inmemory/inMemoryCache.js
  var InMemoryCache = (
    /** @class */
    (function(_super) {
      __extends(InMemoryCache2, _super);
      function InMemoryCache2(config) {
        if (config === void 0) {
          config = {};
        }
        var _this = _super.call(this) || this;
        _this.watches = /* @__PURE__ */ new Set();
        _this.addTypenameTransform = new DocumentTransform(addTypenameToDocument);
        _this.assumeImmutableResults = true;
        _this.makeVar = makeVar;
        _this.txCount = 0;
        _this.config = normalizeConfig(config);
        _this.addTypename = !!_this.config.addTypename;
        _this.policies = new Policies({
          cache: _this,
          dataIdFromObject: _this.config.dataIdFromObject,
          possibleTypes: _this.config.possibleTypes,
          typePolicies: _this.config.typePolicies
        });
        _this.init();
        return _this;
      }
      InMemoryCache2.prototype.init = function() {
        var rootStore = this.data = new EntityStore.Root({
          policies: this.policies,
          resultCaching: this.config.resultCaching
        });
        this.optimisticData = rootStore.stump;
        this.resetResultCache();
      };
      InMemoryCache2.prototype.resetResultCache = function(resetResultIdentities) {
        var _this = this;
        var previousReader = this.storeReader;
        var fragments = this.config.fragments;
        this.storeWriter = new StoreWriter(this, this.storeReader = new StoreReader({
          cache: this,
          addTypename: this.addTypename,
          resultCacheMaxSize: this.config.resultCacheMaxSize,
          canonizeResults: shouldCanonizeResults(this.config),
          canon: resetResultIdentities ? void 0 : previousReader && previousReader.canon,
          fragments
        }), fragments);
        this.maybeBroadcastWatch = wrap3(function(c, options2) {
          return _this.broadcastWatch(c, options2);
        }, {
          max: this.config.resultCacheMaxSize || cacheSizes["inMemoryCache.maybeBroadcastWatch"] || 5e3,
          makeCacheKey: function(c) {
            var store = c.optimistic ? _this.optimisticData : _this.data;
            if (supportsResultCaching(store)) {
              var optimistic = c.optimistic, id = c.id, variables = c.variables;
              return store.makeCacheKey(
                c.query,
                // Different watches can have the same query, optimistic
                // status, rootId, and variables, but if their callbacks are
                // different, the (identical) result needs to be delivered to
                // each distinct callback. The easiest way to achieve that
                // separation is to include c.callback in the cache key for
                // maybeBroadcastWatch calls. See issue #5733.
                c.callback,
                canonicalStringify({ optimistic, id, variables })
              );
            }
          }
        });
        (/* @__PURE__ */ new Set([this.data.group, this.optimisticData.group])).forEach(function(group) {
          return group.resetCaching();
        });
      };
      InMemoryCache2.prototype.restore = function(data) {
        this.init();
        if (data)
          this.data.replace(data);
        return this;
      };
      InMemoryCache2.prototype.extract = function(optimistic) {
        if (optimistic === void 0) {
          optimistic = false;
        }
        return (optimistic ? this.optimisticData : this.data).extract();
      };
      InMemoryCache2.prototype.read = function(options2) {
        var _a2 = options2.returnPartialData, returnPartialData = _a2 === void 0 ? false : _a2;
        try {
          return this.storeReader.diffQueryAgainstStore(__assign(__assign({}, options2), { store: options2.optimistic ? this.optimisticData : this.data, config: this.config, returnPartialData })).result || null;
        } catch (e) {
          if (e instanceof MissingFieldError) {
            return null;
          }
          throw e;
        }
      };
      InMemoryCache2.prototype.write = function(options2) {
        try {
          ++this.txCount;
          return this.storeWriter.writeToStore(this.data, options2);
        } finally {
          if (!--this.txCount && options2.broadcast !== false) {
            this.broadcastWatches();
          }
        }
      };
      InMemoryCache2.prototype.modify = function(options2) {
        if (hasOwn2.call(options2, "id") && !options2.id) {
          return false;
        }
        var store = options2.optimistic ? this.optimisticData : this.data;
        try {
          ++this.txCount;
          return store.modify(options2.id || "ROOT_QUERY", options2.fields);
        } finally {
          if (!--this.txCount && options2.broadcast !== false) {
            this.broadcastWatches();
          }
        }
      };
      InMemoryCache2.prototype.diff = function(options2) {
        return this.storeReader.diffQueryAgainstStore(__assign(__assign({}, options2), { store: options2.optimistic ? this.optimisticData : this.data, rootId: options2.id || "ROOT_QUERY", config: this.config }));
      };
      InMemoryCache2.prototype.watch = function(watch) {
        var _this = this;
        if (!this.watches.size) {
          recallCache(this);
        }
        this.watches.add(watch);
        if (watch.immediate) {
          this.maybeBroadcastWatch(watch);
        }
        return function() {
          if (_this.watches.delete(watch) && !_this.watches.size) {
            forgetCache(_this);
          }
          _this.maybeBroadcastWatch.forget(watch);
        };
      };
      InMemoryCache2.prototype.gc = function(options2) {
        var _a2;
        canonicalStringify.reset();
        print2.reset();
        this.addTypenameTransform.resetCache();
        (_a2 = this.config.fragments) === null || _a2 === void 0 ? void 0 : _a2.resetCaches();
        var ids = this.optimisticData.gc();
        if (options2 && !this.txCount) {
          if (options2.resetResultCache) {
            this.resetResultCache(options2.resetResultIdentities);
          } else if (options2.resetResultIdentities) {
            this.storeReader.resetCanon();
          }
        }
        return ids;
      };
      InMemoryCache2.prototype.retain = function(rootId, optimistic) {
        return (optimistic ? this.optimisticData : this.data).retain(rootId);
      };
      InMemoryCache2.prototype.release = function(rootId, optimistic) {
        return (optimistic ? this.optimisticData : this.data).release(rootId);
      };
      InMemoryCache2.prototype.identify = function(object) {
        if (isReference(object))
          return object.__ref;
        try {
          return this.policies.identify(object)[0];
        } catch (e) {
          globalThis.__DEV__ !== false && invariant3.warn(e);
        }
      };
      InMemoryCache2.prototype.evict = function(options2) {
        if (!options2.id) {
          if (hasOwn2.call(options2, "id")) {
            return false;
          }
          options2 = __assign(__assign({}, options2), { id: "ROOT_QUERY" });
        }
        try {
          ++this.txCount;
          return this.optimisticData.evict(options2, this.data);
        } finally {
          if (!--this.txCount && options2.broadcast !== false) {
            this.broadcastWatches();
          }
        }
      };
      InMemoryCache2.prototype.reset = function(options2) {
        var _this = this;
        this.init();
        canonicalStringify.reset();
        if (options2 && options2.discardWatches) {
          this.watches.forEach(function(watch) {
            return _this.maybeBroadcastWatch.forget(watch);
          });
          this.watches.clear();
          forgetCache(this);
        } else {
          this.broadcastWatches();
        }
        return Promise.resolve();
      };
      InMemoryCache2.prototype.removeOptimistic = function(idToRemove) {
        var newOptimisticData = this.optimisticData.removeLayer(idToRemove);
        if (newOptimisticData !== this.optimisticData) {
          this.optimisticData = newOptimisticData;
          this.broadcastWatches();
        }
      };
      InMemoryCache2.prototype.batch = function(options2) {
        var _this = this;
        var update = options2.update, _a2 = options2.optimistic, optimistic = _a2 === void 0 ? true : _a2, removeOptimistic = options2.removeOptimistic, onWatchUpdated = options2.onWatchUpdated;
        var updateResult;
        var perform = function(layer2) {
          var _a3 = _this, data = _a3.data, optimisticData = _a3.optimisticData;
          ++_this.txCount;
          if (layer2) {
            _this.data = _this.optimisticData = layer2;
          }
          try {
            return updateResult = update(_this);
          } finally {
            --_this.txCount;
            _this.data = data;
            _this.optimisticData = optimisticData;
          }
        };
        var alreadyDirty = /* @__PURE__ */ new Set();
        if (onWatchUpdated && !this.txCount) {
          this.broadcastWatches(__assign(__assign({}, options2), { onWatchUpdated: function(watch) {
            alreadyDirty.add(watch);
            return false;
          } }));
        }
        if (typeof optimistic === "string") {
          this.optimisticData = this.optimisticData.addLayer(optimistic, perform);
        } else if (optimistic === false) {
          perform(this.data);
        } else {
          perform();
        }
        if (typeof removeOptimistic === "string") {
          this.optimisticData = this.optimisticData.removeLayer(removeOptimistic);
        }
        if (onWatchUpdated && alreadyDirty.size) {
          this.broadcastWatches(__assign(__assign({}, options2), { onWatchUpdated: function(watch, diff) {
            var result2 = onWatchUpdated.call(this, watch, diff);
            if (result2 !== false) {
              alreadyDirty.delete(watch);
            }
            return result2;
          } }));
          if (alreadyDirty.size) {
            alreadyDirty.forEach(function(watch) {
              return _this.maybeBroadcastWatch.dirty(watch);
            });
          }
        } else {
          this.broadcastWatches(options2);
        }
        return updateResult;
      };
      InMemoryCache2.prototype.performTransaction = function(update, optimisticId) {
        return this.batch({
          update,
          optimistic: optimisticId || optimisticId !== null
        });
      };
      InMemoryCache2.prototype.transformDocument = function(document2) {
        return this.addTypenameToDocument(this.addFragmentsToDocument(document2));
      };
      InMemoryCache2.prototype.fragmentMatches = function(fragment, typename) {
        return this.policies.fragmentMatches(fragment, typename);
      };
      InMemoryCache2.prototype.lookupFragment = function(fragmentName) {
        var _a2;
        return ((_a2 = this.config.fragments) === null || _a2 === void 0 ? void 0 : _a2.lookup(fragmentName)) || null;
      };
      InMemoryCache2.prototype.broadcastWatches = function(options2) {
        var _this = this;
        if (!this.txCount) {
          this.watches.forEach(function(c) {
            return _this.maybeBroadcastWatch(c, options2);
          });
        }
      };
      InMemoryCache2.prototype.addFragmentsToDocument = function(document2) {
        var fragments = this.config.fragments;
        return fragments ? fragments.transform(document2) : document2;
      };
      InMemoryCache2.prototype.addTypenameToDocument = function(document2) {
        if (this.addTypename) {
          return this.addTypenameTransform.transformDocument(document2);
        }
        return document2;
      };
      InMemoryCache2.prototype.broadcastWatch = function(c, options2) {
        var lastDiff = c.lastDiff;
        var diff = this.diff(c);
        if (options2) {
          if (c.optimistic && typeof options2.optimistic === "string") {
            diff.fromOptimisticTransaction = true;
          }
          if (options2.onWatchUpdated && options2.onWatchUpdated.call(this, c, diff, lastDiff) === false) {
            return;
          }
        }
        if (!lastDiff || !equal(lastDiff.result, diff.result)) {
          c.callback(c.lastDiff = diff, lastDiff);
        }
      };
      return InMemoryCache2;
    })(ApolloCache)
  );
  if (globalThis.__DEV__ !== false) {
    InMemoryCache.prototype.getMemoryInternals = getInMemoryCacheMemoryInternals;
  }

  // node_modules/@apollo/client/core/networkStatus.js
  var NetworkStatus;
  (function(NetworkStatus2) {
    NetworkStatus2[NetworkStatus2["loading"] = 1] = "loading";
    NetworkStatus2[NetworkStatus2["setVariables"] = 2] = "setVariables";
    NetworkStatus2[NetworkStatus2["fetchMore"] = 3] = "fetchMore";
    NetworkStatus2[NetworkStatus2["refetch"] = 4] = "refetch";
    NetworkStatus2[NetworkStatus2["poll"] = 6] = "poll";
    NetworkStatus2[NetworkStatus2["ready"] = 7] = "ready";
    NetworkStatus2[NetworkStatus2["error"] = 8] = "error";
  })(NetworkStatus || (NetworkStatus = {}));
  function isNetworkRequestInFlight(networkStatus) {
    return networkStatus ? networkStatus < 7 : false;
  }

  // node_modules/@apollo/client/core/ObservableQuery.js
  var assign2 = Object.assign;
  var hasOwnProperty6 = Object.hasOwnProperty;
  var ObservableQuery = (
    /** @class */
    (function(_super) {
      __extends(ObservableQuery2, _super);
      function ObservableQuery2(_a2) {
        var queryManager = _a2.queryManager, queryInfo = _a2.queryInfo, options2 = _a2.options;
        var _this = this;
        var startedInactive = ObservableQuery2.inactiveOnCreation.getValue();
        _this = _super.call(this, function(observer) {
          _this._getOrCreateQuery();
          try {
            var subObserver = observer._subscription._observer;
            if (subObserver && !subObserver.error) {
              subObserver.error = defaultSubscriptionObserverErrorCallback;
            }
          } catch (_a3) {
          }
          var first = !_this.observers.size;
          _this.observers.add(observer);
          var last = _this.last;
          if (last && last.error) {
            observer.error && observer.error(last.error);
          } else if (last && last.result) {
            observer.next && observer.next(_this.maskResult(last.result));
          }
          if (first) {
            _this.reobserve().catch(function() {
            });
          }
          return function() {
            if (_this.observers.delete(observer) && !_this.observers.size) {
              _this.tearDownQuery();
            }
          };
        }) || this;
        _this.observers = /* @__PURE__ */ new Set();
        _this.subscriptions = /* @__PURE__ */ new Set();
        _this.dirty = false;
        _this._getOrCreateQuery = function() {
          if (startedInactive) {
            queryManager["queries"].set(_this.queryId, queryInfo);
            startedInactive = false;
          }
          return _this.queryManager.getOrCreateQuery(_this.queryId);
        };
        _this.queryInfo = queryInfo;
        _this.queryManager = queryManager;
        _this.waitForOwnResult = skipCacheDataFor(options2.fetchPolicy);
        _this.isTornDown = false;
        _this.subscribeToMore = _this.subscribeToMore.bind(_this);
        _this.maskResult = _this.maskResult.bind(_this);
        var _b = queryManager.defaultOptions.watchQuery, _c = _b === void 0 ? {} : _b, _d = _c.fetchPolicy, defaultFetchPolicy = _d === void 0 ? "cache-first" : _d;
        var _e = options2.fetchPolicy, fetchPolicy = _e === void 0 ? defaultFetchPolicy : _e, _f = options2.initialFetchPolicy, initialFetchPolicy = _f === void 0 ? fetchPolicy === "standby" ? defaultFetchPolicy : fetchPolicy : _f;
        _this.options = __assign(__assign({}, options2), {
          // Remember the initial options.fetchPolicy so we can revert back to this
          // policy when variables change. This information can also be specified
          // (or overridden) by providing options.initialFetchPolicy explicitly.
          initialFetchPolicy,
          // This ensures this.options.fetchPolicy always has a string value, in
          // case options.fetchPolicy was not provided.
          fetchPolicy
        });
        _this.queryId = queryInfo.queryId || queryManager.generateQueryId();
        var opDef = getOperationDefinition(_this.query);
        _this.queryName = opDef && opDef.name && opDef.name.value;
        return _this;
      }
      Object.defineProperty(ObservableQuery2.prototype, "query", {
        // The `query` computed property will always reflect the document transformed
        // by the last run query. `this.options.query` will always reflect the raw
        // untransformed query to ensure document transforms with runtime conditionals
        // are run on the original document.
        get: function() {
          return this.lastQuery || this.options.query;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ObservableQuery2.prototype, "variables", {
        // Computed shorthand for this.options.variables, preserved for
        // backwards compatibility.
        /**
         * An object containing the variables that were provided for the query.
         */
        get: function() {
          return this.options.variables;
        },
        enumerable: false,
        configurable: true
      });
      ObservableQuery2.prototype.result = function() {
        var _this = this;
        return new Promise(function(resolve, reject) {
          var observer = {
            next: function(result2) {
              resolve(result2);
              _this.observers.delete(observer);
              if (!_this.observers.size) {
                _this.queryManager.removeQuery(_this.queryId);
              }
              setTimeout(function() {
                subscription.unsubscribe();
              }, 0);
            },
            error: reject
          };
          var subscription = _this.subscribe(observer);
        });
      };
      ObservableQuery2.prototype.resetDiff = function() {
        this.queryInfo.resetDiff();
      };
      ObservableQuery2.prototype.getCurrentFullResult = function(saveAsLastResult) {
        if (saveAsLastResult === void 0) {
          saveAsLastResult = true;
        }
        var lastResult = this.getLastResult(true);
        var networkStatus = this.queryInfo.networkStatus || lastResult && lastResult.networkStatus || NetworkStatus.ready;
        var result2 = __assign(__assign({}, lastResult), { loading: isNetworkRequestInFlight(networkStatus), networkStatus });
        var _a2 = this.options.fetchPolicy, fetchPolicy = _a2 === void 0 ? "cache-first" : _a2;
        if (
          // These fetch policies should never deliver data from the cache, unless
          // redelivering a previously delivered result.
          skipCacheDataFor(fetchPolicy) || // If this.options.query has @client(always: true) fields, we cannot
          // trust diff.result, since it was read from the cache without running
          // local resolvers (and it's too late to run resolvers now, since we must
          // return a result synchronously).
          this.queryManager.getDocumentInfo(this.query).hasForcedResolvers
        ) {
        } else if (this.waitForOwnResult) {
          this.queryInfo["updateWatch"]();
        } else {
          var diff = this.queryInfo.getDiff();
          if (diff.complete || this.options.returnPartialData) {
            result2.data = diff.result;
          }
          if (equal(result2.data, {})) {
            result2.data = void 0;
          }
          if (diff.complete) {
            delete result2.partial;
            if (diff.complete && result2.networkStatus === NetworkStatus.loading && (fetchPolicy === "cache-first" || fetchPolicy === "cache-only")) {
              result2.networkStatus = NetworkStatus.ready;
              result2.loading = false;
            }
          } else {
            result2.partial = true;
          }
          if (result2.networkStatus === NetworkStatus.ready && (result2.error || result2.errors)) {
            result2.networkStatus = NetworkStatus.error;
          }
          if (globalThis.__DEV__ !== false && !diff.complete && !this.options.partialRefetch && !result2.loading && !result2.data && !result2.error) {
            logMissingFieldErrors(diff.missing);
          }
        }
        if (saveAsLastResult) {
          this.updateLastResult(result2);
        }
        return result2;
      };
      ObservableQuery2.prototype.getCurrentResult = function(saveAsLastResult) {
        if (saveAsLastResult === void 0) {
          saveAsLastResult = true;
        }
        return this.maskResult(this.getCurrentFullResult(saveAsLastResult));
      };
      ObservableQuery2.prototype.isDifferentFromLastResult = function(newResult, variables) {
        if (!this.last) {
          return true;
        }
        var documentInfo = this.queryManager.getDocumentInfo(this.query);
        var dataMasking = this.queryManager.dataMasking;
        var query = dataMasking ? documentInfo.nonReactiveQuery : this.query;
        var resultIsDifferent = dataMasking || documentInfo.hasNonreactiveDirective ? !equalByQuery(query, this.last.result, newResult, this.variables) : !equal(this.last.result, newResult);
        return resultIsDifferent || variables && !equal(this.last.variables, variables);
      };
      ObservableQuery2.prototype.getLast = function(key, variablesMustMatch) {
        var last = this.last;
        if (last && last[key] && (!variablesMustMatch || equal(last.variables, this.variables))) {
          return last[key];
        }
      };
      ObservableQuery2.prototype.getLastResult = function(variablesMustMatch) {
        return this.getLast("result", variablesMustMatch);
      };
      ObservableQuery2.prototype.getLastError = function(variablesMustMatch) {
        return this.getLast("error", variablesMustMatch);
      };
      ObservableQuery2.prototype.resetLastResults = function() {
        delete this.last;
        this.isTornDown = false;
      };
      ObservableQuery2.prototype.resetQueryStoreErrors = function() {
        this.queryManager.resetErrors(this.queryId);
      };
      ObservableQuery2.prototype.refetch = function(variables) {
        var _a2;
        var reobserveOptions = {
          // Always disable polling for refetches.
          pollInterval: 0
        };
        var fetchPolicy = this.options.fetchPolicy;
        if (fetchPolicy === "no-cache") {
          reobserveOptions.fetchPolicy = "no-cache";
        } else {
          reobserveOptions.fetchPolicy = "network-only";
        }
        if (globalThis.__DEV__ !== false && variables && hasOwnProperty6.call(variables, "variables")) {
          var queryDef = getQueryDefinition(this.query);
          var vars = queryDef.variableDefinitions;
          if (!vars || !vars.some(function(v) {
            return v.variable.name.value === "variables";
          })) {
            globalThis.__DEV__ !== false && invariant3.warn(
              21,
              variables,
              ((_a2 = queryDef.name) === null || _a2 === void 0 ? void 0 : _a2.value) || queryDef
            );
          }
        }
        if (variables && !equal(this.options.variables, variables)) {
          reobserveOptions.variables = this.options.variables = __assign(__assign({}, this.options.variables), variables);
        }
        this.queryInfo.resetLastWrite();
        return this.reobserve(reobserveOptions, NetworkStatus.refetch);
      };
      ObservableQuery2.prototype.fetchMore = function(fetchMoreOptions) {
        var _this = this;
        var combinedOptions = __assign(__assign({}, fetchMoreOptions.query ? fetchMoreOptions : __assign(__assign(__assign(__assign({}, this.options), { query: this.options.query }), fetchMoreOptions), { variables: __assign(__assign({}, this.options.variables), fetchMoreOptions.variables) })), {
          // The fetchMore request goes immediately to the network and does
          // not automatically write its result to the cache (hence no-cache
          // instead of network-only), because we allow the caller of
          // fetchMore to provide an updateQuery callback that determines how
          // the data gets written to the cache.
          fetchPolicy: "no-cache"
        });
        combinedOptions.query = this.transformDocument(combinedOptions.query);
        var qid = this.queryManager.generateQueryId();
        this.lastQuery = fetchMoreOptions.query ? this.transformDocument(this.options.query) : combinedOptions.query;
        var queryInfo = this.queryInfo;
        var originalNetworkStatus = queryInfo.networkStatus;
        queryInfo.networkStatus = NetworkStatus.fetchMore;
        if (combinedOptions.notifyOnNetworkStatusChange) {
          this.observe();
        }
        var updatedQuerySet = /* @__PURE__ */ new Set();
        var updateQuery = fetchMoreOptions === null || fetchMoreOptions === void 0 ? void 0 : fetchMoreOptions.updateQuery;
        var isCached = this.options.fetchPolicy !== "no-cache";
        if (!isCached) {
          invariant3(updateQuery, 22);
        }
        return this.queryManager.fetchQuery(qid, combinedOptions, NetworkStatus.fetchMore).then(function(fetchMoreResult) {
          _this.queryManager.removeQuery(qid);
          if (queryInfo.networkStatus === NetworkStatus.fetchMore) {
            queryInfo.networkStatus = originalNetworkStatus;
          }
          if (isCached) {
            _this.queryManager.cache.batch({
              update: function(cache) {
                var updateQuery2 = fetchMoreOptions.updateQuery;
                if (updateQuery2) {
                  cache.updateQuery({
                    query: _this.query,
                    variables: _this.variables,
                    returnPartialData: true,
                    optimistic: false
                  }, function(previous) {
                    return updateQuery2(previous, {
                      fetchMoreResult: fetchMoreResult.data,
                      variables: combinedOptions.variables
                    });
                  });
                } else {
                  cache.writeQuery({
                    query: combinedOptions.query,
                    variables: combinedOptions.variables,
                    data: fetchMoreResult.data
                  });
                }
              },
              onWatchUpdated: function(watch) {
                updatedQuerySet.add(watch.query);
              }
            });
          } else {
            var lastResult = _this.getLast("result");
            var data = updateQuery(lastResult.data, {
              fetchMoreResult: fetchMoreResult.data,
              variables: combinedOptions.variables
            });
            _this.reportResult(__assign(__assign({}, lastResult), { networkStatus: originalNetworkStatus, loading: isNetworkRequestInFlight(originalNetworkStatus), data }), _this.variables);
          }
          return _this.maskResult(fetchMoreResult);
        }).finally(function() {
          if (isCached && !updatedQuerySet.has(_this.query)) {
            _this.reobserveCacheFirst();
          }
        });
      };
      ObservableQuery2.prototype.subscribeToMore = function(options2) {
        var _this = this;
        var subscription = this.queryManager.startGraphQLSubscription({
          query: options2.document,
          variables: options2.variables,
          context: options2.context
        }).subscribe({
          next: function(subscriptionData) {
            var updateQuery = options2.updateQuery;
            if (updateQuery) {
              _this.updateQuery(function(previous, updateOptions) {
                return updateQuery(previous, __assign({ subscriptionData }, updateOptions));
              });
            }
          },
          error: function(err) {
            if (options2.onError) {
              options2.onError(err);
              return;
            }
            globalThis.__DEV__ !== false && invariant3.error(23, err);
          }
        });
        this.subscriptions.add(subscription);
        return function() {
          if (_this.subscriptions.delete(subscription)) {
            subscription.unsubscribe();
          }
        };
      };
      ObservableQuery2.prototype.setOptions = function(newOptions) {
        return this.reobserve(newOptions);
      };
      ObservableQuery2.prototype.silentSetOptions = function(newOptions) {
        var mergedOptions = compact(this.options, newOptions || {});
        assign2(this.options, mergedOptions);
      };
      ObservableQuery2.prototype.setVariables = function(variables) {
        if (equal(this.variables, variables)) {
          return this.observers.size ? this.result() : Promise.resolve();
        }
        this.options.variables = variables;
        if (!this.observers.size) {
          return Promise.resolve();
        }
        return this.reobserve({
          // Reset options.fetchPolicy to its original value.
          fetchPolicy: this.options.initialFetchPolicy,
          variables
        }, NetworkStatus.setVariables);
      };
      ObservableQuery2.prototype.updateQuery = function(mapFn) {
        var queryManager = this.queryManager;
        var _a2 = queryManager.cache.diff({
          query: this.options.query,
          variables: this.variables,
          returnPartialData: true,
          optimistic: false
        }), result2 = _a2.result, complete = _a2.complete;
        var newResult = mapFn(result2, {
          variables: this.variables,
          complete: !!complete,
          previousData: result2
        });
        if (newResult) {
          queryManager.cache.writeQuery({
            query: this.options.query,
            data: newResult,
            variables: this.variables
          });
          queryManager.broadcastQueries();
        }
      };
      ObservableQuery2.prototype.startPolling = function(pollInterval) {
        this.options.pollInterval = pollInterval;
        this.updatePolling();
      };
      ObservableQuery2.prototype.stopPolling = function() {
        this.options.pollInterval = 0;
        this.updatePolling();
      };
      ObservableQuery2.prototype.applyNextFetchPolicy = function(reason, options2) {
        if (options2.nextFetchPolicy) {
          var _a2 = options2.fetchPolicy, fetchPolicy = _a2 === void 0 ? "cache-first" : _a2, _b = options2.initialFetchPolicy, initialFetchPolicy = _b === void 0 ? fetchPolicy : _b;
          if (fetchPolicy === "standby") {
          } else if (typeof options2.nextFetchPolicy === "function") {
            options2.fetchPolicy = options2.nextFetchPolicy(fetchPolicy, {
              reason,
              options: options2,
              observable: this,
              initialFetchPolicy
            });
          } else if (reason === "variables-changed") {
            options2.fetchPolicy = initialFetchPolicy;
          } else {
            options2.fetchPolicy = options2.nextFetchPolicy;
          }
        }
        return options2.fetchPolicy;
      };
      ObservableQuery2.prototype.fetch = function(options2, newNetworkStatus, query) {
        var queryInfo = this._getOrCreateQuery();
        queryInfo.setObservableQuery(this);
        return this.queryManager["fetchConcastWithInfo"](queryInfo, options2, newNetworkStatus, query);
      };
      ObservableQuery2.prototype.updatePolling = function() {
        var _this = this;
        if (this.queryManager.ssrMode) {
          return;
        }
        var _a2 = this, pollingInfo = _a2.pollingInfo, pollInterval = _a2.options.pollInterval;
        if (!pollInterval || !this.hasObservers()) {
          if (pollingInfo) {
            clearTimeout(pollingInfo.timeout);
            delete this.pollingInfo;
          }
          return;
        }
        if (pollingInfo && pollingInfo.interval === pollInterval) {
          return;
        }
        invariant3(pollInterval, 24);
        var info = pollingInfo || (this.pollingInfo = {});
        info.interval = pollInterval;
        var maybeFetch = function() {
          var _a3, _b;
          if (_this.pollingInfo) {
            if (!isNetworkRequestInFlight(_this.queryInfo.networkStatus) && !((_b = (_a3 = _this.options).skipPollAttempt) === null || _b === void 0 ? void 0 : _b.call(_a3))) {
              _this.reobserve({
                // Most fetchPolicy options don't make sense to use in a polling context, as
                // users wouldn't want to be polling the cache directly. However, network-only and
                // no-cache are both useful for when the user wants to control whether or not the
                // polled results are written to the cache.
                fetchPolicy: _this.options.initialFetchPolicy === "no-cache" ? "no-cache" : "network-only"
              }, NetworkStatus.poll).then(poll, poll);
            } else {
              poll();
            }
          }
        };
        var poll = function() {
          var info2 = _this.pollingInfo;
          if (info2) {
            clearTimeout(info2.timeout);
            info2.timeout = setTimeout(maybeFetch, info2.interval);
          }
        };
        poll();
      };
      ObservableQuery2.prototype.updateLastResult = function(newResult, variables) {
        if (variables === void 0) {
          variables = this.variables;
        }
        var error = this.getLastError();
        if (error && this.last && !equal(variables, this.last.variables)) {
          error = void 0;
        }
        return this.last = __assign({ result: this.queryManager.assumeImmutableResults ? newResult : cloneDeep(newResult), variables }, error ? { error } : null);
      };
      ObservableQuery2.prototype.reobserveAsConcast = function(newOptions, newNetworkStatus) {
        var _this = this;
        this.isTornDown = false;
        var useDisposableConcast = (
          // Refetching uses a disposable Concast to allow refetches using different
          // options/variables, without permanently altering the options of the
          // original ObservableQuery.
          newNetworkStatus === NetworkStatus.refetch || // The fetchMore method does not actually call the reobserve method, but,
          // if it did, it would definitely use a disposable Concast.
          newNetworkStatus === NetworkStatus.fetchMore || // Polling uses a disposable Concast so the polling options (which force
          // fetchPolicy to be "network-only" or "no-cache") won't override the original options.
          newNetworkStatus === NetworkStatus.poll
        );
        var oldVariables = this.options.variables;
        var oldFetchPolicy = this.options.fetchPolicy;
        var mergedOptions = compact(this.options, newOptions || {});
        var options2 = useDisposableConcast ? (
          // Disposable Concast fetches receive a shallow copy of this.options
          // (merged with newOptions), leaving this.options unmodified.
          mergedOptions
        ) : assign2(this.options, mergedOptions);
        var query = this.transformDocument(options2.query);
        this.lastQuery = query;
        if (!useDisposableConcast) {
          this.updatePolling();
          if (newOptions && newOptions.variables && !equal(newOptions.variables, oldVariables) && // Don't mess with the fetchPolicy if it's currently "standby".
          options2.fetchPolicy !== "standby" && // If we're changing the fetchPolicy anyway, don't try to change it here
          // using applyNextFetchPolicy. The explicit options.fetchPolicy wins.
          (options2.fetchPolicy === oldFetchPolicy || // A `nextFetchPolicy` function has even higher priority, though,
          // so in that case `applyNextFetchPolicy` must be called.
          typeof options2.nextFetchPolicy === "function")) {
            this.applyNextFetchPolicy("variables-changed", options2);
            if (newNetworkStatus === void 0) {
              newNetworkStatus = NetworkStatus.setVariables;
            }
          }
        }
        this.waitForOwnResult && (this.waitForOwnResult = skipCacheDataFor(options2.fetchPolicy));
        var finishWaitingForOwnResult = function() {
          if (_this.concast === concast) {
            _this.waitForOwnResult = false;
          }
        };
        var variables = options2.variables && __assign({}, options2.variables);
        var _a2 = this.fetch(options2, newNetworkStatus, query), concast = _a2.concast, fromLink = _a2.fromLink;
        var observer = {
          next: function(result2) {
            if (equal(_this.variables, variables)) {
              finishWaitingForOwnResult();
              _this.reportResult(result2, variables);
            }
          },
          error: function(error) {
            if (equal(_this.variables, variables)) {
              if (!isApolloError(error)) {
                error = new ApolloError({ networkError: error });
              }
              finishWaitingForOwnResult();
              _this.reportError(error, variables);
            }
          }
        };
        if (!useDisposableConcast && (fromLink || !this.concast)) {
          if (this.concast && this.observer) {
            this.concast.removeObserver(this.observer);
          }
          this.concast = concast;
          this.observer = observer;
        }
        concast.addObserver(observer);
        return concast;
      };
      ObservableQuery2.prototype.reobserve = function(newOptions, newNetworkStatus) {
        return preventUnhandledRejection(this.reobserveAsConcast(newOptions, newNetworkStatus).promise.then(this.maskResult));
      };
      ObservableQuery2.prototype.resubscribeAfterError = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var last = this.last;
        this.resetLastResults();
        var subscription = this.subscribe.apply(this, args);
        this.last = last;
        return subscription;
      };
      ObservableQuery2.prototype.observe = function() {
        this.reportResult(
          // Passing false is important so that this.getCurrentResult doesn't
          // save the fetchMore result as this.lastResult, causing it to be
          // ignored due to the this.isDifferentFromLastResult check in
          // this.reportResult.
          this.getCurrentFullResult(false),
          this.variables
        );
      };
      ObservableQuery2.prototype.reportResult = function(result2, variables) {
        var lastError = this.getLastError();
        var isDifferent = this.isDifferentFromLastResult(result2, variables);
        if (lastError || !result2.partial || this.options.returnPartialData) {
          this.updateLastResult(result2, variables);
        }
        if (lastError || isDifferent) {
          iterateObserversSafely(this.observers, "next", this.maskResult(result2));
        }
      };
      ObservableQuery2.prototype.reportError = function(error, variables) {
        var errorResult = __assign(__assign({}, this.getLastResult()), { error, errors: error.graphQLErrors, networkStatus: NetworkStatus.error, loading: false });
        this.updateLastResult(errorResult, variables);
        iterateObserversSafely(this.observers, "error", this.last.error = error);
      };
      ObservableQuery2.prototype.hasObservers = function() {
        return this.observers.size > 0;
      };
      ObservableQuery2.prototype.tearDownQuery = function() {
        if (this.isTornDown)
          return;
        if (this.concast && this.observer) {
          this.concast.removeObserver(this.observer);
          delete this.concast;
          delete this.observer;
        }
        this.stopPolling();
        this.subscriptions.forEach(function(sub) {
          return sub.unsubscribe();
        });
        this.subscriptions.clear();
        this.queryManager.stopQuery(this.queryId);
        this.observers.clear();
        this.isTornDown = true;
      };
      ObservableQuery2.prototype.transformDocument = function(document2) {
        return this.queryManager.transform(document2);
      };
      ObservableQuery2.prototype.maskResult = function(result2) {
        return result2 && "data" in result2 ? __assign(__assign({}, result2), { data: this.queryManager.maskOperation({
          document: this.query,
          data: result2.data,
          fetchPolicy: this.options.fetchPolicy,
          id: this.queryId
        }) }) : result2;
      };
      ObservableQuery2.prototype.resetNotifications = function() {
        this.cancelNotifyTimeout();
        this.dirty = false;
      };
      ObservableQuery2.prototype.cancelNotifyTimeout = function() {
        if (this.notifyTimeout) {
          clearTimeout(this.notifyTimeout);
          this.notifyTimeout = void 0;
        }
      };
      ObservableQuery2.prototype.scheduleNotify = function() {
        var _this = this;
        if (this.dirty)
          return;
        this.dirty = true;
        if (!this.notifyTimeout) {
          this.notifyTimeout = setTimeout(function() {
            return _this.notify();
          }, 0);
        }
      };
      ObservableQuery2.prototype.notify = function() {
        this.cancelNotifyTimeout();
        if (this.dirty) {
          if (this.options.fetchPolicy == "cache-only" || this.options.fetchPolicy == "cache-and-network" || !isNetworkRequestInFlight(this.queryInfo.networkStatus)) {
            var diff = this.queryInfo.getDiff();
            if (diff.fromOptimisticTransaction) {
              this.observe();
            } else {
              this.reobserveCacheFirst();
            }
          }
        }
        this.dirty = false;
      };
      ObservableQuery2.prototype.reobserveCacheFirst = function() {
        var _a2 = this.options, fetchPolicy = _a2.fetchPolicy, nextFetchPolicy = _a2.nextFetchPolicy;
        if (fetchPolicy === "cache-and-network" || fetchPolicy === "network-only") {
          return this.reobserve({
            fetchPolicy: "cache-first",
            // Use a temporary nextFetchPolicy function that replaces itself with the
            // previous nextFetchPolicy value and returns the original fetchPolicy.
            nextFetchPolicy: function(currentFetchPolicy, context) {
              this.nextFetchPolicy = nextFetchPolicy;
              if (typeof this.nextFetchPolicy === "function") {
                return this.nextFetchPolicy(currentFetchPolicy, context);
              }
              return fetchPolicy;
            }
          });
        }
        return this.reobserve();
      };
      ObservableQuery2.inactiveOnCreation = new Slot();
      return ObservableQuery2;
    })(Observable)
  );
  fixObservableSubclass(ObservableQuery);
  function defaultSubscriptionObserverErrorCallback(error) {
    globalThis.__DEV__ !== false && invariant3.error(25, error.message, error.stack);
  }
  function logMissingFieldErrors(missing) {
    if (globalThis.__DEV__ !== false && missing) {
      globalThis.__DEV__ !== false && invariant3.debug(26, missing);
    }
  }
  function skipCacheDataFor(fetchPolicy) {
    return fetchPolicy === "network-only" || fetchPolicy === "no-cache" || fetchPolicy === "standby";
  }

  // node_modules/@apollo/client/core/QueryInfo.js
  var destructiveMethodCounts = new (canUseWeakMap ? WeakMap : Map)();
  function wrapDestructiveCacheMethod(cache, methodName) {
    var original = cache[methodName];
    if (typeof original === "function") {
      cache[methodName] = function() {
        destructiveMethodCounts.set(
          cache,
          // The %1e15 allows the count to wrap around to 0 safely every
          // quadrillion evictions, so there's no risk of overflow. To be
          // clear, this is more of a pedantic principle than something
          // that matters in any conceivable practical scenario.
          (destructiveMethodCounts.get(cache) + 1) % 1e15
        );
        return original.apply(this, arguments);
      };
    }
  }
  var QueryInfo = (
    /** @class */
    (function() {
      function QueryInfo2(queryManager, queryId) {
        if (queryId === void 0) {
          queryId = queryManager.generateQueryId();
        }
        this.queryId = queryId;
        this.document = null;
        this.lastRequestId = 1;
        this.stopped = false;
        this.observableQuery = null;
        var cache = this.cache = queryManager.cache;
        if (!destructiveMethodCounts.has(cache)) {
          destructiveMethodCounts.set(cache, 0);
          wrapDestructiveCacheMethod(cache, "evict");
          wrapDestructiveCacheMethod(cache, "modify");
          wrapDestructiveCacheMethod(cache, "reset");
        }
      }
      QueryInfo2.prototype.init = function(query) {
        var networkStatus = query.networkStatus || NetworkStatus.loading;
        if (this.variables && this.networkStatus !== NetworkStatus.loading && !equal(this.variables, query.variables)) {
          networkStatus = NetworkStatus.setVariables;
        }
        if (!equal(query.variables, this.variables)) {
          this.lastDiff = void 0;
          this.cancel();
        }
        Object.assign(this, {
          document: query.document,
          variables: query.variables,
          networkError: null,
          graphQLErrors: this.graphQLErrors || [],
          networkStatus
        });
        if (query.observableQuery) {
          this.setObservableQuery(query.observableQuery);
        }
        if (query.lastRequestId) {
          this.lastRequestId = query.lastRequestId;
        }
        return this;
      };
      QueryInfo2.prototype.resetDiff = function() {
        this.lastDiff = void 0;
      };
      QueryInfo2.prototype.getDiff = function() {
        var options2 = this.getDiffOptions();
        if (this.lastDiff && equal(options2, this.lastDiff.options)) {
          return this.lastDiff.diff;
        }
        this.updateWatch(this.variables);
        var oq = this.observableQuery;
        if (oq && oq.options.fetchPolicy === "no-cache") {
          return { complete: false };
        }
        var diff = this.cache.diff(options2);
        this.updateLastDiff(diff, options2);
        return diff;
      };
      QueryInfo2.prototype.updateLastDiff = function(diff, options2) {
        this.lastDiff = diff ? {
          diff,
          options: options2 || this.getDiffOptions()
        } : void 0;
      };
      QueryInfo2.prototype.getDiffOptions = function(variables) {
        var _a2;
        if (variables === void 0) {
          variables = this.variables;
        }
        return {
          query: this.document,
          variables,
          returnPartialData: true,
          optimistic: true,
          canonizeResults: (_a2 = this.observableQuery) === null || _a2 === void 0 ? void 0 : _a2.options.canonizeResults
        };
      };
      QueryInfo2.prototype.setDiff = function(diff) {
        var _a2, _b;
        var oldDiff = this.lastDiff && this.lastDiff.diff;
        if (diff && !diff.complete && ((_a2 = this.observableQuery) === null || _a2 === void 0 ? void 0 : _a2.getLastError())) {
          return;
        }
        this.updateLastDiff(diff);
        if (!equal(oldDiff && oldDiff.result, diff && diff.result)) {
          (_b = this.observableQuery) === null || _b === void 0 ? void 0 : _b["scheduleNotify"]();
        }
      };
      QueryInfo2.prototype.setObservableQuery = function(oq) {
        if (oq === this.observableQuery)
          return;
        this.observableQuery = oq;
        if (oq) {
          oq["queryInfo"] = this;
        }
      };
      QueryInfo2.prototype.stop = function() {
        var _a2;
        if (!this.stopped) {
          this.stopped = true;
          (_a2 = this.observableQuery) === null || _a2 === void 0 ? void 0 : _a2["resetNotifications"]();
          this.cancel();
          var oq = this.observableQuery;
          if (oq)
            oq.stopPolling();
        }
      };
      QueryInfo2.prototype.cancel = function() {
        var _a2;
        (_a2 = this.cancelWatch) === null || _a2 === void 0 ? void 0 : _a2.call(this);
        this.cancelWatch = void 0;
      };
      QueryInfo2.prototype.updateWatch = function(variables) {
        var _this = this;
        if (variables === void 0) {
          variables = this.variables;
        }
        var oq = this.observableQuery;
        if (oq && oq.options.fetchPolicy === "no-cache") {
          return;
        }
        var watchOptions = __assign(__assign({}, this.getDiffOptions(variables)), { watcher: this, callback: function(diff) {
          return _this.setDiff(diff);
        } });
        if (!this.lastWatch || !equal(watchOptions, this.lastWatch)) {
          this.cancel();
          this.cancelWatch = this.cache.watch(this.lastWatch = watchOptions);
        }
      };
      QueryInfo2.prototype.resetLastWrite = function() {
        this.lastWrite = void 0;
      };
      QueryInfo2.prototype.shouldWrite = function(result2, variables) {
        var lastWrite = this.lastWrite;
        return !(lastWrite && // If cache.evict has been called since the last time we wrote this
        // data into the cache, there's a chance writing this result into
        // the cache will repair what was evicted.
        lastWrite.dmCount === destructiveMethodCounts.get(this.cache) && equal(variables, lastWrite.variables) && equal(result2.data, lastWrite.result.data));
      };
      QueryInfo2.prototype.markResult = function(result2, document2, options2, cacheWriteBehavior) {
        var _this = this;
        var _a2;
        var merger = new DeepMerger();
        var graphQLErrors = isNonEmptyArray(result2.errors) ? result2.errors.slice(0) : [];
        (_a2 = this.observableQuery) === null || _a2 === void 0 ? void 0 : _a2["resetNotifications"]();
        if ("incremental" in result2 && isNonEmptyArray(result2.incremental)) {
          var mergedData = mergeIncrementalData(this.getDiff().result, result2);
          result2.data = mergedData;
        } else if ("hasNext" in result2 && result2.hasNext) {
          var diff = this.getDiff();
          result2.data = merger.merge(diff.result, result2.data);
        }
        this.graphQLErrors = graphQLErrors;
        if (options2.fetchPolicy === "no-cache") {
          this.updateLastDiff({ result: result2.data, complete: true }, this.getDiffOptions(options2.variables));
        } else if (cacheWriteBehavior !== 0) {
          if (shouldWriteResult(result2, options2.errorPolicy)) {
            this.cache.performTransaction(function(cache) {
              if (_this.shouldWrite(result2, options2.variables)) {
                cache.writeQuery({
                  query: document2,
                  data: result2.data,
                  variables: options2.variables,
                  overwrite: cacheWriteBehavior === 1
                });
                _this.lastWrite = {
                  result: result2,
                  variables: options2.variables,
                  dmCount: destructiveMethodCounts.get(_this.cache)
                };
              } else {
                if (_this.lastDiff && _this.lastDiff.diff.complete) {
                  result2.data = _this.lastDiff.diff.result;
                  return;
                }
              }
              var diffOptions = _this.getDiffOptions(options2.variables);
              var diff2 = cache.diff(diffOptions);
              if (!_this.stopped && equal(_this.variables, options2.variables)) {
                _this.updateWatch(options2.variables);
              }
              _this.updateLastDiff(diff2, diffOptions);
              if (diff2.complete) {
                result2.data = diff2.result;
              }
            });
          } else {
            this.lastWrite = void 0;
          }
        }
      };
      QueryInfo2.prototype.markReady = function() {
        this.networkError = null;
        return this.networkStatus = NetworkStatus.ready;
      };
      QueryInfo2.prototype.markError = function(error) {
        var _a2;
        this.networkStatus = NetworkStatus.error;
        this.lastWrite = void 0;
        (_a2 = this.observableQuery) === null || _a2 === void 0 ? void 0 : _a2["resetNotifications"]();
        if (error.graphQLErrors) {
          this.graphQLErrors = error.graphQLErrors;
        }
        if (error.networkError) {
          this.networkError = error.networkError;
        }
        return error;
      };
      return QueryInfo2;
    })()
  );
  function shouldWriteResult(result2, errorPolicy) {
    if (errorPolicy === void 0) {
      errorPolicy = "none";
    }
    var ignoreErrors = errorPolicy === "ignore" || errorPolicy === "all";
    var writeWithErrors = !graphQLResultHasError(result2);
    if (!writeWithErrors && ignoreErrors && result2.data) {
      writeWithErrors = true;
    }
    return writeWithErrors;
  }

  // node_modules/@apollo/client/core/QueryManager.js
  var hasOwnProperty7 = Object.prototype.hasOwnProperty;
  var IGNORE = /* @__PURE__ */ Object.create(null);
  var QueryManager = (
    /** @class */
    (function() {
      function QueryManager2(options2) {
        var _this = this;
        this.clientAwareness = {};
        this.queries = /* @__PURE__ */ new Map();
        this.fetchCancelFns = /* @__PURE__ */ new Map();
        this.transformCache = new AutoCleanedWeakCache(
          cacheSizes["queryManager.getDocumentInfo"] || 2e3
          /* defaultCacheSizes["queryManager.getDocumentInfo"] */
        );
        this.queryIdCounter = 1;
        this.requestIdCounter = 1;
        this.mutationIdCounter = 1;
        this.inFlightLinkObservables = new Trie(false);
        this.noCacheWarningsByQueryId = /* @__PURE__ */ new Set();
        var defaultDocumentTransform = new DocumentTransform(
          function(document2) {
            return _this.cache.transformDocument(document2);
          },
          // Allow the apollo cache to manage its own transform caches
          { cache: false }
        );
        this.cache = options2.cache;
        this.link = options2.link;
        this.defaultOptions = options2.defaultOptions;
        this.queryDeduplication = options2.queryDeduplication;
        this.clientAwareness = options2.clientAwareness;
        this.localState = options2.localState;
        this.ssrMode = options2.ssrMode;
        this.assumeImmutableResults = options2.assumeImmutableResults;
        this.dataMasking = options2.dataMasking;
        var documentTransform = options2.documentTransform;
        this.documentTransform = documentTransform ? defaultDocumentTransform.concat(documentTransform).concat(defaultDocumentTransform) : defaultDocumentTransform;
        this.defaultContext = options2.defaultContext || /* @__PURE__ */ Object.create(null);
        if (this.onBroadcast = options2.onBroadcast) {
          this.mutationStore = /* @__PURE__ */ Object.create(null);
        }
      }
      QueryManager2.prototype.stop = function() {
        var _this = this;
        this.queries.forEach(function(_info, queryId) {
          _this.stopQueryNoBroadcast(queryId);
        });
        this.cancelPendingFetches(newInvariantError(27));
      };
      QueryManager2.prototype.cancelPendingFetches = function(error) {
        this.fetchCancelFns.forEach(function(cancel) {
          return cancel(error);
        });
        this.fetchCancelFns.clear();
      };
      QueryManager2.prototype.mutate = function(_a2) {
        return __awaiter(this, arguments, void 0, function(_b) {
          var mutationId, hasClientExports2, mutationStoreValue, isOptimistic, self2;
          var _c, _d;
          var mutation = _b.mutation, variables = _b.variables, optimisticResponse = _b.optimisticResponse, updateQueries = _b.updateQueries, _e = _b.refetchQueries, refetchQueries = _e === void 0 ? [] : _e, _f = _b.awaitRefetchQueries, awaitRefetchQueries = _f === void 0 ? false : _f, updateWithProxyFn = _b.update, onQueryUpdated = _b.onQueryUpdated, _g = _b.fetchPolicy, fetchPolicy = _g === void 0 ? ((_c = this.defaultOptions.mutate) === null || _c === void 0 ? void 0 : _c.fetchPolicy) || "network-only" : _g, _h = _b.errorPolicy, errorPolicy = _h === void 0 ? ((_d = this.defaultOptions.mutate) === null || _d === void 0 ? void 0 : _d.errorPolicy) || "none" : _h, keepRootFields = _b.keepRootFields, context = _b.context;
          return __generator(this, function(_j) {
            switch (_j.label) {
              case 0:
                invariant3(mutation, 28);
                invariant3(fetchPolicy === "network-only" || fetchPolicy === "no-cache", 29);
                mutationId = this.generateMutationId();
                mutation = this.cache.transformForLink(this.transform(mutation));
                hasClientExports2 = this.getDocumentInfo(mutation).hasClientExports;
                variables = this.getVariables(mutation, variables);
                if (!hasClientExports2) return [3, 2];
                return [4, this.localState.addExportedVariables(mutation, variables, context)];
              case 1:
                variables = _j.sent();
                _j.label = 2;
              case 2:
                mutationStoreValue = this.mutationStore && (this.mutationStore[mutationId] = {
                  mutation,
                  variables,
                  loading: true,
                  error: null
                });
                isOptimistic = optimisticResponse && this.markMutationOptimistic(optimisticResponse, {
                  mutationId,
                  document: mutation,
                  variables,
                  fetchPolicy,
                  errorPolicy,
                  context,
                  updateQueries,
                  update: updateWithProxyFn,
                  keepRootFields
                });
                this.broadcastQueries();
                self2 = this;
                return [2, new Promise(function(resolve, reject) {
                  return asyncMap(self2.getObservableFromLink(mutation, __assign(__assign({}, context), { optimisticResponse: isOptimistic ? optimisticResponse : void 0 }), variables, {}, false), function(result2) {
                    if (graphQLResultHasError(result2) && errorPolicy === "none") {
                      throw new ApolloError({
                        graphQLErrors: getGraphQLErrorsFromResult(result2)
                      });
                    }
                    if (mutationStoreValue) {
                      mutationStoreValue.loading = false;
                      mutationStoreValue.error = null;
                    }
                    var storeResult = __assign({}, result2);
                    if (typeof refetchQueries === "function") {
                      refetchQueries = refetchQueries(storeResult);
                    }
                    if (errorPolicy === "ignore" && graphQLResultHasError(storeResult)) {
                      delete storeResult.errors;
                    }
                    return self2.markMutationResult({
                      mutationId,
                      result: storeResult,
                      document: mutation,
                      variables,
                      fetchPolicy,
                      errorPolicy,
                      context,
                      update: updateWithProxyFn,
                      updateQueries,
                      awaitRefetchQueries,
                      refetchQueries,
                      removeOptimistic: isOptimistic ? mutationId : void 0,
                      onQueryUpdated,
                      keepRootFields
                    });
                  }).subscribe({
                    next: function(storeResult) {
                      self2.broadcastQueries();
                      if (!("hasNext" in storeResult) || storeResult.hasNext === false) {
                        resolve(__assign(__assign({}, storeResult), { data: self2.maskOperation({
                          document: mutation,
                          data: storeResult.data,
                          fetchPolicy,
                          id: mutationId
                        }) }));
                      }
                    },
                    error: function(err) {
                      if (mutationStoreValue) {
                        mutationStoreValue.loading = false;
                        mutationStoreValue.error = err;
                      }
                      if (isOptimistic) {
                        self2.cache.removeOptimistic(mutationId);
                      }
                      self2.broadcastQueries();
                      reject(err instanceof ApolloError ? err : new ApolloError({
                        networkError: err
                      }));
                    }
                  });
                })];
            }
          });
        });
      };
      QueryManager2.prototype.markMutationResult = function(mutation, cache) {
        var _this = this;
        if (cache === void 0) {
          cache = this.cache;
        }
        var result2 = mutation.result;
        var cacheWrites = [];
        var skipCache = mutation.fetchPolicy === "no-cache";
        if (!skipCache && shouldWriteResult(result2, mutation.errorPolicy)) {
          if (!isExecutionPatchIncrementalResult(result2)) {
            cacheWrites.push({
              result: result2.data,
              dataId: "ROOT_MUTATION",
              query: mutation.document,
              variables: mutation.variables
            });
          }
          if (isExecutionPatchIncrementalResult(result2) && isNonEmptyArray(result2.incremental)) {
            var diff = cache.diff({
              id: "ROOT_MUTATION",
              // The cache complains if passed a mutation where it expects a
              // query, so we transform mutations and subscriptions to queries
              // (only once, thanks to this.transformCache).
              query: this.getDocumentInfo(mutation.document).asQuery,
              variables: mutation.variables,
              optimistic: false,
              returnPartialData: true
            });
            var mergedData = void 0;
            if (diff.result) {
              mergedData = mergeIncrementalData(diff.result, result2);
            }
            if (typeof mergedData !== "undefined") {
              result2.data = mergedData;
              cacheWrites.push({
                result: mergedData,
                dataId: "ROOT_MUTATION",
                query: mutation.document,
                variables: mutation.variables
              });
            }
          }
          var updateQueries_1 = mutation.updateQueries;
          if (updateQueries_1) {
            this.queries.forEach(function(_a2, queryId) {
              var observableQuery = _a2.observableQuery;
              var queryName = observableQuery && observableQuery.queryName;
              if (!queryName || !hasOwnProperty7.call(updateQueries_1, queryName)) {
                return;
              }
              var updater = updateQueries_1[queryName];
              var _b = _this.queries.get(queryId), document2 = _b.document, variables = _b.variables;
              var _c = cache.diff({
                query: document2,
                variables,
                returnPartialData: true,
                optimistic: false
              }), currentQueryResult = _c.result, complete = _c.complete;
              if (complete && currentQueryResult) {
                var nextQueryResult = updater(currentQueryResult, {
                  mutationResult: result2,
                  queryName: document2 && getOperationName(document2) || void 0,
                  queryVariables: variables
                });
                if (nextQueryResult) {
                  cacheWrites.push({
                    result: nextQueryResult,
                    dataId: "ROOT_QUERY",
                    query: document2,
                    variables
                  });
                }
              }
            });
          }
        }
        if (cacheWrites.length > 0 || (mutation.refetchQueries || "").length > 0 || mutation.update || mutation.onQueryUpdated || mutation.removeOptimistic) {
          var results_1 = [];
          this.refetchQueries({
            updateCache: function(cache2) {
              if (!skipCache) {
                cacheWrites.forEach(function(write2) {
                  return cache2.write(write2);
                });
              }
              var update = mutation.update;
              var isFinalResult = !isExecutionPatchResult(result2) || isExecutionPatchIncrementalResult(result2) && !result2.hasNext;
              if (update) {
                if (!skipCache) {
                  var diff2 = cache2.diff({
                    id: "ROOT_MUTATION",
                    // The cache complains if passed a mutation where it expects a
                    // query, so we transform mutations and subscriptions to queries
                    // (only once, thanks to this.transformCache).
                    query: _this.getDocumentInfo(mutation.document).asQuery,
                    variables: mutation.variables,
                    optimistic: false,
                    returnPartialData: true
                  });
                  if (diff2.complete) {
                    result2 = __assign(__assign({}, result2), { data: diff2.result });
                    if ("incremental" in result2) {
                      delete result2.incremental;
                    }
                    if ("hasNext" in result2) {
                      delete result2.hasNext;
                    }
                  }
                }
                if (isFinalResult) {
                  update(cache2, result2, {
                    context: mutation.context,
                    variables: mutation.variables
                  });
                }
              }
              if (!skipCache && !mutation.keepRootFields && isFinalResult) {
                cache2.modify({
                  id: "ROOT_MUTATION",
                  fields: function(value, _a2) {
                    var fieldName = _a2.fieldName, DELETE2 = _a2.DELETE;
                    return fieldName === "__typename" ? value : DELETE2;
                  }
                });
              }
            },
            include: mutation.refetchQueries,
            // Write the final mutation.result to the root layer of the cache.
            optimistic: false,
            // Remove the corresponding optimistic layer at the same time as we
            // write the final non-optimistic result.
            removeOptimistic: mutation.removeOptimistic,
            // Let the caller of client.mutate optionally determine the refetching
            // behavior for watched queries after the mutation.update function runs.
            // If no onQueryUpdated function was provided for this mutation, pass
            // null instead of undefined to disable the default refetching behavior.
            onQueryUpdated: mutation.onQueryUpdated || null
          }).forEach(function(result3) {
            return results_1.push(result3);
          });
          if (mutation.awaitRefetchQueries || mutation.onQueryUpdated) {
            return Promise.all(results_1).then(function() {
              return result2;
            });
          }
        }
        return Promise.resolve(result2);
      };
      QueryManager2.prototype.markMutationOptimistic = function(optimisticResponse, mutation) {
        var _this = this;
        var data = typeof optimisticResponse === "function" ? optimisticResponse(mutation.variables, { IGNORE }) : optimisticResponse;
        if (data === IGNORE) {
          return false;
        }
        this.cache.recordOptimisticTransaction(function(cache) {
          try {
            _this.markMutationResult(__assign(__assign({}, mutation), { result: { data } }), cache);
          } catch (error) {
            globalThis.__DEV__ !== false && invariant3.error(error);
          }
        }, mutation.mutationId);
        return true;
      };
      QueryManager2.prototype.fetchQuery = function(queryId, options2, networkStatus) {
        return this.fetchConcastWithInfo(this.getOrCreateQuery(queryId), options2, networkStatus).concast.promise;
      };
      QueryManager2.prototype.getQueryStore = function() {
        var store = /* @__PURE__ */ Object.create(null);
        this.queries.forEach(function(info, queryId) {
          store[queryId] = {
            variables: info.variables,
            networkStatus: info.networkStatus,
            networkError: info.networkError,
            graphQLErrors: info.graphQLErrors
          };
        });
        return store;
      };
      QueryManager2.prototype.resetErrors = function(queryId) {
        var queryInfo = this.queries.get(queryId);
        if (queryInfo) {
          queryInfo.networkError = void 0;
          queryInfo.graphQLErrors = [];
        }
      };
      QueryManager2.prototype.transform = function(document2) {
        return this.documentTransform.transformDocument(document2);
      };
      QueryManager2.prototype.getDocumentInfo = function(document2) {
        var transformCache = this.transformCache;
        if (!transformCache.has(document2)) {
          var cacheEntry = {
            // TODO These three calls (hasClientExports, shouldForceResolvers, and
            // usesNonreactiveDirective) are performing independent full traversals
            // of the transformed document. We should consider merging these
            // traversals into a single pass in the future, though the work is
            // cached after the first time.
            hasClientExports: hasClientExports(document2),
            hasForcedResolvers: this.localState.shouldForceResolvers(document2),
            hasNonreactiveDirective: hasDirectives(["nonreactive"], document2),
            nonReactiveQuery: addNonReactiveToNamedFragments(document2),
            clientQuery: this.localState.clientQuery(document2),
            serverQuery: removeDirectivesFromDocument([
              { name: "client", remove: true },
              { name: "connection" },
              { name: "nonreactive" },
              { name: "unmask" }
            ], document2),
            defaultVars: getDefaultValues(getOperationDefinition(document2)),
            // Transform any mutation or subscription operations to query operations
            // so we can read/write them from/to the cache.
            asQuery: __assign(__assign({}, document2), { definitions: document2.definitions.map(function(def) {
              if (def.kind === "OperationDefinition" && def.operation !== "query") {
                return __assign(__assign({}, def), { operation: "query" });
              }
              return def;
            }) })
          };
          transformCache.set(document2, cacheEntry);
        }
        return transformCache.get(document2);
      };
      QueryManager2.prototype.getVariables = function(document2, variables) {
        return __assign(__assign({}, this.getDocumentInfo(document2).defaultVars), variables);
      };
      QueryManager2.prototype.watchQuery = function(options2) {
        var query = this.transform(options2.query);
        options2 = __assign(__assign({}, options2), { variables: this.getVariables(query, options2.variables) });
        if (typeof options2.notifyOnNetworkStatusChange === "undefined") {
          options2.notifyOnNetworkStatusChange = false;
        }
        var queryInfo = new QueryInfo(this);
        var observable = new ObservableQuery({
          queryManager: this,
          queryInfo,
          options: options2
        });
        observable["lastQuery"] = query;
        if (!ObservableQuery["inactiveOnCreation"].getValue()) {
          this.queries.set(observable.queryId, queryInfo);
        }
        queryInfo.init({
          document: query,
          observableQuery: observable,
          variables: observable.variables
        });
        return observable;
      };
      QueryManager2.prototype.query = function(options2, queryId) {
        var _this = this;
        if (queryId === void 0) {
          queryId = this.generateQueryId();
        }
        invariant3(options2.query, 30);
        invariant3(options2.query.kind === "Document", 31);
        invariant3(!options2.returnPartialData, 32);
        invariant3(!options2.pollInterval, 33);
        var query = this.transform(options2.query);
        return this.fetchQuery(queryId, __assign(__assign({}, options2), { query })).then(function(result2) {
          return result2 && __assign(__assign({}, result2), { data: _this.maskOperation({
            document: query,
            data: result2.data,
            fetchPolicy: options2.fetchPolicy,
            id: queryId
          }) });
        }).finally(function() {
          return _this.stopQuery(queryId);
        });
      };
      QueryManager2.prototype.generateQueryId = function() {
        return String(this.queryIdCounter++);
      };
      QueryManager2.prototype.generateRequestId = function() {
        return this.requestIdCounter++;
      };
      QueryManager2.prototype.generateMutationId = function() {
        return String(this.mutationIdCounter++);
      };
      QueryManager2.prototype.stopQueryInStore = function(queryId) {
        this.stopQueryInStoreNoBroadcast(queryId);
        this.broadcastQueries();
      };
      QueryManager2.prototype.stopQueryInStoreNoBroadcast = function(queryId) {
        var queryInfo = this.queries.get(queryId);
        if (queryInfo)
          queryInfo.stop();
      };
      QueryManager2.prototype.clearStore = function(options2) {
        if (options2 === void 0) {
          options2 = {
            discardWatches: true
          };
        }
        this.cancelPendingFetches(newInvariantError(34));
        this.queries.forEach(function(queryInfo) {
          if (queryInfo.observableQuery) {
            queryInfo.networkStatus = NetworkStatus.loading;
          } else {
            queryInfo.stop();
          }
        });
        if (this.mutationStore) {
          this.mutationStore = /* @__PURE__ */ Object.create(null);
        }
        return this.cache.reset(options2);
      };
      QueryManager2.prototype.getObservableQueries = function(include) {
        var _this = this;
        if (include === void 0) {
          include = "active";
        }
        var queries2 = /* @__PURE__ */ new Map();
        var queryNames = /* @__PURE__ */ new Map();
        var queryNamesAndQueryStrings = /* @__PURE__ */ new Map();
        var legacyQueryOptions = /* @__PURE__ */ new Set();
        if (Array.isArray(include)) {
          include.forEach(function(desc) {
            if (typeof desc === "string") {
              queryNames.set(desc, desc);
              queryNamesAndQueryStrings.set(desc, false);
            } else if (isDocumentNode(desc)) {
              var queryString = print2(_this.transform(desc));
              queryNames.set(queryString, getOperationName(desc));
              queryNamesAndQueryStrings.set(queryString, false);
            } else if (isNonNullObject(desc) && desc.query) {
              legacyQueryOptions.add(desc);
            }
          });
        }
        this.queries.forEach(function(_a2, queryId) {
          var oq = _a2.observableQuery, document2 = _a2.document;
          if (oq) {
            if (include === "all") {
              queries2.set(queryId, oq);
              return;
            }
            var queryName = oq.queryName, fetchPolicy = oq.options.fetchPolicy;
            if (fetchPolicy === "standby" || include === "active" && !oq.hasObservers()) {
              return;
            }
            if (include === "active" || queryName && queryNamesAndQueryStrings.has(queryName) || document2 && queryNamesAndQueryStrings.has(print2(document2))) {
              queries2.set(queryId, oq);
              if (queryName)
                queryNamesAndQueryStrings.set(queryName, true);
              if (document2)
                queryNamesAndQueryStrings.set(print2(document2), true);
            }
          }
        });
        if (legacyQueryOptions.size) {
          legacyQueryOptions.forEach(function(options2) {
            var queryId = makeUniqueId("legacyOneTimeQuery");
            var queryInfo = _this.getOrCreateQuery(queryId).init({
              document: options2.query,
              variables: options2.variables
            });
            var oq = new ObservableQuery({
              queryManager: _this,
              queryInfo,
              options: __assign(__assign({}, options2), { fetchPolicy: "network-only" })
            });
            invariant3(oq.queryId === queryId);
            queryInfo.setObservableQuery(oq);
            queries2.set(queryId, oq);
          });
        }
        if (globalThis.__DEV__ !== false && queryNamesAndQueryStrings.size) {
          queryNamesAndQueryStrings.forEach(function(included, nameOrQueryString) {
            if (!included) {
              var queryName = queryNames.get(nameOrQueryString);
              if (queryName) {
                globalThis.__DEV__ !== false && invariant3.warn(35, queryName);
              } else {
                globalThis.__DEV__ !== false && invariant3.warn(36);
              }
            }
          });
        }
        return queries2;
      };
      QueryManager2.prototype.reFetchObservableQueries = function(includeStandby) {
        var _this = this;
        if (includeStandby === void 0) {
          includeStandby = false;
        }
        var observableQueryPromises = [];
        this.getObservableQueries(includeStandby ? "all" : "active").forEach(function(observableQuery, queryId) {
          var fetchPolicy = observableQuery.options.fetchPolicy;
          observableQuery.resetLastResults();
          if (includeStandby || fetchPolicy !== "standby" && fetchPolicy !== "cache-only") {
            observableQueryPromises.push(observableQuery.refetch());
          }
          (_this.queries.get(queryId) || observableQuery["queryInfo"]).setDiff(null);
        });
        this.broadcastQueries();
        return Promise.all(observableQueryPromises);
      };
      QueryManager2.prototype.startGraphQLSubscription = function(options2) {
        var _this = this;
        var query = options2.query, variables = options2.variables;
        var fetchPolicy = options2.fetchPolicy, _a2 = options2.errorPolicy, errorPolicy = _a2 === void 0 ? "none" : _a2, _b = options2.context, context = _b === void 0 ? {} : _b, _c = options2.extensions, extensions = _c === void 0 ? {} : _c;
        query = this.transform(query);
        variables = this.getVariables(query, variables);
        var makeObservable = function(variables2) {
          return _this.getObservableFromLink(query, context, variables2, extensions).map(function(result2) {
            if (fetchPolicy !== "no-cache") {
              if (shouldWriteResult(result2, errorPolicy)) {
                _this.cache.write({
                  query,
                  result: result2.data,
                  dataId: "ROOT_SUBSCRIPTION",
                  variables: variables2
                });
              }
              _this.broadcastQueries();
            }
            var hasErrors = graphQLResultHasError(result2);
            var hasProtocolErrors = graphQLResultHasProtocolErrors(result2);
            if (hasErrors || hasProtocolErrors) {
              var errors = {};
              if (hasErrors) {
                errors.graphQLErrors = result2.errors;
              }
              if (hasProtocolErrors) {
                errors.protocolErrors = result2.extensions[PROTOCOL_ERRORS_SYMBOL];
              }
              if (errorPolicy === "none" || hasProtocolErrors) {
                throw new ApolloError(errors);
              }
            }
            if (errorPolicy === "ignore") {
              delete result2.errors;
            }
            return result2;
          });
        };
        if (this.getDocumentInfo(query).hasClientExports) {
          var observablePromise_1 = this.localState.addExportedVariables(query, variables, context).then(makeObservable);
          return new Observable(function(observer) {
            var sub = null;
            observablePromise_1.then(function(observable) {
              return sub = observable.subscribe(observer);
            }, observer.error);
            return function() {
              return sub && sub.unsubscribe();
            };
          });
        }
        return makeObservable(variables);
      };
      QueryManager2.prototype.stopQuery = function(queryId) {
        this.stopQueryNoBroadcast(queryId);
        this.broadcastQueries();
      };
      QueryManager2.prototype.stopQueryNoBroadcast = function(queryId) {
        this.stopQueryInStoreNoBroadcast(queryId);
        this.removeQuery(queryId);
      };
      QueryManager2.prototype.removeQuery = function(queryId) {
        var _a2;
        this.fetchCancelFns.delete(queryId);
        if (this.queries.has(queryId)) {
          (_a2 = this.queries.get(queryId)) === null || _a2 === void 0 ? void 0 : _a2.stop();
          this.queries.delete(queryId);
        }
      };
      QueryManager2.prototype.broadcastQueries = function() {
        if (this.onBroadcast)
          this.onBroadcast();
        this.queries.forEach(function(info) {
          var _a2;
          return (_a2 = info.observableQuery) === null || _a2 === void 0 ? void 0 : _a2["notify"]();
        });
      };
      QueryManager2.prototype.getLocalState = function() {
        return this.localState;
      };
      QueryManager2.prototype.getObservableFromLink = function(query, context, variables, extensions, deduplication) {
        var _this = this;
        var _a2;
        if (deduplication === void 0) {
          deduplication = (_a2 = context === null || context === void 0 ? void 0 : context.queryDeduplication) !== null && _a2 !== void 0 ? _a2 : this.queryDeduplication;
        }
        var observable;
        var _b = this.getDocumentInfo(query), serverQuery = _b.serverQuery, clientQuery = _b.clientQuery;
        if (serverQuery) {
          var _c = this, inFlightLinkObservables_1 = _c.inFlightLinkObservables, link = _c.link;
          var operation = {
            query: serverQuery,
            variables,
            operationName: getOperationName(serverQuery) || void 0,
            context: this.prepareContext(__assign(__assign({}, context), { forceFetch: !deduplication })),
            extensions
          };
          context = operation.context;
          if (deduplication) {
            var printedServerQuery_1 = print2(serverQuery);
            var varJson_1 = canonicalStringify(variables);
            var entry = inFlightLinkObservables_1.lookup(printedServerQuery_1, varJson_1);
            observable = entry.observable;
            if (!observable) {
              var concast_1 = new Concast([
                execute(link, operation)
              ]);
              observable = entry.observable = concast_1;
              concast_1.beforeNext(function cb(method, arg) {
                if (method === "next" && "hasNext" in arg && arg.hasNext) {
                  concast_1.beforeNext(cb);
                } else {
                  inFlightLinkObservables_1.remove(printedServerQuery_1, varJson_1);
                }
              });
            }
          } else {
            observable = new Concast([
              execute(link, operation)
            ]);
          }
        } else {
          observable = new Concast([Observable.of({ data: {} })]);
          context = this.prepareContext(context);
        }
        if (clientQuery) {
          observable = asyncMap(observable, function(result2) {
            return _this.localState.runResolvers({
              document: clientQuery,
              remoteResult: result2,
              context,
              variables
            });
          });
        }
        return observable;
      };
      QueryManager2.prototype.getResultsFromLink = function(queryInfo, cacheWriteBehavior, options2) {
        var requestId = queryInfo.lastRequestId = this.generateRequestId();
        var linkDocument = this.cache.transformForLink(options2.query);
        return asyncMap(this.getObservableFromLink(linkDocument, options2.context, options2.variables), function(result2) {
          var graphQLErrors = getGraphQLErrorsFromResult(result2);
          var hasErrors = graphQLErrors.length > 0;
          var errorPolicy = options2.errorPolicy;
          if (requestId >= queryInfo.lastRequestId) {
            if (hasErrors && errorPolicy === "none") {
              throw queryInfo.markError(new ApolloError({
                graphQLErrors
              }));
            }
            queryInfo.markResult(result2, linkDocument, options2, cacheWriteBehavior);
            queryInfo.markReady();
          }
          var aqr = {
            data: result2.data,
            loading: false,
            networkStatus: NetworkStatus.ready
          };
          if (hasErrors && errorPolicy === "none") {
            aqr.data = void 0;
          }
          if (hasErrors && errorPolicy !== "ignore") {
            aqr.errors = graphQLErrors;
            aqr.networkStatus = NetworkStatus.error;
          }
          return aqr;
        }, function(networkError) {
          var error = isApolloError(networkError) ? networkError : new ApolloError({ networkError });
          if (requestId >= queryInfo.lastRequestId) {
            queryInfo.markError(error);
          }
          throw error;
        });
      };
      QueryManager2.prototype.fetchConcastWithInfo = function(queryInfo, options2, networkStatus, query) {
        var _this = this;
        if (networkStatus === void 0) {
          networkStatus = NetworkStatus.loading;
        }
        if (query === void 0) {
          query = options2.query;
        }
        var variables = this.getVariables(query, options2.variables);
        var defaults = this.defaultOptions.watchQuery;
        var _a2 = options2.fetchPolicy, fetchPolicy = _a2 === void 0 ? defaults && defaults.fetchPolicy || "cache-first" : _a2, _b = options2.errorPolicy, errorPolicy = _b === void 0 ? defaults && defaults.errorPolicy || "none" : _b, _c = options2.returnPartialData, returnPartialData = _c === void 0 ? false : _c, _d = options2.notifyOnNetworkStatusChange, notifyOnNetworkStatusChange = _d === void 0 ? false : _d, _e = options2.context, context = _e === void 0 ? {} : _e;
        var normalized = Object.assign({}, options2, {
          query,
          variables,
          fetchPolicy,
          errorPolicy,
          returnPartialData,
          notifyOnNetworkStatusChange,
          context
        });
        var fromVariables = function(variables2) {
          normalized.variables = variables2;
          var sourcesWithInfo2 = _this.fetchQueryByPolicy(queryInfo, normalized, networkStatus);
          if (
            // If we're in standby, postpone advancing options.fetchPolicy using
            // applyNextFetchPolicy.
            normalized.fetchPolicy !== "standby" && // The "standby" policy currently returns [] from fetchQueryByPolicy, so
            // this is another way to detect when nothing was done/fetched.
            sourcesWithInfo2.sources.length > 0 && queryInfo.observableQuery
          ) {
            queryInfo.observableQuery["applyNextFetchPolicy"]("after-fetch", options2);
          }
          return sourcesWithInfo2;
        };
        var cleanupCancelFn = function() {
          return _this.fetchCancelFns.delete(queryInfo.queryId);
        };
        this.fetchCancelFns.set(queryInfo.queryId, function(reason) {
          cleanupCancelFn();
          setTimeout(function() {
            return concast.cancel(reason);
          });
        });
        var concast, containsDataFromLink;
        if (this.getDocumentInfo(normalized.query).hasClientExports) {
          concast = new Concast(this.localState.addExportedVariables(normalized.query, normalized.variables, normalized.context).then(fromVariables).then(function(sourcesWithInfo2) {
            return sourcesWithInfo2.sources;
          }));
          containsDataFromLink = true;
        } else {
          var sourcesWithInfo = fromVariables(normalized.variables);
          containsDataFromLink = sourcesWithInfo.fromLink;
          concast = new Concast(sourcesWithInfo.sources);
        }
        concast.promise.then(cleanupCancelFn, cleanupCancelFn);
        return {
          concast,
          fromLink: containsDataFromLink
        };
      };
      QueryManager2.prototype.refetchQueries = function(_a2) {
        var _this = this;
        var updateCache = _a2.updateCache, include = _a2.include, _b = _a2.optimistic, optimistic = _b === void 0 ? false : _b, _c = _a2.removeOptimistic, removeOptimistic = _c === void 0 ? optimistic ? makeUniqueId("refetchQueries") : void 0 : _c, onQueryUpdated = _a2.onQueryUpdated;
        var includedQueriesById = /* @__PURE__ */ new Map();
        if (include) {
          this.getObservableQueries(include).forEach(function(oq, queryId) {
            includedQueriesById.set(queryId, {
              oq,
              lastDiff: (_this.queries.get(queryId) || oq["queryInfo"]).getDiff()
            });
          });
        }
        var results = /* @__PURE__ */ new Map();
        if (updateCache) {
          this.cache.batch({
            update: updateCache,
            // Since you can perform any combination of cache reads and/or writes in
            // the cache.batch update function, its optimistic option can be either
            // a boolean or a string, representing three distinct modes of
            // operation:
            //
            // * false: read/write only the root layer
            // * true: read/write the topmost layer
            // * string: read/write a fresh optimistic layer with that ID string
            //
            // When typeof optimistic === "string", a new optimistic layer will be
            // temporarily created within cache.batch with that string as its ID. If
            // we then pass that same string as the removeOptimistic option, we can
            // make cache.batch immediately remove the optimistic layer after
            // running the updateCache function, triggering only one broadcast.
            //
            // However, the refetchQueries method accepts only true or false for its
            // optimistic option (not string). We interpret true to mean a temporary
            // optimistic layer should be created, to allow efficiently rolling back
            // the effect of the updateCache function, which involves passing a
            // string instead of true as the optimistic option to cache.batch, when
            // refetchQueries receives optimistic: true.
            //
            // In other words, we are deliberately not supporting the use case of
            // writing to an *existing* optimistic layer (using the refetchQueries
            // updateCache function), since that would potentially interfere with
            // other optimistic updates in progress. Instead, you can read/write
            // only the root layer by passing optimistic: false to refetchQueries,
            // or you can read/write a brand new optimistic layer that will be
            // automatically removed by passing optimistic: true.
            optimistic: optimistic && removeOptimistic || false,
            // The removeOptimistic option can also be provided by itself, even if
            // optimistic === false, to remove some previously-added optimistic
            // layer safely and efficiently, like we do in markMutationResult.
            //
            // If an explicit removeOptimistic string is provided with optimistic:
            // true, the removeOptimistic string will determine the ID of the
            // temporary optimistic layer, in case that ever matters.
            removeOptimistic,
            onWatchUpdated: function(watch, diff, lastDiff) {
              var oq = watch.watcher instanceof QueryInfo && watch.watcher.observableQuery;
              if (oq) {
                if (onQueryUpdated) {
                  includedQueriesById.delete(oq.queryId);
                  var result2 = onQueryUpdated(oq, diff, lastDiff);
                  if (result2 === true) {
                    result2 = oq.refetch();
                  }
                  if (result2 !== false) {
                    results.set(oq, result2);
                  }
                  return result2;
                }
                if (onQueryUpdated !== null) {
                  includedQueriesById.set(oq.queryId, { oq, lastDiff, diff });
                }
              }
            }
          });
        }
        if (includedQueriesById.size) {
          includedQueriesById.forEach(function(_a3, queryId) {
            var oq = _a3.oq, lastDiff = _a3.lastDiff, diff = _a3.diff;
            var result2;
            if (onQueryUpdated) {
              if (!diff) {
                diff = _this.cache.diff(oq["queryInfo"]["getDiffOptions"]());
              }
              result2 = onQueryUpdated(oq, diff, lastDiff);
            }
            if (!onQueryUpdated || result2 === true) {
              result2 = oq.refetch();
            }
            if (result2 !== false) {
              results.set(oq, result2);
            }
            if (queryId.indexOf("legacyOneTimeQuery") >= 0) {
              _this.stopQueryNoBroadcast(queryId);
            }
          });
        }
        if (removeOptimistic) {
          this.cache.removeOptimistic(removeOptimistic);
        }
        return results;
      };
      QueryManager2.prototype.maskOperation = function(options2) {
        var _a2, _b, _c;
        var document2 = options2.document, data = options2.data;
        if (globalThis.__DEV__ !== false) {
          var fetchPolicy = options2.fetchPolicy, id = options2.id;
          var operationType = (_a2 = getOperationDefinition(document2)) === null || _a2 === void 0 ? void 0 : _a2.operation;
          var operationId = ((_b = operationType === null || operationType === void 0 ? void 0 : operationType[0]) !== null && _b !== void 0 ? _b : "o") + id;
          if (this.dataMasking && fetchPolicy === "no-cache" && !isFullyUnmaskedOperation(document2) && !this.noCacheWarningsByQueryId.has(operationId)) {
            this.noCacheWarningsByQueryId.add(operationId);
            globalThis.__DEV__ !== false && invariant3.warn(
              37,
              (_c = getOperationName(document2)) !== null && _c !== void 0 ? _c : "Unnamed ".concat(operationType !== null && operationType !== void 0 ? operationType : "operation")
            );
          }
        }
        return this.dataMasking ? maskOperation(data, document2, this.cache) : data;
      };
      QueryManager2.prototype.maskFragment = function(options2) {
        var data = options2.data, fragment = options2.fragment, fragmentName = options2.fragmentName;
        return this.dataMasking ? maskFragment(data, fragment, this.cache, fragmentName) : data;
      };
      QueryManager2.prototype.fetchQueryByPolicy = function(queryInfo, _a2, networkStatus) {
        var _this = this;
        var query = _a2.query, variables = _a2.variables, fetchPolicy = _a2.fetchPolicy, refetchWritePolicy = _a2.refetchWritePolicy, errorPolicy = _a2.errorPolicy, returnPartialData = _a2.returnPartialData, context = _a2.context, notifyOnNetworkStatusChange = _a2.notifyOnNetworkStatusChange;
        var oldNetworkStatus = queryInfo.networkStatus;
        queryInfo.init({
          document: query,
          variables,
          networkStatus
        });
        var readCache = function() {
          return queryInfo.getDiff();
        };
        var resultsFromCache = function(diff2, networkStatus2) {
          if (networkStatus2 === void 0) {
            networkStatus2 = queryInfo.networkStatus || NetworkStatus.loading;
          }
          var data = diff2.result;
          if (globalThis.__DEV__ !== false && !returnPartialData && !equal(data, {})) {
            logMissingFieldErrors(diff2.missing);
          }
          var fromData = function(data2) {
            return Observable.of(__assign({ data: data2, loading: isNetworkRequestInFlight(networkStatus2), networkStatus: networkStatus2 }, diff2.complete ? null : { partial: true }));
          };
          if (data && _this.getDocumentInfo(query).hasForcedResolvers) {
            return _this.localState.runResolvers({
              document: query,
              remoteResult: { data },
              context,
              variables,
              onlyRunForcedResolvers: true
            }).then(function(resolved) {
              return fromData(resolved.data || void 0);
            });
          }
          if (errorPolicy === "none" && networkStatus2 === NetworkStatus.refetch && Array.isArray(diff2.missing)) {
            return fromData(void 0);
          }
          return fromData(data);
        };
        var cacheWriteBehavior = fetchPolicy === "no-cache" ? 0 : networkStatus === NetworkStatus.refetch && refetchWritePolicy !== "merge" ? 1 : 2;
        var resultsFromLink = function() {
          return _this.getResultsFromLink(queryInfo, cacheWriteBehavior, {
            query,
            variables,
            context,
            fetchPolicy,
            errorPolicy
          });
        };
        var shouldNotify = notifyOnNetworkStatusChange && typeof oldNetworkStatus === "number" && oldNetworkStatus !== networkStatus && isNetworkRequestInFlight(networkStatus);
        switch (fetchPolicy) {
          default:
          case "cache-first": {
            var diff = readCache();
            if (diff.complete) {
              return {
                fromLink: false,
                sources: [resultsFromCache(diff, queryInfo.markReady())]
              };
            }
            if (returnPartialData || shouldNotify) {
              return {
                fromLink: true,
                sources: [resultsFromCache(diff), resultsFromLink()]
              };
            }
            return { fromLink: true, sources: [resultsFromLink()] };
          }
          case "cache-and-network": {
            var diff = readCache();
            if (diff.complete || returnPartialData || shouldNotify) {
              return {
                fromLink: true,
                sources: [resultsFromCache(diff), resultsFromLink()]
              };
            }
            return { fromLink: true, sources: [resultsFromLink()] };
          }
          case "cache-only":
            return {
              fromLink: false,
              sources: [resultsFromCache(readCache(), queryInfo.markReady())]
            };
          case "network-only":
            if (shouldNotify) {
              return {
                fromLink: true,
                sources: [resultsFromCache(readCache()), resultsFromLink()]
              };
            }
            return { fromLink: true, sources: [resultsFromLink()] };
          case "no-cache":
            if (shouldNotify) {
              return {
                fromLink: true,
                // Note that queryInfo.getDiff() for no-cache queries does not call
                // cache.diff, but instead returns a { complete: false } stub result
                // when there is no queryInfo.diff already defined.
                sources: [resultsFromCache(queryInfo.getDiff()), resultsFromLink()]
              };
            }
            return { fromLink: true, sources: [resultsFromLink()] };
          case "standby":
            return { fromLink: false, sources: [] };
        }
      };
      QueryManager2.prototype.getOrCreateQuery = function(queryId) {
        if (queryId && !this.queries.has(queryId)) {
          this.queries.set(queryId, new QueryInfo(this, queryId));
        }
        return this.queries.get(queryId);
      };
      QueryManager2.prototype.prepareContext = function(context) {
        if (context === void 0) {
          context = {};
        }
        var newContext = this.localState.prepareContext(context);
        return __assign(__assign(__assign({}, this.defaultContext), newContext), { clientAwareness: this.clientAwareness });
      };
      return QueryManager2;
    })()
  );

  // node_modules/@apollo/client/core/LocalState.js
  var LocalState = (
    /** @class */
    (function() {
      function LocalState2(_a2) {
        var cache = _a2.cache, client2 = _a2.client, resolvers = _a2.resolvers, fragmentMatcher = _a2.fragmentMatcher;
        this.selectionsToResolveCache = /* @__PURE__ */ new WeakMap();
        this.cache = cache;
        if (client2) {
          this.client = client2;
        }
        if (resolvers) {
          this.addResolvers(resolvers);
        }
        if (fragmentMatcher) {
          this.setFragmentMatcher(fragmentMatcher);
        }
      }
      LocalState2.prototype.addResolvers = function(resolvers) {
        var _this = this;
        this.resolvers = this.resolvers || {};
        if (Array.isArray(resolvers)) {
          resolvers.forEach(function(resolverGroup) {
            _this.resolvers = mergeDeep(_this.resolvers, resolverGroup);
          });
        } else {
          this.resolvers = mergeDeep(this.resolvers, resolvers);
        }
      };
      LocalState2.prototype.setResolvers = function(resolvers) {
        this.resolvers = {};
        this.addResolvers(resolvers);
      };
      LocalState2.prototype.getResolvers = function() {
        return this.resolvers || {};
      };
      LocalState2.prototype.runResolvers = function(_a2) {
        return __awaiter(this, arguments, void 0, function(_b) {
          var document2 = _b.document, remoteResult = _b.remoteResult, context = _b.context, variables = _b.variables, _c = _b.onlyRunForcedResolvers, onlyRunForcedResolvers = _c === void 0 ? false : _c;
          return __generator(this, function(_d) {
            if (document2) {
              return [2, this.resolveDocument(document2, remoteResult.data, context, variables, this.fragmentMatcher, onlyRunForcedResolvers).then(function(localResult) {
                return __assign(__assign({}, remoteResult), { data: localResult.result });
              })];
            }
            return [2, remoteResult];
          });
        });
      };
      LocalState2.prototype.setFragmentMatcher = function(fragmentMatcher) {
        this.fragmentMatcher = fragmentMatcher;
      };
      LocalState2.prototype.getFragmentMatcher = function() {
        return this.fragmentMatcher;
      };
      LocalState2.prototype.clientQuery = function(document2) {
        if (hasDirectives(["client"], document2)) {
          if (this.resolvers) {
            return document2;
          }
        }
        return null;
      };
      LocalState2.prototype.serverQuery = function(document2) {
        return removeClientSetsFromDocument(document2);
      };
      LocalState2.prototype.prepareContext = function(context) {
        var cache = this.cache;
        return __assign(__assign({}, context), {
          cache,
          // Getting an entry's cache key is useful for local state resolvers.
          getCacheKey: function(obj) {
            return cache.identify(obj);
          }
        });
      };
      LocalState2.prototype.addExportedVariables = function(document_1) {
        return __awaiter(this, arguments, void 0, function(document2, variables, context) {
          if (variables === void 0) {
            variables = {};
          }
          if (context === void 0) {
            context = {};
          }
          return __generator(this, function(_a2) {
            if (document2) {
              return [2, this.resolveDocument(document2, this.buildRootValueFromCache(document2, variables) || {}, this.prepareContext(context), variables).then(function(data) {
                return __assign(__assign({}, variables), data.exportedVariables);
              })];
            }
            return [2, __assign({}, variables)];
          });
        });
      };
      LocalState2.prototype.shouldForceResolvers = function(document2) {
        var forceResolvers = false;
        visit(document2, {
          Directive: {
            enter: function(node2) {
              if (node2.name.value === "client" && node2.arguments) {
                forceResolvers = node2.arguments.some(function(arg) {
                  return arg.name.value === "always" && arg.value.kind === "BooleanValue" && arg.value.value === true;
                });
                if (forceResolvers) {
                  return BREAK;
                }
              }
            }
          }
        });
        return forceResolvers;
      };
      LocalState2.prototype.buildRootValueFromCache = function(document2, variables) {
        return this.cache.diff({
          query: buildQueryFromSelectionSet(document2),
          variables,
          returnPartialData: true,
          optimistic: false
        }).result;
      };
      LocalState2.prototype.resolveDocument = function(document_1, rootValue_1) {
        return __awaiter(this, arguments, void 0, function(document2, rootValue, context, variables, fragmentMatcher, onlyRunForcedResolvers) {
          var mainDefinition, fragments, fragmentMap, selectionsToResolve, definitionOperation, defaultOperationType, _a2, cache, client2, execContext, isClientFieldDescendant;
          if (context === void 0) {
            context = {};
          }
          if (variables === void 0) {
            variables = {};
          }
          if (fragmentMatcher === void 0) {
            fragmentMatcher = function() {
              return true;
            };
          }
          if (onlyRunForcedResolvers === void 0) {
            onlyRunForcedResolvers = false;
          }
          return __generator(this, function(_b) {
            mainDefinition = getMainDefinition(document2);
            fragments = getFragmentDefinitions(document2);
            fragmentMap = createFragmentMap(fragments);
            selectionsToResolve = this.collectSelectionsToResolve(mainDefinition, fragmentMap);
            definitionOperation = mainDefinition.operation;
            defaultOperationType = definitionOperation ? definitionOperation.charAt(0).toUpperCase() + definitionOperation.slice(1) : "Query";
            _a2 = this, cache = _a2.cache, client2 = _a2.client;
            execContext = {
              fragmentMap,
              context: __assign(__assign({}, context), { cache, client: client2 }),
              variables,
              fragmentMatcher,
              defaultOperationType,
              exportedVariables: {},
              selectionsToResolve,
              onlyRunForcedResolvers
            };
            isClientFieldDescendant = false;
            return [2, this.resolveSelectionSet(mainDefinition.selectionSet, isClientFieldDescendant, rootValue, execContext).then(function(result2) {
              return {
                result: result2,
                exportedVariables: execContext.exportedVariables
              };
            })];
          });
        });
      };
      LocalState2.prototype.resolveSelectionSet = function(selectionSet, isClientFieldDescendant, rootValue, execContext) {
        return __awaiter(this, void 0, void 0, function() {
          var fragmentMap, context, variables, resultsToMerge, execute2;
          var _this = this;
          return __generator(this, function(_a2) {
            fragmentMap = execContext.fragmentMap, context = execContext.context, variables = execContext.variables;
            resultsToMerge = [rootValue];
            execute2 = function(selection) {
              return __awaiter(_this, void 0, void 0, function() {
                var fragment, typeCondition;
                return __generator(this, function(_a3) {
                  if (!isClientFieldDescendant && !execContext.selectionsToResolve.has(selection)) {
                    return [
                      2
                      /*return*/
                    ];
                  }
                  if (!shouldInclude(selection, variables)) {
                    return [
                      2
                      /*return*/
                    ];
                  }
                  if (isField(selection)) {
                    return [2, this.resolveField(selection, isClientFieldDescendant, rootValue, execContext).then(function(fieldResult) {
                      var _a4;
                      if (typeof fieldResult !== "undefined") {
                        resultsToMerge.push((_a4 = {}, _a4[resultKeyNameFromField(selection)] = fieldResult, _a4));
                      }
                    })];
                  }
                  if (isInlineFragment(selection)) {
                    fragment = selection;
                  } else {
                    fragment = fragmentMap[selection.name.value];
                    invariant3(fragment, 19, selection.name.value);
                  }
                  if (fragment && fragment.typeCondition) {
                    typeCondition = fragment.typeCondition.name.value;
                    if (execContext.fragmentMatcher(rootValue, typeCondition, context)) {
                      return [2, this.resolveSelectionSet(fragment.selectionSet, isClientFieldDescendant, rootValue, execContext).then(function(fragmentResult) {
                        resultsToMerge.push(fragmentResult);
                      })];
                    }
                  }
                  return [
                    2
                    /*return*/
                  ];
                });
              });
            };
            return [2, Promise.all(selectionSet.selections.map(execute2)).then(function() {
              return mergeDeepArray(resultsToMerge);
            })];
          });
        });
      };
      LocalState2.prototype.resolveField = function(field, isClientFieldDescendant, rootValue, execContext) {
        return __awaiter(this, void 0, void 0, function() {
          var variables, fieldName, aliasedFieldName, aliasUsed, defaultResult, resultPromise, resolverType, resolverMap, resolve;
          var _this = this;
          return __generator(this, function(_a2) {
            if (!rootValue) {
              return [2, null];
            }
            variables = execContext.variables;
            fieldName = field.name.value;
            aliasedFieldName = resultKeyNameFromField(field);
            aliasUsed = fieldName !== aliasedFieldName;
            defaultResult = rootValue[aliasedFieldName] || rootValue[fieldName];
            resultPromise = Promise.resolve(defaultResult);
            if (!execContext.onlyRunForcedResolvers || this.shouldForceResolvers(field)) {
              resolverType = rootValue.__typename || execContext.defaultOperationType;
              resolverMap = this.resolvers && this.resolvers[resolverType];
              if (resolverMap) {
                resolve = resolverMap[aliasUsed ? fieldName : aliasedFieldName];
                if (resolve) {
                  resultPromise = Promise.resolve(
                    // In case the resolve function accesses reactive variables,
                    // set cacheSlot to the current cache instance.
                    cacheSlot.withValue(this.cache, resolve, [
                      rootValue,
                      argumentsObjectFromField(field, variables),
                      execContext.context,
                      { field, fragmentMap: execContext.fragmentMap }
                    ])
                  );
                }
              }
            }
            return [2, resultPromise.then(function(result2) {
              var _a3, _b;
              if (result2 === void 0) {
                result2 = defaultResult;
              }
              if (field.directives) {
                field.directives.forEach(function(directive) {
                  if (directive.name.value === "export" && directive.arguments) {
                    directive.arguments.forEach(function(arg) {
                      if (arg.name.value === "as" && arg.value.kind === "StringValue") {
                        execContext.exportedVariables[arg.value.value] = result2;
                      }
                    });
                  }
                });
              }
              if (!field.selectionSet) {
                return result2;
              }
              if (result2 == null) {
                return result2;
              }
              var isClientField = (_b = (_a3 = field.directives) === null || _a3 === void 0 ? void 0 : _a3.some(function(d) {
                return d.name.value === "client";
              })) !== null && _b !== void 0 ? _b : false;
              if (Array.isArray(result2)) {
                return _this.resolveSubSelectedArray(field, isClientFieldDescendant || isClientField, result2, execContext);
              }
              if (field.selectionSet) {
                return _this.resolveSelectionSet(field.selectionSet, isClientFieldDescendant || isClientField, result2, execContext);
              }
            })];
          });
        });
      };
      LocalState2.prototype.resolveSubSelectedArray = function(field, isClientFieldDescendant, result2, execContext) {
        var _this = this;
        return Promise.all(result2.map(function(item) {
          if (item === null) {
            return null;
          }
          if (Array.isArray(item)) {
            return _this.resolveSubSelectedArray(field, isClientFieldDescendant, item, execContext);
          }
          if (field.selectionSet) {
            return _this.resolveSelectionSet(field.selectionSet, isClientFieldDescendant, item, execContext);
          }
        }));
      };
      LocalState2.prototype.collectSelectionsToResolve = function(mainDefinition, fragmentMap) {
        var isSingleASTNode = function(node2) {
          return !Array.isArray(node2);
        };
        var selectionsToResolveCache = this.selectionsToResolveCache;
        function collectByDefinition(definitionNode) {
          if (!selectionsToResolveCache.has(definitionNode)) {
            var matches_1 = /* @__PURE__ */ new Set();
            selectionsToResolveCache.set(definitionNode, matches_1);
            visit(definitionNode, {
              Directive: function(node2, _, __, ___, ancestors) {
                if (node2.name.value === "client") {
                  ancestors.forEach(function(node3) {
                    if (isSingleASTNode(node3) && isSelectionNode(node3)) {
                      matches_1.add(node3);
                    }
                  });
                }
              },
              FragmentSpread: function(spread, _, __, ___, ancestors) {
                var fragment = fragmentMap[spread.name.value];
                invariant3(fragment, 20, spread.name.value);
                var fragmentSelections = collectByDefinition(fragment);
                if (fragmentSelections.size > 0) {
                  ancestors.forEach(function(node2) {
                    if (isSingleASTNode(node2) && isSelectionNode(node2)) {
                      matches_1.add(node2);
                    }
                  });
                  matches_1.add(spread);
                  fragmentSelections.forEach(function(selection) {
                    matches_1.add(selection);
                  });
                }
              }
            });
          }
          return selectionsToResolveCache.get(definitionNode);
        }
        return collectByDefinition(mainDefinition);
      };
      return LocalState2;
    })()
  );

  // node_modules/@apollo/client/core/ApolloClient.js
  var hasSuggestedDevtools = false;
  var ApolloClient = (
    /** @class */
    (function() {
      function ApolloClient2(options2) {
        var _this = this;
        var _a2;
        this.resetStoreCallbacks = [];
        this.clearStoreCallbacks = [];
        if (!options2.cache) {
          throw newInvariantError(16);
        }
        var uri = options2.uri, credentials = options2.credentials, headers = options2.headers, cache = options2.cache, documentTransform = options2.documentTransform, _b = options2.ssrMode, ssrMode = _b === void 0 ? false : _b, _c = options2.ssrForceFetchDelay, ssrForceFetchDelay = _c === void 0 ? 0 : _c, connectToDevTools = options2.connectToDevTools, _d = options2.queryDeduplication, queryDeduplication = _d === void 0 ? true : _d, defaultOptions4 = options2.defaultOptions, defaultContext = options2.defaultContext, _e = options2.assumeImmutableResults, assumeImmutableResults = _e === void 0 ? cache.assumeImmutableResults : _e, resolvers = options2.resolvers, typeDefs = options2.typeDefs, fragmentMatcher = options2.fragmentMatcher, clientAwarenessName = options2.name, clientAwarenessVersion = options2.version, devtools = options2.devtools, dataMasking = options2.dataMasking;
        var link = options2.link;
        if (!link) {
          link = uri ? new HttpLink({ uri, credentials, headers }) : ApolloLink.empty();
        }
        this.link = link;
        this.cache = cache;
        this.disableNetworkFetches = ssrMode || ssrForceFetchDelay > 0;
        this.queryDeduplication = queryDeduplication;
        this.defaultOptions = defaultOptions4 || /* @__PURE__ */ Object.create(null);
        this.typeDefs = typeDefs;
        this.devtoolsConfig = __assign(__assign({}, devtools), { enabled: (_a2 = devtools === null || devtools === void 0 ? void 0 : devtools.enabled) !== null && _a2 !== void 0 ? _a2 : connectToDevTools });
        if (this.devtoolsConfig.enabled === void 0) {
          this.devtoolsConfig.enabled = globalThis.__DEV__ !== false;
        }
        if (ssrForceFetchDelay) {
          setTimeout(function() {
            return _this.disableNetworkFetches = false;
          }, ssrForceFetchDelay);
        }
        this.watchQuery = this.watchQuery.bind(this);
        this.query = this.query.bind(this);
        this.mutate = this.mutate.bind(this);
        this.watchFragment = this.watchFragment.bind(this);
        this.resetStore = this.resetStore.bind(this);
        this.reFetchObservableQueries = this.reFetchObservableQueries.bind(this);
        this.version = version;
        this.localState = new LocalState({
          cache,
          client: this,
          resolvers,
          fragmentMatcher
        });
        this.queryManager = new QueryManager({
          cache: this.cache,
          link: this.link,
          defaultOptions: this.defaultOptions,
          defaultContext,
          documentTransform,
          queryDeduplication,
          ssrMode,
          dataMasking: !!dataMasking,
          clientAwareness: {
            name: clientAwarenessName,
            version: clientAwarenessVersion
          },
          localState: this.localState,
          assumeImmutableResults,
          onBroadcast: this.devtoolsConfig.enabled ? function() {
            if (_this.devToolsHookCb) {
              _this.devToolsHookCb({
                action: {},
                state: {
                  queries: _this.queryManager.getQueryStore(),
                  mutations: _this.queryManager.mutationStore || {}
                },
                dataWithOptimisticResults: _this.cache.extract(true)
              });
            }
          } : void 0
        });
        if (this.devtoolsConfig.enabled)
          this.connectToDevTools();
      }
      ApolloClient2.prototype.connectToDevTools = function() {
        if (typeof window === "undefined") {
          return;
        }
        var windowWithDevTools = window;
        var devtoolsSymbol = Symbol.for("apollo.devtools");
        (windowWithDevTools[devtoolsSymbol] = windowWithDevTools[devtoolsSymbol] || []).push(this);
        windowWithDevTools.__APOLLO_CLIENT__ = this;
        if (!hasSuggestedDevtools && globalThis.__DEV__ !== false) {
          hasSuggestedDevtools = true;
          if (window.document && window.top === window.self && /^(https?|file):$/.test(window.location.protocol)) {
            setTimeout(function() {
              if (!window.__APOLLO_DEVTOOLS_GLOBAL_HOOK__) {
                var nav = window.navigator;
                var ua = nav && nav.userAgent;
                var url = void 0;
                if (typeof ua === "string") {
                  if (ua.indexOf("Chrome/") > -1) {
                    url = "https://chrome.google.com/webstore/detail/apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm";
                  } else if (ua.indexOf("Firefox/") > -1) {
                    url = "https://addons.mozilla.org/en-US/firefox/addon/apollo-developer-tools/";
                  }
                }
                if (url) {
                  globalThis.__DEV__ !== false && invariant3.log("Download the Apollo DevTools for a better development experience: %s", url);
                }
              }
            }, 1e4);
          }
        }
      };
      Object.defineProperty(ApolloClient2.prototype, "documentTransform", {
        /**
         * The `DocumentTransform` used to modify GraphQL documents before a request
         * is made. If a custom `DocumentTransform` is not provided, this will be the
         * default document transform.
         */
        get: function() {
          return this.queryManager.documentTransform;
        },
        enumerable: false,
        configurable: true
      });
      ApolloClient2.prototype.stop = function() {
        this.queryManager.stop();
      };
      ApolloClient2.prototype.watchQuery = function(options2) {
        if (this.defaultOptions.watchQuery) {
          options2 = mergeOptions(this.defaultOptions.watchQuery, options2);
        }
        if (this.disableNetworkFetches && (options2.fetchPolicy === "network-only" || options2.fetchPolicy === "cache-and-network")) {
          options2 = __assign(__assign({}, options2), { fetchPolicy: "cache-first" });
        }
        return this.queryManager.watchQuery(options2);
      };
      ApolloClient2.prototype.query = function(options2) {
        if (this.defaultOptions.query) {
          options2 = mergeOptions(this.defaultOptions.query, options2);
        }
        invariant3(options2.fetchPolicy !== "cache-and-network", 17);
        if (this.disableNetworkFetches && options2.fetchPolicy === "network-only") {
          options2 = __assign(__assign({}, options2), { fetchPolicy: "cache-first" });
        }
        return this.queryManager.query(options2);
      };
      ApolloClient2.prototype.mutate = function(options2) {
        if (this.defaultOptions.mutate) {
          options2 = mergeOptions(this.defaultOptions.mutate, options2);
        }
        return this.queryManager.mutate(options2);
      };
      ApolloClient2.prototype.subscribe = function(options2) {
        var _this = this;
        var id = this.queryManager.generateQueryId();
        return this.queryManager.startGraphQLSubscription(options2).map(function(result2) {
          return __assign(__assign({}, result2), { data: _this.queryManager.maskOperation({
            document: options2.query,
            data: result2.data,
            fetchPolicy: options2.fetchPolicy,
            id
          }) });
        });
      };
      ApolloClient2.prototype.readQuery = function(options2, optimistic) {
        if (optimistic === void 0) {
          optimistic = false;
        }
        return this.cache.readQuery(options2, optimistic);
      };
      ApolloClient2.prototype.watchFragment = function(options2) {
        var _a2;
        return this.cache.watchFragment(__assign(__assign({}, options2), (_a2 = {}, _a2[Symbol.for("apollo.dataMasking")] = this.queryManager.dataMasking, _a2)));
      };
      ApolloClient2.prototype.readFragment = function(options2, optimistic) {
        if (optimistic === void 0) {
          optimistic = false;
        }
        return this.cache.readFragment(options2, optimistic);
      };
      ApolloClient2.prototype.writeQuery = function(options2) {
        var ref = this.cache.writeQuery(options2);
        if (options2.broadcast !== false) {
          this.queryManager.broadcastQueries();
        }
        return ref;
      };
      ApolloClient2.prototype.writeFragment = function(options2) {
        var ref = this.cache.writeFragment(options2);
        if (options2.broadcast !== false) {
          this.queryManager.broadcastQueries();
        }
        return ref;
      };
      ApolloClient2.prototype.__actionHookForDevTools = function(cb) {
        this.devToolsHookCb = cb;
      };
      ApolloClient2.prototype.__requestRaw = function(payload) {
        return execute(this.link, payload);
      };
      ApolloClient2.prototype.resetStore = function() {
        var _this = this;
        return Promise.resolve().then(function() {
          return _this.queryManager.clearStore({
            discardWatches: false
          });
        }).then(function() {
          return Promise.all(_this.resetStoreCallbacks.map(function(fn2) {
            return fn2();
          }));
        }).then(function() {
          return _this.reFetchObservableQueries();
        });
      };
      ApolloClient2.prototype.clearStore = function() {
        var _this = this;
        return Promise.resolve().then(function() {
          return _this.queryManager.clearStore({
            discardWatches: true
          });
        }).then(function() {
          return Promise.all(_this.clearStoreCallbacks.map(function(fn2) {
            return fn2();
          }));
        });
      };
      ApolloClient2.prototype.onResetStore = function(cb) {
        var _this = this;
        this.resetStoreCallbacks.push(cb);
        return function() {
          _this.resetStoreCallbacks = _this.resetStoreCallbacks.filter(function(c) {
            return c !== cb;
          });
        };
      };
      ApolloClient2.prototype.onClearStore = function(cb) {
        var _this = this;
        this.clearStoreCallbacks.push(cb);
        return function() {
          _this.clearStoreCallbacks = _this.clearStoreCallbacks.filter(function(c) {
            return c !== cb;
          });
        };
      };
      ApolloClient2.prototype.reFetchObservableQueries = function(includeStandby) {
        return this.queryManager.reFetchObservableQueries(includeStandby);
      };
      ApolloClient2.prototype.refetchQueries = function(options2) {
        var map = this.queryManager.refetchQueries(options2);
        var queries2 = [];
        var results = [];
        map.forEach(function(result3, obsQuery) {
          queries2.push(obsQuery);
          results.push(result3);
        });
        var result2 = Promise.all(results);
        result2.queries = queries2;
        result2.results = results;
        result2.catch(function(error) {
          globalThis.__DEV__ !== false && invariant3.debug(18, error);
        });
        return result2;
      };
      ApolloClient2.prototype.getObservableQueries = function(include) {
        if (include === void 0) {
          include = "active";
        }
        return this.queryManager.getObservableQueries(include);
      };
      ApolloClient2.prototype.extract = function(optimistic) {
        return this.cache.extract(optimistic);
      };
      ApolloClient2.prototype.restore = function(serializedState) {
        return this.cache.restore(serializedState);
      };
      ApolloClient2.prototype.addResolvers = function(resolvers) {
        this.localState.addResolvers(resolvers);
      };
      ApolloClient2.prototype.setResolvers = function(resolvers) {
        this.localState.setResolvers(resolvers);
      };
      ApolloClient2.prototype.getResolvers = function() {
        return this.localState.getResolvers();
      };
      ApolloClient2.prototype.setLocalStateFragmentMatcher = function(fragmentMatcher) {
        this.localState.setFragmentMatcher(fragmentMatcher);
      };
      ApolloClient2.prototype.setLink = function(newLink) {
        this.link = this.queryManager.link = newLink;
      };
      Object.defineProperty(ApolloClient2.prototype, "defaultContext", {
        get: function() {
          return this.queryManager.defaultContext;
        },
        enumerable: false,
        configurable: true
      });
      return ApolloClient2;
    })()
  );
  if (globalThis.__DEV__ !== false) {
    ApolloClient.prototype.getMemoryInternals = getApolloClientMemoryInternals;
  }

  // node_modules/graphql-tag/lib/index.js
  var docCache = /* @__PURE__ */ new Map();
  var fragmentSourceMap = /* @__PURE__ */ new Map();
  var printFragmentWarnings = true;
  var experimentalFragmentVariables = false;
  function normalize2(string) {
    return string.replace(/[\s,]+/g, " ").trim();
  }
  function cacheKeyFromLoc(loc) {
    return normalize2(loc.source.body.substring(loc.start, loc.end));
  }
  function processFragments(ast) {
    var seenKeys = /* @__PURE__ */ new Set();
    var definitions = [];
    ast.definitions.forEach(function(fragmentDefinition) {
      if (fragmentDefinition.kind === "FragmentDefinition") {
        var fragmentName = fragmentDefinition.name.value;
        var sourceKey = cacheKeyFromLoc(fragmentDefinition.loc);
        var sourceKeySet = fragmentSourceMap.get(fragmentName);
        if (sourceKeySet && !sourceKeySet.has(sourceKey)) {
          if (printFragmentWarnings) {
            console.warn("Warning: fragment with name " + fragmentName + " already exists.\ngraphql-tag enforces all fragment names across your application to be unique; read more about\nthis in the docs: http://dev.apollodata.com/core/fragments.html#unique-names");
          }
        } else if (!sourceKeySet) {
          fragmentSourceMap.set(fragmentName, sourceKeySet = /* @__PURE__ */ new Set());
        }
        sourceKeySet.add(sourceKey);
        if (!seenKeys.has(sourceKey)) {
          seenKeys.add(sourceKey);
          definitions.push(fragmentDefinition);
        }
      } else {
        definitions.push(fragmentDefinition);
      }
    });
    return __assign(__assign({}, ast), { definitions });
  }
  function stripLoc(doc) {
    var workSet = new Set(doc.definitions);
    workSet.forEach(function(node2) {
      if (node2.loc)
        delete node2.loc;
      Object.keys(node2).forEach(function(key) {
        var value = node2[key];
        if (value && typeof value === "object") {
          workSet.add(value);
        }
      });
    });
    var loc = doc.loc;
    if (loc) {
      delete loc.startToken;
      delete loc.endToken;
    }
    return doc;
  }
  function parseDocument(source2) {
    var cacheKey = normalize2(source2);
    if (!docCache.has(cacheKey)) {
      var parsed = parse4(source2, {
        experimentalFragmentVariables,
        allowLegacyFragmentVariables: experimentalFragmentVariables
      });
      if (!parsed || parsed.kind !== "Document") {
        throw new Error("Not a valid GraphQL document.");
      }
      docCache.set(cacheKey, stripLoc(processFragments(parsed)));
    }
    return docCache.get(cacheKey);
  }
  function gql(literals) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    if (typeof literals === "string") {
      literals = [literals];
    }
    var result2 = literals[0];
    args.forEach(function(arg, i) {
      if (arg && arg.kind === "Document") {
        result2 += arg.loc.source.body;
      } else {
        result2 += arg;
      }
      result2 += literals[i + 1];
    });
    return parseDocument(result2);
  }
  function resetCaches() {
    docCache.clear();
    fragmentSourceMap.clear();
  }
  function disableFragmentWarnings() {
    printFragmentWarnings = false;
  }
  function enableExperimentalFragmentVariables() {
    experimentalFragmentVariables = true;
  }
  function disableExperimentalFragmentVariables() {
    experimentalFragmentVariables = false;
  }
  var extras = {
    gql,
    resetCaches,
    disableFragmentWarnings,
    enableExperimentalFragmentVariables,
    disableExperimentalFragmentVariables
  };
  (function(gql_1) {
    gql_1.gql = extras.gql, gql_1.resetCaches = extras.resetCaches, gql_1.disableFragmentWarnings = extras.disableFragmentWarnings, gql_1.enableExperimentalFragmentVariables = extras.enableExperimentalFragmentVariables, gql_1.disableExperimentalFragmentVariables = extras.disableExperimentalFragmentVariables;
  })(gql || (gql = {}));
  gql["default"] = gql;

  // node_modules/@apollo/client/core/index.js
  setVerbosity(globalThis.__DEV__ !== false ? "log" : "silent");

  // src/services/apolloClient.js
  async function cookieHeaderFor(url) {
    return new Promise((resolve, reject) => {
      if (!chrome.cookies) {
        resolve("");
        return;
      }
      chrome.cookies.getAll({ url }, (cookies) => {
        if (chrome.runtime.lastError) {
          reject(chrome.runtime.lastError);
          return;
        }
        const cookieHeader = cookies.map((c) => `${c.name}=${c.value}`).join("; ");
        resolve(cookieHeader);
      });
    });
  }
  var customFetch = async (uri, options2) => {
    const cookie = await cookieHeaderFor("https://home.atlassian.com");
    return fetch(uri, {
      ...options2,
      headers: {
        ...options2.headers,
        "content-type": "application/json",
        "cookie": cookie,
        "origin": "https://home.atlassian.com",
        "referer": "https://home.atlassian.com/",
        "user-agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
        "Atl-Client-Name": "townsquare-frontend",
        "Atl-Client-Version": "6c7228"
      }
    });
  };
  var httpLink = new HttpLink({
    uri: "https://home.atlassian.com/gateway/api/townsquare/s/2b2b6771-c929-476f-8b6f-ca6ebcace8a2/graphql",
    fetch: customFetch
  });
  var client = new ApolloClient({
    link: httpLink,
    cache: new InMemoryCache(),
    connectToDevTools: true
  });
  window.__APOLLO_CLIENT__ = client;
  var apolloClient = client;

  // src/graphql/projectViewQuery.js
  var PROJECT_VIEW_QUERY = `
  query ProjectViewQuery(
  $key: String!
  $trackViewEvent: TrackViewEvent
  $workspaceId: ID
  $onboardingKeyFilter: OnboardingItemKey!
  $areMilestonesEnabled: Boolean!
  $cloudId: String
  $isNavRefreshEnabled: Boolean!
) {
  project: projectByKey(key: $key, trackViewEvent: $trackViewEvent) {
    uuid
    name
    key
    owner {
      aaid
      id
    }
    members {
      ...utils_isUserInList
    }
    watchers {
      ...utils_isUserInList
    }
    private
    archived
    state {
      value
    }
    ...ProjectArchivedPanel
    ...ProjectHeader
    ...ProjectTabs
    ...ProjectContent @include(if: $isNavRefreshEnabled)
    ...ProjectSidebar_2SVbDg @skip(if: $isNavRefreshEnabled)
    ...useRedirectToDefaultTab
    id
  }
  currentUser(workspaceId: $workspaceId) {
    aaid
    onboarding(filter: {keys: [$onboardingKeyFilter]}) {
      edges {
        __typename
      }
    }
    id
  }
  ...OnboardingSpotlightTour_2tC7yX
}

fragment AddOrEditButton on CustomFieldNode {
  __isCustomFieldNode: __typename
  id
  definition {
    __typename
    ... on CustomFieldDefinitionNode {
      __isCustomFieldDefinitionNode: __typename
      type
    }
    ... on UserCustomFieldDefinition {
      canSetMultipleValues
    }
    ... on TextSelectCustomFieldDefinition {
      canSetMultipleValues
    }
    ... on Node {
      __isNode: __typename
      id
    }
  }
}

fragment Comment on Comment {
  id
  ari
  commentText
  creationDate
  editDate
  creator {
    aaid
    ...UserAvatar
    id
  }
}

fragment Comments on CommentConnection {
  edges {
    node {
      id
      editDate
      ...Comment
    }
  }
}

fragment DraftProjectUpdate on DraftUpdate {
  input
  modifiedDate
  author {
    pii {
      accountId
      name
      picture
    }
    id
  }
}

fragment FollowersSidebarSection on UserConnection {
  count
  edges {
    node {
      pii {
        name
        picture
        accountId
      }
      id
    }
  }
}

fragment FollowersSidebarSection_Owner on UserPII {
  accountId
}

fragment FollowersSidebarSection_ProjectKey on Project {
  key
}

fragment FreeformNumberField on NumberCustomField {
  ...AddOrEditButton
  id
  definition {
    __typename
    ... on CustomFieldDefinitionNode {
      __isCustomFieldDefinitionNode: __typename
      name
      description
    }
    ... on Node {
      __isNode: __typename
      id
    }
  }
  value {
    id
    numberValue: value
  }
}

fragment FreeformTextField on TextCustomField {
  ...AddOrEditButton
  id
  definition {
    __typename
    ... on CustomFieldDefinitionNode {
      __isCustomFieldDefinitionNode: __typename
      name
      description
    }
    ... on Node {
      __isNode: __typename
      id
    }
  }
  value {
    id
    textValue: value
  }
}

fragment GenericWorkTrackingLinks on Project {
  id
  workTrackingLinks: links(type: WORK_TRACKING, first: 1) {
    ...ProjectLinks
  }
}

fragment GoalItem on Goal {
  ...PlatformGoalIcon
  ...progressBarMetricTarget
  ...MetricChart
  progress {
    percentage
  }
  name
  key
  id
}

fragment InviteUserPromptPopup on Project {
  watchers {
    count
  }
}

fragment LinkedGoals on Project {
  id
  uuid
  goals {
    edges {
      node {
        id
        ...GoalItem
      }
    }
  }
}

fragment LinkedProject on ProjectDependency {
  dependencyId: id
  incomingProject {
    id
  }
  outgoingProject {
    id
    ...ProjectName_data
    state {
      ...ProjectState
    }
  }
}

fragment LinkedProjects on Project {
  id
  key
  dependencies {
    edges {
      node {
        linkType
        outgoingProject {
          key
          id
        }
        ...LinkedProject
        id
      }
    }
  }
}

fragment MetaActions on Project {
  key
  private
  ...ProjectStateAndTargetDate
  ...ProjectFollowButton
  ...InviteUserPromptPopup
  ...ProjectActions
}

fragment MetricChart on Goal {
  ...WrappedWithMetricPopup
  id
  progress {
    type
    percentage
  }
  subGoals {
    count
  }
  metricTargets {
    edges {
      node {
        ...common_metricTarget_direct
        id
      }
    }
  }
}

fragment MilestoneFields on Milestone {
  id
  title
  targetDate
  targetDateType
  status
}

fragment Milestones on Project {
  creationDate
  startDate
  milestones(first: 20) {
    edges {
      node {
        id
        status
        ...MilestoneFields
        __typename
      }
      cursor
    }
    pageInfo {
      endCursor
      hasNextPage
    }
  }
}

fragment NewProjectUpdate on Project {
  id
  key
  uuid
  workspace {
    uuid
    id
    aiConfig {
      enabled
    }
  }
  watchers {
    count
  }
  creationDate
  startDate
  targetDate
  state {
    value
  }
  latestUserUpdate {
    editDate
    creationDate
    summary
    notes {
      title
      summary
      id
    }
    id
  }
  ...ProjectTargetDateAutoUpdated
  draftUpdate {
    ...DraftProjectUpdate
    input
    id
  }
}

fragment OnboardingSpotlightTour_2tC7yX on Query {
  currentUser(workspaceId: $workspaceId) {
    id
  }
}

fragment PlatformGoalIcon on Goal {
  icon {
    key
    appearance
  }
}

fragment ProjectAboutTab on Project {
  ...ProjectDescription
  ...ProjectComments
}

fragment ProjectActions on Project {
  id
  name
  archived
  private
}

fragment ProjectArchivedPanel on Project {
  id
  state {
    value
  }
}

fragment ProjectComments on Project {
  id
  uuid
  ari
  workspace {
    uuid
    id
  }
  comments {
    edges {
      node {
        id
      }
    }
    ...Comments
  }
}

fragment ProjectContent on Project {
  watching
  userUpdateCount
  ...ProjectAboutTab
  ...ProjectUpdatesTab
}

fragment ProjectContributors_OtPnR on Project {
  id
  name
  key
  canEditMembers
  private
  owner {
    aaid
    id
  }
  contributors {
    edges {
      node {
        __typename
        ... on User {
          aaid
          ...UserItem
        }
        ... on Team {
          id
          teamId
          name
          ...TeamAndMembersItem_OtPnR
        }
        ... on Node {
          __isNode: __typename
          id
        }
      }
    }
  }
  members {
    count
    edges {
      node {
        aaid
        id
      }
    }
  }
}

fragment ProjectDescription on Project {
  id
  uuid
  name
  theWhat
  theWhy
  theMeasurement
  workspace {
    uuid
    id
  }
}

fragment ProjectFollowButton on Project {
  id
  uuid
  watching
}

fragment ProjectHeader on Project {
  id
  name
  key
  ...ProjectKey
  ...ProjectIconPicker
  ...ProjectStateAndTargetDate
}

fragment ProjectIcon on Project {
  private
  iconUrl {
    square {
      light
      dark
      transparent
    }
  }
}

fragment ProjectIconPicker on Project {
  id
  uuid
  icon {
    id
    color
    shortName
  }
  ...ProjectIcon
}

fragment ProjectKey on Project {
  key
}

fragment ProjectLinks on LinkConnection {
  edges {
    node {
      id
      name
      url
    }
  }
}

fragment ProjectName_data on Project {
  id
  key
  name
  uuid
  ...ProjectIcon
}

fragment ProjectOwner on Project {
  id
  key
  canEditMembers
  owner {
    aaid
    pii {
      name
      picture
      accountStatus
      email
    }
    ...UserAvatar
    id
  }
}

fragment ProjectSidebar_2SVbDg on Project {
  ari
  id
  key
  ...MetaActions
  ...ProjectOwner
  ...ProjectContributors_OtPnR
  ...LinkedGoals
  ...LinkedProjects
  ...WorkTrackingLinks
  ...RelatedLinks
  ...Milestones @include(if: $areMilestonesEnabled)
  ...FollowersSidebarSection_ProjectKey
  milestoneCount: milestones {
    count
  }
  tags {
    ...Tags
  }
  customFields {
    ...SidebarFields
  }
  watchers {
    ...FollowersSidebarSection
  }
  owner {
    pii {
      ...FollowersSidebarSection_Owner
    }
    id
  }
  ...ProjectStartDate
}

fragment ProjectStartDate on Project {
  id
  startDate
  ...ProjectStartDatePicker
}

fragment ProjectStartDatePicker on Project {
  startDate
  targetDate
  targetDateSet
  creationDate
  state {
    value
  }
}

fragment ProjectState on ProjectState {
  label
  localizedLabel {
    messageId
  }
  projectStateValue: value
  atCompletionState {
    value
    label
    localizedLabel {
      messageId
    }
  }
}

fragment ProjectStateAndTargetDate on Project {
  state {
    value
    atCompletionState {
      value
    }
  }
  creationDate
  startDate
  targetDate
  targetDateConfidence
}

fragment ProjectTabs on Project {
  id
  key
  watching
  userUpdateCount
  learningsCount: learnings(first: 100, type: LEARNING) {
    edges {
      __typename
      cursor
      node {
        __typename
        id
      }
    }
    pageInfo {
      endCursor
      hasNextPage
    }
  }
  risksCount: learnings(first: 100, type: RISK) {
    edges {
      __typename
      cursor
      node {
        __typename
        id
      }
    }
    pageInfo {
      endCursor
      hasNextPage
    }
  }
  decisionsCount: learnings(first: 100, type: DECISION) {
    edges {
      __typename
      cursor
      node {
        __typename
        id
      }
    }
    pageInfo {
      endCursor
      hasNextPage
    }
  }
  ...ProjectAboutTab
  ...ProjectUpdatesTab
}

fragment ProjectTargetDateAutoUpdated on Project {
  key
  targetDate
  changelog(hasUpdateId: false) {
    count
    edges {
      node {
        newValue
        oldValue
        id
      }
    }
  }
}

fragment ProjectUpdateComposer on Project {
  ...ProjectUpdateDueDateContext
  ...NewProjectUpdate
  draftUpdate {
    ...DraftProjectUpdate
    id
  }
  id
  uuid
  workspace {
    uuid
    id
  }
}

fragment ProjectUpdateDueDateContext on Project {
  state {
    value
  }
  latestUpdateDate
}

fragment ProjectUpdatesTab on Project {
  key
  state {
    value
  }
  watching
  targetDate
  targetDateConfidence
  ...ProjectUpdateComposer
  draftUpdate {
    id
  }
}

fragment RelatedLinks on Project {
  id
  relatedLinks: links(type: RELATED) {
    ...ProjectLinks
  }
}

fragment RemoveMemberButton on User {
  id
  aaid
  pii {
    name
  }
}

fragment SelectField on TextSelectCustomField {
  ...AddOrEditButton
  id
  definition {
    __typename
    ... on TextSelectCustomFieldDefinition {
      name
      description
      canSetMultipleValues
      allowedValues {
        edges {
          node {
            id
            value
          }
        }
      }
    }
    ... on Node {
      __isNode: __typename
      id
    }
  }
  values {
    edges {
      node {
        id
        value
      }
    }
  }
}

fragment SidebarFields on CustomFieldConnection {
  edges {
    node {
      __typename
      ... on TextCustomField {
        ...FreeformTextField
      }
      ... on NumberCustomField {
        ...FreeformNumberField
      }
      ... on UserCustomField {
        ...UserField
      }
      ... on TextSelectCustomField {
        ...SelectField
      }
      ... on Node {
        __isNode: __typename
        id
      }
    }
  }
}

fragment Tag on Tag {
  ...Tag_createTagOption
}

fragment Tag_createTagOption on Tag {
  id
  name
  uuid
  description
  projectUsageCount
  goalUsageCount
  helpPointerUsageCount
  watcherCount
}

fragment Tags on TagConnection {
  edges {
    node {
      id
      uuid
      name
      ...Tag
      ...Tag_createTagOption
    }
  }
}

fragment TeamAndMembersItem_OtPnR on Team {
  ...TeamItem_OtPnR
  name
  id
  teamId
  teamDetails {
    membershipSettings
  }
  permission(cloudId: $cloudId)
  membersOfProject(key: $key) {
    edges {
      node {
        aaid
        ...UserItem
        id
      }
    }
  }
}

fragment TeamAvatar on Team {
  id
  name
  teamId
  teamDetails {
    isVerified
  }
  avatarUrl
}

fragment TeamItem_OtPnR on Team {
  id
  name
  teamId
  ...TeamAvatar
  ...TeamOptionsMenu_OtPnR
}

fragment TeamOptionsMenu_OtPnR on Team {
  id
  teamId
  name
  watching
  permission(cloudId: $cloudId)
  teamDetails {
    membershipSettings
  }
  membersOfProject(key: $key) {
    edges {
      node {
        aaid
        ...UserItem
        id
      }
    }
  }
}

fragment UserAvatar on User {
  aaid
  pii {
    picture
    name
    accountStatus
    accountId
  }
}

fragment UserAvatar_1TWJ92 on User {
  aaid
  pii {
    picture
    name
    accountStatus
    accountId
    extendedProfile {
      jobTitle
    }
  }
}

fragment UserField on UserCustomField {
  ...AddOrEditButton
  id
  definition {
    __typename
    ... on UserCustomFieldDefinition {
      name
      description
      canSetMultipleValues
    }
    ... on Node {
      __isNode: __typename
      id
    }
  }
  values {
    edges {
      node {
        id
        aaid
        ...UserAvatar_1TWJ92
      }
    }
  }
}

fragment UserItem on User {
  ...UserAvatar_1TWJ92
  ...RemoveMemberButton
}

fragment WorkTrackingLinks on Project {
  id
  uuid
  key
  ari
  workTrackingLinks: links(type: WORK_TRACKING, first: 1) {
    edges {
      node {
        id
        url
      }
    }
  }
  fusion {
    synced
  }
  workspace {
    site {
      productActivations {
        edges {
          node {
            __typename
            ... on JiraProductActivation {
              atlasForJiraCloudEnabled
            }
          }
        }
      }
    }
    id
  }
  ...GenericWorkTrackingLinks
}

fragment WrappedWithMetricPopup on Goal {
  id
  progress {
    percentage
  }
  metricTargets {
    edges {
      node {
        ...common_metricTarget_direct
        metric {
          archived
          id
        }
        id
      }
    }
  }
}

fragment common_metricTarget_direct on MetricTarget {
  startValue
  targetValue
  snapshotValue {
    value
    id
  }
  metric {
    id
    name
    type
    subType
    externalEntityId
  }
}

fragment progressBarMetricTarget on Goal {
  progress {
    type
    percentage
  }
  metricTargets {
    edges {
      node {
        snapshotValue {
          value
          id
        }
        startValue
        targetValue
        metric {
          type
          subType
          id
        }
        id
      }
    }
  }
}

fragment useRedirectToDefaultTab on Project {
  watching
  key
}

fragment utils_isUserInList on UserConnection {
  edges {
    node {
      aaid
      id
    }
  }
}
`;

  // src/graphql/projectStatusHistoryQuery.js
  var PROJECT_STATUS_HISTORY_QUERY = `
  query ProjectStatusHistoryQuery(
  $projectKey: String!
) {
  project: projectByKey(key: $projectKey) {
    latestUpdateDate
    ...ProjectHistoryBars
    id
  }
}

fragment ProjectHistoryBars on Project {
  owner {
    aaid
    id
  }
  creationDate
  startDate
  targetDate
  state {
    value
  }
  updates {
    edges {
      node {
        id
        creationDate
        missedUpdate
        updateType
        newState {
          label
          localizedLabel {
            messageId
          }
          value
        }
        newTargetDate
        newTargetDateConfidence
        oldTargetDate
        oldTargetDateConfidence
      }
    }
  }
  projectMemberships {
    edges {
      node {
        user {
          ...UserAvatar
          aaid
          id
        }
        joined
      }
    }
  }
  projectTeamLinks {
    edges {
      node {
        team {
          ...TeamAvatar
          teamId
          members {
            edges {
              node {
                aaid
              }
            }
          }
          id
        }
        creationDate
      }
    }
  }
}

fragment TeamAvatar on Team {
  id
  name
  teamId
  teamDetails {
    isVerified
  }
  avatarUrl
}

fragment UserAvatar on User {
  aaid
  pii {
    picture
    name
    accountStatus
    accountId
  }
}
`;

  // src/graphql/projectUpdatesQuery.js
  var PROJECT_UPDATES_QUERY = `
  query ProjectUpdatesQuery(
    $key: String!
    $isUpdatesTab: Boolean!
  ) {
    project: projectByKey(key: $key) {
      key @include(if: $isUpdatesTab)
      ...ProjectUpdates @include(if: $isUpdatesTab)
      id
    }
  }

  fragment Comment on Comment {
    id
    ari
    commentText
    creationDate
    editDate
    creator {
      aaid
      ...UserAvatar
      id
    }
  }

  fragment Comments on CommentConnection {
    edges {
      node {
        id
        editDate
        ...Comment
      }
    }
  }

  fragment EditProjectUpdate on ProjectUpdate {
    id
    uuid
    summary
    newState {
      value
    }
    newTargetDate
    newTargetDateConfidence
    notes {
      summary
      title
      uuid
      archived
      id
    }
    project {
      id
      key
      uuid
      workspace {
        uuid
        id
        aiConfig {
          enabled
        }
      }
      startDate
      creationDate
      latestUserUpdate {
        editDate
        creationDate
        summary
        notes {
          title
          summary
          id
        }
        id
      }
    }
    missedUpdate
    updateType
    creationDate
    ...ProjectUpdateTargetDateAutoUpdated
    ...LearningsInUpdate
  }

  fragment EditableProjectUpdateCard on ProjectUpdate {
    id
    project {
      id
    }
    creator {
      aaid
      id
    }
    creationDate
    ...ProjectUpdateCard
    ...EditProjectUpdate
  }

  fragment LearningCard_cardQuery on Learning {
    uuid
    id
    summary
    description
    type
    ...LearningModifierSignatures_data
  }

  fragment LearningModifierSignatures_data on Highlight {
    __isHighlight: __typename
    uuid
    ari
    project {
      key
      ari
      id
    }
    goal {
      key
      ari
      id
    }
    creator {
      pii {
        name
      }
      ...UserAvatar_2aqwkz
      id
    }
    creationDate
    lastEditedBy {
      pii {
        name
      }
      ...UserAvatar_2aqwkz
      id
    }
    lastEditedDate
  }

  fragment LearningsInUpdate on ProjectUpdate {
    project {
      uuid
      id
      workspace {
        uuid
        id
      }
      state {
        label
      }
    }
    learnings {
      edges {
        node {
          type
          ...LearningCard_cardQuery
          id
        }
      }
    }
  }

  fragment LearningsSummary_data on ProjectUpdate {
    learnings {
      edges {
        node {
          type
          ...LearningCard_cardQuery
          id
        }
      }
    }
  }

  fragment MilestoneCard_cardQuery on Milestone {
    uuid
    ...MilestoneFields
  }

  fragment MilestoneFields on Milestone {
    id
    title
    targetDate
    targetDateType
    status
  }

  fragment MilestonesSummary_data on ProjectUpdate {
    milestones {
      edges {
        node {
          ...MilestoneCard_cardQuery
          id
        }
      }
    }
  }

  fragment MissedProjectUpdateCard on ProjectUpdate {
    id
    uuid
    project {
      ari
      uuid
      workspace {
        uuid
        id
      }
      id
    }
    ...ProjectUpdateCardHeader
    ...ProjectUpdateCardTop_PTxnb
    ...ProjectUpdateTargetDateAutoUpdated
    ...LearningsSummary_data
    ...ProjectUpdateCardFooter
    comments {
      ...Comments
    }
  }

  fragment ProjectDateChanged on ProjectUpdate {
    oldDueDate {
      ...TargetDate
    }
    newDueDate {
      ...TargetDate
    }
  }

  fragment ProjectFollowButton on Project {
    id
    uuid
    watching
  }

  fragment ProjectIcon on Project {
    private
    iconUrl {
      square {
        light
        dark
        transparent
      }
    }
  }

  fragment ProjectMissedUpdateLabel on ProjectUpdate {
    creationDate
    missedUpdate
    updateType
    project {
      id
      key
      latestUserUpdate {
        id
        creationDate
      }
      latestUpdateDate
    }
  }

  fragment ProjectState on ProjectState {
    label
    localizedLabel {
      messageId
    }
    projectStateValue: value
    atCompletionState {
      value
      label
      localizedLabel {
        messageId
      }
    }
  }

  fragment ProjectStatusChanged on ProjectUpdate {
    newState {
      ...ProjectState
    }
    oldState {
      ...ProjectState
    }
  }

  fragment ProjectUpdateCard on ProjectUpdate {
    id
    uuid
    missedUpdate
    updateType
    creator {
      aaid
      id
    }
    ...MissedProjectUpdateCard
    ...ProjectUpdateCardInternal
    project {
      uuid
      id
    }
    milestones {
      count
    }
    learnings {
      count
    }
    notes {
      __typename
      id
    }
  }

  fragment ProjectUpdateCardContentExtras on ProjectUpdate {
    ...ProjectUpdateNotes
    ...ProjectUpdateDiff
    ...LearningsSummary_data
    ...MilestonesSummary_data
    ...ProjectUpdateTargetDateAutoUpdated
  }

  fragment ProjectUpdateCardFooter on ProjectUpdate {
    ari
    updateType
    missedUpdate
    project {
      ari
      ...ProjectFollowButton
      id
    }
    ...ShareUpdateButton
  }

  fragment ProjectUpdateCardHeader on ProjectUpdate {
    project {
      ...ProjectFollowButton
      ...ProjectIcon
      id
      key
      name
    }
  }

  fragment ProjectUpdateCardInternal on ProjectUpdate {
    id
    project {
      uuid
      ari
      workspace {
        uuid
        id
      }
      id
    }
    ...ProjectUpdateCardHeader
    ...ProjectUpdateCardTop
    ...ProjectUpdateSummary
    ...ProjectUpdateCardContentExtras
    ...ProjectUpdateCardFooter
    comments {
      ...Comments
    }
  }

  fragment ProjectUpdateCardTop on ProjectUpdate {
    ari
    creator {
      ...UserAvatar_2aqwkz
      ...UserName
      id
    }
    ...ProjectUpdateCreationDate
    ...ProjectUpdateStatus
    ...ProjectMissedUpdateLabel
  }

  fragment ProjectUpdateCardTop_PTxnb on ProjectUpdate {
    ari
    creator {
      ...UserAvatar_2aqwkz
      ...UserName
      id
    }
    ...ProjectMissedUpdateLabel
    missedUpdate
  }

  fragment ProjectUpdateCreationDate on ProjectUpdate {
    id
    project {
      key
      id
    }
    creationDate
    editDate
    creator {
      aaid
      id
    }
    lastEditedBy {
      aaid
      pii {
        name
      }
      id
    }
  }

  fragment ProjectUpdateDiff on ProjectUpdate {
    ...ProjectDateChanged
    ...ProjectStatusChanged
  }

  fragment ProjectUpdateNotes on ProjectUpdate {
    notes {
      uuid
      ...UpdateNote
      id
    }
  }

  fragment ProjectUpdateStatus on ProjectUpdate {
    newDueDate {
      ...TargetDate
    }
    newState {
      projectStateValue: value
      ...ProjectState
    }
  }

  fragment ProjectUpdateSummary on ProjectUpdate {
    summary
  }

  fragment ProjectUpdateTargetDateAutoUpdated on ProjectUpdate {
    project {
      key
      id
    }
    newTargetDate
    changelog {
      newValue
      oldValue
      id
    }
  }

  fragment ProjectUpdates on Project {
    updates(first: 100) {
      edges {
        node {
          uuid
          creationDate
          ...EditableProjectUpdateCard
          id
          __typename
        }
        cursor
      }
      pageInfo {
        endCursor
        hasNextPage
      }
    }
    id
  }

  fragment ShareUpdateButton on Update {
    __isUpdate: __typename
    ... on ProjectUpdate {
      id
    }
    ... on GoalUpdate {
      id
    }
    ...ShareUpdateDialogContent
  }

  fragment ShareUpdateDialogContent on Update {
    __isUpdate: __typename
    ... on ProjectUpdate {
      id
      project {
        key
        id
      }
    }
    ... on GoalUpdate {
      id
      url
      goal {
        key
        id
      }
    }
  }

  fragment TargetDate on TargetDate {
    confidence
    label
    localizedLabel {
      messageId
    }
    tooltip: label(longFormat: true)
    localizedTooltip: localizedLabel(longFormat: true) {
      messageId
    }
    overdue
  }

  fragment UpdateNote on UpdateNote {
    archived
    uuid
    title
    summary
  }

  fragment UserAvatar on User {
    aaid
    pii {
      picture
      name
      accountStatus
      accountId
    }
  }

  fragment UserAvatar_2aqwkz on User {
    aaid
    pii {
      picture
      accountId
    }
  }

  fragment UserName on User {
    aaid
    pii {
      name
      accountStatus
    }
  }
`;

  // src/utils/projectIdScanner.ts
  var projectLinkPattern = /\/o\/([a-f0-9\-]+)\/s\/([a-f0-9\-]+)\/project\/([A-Z]+-\d+)/;
  function findMatchingProjectLinksFromHrefs(hrefs) {
    const seen = /* @__PURE__ */ new Set();
    const results = [];
    hrefs.forEach((href) => {
      if (!href) return;
      const match3 = href.match(projectLinkPattern);
      if (match3 && match3[3]) {
        const cloudId2 = match3[1];
        const sectionId2 = match3[2];
        const projectId = match3[3];
        const key = `${cloudId2}:${projectId}`;
        if (!seen.has(key)) {
          seen.add(key);
          setGlobalCloudAndSection({ newCloudId: cloudId2, newSectionId: sectionId2 });
          results.push({ projectId, cloudId: cloudId2, sectionId: sectionId2 });
        }
      }
    });
    return results;
  }
  async function processAndStoreImages(projectKey, content) {
    if (!content || !Array.isArray(content)) return;
    for (const node2 of content) {
      if (node2.type === "media" && node2.attrs?.id) {
        const mediaId = node2.attrs.id;
        const existing = await getItem(`image:${projectKey}:${mediaId}`);
        if (existing) continue;
        const imageElement = document.querySelector(`[data-media-id="${mediaId}"], [data-attachment-id="${mediaId}"]`);
        if (imageElement) {
          const imgSrc = imageElement.getAttribute("src");
          if (imgSrc && imgSrc.startsWith("blob:")) {
            try {
              const imageData = await fetchImageFromBlobUrl(imgSrc);
              if (imageData) {
                await storeProjectImage(projectKey, mediaId, imageData.imageData, imageData.mimeType);
                await setItem(`image:${projectKey}:${mediaId}`, "stored");
                console.log(`[AtlasXray] Stored image for ${projectKey}:${mediaId}`);
              }
            } catch (error) {
              console.warn(`[AtlasXray] Failed to store image ${mediaId}:`, error);
            }
          }
        }
      }
      if (node2.content) {
        await processAndStoreImages(projectKey, node2.content);
      }
    }
  }
  async function fetchAndStoreProjectData(projectId, cloudId2) {
    const variables = {
      key: projectId,
      trackViewEvent: "DIRECT",
      workspaceId: null,
      onboardingKeyFilter: "PROJECT_SPOTLIGHT",
      areMilestonesEnabled: false,
      cloudId: cloudId2 || "",
      isNavRefreshEnabled: true
    };
    try {
      const { data } = await apolloClient.query({
        query: gql`${PROJECT_VIEW_QUERY}`,
        variables
      });
      await setProjectView(projectId, data);
    } catch (err) {
      console.error(`[AtlasXray] Failed to fetch project view data for projectId: ${projectId}`, err);
    }
    try {
      const { data } = await apolloClient.query({
        query: gql`${PROJECT_STATUS_HISTORY_QUERY}`,
        variables: { projectKey: projectId }
      });
      if (!projectId) {
        console.error("[AtlasXray] projectId is undefined when saving status history!");
        return;
      }
      const nodes = data?.project?.updates?.edges?.map((edge) => edge.node).filter(Boolean) || [];
      if (nodes.length > 0) {
        await upsertProjectStatusHistory(nodes, projectId);
      }
    } catch (err) {
      console.error(`[AtlasXray] Failed to fetch project status history for projectId: ${projectId}`, err);
    }
    try {
      const { data } = await apolloClient.query({
        query: gql`${PROJECT_UPDATES_QUERY}`,
        variables: { key: projectId, isUpdatesTab: true }
      });
      const nodes = data?.project?.updates?.edges?.map((edge) => edge.node).filter(Boolean) || [];
      if (nodes.length > 0) {
        await upsertProjectUpdates(nodes);
        for (const node2 of nodes) {
          if (node2.summary) {
            try {
              const summaryContent = JSON.parse(node2.summary);
              await processAndStoreImages(projectId, summaryContent.content);
            } catch (error) {
            }
          }
        }
      }
    } catch (err) {
      console.error(`[AtlasXray] Failed to fetch [ProjectUpdatesQuery] for projectId: ${projectId}`, err);
    }
  }
  async function downloadProjectData() {
    const links = Array.from(document.querySelectorAll("a[href]"));
    const hrefs = links.map((link) => link.getAttribute("href"));
    const matches = findMatchingProjectLinksFromHrefs(hrefs);
    const newProjects = [];
    for (const { projectId, cloudId: cloudId2 } of matches) {
      const key = `projectId:${projectId}`;
      const existing = await getItem(key);
      if (!existing) {
        newProjects.push({ projectId, cloudId: cloudId2 });
      }
    }
    const batchSize = 5;
    for (let i = 0; i < newProjects.length; i += batchSize) {
      const batch = newProjects.slice(i, i + batchSize);
      await Promise.all(
        batch.map(async ({ projectId, cloudId: cloudId2 }) => {
          const key = `projectId:${projectId}`;
          await setItem(key, projectId);
          await fetchAndStoreProjectData(projectId, cloudId2);
        })
      );
      if (i + batchSize < newProjects.length) {
        await new Promise((resolve) => setTimeout(resolve, 100));
      }
    }
    return matches;
  }

  // src/components/FloatingButton/FloatingButton.tsx
  var import_jsx_runtime8 = __toESM(require_jsx_runtime());
  function debounce2(func, wait) {
    let timeout;
    return (...args) => {
      clearTimeout(timeout);
      timeout = setTimeout(() => func(...args), wait);
    };
  }
  function FloatingButton() {
    const projectCount = useLiveQuery(() => db.projectView.count(), []);
    const projects = useLiveQuery(() => db.projectView.toArray(), []);
    const updatesByProject = useLiveQuery(
      async () => {
        const updates = {};
        const allUpdates = await db.projectUpdates.toArray();
        for (const update of allUpdates) {
          const key = update.projectKey;
          const edges = update?.projectUpdates?.edges || [];
          updates[key] = edges.map((e) => e.node?.creationDate).filter(Boolean);
        }
        return updates;
      },
      []
    );
    const [modalOpen, setModalOpen] = (0, import_react139.useState)(false);
    const [visibleProjectKeys, setVisibleProjectKeys] = (0, import_react139.useState)([]);
    const observerRef = (0, import_react139.useRef)(null);
    const updateVisibleProjects = (0, import_react139.useRef)(
      debounce2(async () => {
        const matches = await downloadProjectData();
        setVisibleProjectKeys(matches.map((m) => m.projectId));
      }, 1e3)
      // Debounce to 1 second
    );
    (0, import_react139.useEffect)(() => {
      updateVisibleProjects.current();
      const observer = new window.MutationObserver((mutations) => {
        const hasNewProjectLinks = mutations.some(
          (mutation) => Array.from(mutation.addedNodes).some(
            (node2) => node2.nodeType === Node.ELEMENT_NODE && node2.querySelector?.('a[href*="/project/"]')
          )
        );
        if (hasNewProjectLinks) {
          updateVisibleProjects.current();
        }
      });
      observer.observe(document.body, {
        childList: true,
        subtree: true,
        attributes: false,
        // Don't watch attribute changes
        characterData: false
        // Don't watch text changes
      });
      observerRef.current = observer;
      return () => {
        if (observerRef.current) observerRef.current.disconnect();
      };
    }, []);
    const projectViewModel = (projects || []).map((proj) => ({
      projectKey: proj.projectKey,
      name: proj.project?.name || "",
      updateDates: updatesByProject && updatesByProject[proj.projectKey] ? updatesByProject[proj.projectKey] : []
    }));
    const filteredProjects = visibleProjectKeys.length > 0 ? projectViewModel.filter((p) => visibleProjectKeys.includes(p.projectKey)) : projectViewModel;
    const handleOpenModal = () => setModalOpen(true);
    return /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)(import_jsx_runtime8.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("button", { className: "atlas-xray-floating-btn", onClick: handleOpenModal, children: [
        "Atlas Xray",
        visibleProjectKeys.length > 0 ? ` (${visibleProjectKeys.length}/${projectCount !== void 0 ? projectCount : 0})` : projectCount !== void 0 ? ` (${projectCount})` : ""
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(ProjectStatusHistoryModal, { open: modalOpen, onClose: () => setModalOpen(false), children: (weekLimit) => /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(StatusTimelineHeatmap, { weekLimit }) })
    ] });
  }
})();
/*! Bundled license information:

react/cjs/react.production.min.js:
  (**
   * @license React
   * react.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

dexie/dist/dexie.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

@babel/runtime/helpers/regenerator.js:
  (*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE *)

scheduler/cjs/scheduler.production.min.js:
  (**
   * @license React
   * scheduler.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom.production.min.js:
  (**
   * @license React
   * react-dom.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

exenv/index.js:
  (*!
    Copyright (c) 2015 Jed Watson.
    Based on code that is Copyright 2013-2015, Facebook, Inc.
    All rights reserved.
  *)

react-is/cjs/react-is.production.min.js:
  (** @license React v16.13.1
   * react-is.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react/cjs/react-jsx-runtime.production.min.js:
  (**
   * @license React
   * react-jsx-runtime.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
