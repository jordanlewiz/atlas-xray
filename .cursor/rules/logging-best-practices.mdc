
# Logging Best Practices

## Overview
This rule establishes logging standards and patterns for the Atlas Xray Chrome extension, ensuring consistent, performant, and maintainable logging using a **single, unified logger utility** with **manual prefix control**.

## Core Principles

### 1. Use the Unified Logger Utility
Always use the single `log` utility from [src/utils/logger.ts](mdc:src/utils/logger.ts) for all logging purposes. This utility wraps browser console methods and respects the debug toggle.

```typescript
import { log } from '../utils/logger';

// Use the unified logger with manual prefixes
log.debug('[ServiceName]', 'Debug message');
log.info('[ServiceName]', 'Info message');
log.warn('[ServiceName]', 'Warning message');
log.error('[ServiceName]', 'Error message');
```

### 2. Manual Prefix Control
**Always include a manual prefix** for service identification. The prefix should be the first parameter to every log call.

```typescript
// ‚úÖ Good - manual prefix for service identification
log.info('[PageTypeDetector]', 'Pattern matched:', type);
log.debug('[TimelineService]', 'Toggling dependencies visibility');
log.warn('[DatabaseService]', 'Could not cleanup service');
log.error('[ContentScript]', 'Failed to initialize');

// ‚ùå Bad - no prefix
log.info('Pattern matched:', type);
log.debug('Toggling dependencies visibility');
```

### 3. Debug Toggle Integration
The logger automatically respects the debug toggle state:
- **Debug ON**: All logs appear (debug, info, warn, error)
- **Debug OFF**: Only errors appear (critical issues always visible)
- **Toggle updates immediately** - No caching issues

### 4. Log Level Usage

#### Debug (`log.debug`)
- Page type changes
- URL navigation events
- Button mounting/unmounting decisions
- Service state changes
- Pattern matching details
- Method entry/exit points

#### Information (`log.info`)
- Current state information
- Successful operations
- Component mounting/unmounting
- Service initialization success
- Button management completion
- URL changes

#### Warnings (`log.warn`)
- Non-critical failures
- Fallback operations
- Service cleanup issues
- Expected but suboptimal conditions
- Missing patterns or configurations

#### Errors (`log.error`)
- Critical failures
- Service mounting errors
- Unexpected exceptions
- Operations that prevent normal functionality
- Import failures

## Implementation Examples

### Service Class Template
```typescript
import { log } from '../utils/logger';

export class ExampleService {
  static async performOperation(): Promise<void> {
    try {
      log.debug('[ExampleService]', 'Starting operation...');
      
      // ... operation logic ...
      
      log.info('[ExampleService]', 'Operation completed successfully');
    } catch (error) {
      log.error('[ExampleService]', 'Operation failed', error);
      throw error;
    }
  }
}
```

### Component Logging
```typescript
import { log } from '../utils/logger';

function MyComponent() {
  useEffect(() => {
    log.info('[MyComponent]', 'Component mounted');
    
    return () => {
      log.info('[MyComponent]', 'Component unmounting');
    };
  }, []);
  
  // ... component logic ...
}
```

## Environment Control

### Debug Toggle Control
Users can toggle debug logging through the extension popup:
- **Debug ON**: Sets `localStorage['atlas-xray-debug'] = 'true'` - shows all logs
- **Debug OFF**: Sets `localStorage['atlas-xray-debug'] = 'false'` - shows only errors

### Runtime Control
```typescript
import { forceDebugLogging, getDebugState } from '../utils/logger';

// Force enable/disable debug logging
forceDebugLogging(true);  // Enable all logs
forceDebugLogging(false); // Disable all logs except errors

// Check current debug state
console.log('Debug enabled:', getDebugState());
```

## Performance Benefits

### Zero Overhead When Disabled
- No function calls when debug toggle is OFF
- No string concatenation overhead
- No conditional checks at runtime
- Production builds are completely clean

### Immediate Response
- Debug toggle changes take effect immediately
- No caching issues
- Dynamic control without restarting

### Lightweight Implementation
- No external npm packages
- Native browser console wrapper
- Minimal memory footprint

## Best Practices

### 1. Always Use Manual Prefixes
```typescript
// ‚úÖ Good - manual prefix with context
log.info('[PageTypeDetector]', 'Button mounted for page type:', pageType, 'at URL:', url);

// ‚ùå Bad - no prefix
log.info('Button mounted for page type:', pageType, 'at URL:', url);
```

### 2. Include Relevant Context
```typescript
// ‚úÖ Good - includes relevant data
log.info('[PageTypeDetector]', 'Skipping mount - button already exists for:', pageType);

// ‚ùå Bad - lacks context
log.info('[PageTypeDetector]', 'Skipping mount');
```

### 3. Use Appropriate Log Levels
```typescript
// ‚úÖ Good - debug for detailed flow
log.debug('[PageTypeDetector]', 'Testing pattern:', type, 'regex:', regex);

// ‚úÖ Good - info for successful operations
log.info('[PageTypeDetector]', 'Pattern matched:', type);

// ‚úÖ Good - warn for non-critical issues
log.warn('[PageTypeDetector]', 'No pattern matched, returning UNKNOWN');

// ‚úÖ Good - error for failures
log.error('[PageTypeDetector]', 'Failed to mount button:', error);
```

### 4. Avoid Sensitive Information
```typescript
// ‚úÖ Good - no sensitive data
log.info('[PageTypeDetector]', 'User action performed on project:', projectId);

// ‚ùå Bad - includes sensitive data
log.info('[PageTypeDetector]', 'User action performed by:', user.email, 'on project:', projectId);
```

### 5. Use Emojis for Visual Clarity
```typescript
// ‚úÖ Good - visual indicators with manual prefixes
log.info('[PageTypeDetector]', 'üöÄ Page type monitoring started');
log.debug('[PageTypeDetector]', 'üîÑ URL changed to:', newUrl);
log.warn('[PageTypeDetector]', '‚ö†Ô∏è Could not cleanup service');
log.error('[PageTypeDetector]', '‚ùå Failed to mount component');
```

## Migration Guide

### From Console.log
```typescript
// Before
console.log('[Service] Operation started');

// After
log.info('[Service]', 'Operation started');
```

### From Multiple Logger Instances
```typescript
// Before
const log = createLogger('ServiceName');
log.info('Operation started');

// After
import { log } from '../utils/logger';
log.info('[ServiceName]', 'Operation started');
```

### From Complex Prefix Systems
```typescript
// Before
// Complex Loglevel with automatic prefixes
const log = createLogger('ServiceName');
log.info('Operation started');

// After
// Simple unified logger with manual prefixes
import { log } from '../utils/logger';
log.info('[ServiceName]', 'Operation started');
```

## File References

- [src/utils/logger.ts](mdc:src/utils/logger.ts) - Unified logger utility with manual prefix control
- [src/services/PageTypeDetector.ts](mdc:src/services/PageTypeDetector.ts) - Example implementation with manual prefixes
- [src/contentScripts/contentScript.js](mdc:src/contentScripts/contentScript.js) - Debug toggle integration
- [src/components/ChromeExtension/ChromeExtensionPopup.tsx](mdc:src/components/ChromeExtension/ChromeExtensionPopup.tsx) - Debug toggle UI
- [package.json](mdc:package.json) - No external logging dependencies

## Related Rules

- [Chrome Extension General](mdc:chrome-extension-general) - Extension-specific patterns
- [Chrome Extension Patterns](mdc:chrome-extension-patterns) - Architecture guidelines
