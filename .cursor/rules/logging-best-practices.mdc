
# Logging Best Practices

## Overview
This rule establishes logging standards and patterns for the Atlas Xray Chrome extension, ensuring consistent, performant, and maintainable logging using a **single, unified logger utility** with **file-level prefix control** and **override capability**.

## Core Principles

### 1. Use the Unified Logger Utility
Always use the single `log` utility from [src/utils/logger.ts](mdc:src/utils/logger.ts) for all logging purposes. This utility wraps browser console methods and respects the debug toggle.

**Exception: Service Worker Scripts**
Service worker scripts (`src/background/*.js`) should use `console.log` directly instead of the logger utility, as they log to a different console context and the logger utility is designed for content scripts and popup contexts.

```typescript
import { log, setFilePrefix } from '../utils/logger';

// Set file-level prefix for all logging in this file
setFilePrefix('[ServiceName]');

// Use the unified logger with automatic file prefix
log.debug('Debug message');
log.info('Info message');
log.warn('Warning message');
log.error('Error message');
```

### 2. File-Level Prefix Control
**Set the prefix once per file** using `setFilePrefix()`. This eliminates repetition and ensures consistent service identification.

```typescript
// At the top of each file, after imports
import { log, setFilePrefix } from '../utils/logger';

// Set prefix for this entire file
setFilePrefix('[PageTypeDetector]');

// Now all log calls automatically use this prefix
log.info('Pattern matched:', type);
log.debug('Testing pattern:', type, 'regex:', regex);
log.warn('No pattern matched, returning UNKNOWN');
```

### 3. Prefix Override Capability
**Override the file prefix when needed** by passing a custom prefix as the first parameter.

```typescript
// Use default file prefix
log.info('Button mounted successfully');

// Override with custom prefix for special context
log.info('[Validation]', 'Invalid URL format');
log.warn('[Cleanup]', 'Could not cleanup service');

// Override with no prefix for generic messages
log.info('', 'Generic system message');
```

### 4. Debug Toggle Integration
The logger automatically respects the debug toggle state:
- **Debug ON**: All logs appear (debug, info, warn, error)
- **Debug OFF**: Only errors appear (critical issues always visible)
- **Toggle updates immediately** - No caching issues

### 5. Log Level Usage

#### Debug (`log.debug`)
- Page type changes
- URL navigation events
- Button mounting/unmounting decisions
- Service state changes
- Pattern matching details
- Method entry/exit points

#### Information (`log.info`)
- Current state information
- Successful operations
- Component mounting/unmounting
- Service initialization success
- Button management completion
- URL changes

#### Warnings (`log.warn`)
- Non-critical failures
- Fallback operations
- Service cleanup issues
- Expected but suboptimal conditions
- Missing patterns or configurations

#### Errors (`log.error`)
- Critical failures
- Service mounting errors
- Unexpected exceptions
- Operations that prevent normal functionality
- Import failures

## Implementation Examples

### Service Class Template
```typescript
import { log, setFilePrefix } from '../utils/logger';

// Set file-level prefix once
setFilePrefix('[ExampleService]');

export class ExampleService {
  static async performOperation(): Promise<void> {
    try {
      log.debug('Starting operation...'); // Uses [ExampleService] prefix
      
      // Example of logging with objects and data
      const operationData = { id: 123, type: 'process' };
      log.debug('Processing data:', JSON.stringify(operationData));
      
      // ... operation logic ...
      
      log.info('Operation completed successfully'); // Uses [ExampleService] prefix
    } catch (error) {
      log.error('Operation failed', String(error)); // Uses [ExampleService] prefix
      throw error;
    }
  }
  
  static async specialOperation(): Promise<void> {
    try {
      // Override prefix for special context
      log.info('[SpecialContext]', 'Special operation started');
      
      // Example of logging GraphQL errors or API responses
      const apiResponse = { data: null, errors: [{ message: 'Invalid input' }] };
      if (apiResponse.errors) {
        log.error('[SpecialContext]', 'API errors:', JSON.stringify(apiResponse.errors));
      }
      
      // ... special logic ...
      
      log.info('[SpecialContext]', 'Special operation completed');
    } catch (error) {
      // Use default file prefix
      log.error('Special operation failed', String(error));
    }
  }
}
```

### Component Logging
```typescript
import { log, setFilePrefix } from '../utils/logger';

// Set file-level prefix once
setFilePrefix('[MyComponent]');

function MyComponent() {
  useEffect(() => {
    log.info('Component mounted'); // Uses [MyComponent] prefix
    
    return () => {
      log.info('Component unmounting'); // Uses [MyComponent] prefix
    };
  }, []);
  
  // ... component logic ...
}
```

## Environment Control

### Debug Toggle Control
Users can toggle debug logging through the extension popup:
- **Debug ON**: Sets `localStorage['atlas-xray-debug'] = 'true'` - shows all logs
- **Debug OFF**: Sets `localStorage['atlas-xray-debug'] = 'false'` - shows only errors

### Runtime Control
```typescript
import { forceDebugLogging, getDebugState } from '../utils/logger';

// Force enable/disable debug logging
forceDebugLogging(true);  // Enable all logs
forceDebugLogging(false); // Disable all logs except errors

// Check current debug state
console.log('Debug enabled:', getDebugState());
```

## Performance Benefits

### Zero Overhead When Disabled
- No function calls when debug toggle is OFF
- No string concatenation overhead
- No conditional checks at runtime
- Production builds are completely clean

### Immediate Response
- Debug toggle changes take effect immediately
- No caching issues
- Dynamic control without restarting

### Lightweight Implementation
- No external npm packages
- Native browser console wrapper
- Minimal memory footprint

## Best Practices

### 1. Always Set File-Level Prefix
```typescript
// ‚úÖ Good - set prefix once at file top
import { log, setFilePrefix } from '../utils/logger';
setFilePrefix('[PageTypeDetector]');

// Now use simple logging calls
log.info('Button mounted for page type:', pageType, 'at URL:', url);

// ‚ùå Bad - no file prefix set
import { log } from '../utils/logger';
log.info('Button mounted for page type:', pageType, 'at URL:', url);
```

### 2. Use Override Prefixes for Special Context
```typescript
// ‚úÖ Good - override prefix for special operations
log.info('[Validation]', 'URL validation failed:', url);
log.warn('[Cleanup]', 'Could not cleanup service:', serviceName);

// ‚úÖ Good - use default file prefix for normal operations
log.info('Pattern matched:', type);
log.debug('Testing pattern:', type, 'regex:', regex);
```

### 3. Include Relevant Context
```typescript
// ‚úÖ Good - includes relevant data
log.info('Skipping mount - button already exists for:', pageType);

// ‚ùå Bad - lacks context
log.info('Skipping mount');
```

### 4. Use Appropriate Log Levels
```typescript
// ‚úÖ Good - debug for detailed flow
log.debug('Testing pattern:', type, 'regex:', regex);

// ‚úÖ Good - info for successful operations
log.info('Pattern matched:', type);

// ‚úÖ Good - warn for non-critical issues
log.warn('No pattern matched, returning UNKNOWN');

// ‚úÖ Good - error for failures
log.error('Failed to mount button:', String(error));
```

### 5. Properly Format Objects and Non-String Values
**Always convert objects, arrays, and non-string values to strings** before passing to the logger.

```typescript
// ‚úÖ Good - objects converted to JSON strings
log.debug('Processing data:', JSON.stringify({ key: 'value', count: 42 }));
log.error('GraphQL errors:', JSON.stringify(response.errors));

// ‚úÖ Good - non-string values converted to strings
log.debug('Count:', String(items.length));
log.info('URL:', String(window.location.href));
log.warn('Status:', String(response.status));

// ‚úÖ Good - error objects properly converted
log.error('Operation failed:', String(error));
log.warn('Warning with error:', String(error), 'context:', JSON.stringify(context));

// ‚ùå Bad - passing objects directly
log.debug('Processing data:', { key: 'value', count: 42 });
log.error('GraphQL errors:', response.errors);
log.debug('Count:', items.length);

// ‚ùå Bad - passing error objects directly
log.error('Operation failed:', error);
```

**Why This Matters:**
- **Consistency**: All logger arguments are properly formatted strings
- **Debugging**: Objects are serialized and readable in console output
- **Type Safety**: Matches the logger interface expectations
- **Maintainability**: Clear and predictable logging behavior

### 6. Let the Logger Handle Visual Indicators
**The logger automatically adds appropriate icons based on log level. Do not add emojis manually in log messages.**

```typescript
// ‚úÖ Good - let the logger handle the visual indicators
log.info('Page type monitoring started');        // Shows: [Service] ‚ÑπÔ∏è Page type monitoring started
log.debug('URL changed to:', newUrl);            // Shows: [Service] üîç URL changed to: http://...
log.warn('Could not cleanup service');           // Shows: [Service] ‚ö†Ô∏è Could not cleanup service
log.error('Failed to mount component');          // Shows: [Service] ‚ùå Failed to mount component

// ‚ùå Bad - redundant emojis create double icons
log.info('üöÄ Page type monitoring started');     // Shows: [Service] ‚ÑπÔ∏è üöÄ Page type monitoring started
log.debug('üîÑ URL changed to:', newUrl);         // Shows: [Service] üîç üîÑ URL changed to: http://...
log.warn('‚ö†Ô∏è Could not cleanup service');        // Shows: [Service] ‚ö†Ô∏è ‚ö†Ô∏è Could not cleanup service
log.error('‚ùå Failed to mount component');       // Shows: [Service] ‚ùå ‚ùå Failed to mount component
```

**Why This Matters:**
- **Consistency**: All logs have uniform visual indicators
- **Clean Output**: No duplicate emojis cluttering the console
- **Maintainability**: Visual indicators are managed in one place (the logger)
- **Readability**: Clear, consistent formatting across all log messages

### 7. Service Worker Logging (Exception)
**Service worker scripts should use `console.log` directly, not the logger utility.**

```javascript
// ‚úÖ Good - Service worker scripts use console.log directly
console.log('[AtlasXray] Background service worker is running');
console.log('[AtlasXray] Message received:', message.type);
console.error('[AtlasXray] Failed to initialize:', error);

// ‚ùå Bad - Don't use logger utility in service workers
import { log, setFilePrefix } from '../utils/logger';
log.info('Background service worker is running'); // May cause initialization issues
```

**Why Service Workers Are Different:**
- **Different Console Context**: Service workers log to a separate console
- **Initialization Issues**: Logger utility may not be available during service worker startup
- **Simplicity**: Direct console logging is more reliable in service worker context
- **Performance**: No overhead from logger utility in background scripts

## Migration Guide

### From Console.log
```typescript
// Before
console.log('[Service] Operation started');

// After
import { log, setFilePrefix } from '../utils/logger';
setFilePrefix('[Service]');
log.info('Operation started');
```

### From Multiple Logger Instances
```typescript
// Before
const log = createLogger('ServiceName');
log.info('Operation started');

// After
import { log, setFilePrefix } from '../utils/logger';
setFilePrefix('[ServiceName]');
log.info('Operation started');
```

### From Manual Prefixes Everywhere
```typescript
// Before
log.info('[PageTypeDetector]', 'Pattern matched:', type);
log.debug('[PageTypeDetector]', 'Testing pattern:', type, 'regex:', regex);
log.warn('[PageTypeDetector]', 'No pattern matched, returning UNKNOWN');

// After
import { log, setFilePrefix } from '../utils/logger';
setFilePrefix('[PageTypeDetector]');

log.info('Pattern matched:', type);
log.debug('Testing pattern:', type, 'regex:', regex);
log.warn('No pattern matched, returning UNKNOWN');
```

## File References

- [src/utils/logger.ts](mdc:src/utils/logger.ts) - Unified logger utility with file-level prefix control
- [src/services/PageTypeDetector.ts](mdc:src/services/PageTypeDetector.ts) - Example implementation with file-level prefix
- [src/contentScripts/contentScript.js](mdc:src/contentScripts/contentScript.js) - Debug toggle integration with file-level prefix
- [src/components/ChromeExtension/ChromeExtensionPopup.tsx](mdc:src/components/ChromeExtension/ChromeExtensionPopup.tsx) - Debug toggle UI
- [src/background/background.js](mdc:src/background/background.js) - Service worker using console.log directly (exception)
- [package.json](mdc:package.json) - No external logging dependencies

## Related Rules

- [Chrome Extension General](mdc:chrome-extension-general) - Extension-specific patterns
- [Chrome Extension Patterns](mdc:chrome-extension-patterns) - Architecture guidelines
